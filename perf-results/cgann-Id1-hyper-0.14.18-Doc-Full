--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate --auto=yes --show-percs=yes results/cgout-Id1-hyper-0.14.18-Doc-Full
Command:          /data/code/rust/build/keep/before/bin/rustdoc --edition=2018 --crate-type lib --crate-name hyper src/lib.rs -o /tmp/.tmp6p5kaU/target/doc --cfg feature="client" --cfg feature="default" --cfg feature="h2" --cfg feature="http1" --cfg feature="http2" --cfg feature="server" --cfg feature="stream" --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat -C metadata=6ddab4bf30f0818d -L dependency=/tmp/.tmp6p5kaU/target/debug/deps --extern bytes=/tmp/.tmp6p5kaU/target/debug/deps/libbytes-029116899d9f8f87.rmeta --extern futures_channel=/tmp/.tmp6p5kaU/target/debug/deps/libfutures_channel-c0c60745537d3e9a.rmeta --extern futures_core=/tmp/.tmp6p5kaU/target/debug/deps/libfutures_core-8a4f41e17ec130a6.rmeta --extern futures_util=/tmp/.tmp6p5kaU/target/debug/deps/libfutures_util-c771f8511624a3b9.rmeta --extern h2=/tmp/.tmp6p5kaU/target/debug/deps/libh2-caef54af8e03d6cf.rmeta --extern http=/tmp/.tmp6p5kaU/target/debug/deps/libhttp-23cad9751cd244de.rmeta --extern http_body=/tmp/.tmp6p5kaU/target/debug/deps/libhttp_body-1dbc19e485c4cc97.rmeta --extern httparse=/tmp/.tmp6p5kaU/target/debug/deps/libhttparse-afd8abf8b89a5c8d.rmeta --extern httpdate=/tmp/.tmp6p5kaU/target/debug/deps/libhttpdate-b6e2db706d027fc3.rmeta --extern itoa=/tmp/.tmp6p5kaU/target/debug/deps/libitoa-88d7da467714815e.rmeta --extern pin_project_lite=/tmp/.tmp6p5kaU/target/debug/deps/libpin_project_lite-45f5bd47db9092f1.rmeta --extern tokio=/tmp/.tmp6p5kaU/target/debug/deps/libtokio-8a12e25eebceb973.rmeta --extern tower_service=/tmp/.tmp6p5kaU/target/debug/deps/libtower_service-ec615f7c3750c075.rmeta --extern tracing=/tmp/.tmp6p5kaU/target/debug/deps/libtracing-93ab3ae544d5eac4.rmeta --extern want=/tmp/.tmp6p5kaU/target/debug/deps/libwant-47753403e0c21687.rmeta --crate-version 0.14.18 -Adeprecated -Aunknown-lints -Zincremental-verify-ich
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir____________________ 

7,984,813,166 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir__________________________  file:function

< 1,032,596,441 (12.9%, 12.9%)  /usr/src/debug/glibc/glibc/malloc/malloc.c:
    291,983,666  (3.7%)           _int_free
    249,795,624  (3.1%)           _int_malloc
    200,360,728  (2.5%)           malloc
     97,823,877  (1.2%)           free
     55,099,452  (0.7%)           malloc_consolidate
     39,741,716  (0.5%)           realloc
     31,928,676  (0.4%)           _int_realloc
     28,456,344  (0.4%)           unlink_chunk.isra.0
     17,790,351  (0.2%)           _int_free_merge_chunk
     14,708,528  (0.2%)           _int_free_create_chunk

<   466,463,921  (5.8%, 18.8%)  /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs:
     26,152,153  (0.3%)           <rustc_middle::ty::context::TyCtxt>::mk_args
     24,136,965  (0.3%)           <rustc_middle::ty::context::CtxtInterners>::intern_predicate
     20,520,960  (0.3%)           <rustc_infer::traits::util::PredicateSet>::insert
     19,265,109  (0.2%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 8]>>>
     18,490,775  (0.2%)           <rustc_middle::ty::context::CtxtInterners>::intern_ty
     18,400,104  (0.2%)           <hashbrown::map::HashMap<rustc_span::def_id::DefId, rustc_query_system::query::plumbing::QueryResult, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::remove::<rustc_span::def_id::DefId>
     17,956,887  (0.2%)           <hashbrown::raw::RawTable<(rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId)>>::reserve_rehash::<hashbrown::map::make_hasher<rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>::{closure#0}>
     16,035,259  (0.2%)           <hashbrown::map::HashMap<rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::insert
     15,837,187  (0.2%)           <hashbrown::raw::RawTable<(rustc_middle::ty::predicate::Predicate, ())>>::reserve_rehash::<hashbrown::map::make_hasher<rustc_middle::ty::predicate::Predicate, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>::{closure#0}>
     12,207,958  (0.2%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 24]>>>

<   340,322,257  (4.3%, 23.0%)  /data/code/rust/library/core/src/ptr/mod.rs:
     19,650,598  (0.2%)           <rustc_parse::parser::Parser>::bump
      9,095,608  (0.1%)           core::ptr::drop_in_place::<alloc::vec::into_iter::IntoIter<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>>
      8,200,068  (0.1%)           core::ptr::drop_in_place::<alloc::vec::Vec<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>>

<   170,100,465  (2.1%, 25.2%)  /data/code/rust/compiler/rustc_span/src/span_encoding.rs:
     72,721,311  (0.9%)           <rustc_span::span_encoding::Span>::new
     61,021,945  (0.8%)           <rustc_span::span_encoding::Span>::data_untracked
     16,829,330  (0.2%)           <rustc_span::span_encoding::Span>::ctxt

<   166,367,320  (2.1%, 27.2%)  /data/code/rust/library/core/src/num/mod.rs:
     18,908,380  (0.2%)           <rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<8>
     12,577,953  (0.2%)           <rustc_data_structures::sip128::SipHasher128>::finish128
      8,355,908  (0.1%)           <rustc_middle::ty::context::TyCtxt>::mk_args

<   156,307,622  (2.0%, 29.2%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
    156,301,360  (2.0%)           __memcpy_avx_unaligned_erms

<   152,620,062  (1.9%, 31.1%)  /data/code/rust/compiler/rustc_middle/src/ty/context.rs:
     32,022,090  (0.4%)           <rustc_middle::ty::context::TyCtxt>::mk_args
     18,280,988  (0.2%)           <rustc_middle::ty::context::TyCtxt>::reuse_or_mk_predicate
     16,019,526  (0.2%)           <rustc_middle::ty::context::CtxtInterners>::intern_predicate
     15,790,887  (0.2%)           <rustc_middle::ty::context::TyCtxt>::mk_bound_variable_kinds
     15,169,358  (0.2%)           <rustc_middle::ty::context::CtxtInterners>::intern_ty
     10,955,685  (0.1%)           <rustc_middle::ty::context::TyCtxt>::def_path_hash

<   143,050,291  (1.8%, 32.9%)  /data/code/rust/compiler/rustc_middle/src/ty/generic_args.rs:
     24,705,041  (0.3%)           <&rustc_middle::ty::list::RawList<(), rustc_middle::ty::generic_args::GenericArg> as rustc_type_ir::fold::TypeFoldable<rustc_middle::ty::context::TyCtxt>>::try_fold_with::<rustc_infer::infer::freshen::TypeFreshener>
     15,978,216  (0.2%)           <&rustc_middle::ty::list::RawList<(), rustc_middle::ty::generic_args::GenericArg> as rustc_type_ir::fold::TypeFoldable<rustc_middle::ty::context::TyCtxt>>::try_fold_with::<rustc_middle::ty::generic_args::ArgFolder>
     10,759,230  (0.1%)           <rustc_type_ir::predicate_kind::ClauseKind<rustc_middle::ty::context::TyCtxt> as rustc_type_ir::visit::TypeVisitable<rustc_middle::ty::context::TyCtxt>>::visit_with::<rustc_type_ir::visit::HasEscapingVarsVisitor>

<   121,829,421  (1.5%, 34.4%)  /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs:
     22,211,773  (0.3%)           <rustc_trait_selection::traits::select::SelectionContext>::candidate_from_obligation
     17,863,499  (0.2%)           <rustc_trait_selection::traits::select::SelectionContext>::evaluate_trait_predicate_recursively
     10,606,878  (0.1%)           <rustc_trait_selection::traits::select::SelectionContext>::poly_select
     10,086,734  (0.1%)           <rustc_trait_selection::traits::select::SelectionContext>::assemble_candidates_from_caller_bounds
      9,641,508  (0.1%)           <rustc_trait_selection::traits::select::SelectionContext>::impl_or_trait_obligations

<   111,803,549  (1.4%, 35.8%)  /data/code/rust/library/alloc/src/raw_vec.rs:
     28,311,788  (0.4%)           alloc::raw_vec::finish_grow::<alloc::alloc::Global>

<   109,850,746  (1.4%, 37.2%)  /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs:
     23,434,267  (0.3%)           <rustc_type_ir::predicate_kind::ClauseKind<rustc_middle::ty::context::TyCtxt> as rustc_type_ir::visit::TypeVisitable<rustc_middle::ty::context::TyCtxt>>::visit_with::<rustc_type_ir::visit::HasEscapingVarsVisitor>
     22,379,504  (0.3%)           <rustc_middle::ty::context::TyCtxt>::reuse_or_mk_predicate
     16,473,354  (0.2%)           <rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt> as core::cmp::PartialEq>::eq
     16,308,740  (0.2%)           <rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt> as rustc_type_ir::visit::TypeVisitableExt<rustc_middle::ty::context::TyCtxt>>::has_vars_bound_at_or_above
     12,487,518  (0.2%)           <rustc_middle::ty::sty::Binder<rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt>> as core::hash::Hash>::hash::<rustc_hash::FxHasher>

<    84,858,354  (1.1%, 38.3%)  /data/code/rust/compiler/rustc_middle/src/query/plumbing.rs:
     28,988,941  (0.4%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 8]>>>
     21,903,780  (0.3%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 24]>>>
     12,389,292  (0.2%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 3]>>>

<    79,895,685  (1.0%, 39.3%)  /data/code/rust/compiler/rustc_metadata/src/rmeta/decoder.rs:
     15,155,904  (0.2%)           <rustc_span::SpanData as rustc_serialize::serialize::Decodable<rustc_metadata::rmeta::decoder::DecodeContext>>::decode
     12,511,810  (0.2%)           <rustc_metadata::rmeta::decoder::DecodeContext as rustc_span::SpanDecoder>::decode_span
     11,132,730  (0.1%)           <rustc_metadata::creader::CrateMetadataRef>::imported_source_file

<    78,746,106  (1.0%, 40.3%)  /data/code/rust/compiler/rustc_ast/src/token.rs:
     33,241,148  (0.4%)           <rustc_ast::token::TokenKind as core::cmp::PartialEq>::eq
     12,850,497  (0.2%)           <rustc_ast::token::TokenKind as core::clone::Clone>::clone
      8,388,132  (0.1%)           <rustc_ast::token::Token>::is_keyword

<    71,100,713  (0.9%, 41.2%)  /usr/src/debug/glibc/glibc/malloc/arena.c:
     48,889,986  (0.6%)           free
     11,458,631  (0.1%)           malloc
     10,265,350  (0.1%)           realloc

<    69,161,806  (0.9%, 42.0%)  /data/code/rust/compiler/rustc_parse/src/parser/mod.rs:
     26,257,306  (0.3%)           <rustc_parse::parser::Parser>::bump

<    66,484,327  (0.8%, 42.9%)  /data/code/rust/library/core/src/result.rs:
     15,189,174  (0.2%)           alloc::raw_vec::finish_grow::<alloc::alloc::Global>

<    63,759,572  (0.8%, 43.6%)  /data/code/rust/compiler/rustc_middle/src/ty/predicate.rs:
      9,435,240  (0.1%)           <rustc_middle::ty::predicate::Clause>::as_trait_clause

<    61,301,141  (0.8%, 44.4%)  /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/map.rs:
     13,668,642  (0.2%)           <hashbrown::map::HashMap<rustc_span::def_id::DefId, rustc_query_system::query::plumbing::QueryResult, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::remove::<rustc_span::def_id::DefId>
     12,455,121  (0.2%)           <hashbrown::map::HashMap<rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::insert

<    53,334,865  (0.7%, 45.1%)  /data/code/rust/compiler/rustc_serialize/src/opaque.rs:
     10,823,518  (0.1%)           <rustc_span::SpanData as rustc_serialize::serialize::Decodable<rustc_metadata::rmeta::decoder::DecodeContext>>::decode
      8,713,887  (0.1%)           <rustc_metadata::rmeta::decoder::DecodeContext as rustc_span::SpanDecoder>::decode_symbol

<    53,186,387  (0.7%, 45.8%)  /data/code/rust/src/librustdoc/html/highlight.rs:
     10,603,338  (0.1%)           <rustdoc::html::highlight::Classifier>::highlight
      8,304,664  (0.1%)           <rustdoc::html::highlight::PeekIter>::peek
      8,286,042  (0.1%)           rustdoc::html::highlight::write_code::<core::fmt::Formatter>::{closure#1}

<    53,155,861  (0.7%, 46.4%)  /data/code/rust/library/core/src/fmt/mod.rs:
     23,921,806  (0.3%)           core::fmt::write
      9,227,784  (0.1%)           core::fmt::Formatter::pad

<    51,830,424  (0.6%, 47.1%)  /data/code/rust/compiler/rustc_span/src/lib.rs:
     13,345,346  (0.2%)           <rustc_span::span_encoding::Span as rustc_data_structures::stable_hasher::HashStable<rustc_query_system::ich::hcx::StableHashingContext>>::hash_stable
      9,291,377  (0.1%)           <rustc_span::span_encoding::Span>::prepare_to_combine

<    51,392,273  (0.6%, 47.7%)  /data/code/rust/compiler/rustc_infer/src/traits/util.rs:
     24,827,099  (0.3%)           <rustc_infer::traits::util::Elaborator<rustc_middle::ty::predicate::Clause> as core::iter::traits::iterator::Iterator>::next
     20,922,543  (0.3%)           <rustc_infer::traits::util::PredicateSet>::insert

<    50,064,390  (0.6%, 48.3%)  /data/code/rust/compiler/rustc_data_structures/src/sip128.rs:
     15,910,710  (0.2%)           <rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<8>
      9,207,600  (0.1%)           <rustc_span::span_encoding::Span as rustc_data_structures::stable_hasher::HashStable<rustc_query_system::ich::hcx::StableHashingContext>>::hash_stable
      9,042,545  (0.1%)           <rustc_data_structures::sip128::SipHasher128>::finish128

<    48,080,225  (0.6%, 48.9%)  /data/code/rust/compiler/rustc_query_impl/src/plumbing.rs:
     15,702,717  (0.2%)           rustc_query_impl::plumbing::query_key_hash_verify::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 16]>>, false, false, false>>::{closure#0}

<    41,633,531  (0.5%, 49.5%)  /data/code/rust/compiler/rustc_middle/src/ty/sty.rs:
      9,299,692  (0.1%)           <rustc_middle::ty::context::TyCtxt>::anonymize_bound_vars::<rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt>>

<    41,449,429  (0.5%, 50.0%)  /data/code/rust/library/std/src/sys/pal/unix/alloc.rs:
     26,655,358  (0.3%)           __rdl_alloc
      8,888,388  (0.1%)           __rdl_dealloc

<    40,064,348  (0.5%, 50.5%)  /data/code/rust/compiler/rustc_span/src/symbol.rs:
     12,193,080  (0.2%)           <rustc_span::symbol::Symbol>::as_str
      8,200,035  (0.1%)           <rustc_span::symbol::Symbol>::intern

<    39,803,735  (0.5%, 51.0%)  /data/code/rust/compiler/rustc_trait_selection/src/traits/normalize.rs:
      8,700,660  (0.1%)           rustc_trait_selection::traits::normalize::normalize_with_depth_to::<rustc_middle::ty::Ty>

<    37,491,126  (0.5%, 51.4%)  /data/code/rust/compiler/rustc_resolve/src/ident.rs:
     11,592,062  (0.1%)           <rustc_resolve::Resolver>::early_resolve_ident_in_lexical_scope

<    37,244,223  (0.5%, 51.9%)  /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stacker-0.1.15/src/lib.rs:
     21,460,802  (0.3%)           stacker::remaining_stack

<    36,940,963  (0.5%, 52.4%)  /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulldown-cmark-0.9.6/src/firstpass.rs:
     20,377,187  (0.3%)           <pulldown_cmark::firstpass::FirstPass>::parse_line

<    35,233,003  (0.4%, 52.8%)  /data/code/rust/src/librustdoc/clean/mod.rs:
     15,439,404  (0.2%)           rustdoc::clean::clean_middle_ty

<    35,124,191  (0.4%, 53.3%)  /data/code/rust/compiler/rustc_type_ir/src/ty_kind.rs:
     19,045,732  (0.2%)           <rustc_type_ir::ty_kind::TyKind<rustc_middle::ty::context::TyCtxt> as core::cmp::PartialEq>::eq
     12,614,457  (0.2%)           <rustc_type_ir::ty_kind::TyKind<rustc_middle::ty::context::TyCtxt> as core::hash::Hash>::hash::<rustc_hash::FxHasher>

<    34,224,568  (0.4%, 53.7%)  /data/code/rust/compiler/rustc_type_ir/src/interner.rs:
     17,174,336  (0.2%)           <rustc_middle::ty::sty::BoundVariableKind as rustc_type_ir::interner::CollectAndApply<rustc_middle::ty::sty::BoundVariableKind, &rustc_middle::ty::list::RawList<(), rustc_middle::ty::sty::BoundVariableKind>>>::collect_and_apply::<indexmap::map::iter::IntoValues<rustc_type_ir::BoundVar, rustc_middle::ty::sty::BoundVariableKind>, <rustc_middle::ty::context::TyCtxt>::mk_bound_variable_kinds_from_iter<indexmap::map::iter::IntoValues<rustc_type_ir::BoundVar, rustc_middle::ty::sty::BoundVariableKind>, rustc_middle::ty::sty::BoundVariableKind>::{closure#0}>

<    32,446,925  (0.4%, 54.1%)  /data/code/rust/compiler/rustc_middle/src/ty/relate.rs:
     11,516,195  (0.1%)           rustc_middle::ty::relate::structurally_relate_tys::<rustc_infer::infer::relate::type_relating::TypeRelating>

<    32,390,234  (0.4%, 54.5%)  /data/code/rust/compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs:
     13,750,568  (0.2%)           <rustc_trait_selection::traits::select::SelectionContext>::assemble_candidates

<    31,953,245  (0.4%, 54.9%)  /data/code/rust/compiler/rustc_middle/src/ty/fold.rs:
     29,448,642  (0.4%)           <rustc_middle::ty::context::TyCtxt>::anonymize_bound_vars::<rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt>>

<    30,871,190  (0.4%, 55.3%)  /data/code/rust/compiler/rustc_query_system/src/query/caches.rs:
      8,296,841  (0.1%)           rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 8]>>>

<    30,173,168  (0.4%, 55.7%)  /data/code/rust/library/core/src/mem/mod.rs:
     15,318,028  (0.2%)           <rustc_middle::ty::context::TyCtxt>::reuse_or_mk_predicate
      8,561,410  (0.1%)           <rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt> as core::cmp::PartialEq>::eq

<    29,666,031  (0.4%, 56.0%)  /data/code/rust/library/core/src/iter/traits/iterator.rs:
     10,583,851  (0.1%)           <rustc_resolve::Resolver>::traits_in_scope

<    28,670,416  (0.4%, 56.4%)  /data/code/rust/compiler/rustc_lexer/src/lib.rs:
     22,977,609  (0.3%)           <rustc_lexer::cursor::Cursor>::advance_token

<    28,298,842  (0.4%, 56.7%)  /data/code/rust/library/core/src/slice/memchr.rs:
     23,035,403  (0.3%)           core::slice::memchr::memchr_aligned

<    25,597,403  (0.3%, 57.1%)  /data/code/rust/compiler/rustc_infer/src/infer/relate/higher_ranked.rs:
     15,536,876  (0.2%)           <rustc_infer::infer::InferCtxt>::enter_forall_and_leak_universe::<rustc_middle::ty::predicate::TraitPredicate>

<    25,279,766  (0.3%, 57.4%)  /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-1.1.0/src/lib.rs:
      8,209,435  (0.1%)           <rustc_span::symbol::Symbol>::intern

<    24,697,164  (0.3%, 57.7%)  /data/code/rust/library/alloc/src/string.rs:
     17,911,350  (0.2%)           <alloc::string::String as core::fmt::Write>::write_str

<    23,766,904  (0.3%, 58.0%)  /data/code/rust/compiler/rustc_span/src/caching_source_map_view.rs:
     19,742,230  (0.2%)           <rustc_span::caching_source_map_view::CachingSourceMapView>::span_data_to_lines_and_cols

<    22,460,127  (0.3%, 58.3%)  /data/code/rust/compiler/rustc_trait_selection/src/traits/select/confirmation.rs:
     13,283,704  (0.2%)           <rustc_trait_selection::traits::select::SelectionContext>::confirm_candidate

<    21,120,179  (0.3%, 58.5%)  /data/code/rust/compiler/rustc_infer/src/infer/relate/type_relating.rs:
     16,733,158  (0.2%)           <rustc_infer::infer::relate::type_relating::TypeRelating as rustc_middle::ty::relate::TypeRelation>::tys

<    20,675,880  (0.3%, 58.8%)  /data/code/rust/compiler/rustc_parse/src/lexer/mod.rs:
     15,054,546  (0.2%)           <rustc_parse::lexer::StringReader>::next_token

<    19,322,204  (0.2%, 59.0%)  /data/code/rust/compiler/rustc_infer/src/infer/snapshot/undo_log.rs:
     12,650,046  (0.2%)           <rustc_infer::infer::InferCtxtInner>::rollback_to

<    18,844,925  (0.2%, 59.3%)  /data/code/rust/compiler/rustc_infer/src/infer/at.rs:
      8,503,560  (0.1%)           <rustc_infer::infer::at::At>::eq::<rustc_middle::ty::predicate::TraitRef>
      8,077,230  (0.1%)           <rustc_middle::ty::predicate::TraitRef as rustc_infer::infer::at::ToTrace>::to_trace

<    18,760,105  (0.2%, 59.5%)  /data/code/rust/library/core/src/iter/adapters/flatten.rs:
     10,202,132  (0.1%)           <core::iter::adapters::flatten::FlattenCompat<core::iter::adapters::map::Map<core::slice::iter::Iter<rustc_middle::ty::Ty>, <rustc_trait_selection::traits::select::SelectionContext>::collect_predicates_for_types::{closure#0}>, alloc::vec::into_iter::IntoIter<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>> as core::iter::traits::iterator::Iterator>::next

<    18,631,299  (0.2%, 59.7%)  /data/code/rust/compiler/rustc_expand/src/mbe/transcribe.rs:
     10,169,253  (0.1%)           rustc_expand::mbe::macro_rules::expand_macro

<    18,056,591  (0.2%, 60.0%)  /data/code/rust/library/core/src/slice/cmp.rs:
      8,512,845  (0.1%)           <rustc_middle::ty::context::TyCtxt>::mk_args

<    17,755,600  (0.2%, 60.2%)  /data/code/rust/library/std/src/alloc.rs:
      8,888,388  (0.1%)           __rdl_dealloc

<    16,928,203  (0.2%, 60.4%)  /data/code/rust/compiler/rustc_infer/src/infer/type_variable.rs:
     10,049,343  (0.1%)           <rustc_infer::infer::type_variable::TypeVariableTable>::replace_if_possible

<    16,018,537  (0.2%, 60.6%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe

<    15,542,890  (0.2%, 60.8%)  /data/code/rust/compiler/rustc_parse/src/lexer/tokentrees.rs:
      9,962,578  (0.1%)           <rustc_parse::lexer::tokentrees::TokenTreesReader>::bump

<    13,637,274  (0.2%, 61.0%)  /data/code/rust/compiler/rustc_expand/src/mbe/macro_parser.rs:
     12,254,807  (0.2%)           <rustc_expand::mbe::macro_parser::TtParser>::parse_tt::<rustc_expand::mbe::macro_rules::NoopTracker>

<    13,319,219  (0.2%, 61.1%)  /data/code/rust/compiler/rustc_trait_selection/src/traits/auto_trait.rs:
      9,730,229  (0.1%)           <rustc_trait_selection::traits::auto_trait::AutoTraitFinder>::evaluate_predicates

<    11,639,727  (0.1%, 61.3%)  /data/code/rust/compiler/rustc_metadata/src/creader.rs:
     11,295,271  (0.1%)           <rustc_metadata::creader::CStore>::from_tcx

<    11,472,947  (0.1%, 61.4%)  /data/code/rust/src/librustdoc/html/escape.rs:
     10,295,016  (0.1%)           <rustdoc::html::escape::EscapeBodyText as core::fmt::Display>::fmt

<    10,930,744  (0.1%, 61.6%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<     9,440,399  (0.1%, 61.7%)  /data/code/rust/compiler/rustc_infer/src/infer/relate/combine.rs:
      9,387,188  (0.1%)           <rustc_infer::infer::InferCtxt>::super_combine_tys::<rustc_infer::infer::relate::type_relating::TypeRelating>

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 291,983,666 (3.7%,  3.7%)  _int_free:/usr/src/debug/glibc/glibc/malloc/malloc.c

> 249,795,624 (3.1%,  6.8%)  _int_malloc:/usr/src/debug/glibc/glibc/malloc/malloc.c

> 211,819,359 (2.7%,  9.4%)  malloc:
  200,360,728 (2.5%)           /usr/src/debug/glibc/glibc/malloc/malloc.c
   11,458,631 (0.1%)           /usr/src/debug/glibc/glibc/malloc/arena.c

> 156,301,360 (2.0%, 11.4%)  __memcpy_avx_unaligned_erms:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

> 146,713,863 (1.8%, 13.2%)  free:
   97,823,877 (1.2%)           /usr/src/debug/glibc/glibc/malloc/malloc.c
   48,889,986 (0.6%)           /usr/src/debug/glibc/glibc/malloc/arena.c

> 120,728,140 (1.5%, 14.7%)  <rustc_middle::ty::context::TyCtxt>::mk_args:
   32,022,090 (0.4%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs
   26,152,153 (0.3%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
    8,512,845 (0.1%)           /data/code/rust/library/core/src/slice/cmp.rs
    8,355,908 (0.1%)           /data/code/rust/library/core/src/num/mod.rs

> 108,179,465 (1.4%, 16.1%)  rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 8]>>>:
   28,988,941 (0.4%)           /data/code/rust/compiler/rustc_middle/src/query/plumbing.rs
   19,265,109 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
    8,296,841 (0.1%)           /data/code/rust/compiler/rustc_query_system/src/query/caches.rs

>  74,372,954 (0.9%, 17.0%)  rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 24]>>>:
   21,903,780 (0.3%)           /data/code/rust/compiler/rustc_middle/src/query/plumbing.rs
   12,207,958 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs

>  72,816,700 (0.9%, 17.9%)  <rustc_span::span_encoding::Span>::new:
   72,721,311 (0.9%)           /data/code/rust/compiler/rustc_span/src/span_encoding.rs

>  71,882,704 (0.9%, 18.8%)  <rustc_middle::ty::context::TyCtxt>::reuse_or_mk_predicate:
   22,379,504 (0.3%)           /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs
   18,280,988 (0.2%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs
   15,318,028 (0.2%)           /data/code/rust/library/core/src/mem/mod.rs

>  65,800,939 (0.8%, 19.7%)  <rustc_middle::ty::context::CtxtInterners>::intern_predicate:
   24,136,965 (0.3%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
   16,019,526 (0.2%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs

>  63,509,458 (0.8%, 20.5%)  <rustc_span::span_encoding::Span>::data_untracked:
   61,021,945 (0.8%)           /data/code/rust/compiler/rustc_span/src/span_encoding.rs

>  61,028,941 (0.8%, 21.2%)  <rustc_trait_selection::traits::auto_trait::AutoTraitFinder>::evaluate_predicates:
    9,730,229 (0.1%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/auto_trait.rs

>  60,378,628 (0.8%, 22.0%)  <rustc_parse::parser::Parser>::bump:
   26,257,306 (0.3%)           /data/code/rust/compiler/rustc_parse/src/parser/mod.rs
   19,650,598 (0.2%)           /data/code/rust/library/core/src/ptr/mod.rs

>  57,864,182 (0.7%, 22.7%)  <rustc_middle::ty::context::CtxtInterners>::intern_ty:
   18,490,775 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
   15,169,358 (0.2%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs

>  57,046,575 (0.7%, 23.4%)  <rustc_infer::traits::util::PredicateSet>::insert:
   20,922,543 (0.3%)           /data/code/rust/compiler/rustc_infer/src/traits/util.rs
   20,520,960 (0.3%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs

>  55,776,461 (0.7%, 24.1%)  <hashbrown::map::HashMap<rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::insert:
   16,035,259 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
   12,455,121 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/map.rs

>  55,099,452 (0.7%, 24.8%)  malloc_consolidate:/usr/src/debug/glibc/glibc/malloc/malloc.c

>  53,491,814 (0.7%, 25.5%)  <rustc_middle::ty::context::TyCtxt>::anonymize_bound_vars::<rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt>>:
   29,448,642 (0.4%)           /data/code/rust/compiler/rustc_middle/src/ty/fold.rs
    9,299,692 (0.1%)           /data/code/rust/compiler/rustc_middle/src/ty/sty.rs

>  52,682,960 (0.7%, 26.1%)  <rustc_span::symbol::Symbol>::intern:
    8,209,435 (0.1%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-1.1.0/src/lib.rs
    8,200,035 (0.1%)           /data/code/rust/compiler/rustc_span/src/symbol.rs

>  52,046,022 (0.7%, 26.8%)  <hashbrown::map::HashMap<rustc_span::def_id::DefId, rustc_query_system::query::plumbing::QueryResult, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::remove::<rustc_span::def_id::DefId>:
   18,400,104 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
   13,668,642 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/map.rs

>  50,007,066 (0.6%, 27.4%)  realloc:
   39,741,716 (0.5%)           /usr/src/debug/glibc/glibc/malloc/malloc.c
   10,265,350 (0.1%)           /usr/src/debug/glibc/glibc/malloc/arena.c

>  45,567,522 (0.6%, 28.0%)  alloc::raw_vec::finish_grow::<alloc::alloc::Global>:
   28,311,788 (0.4%)           /data/code/rust/library/alloc/src/raw_vec.rs
   15,189,174 (0.2%)           /data/code/rust/library/core/src/result.rs

>  43,135,451 (0.5%, 28.5%)  rustc_middle::query::plumbing::query_get_at::<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 3]>>>:
   12,389,292 (0.2%)           /data/code/rust/compiler/rustc_middle/src/query/plumbing.rs

>  41,658,425 (0.5%, 29.1%)  <rustc_span::SpanData as rustc_serialize::serialize::Decodable<rustc_metadata::rmeta::decoder::DecodeContext>>::decode:
   15,155,904 (0.2%)           /data/code/rust/compiler/rustc_metadata/src/rmeta/decoder.rs
   10,823,518 (0.1%)           /data/code/rust/compiler/rustc_serialize/src/opaque.rs

>  41,592,354 (0.5%, 29.6%)  <rustc_type_ir::predicate_kind::ClauseKind<rustc_middle::ty::context::TyCtxt> as rustc_type_ir::visit::TypeVisitable<rustc_middle::ty::context::TyCtxt>>::visit_with::<rustc_type_ir::visit::HasEscapingVarsVisitor>:
   23,434,267 (0.3%)           /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs
   10,759,230 (0.1%)           /data/code/rust/compiler/rustc_middle/src/ty/generic_args.rs

>  40,548,197 (0.5%, 30.1%)  <rustc_trait_selection::traits::select::SelectionContext>::assemble_candidates_from_caller_bounds:
   10,086,734 (0.1%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs

>  40,152,342 (0.5%, 30.6%)  <core::iter::adapters::flatten::FlattenCompat<core::iter::adapters::map::Map<core::slice::iter::Iter<rustc_middle::ty::Ty>, <rustc_trait_selection::traits::select::SelectionContext>::collect_predicates_for_types::{closure#0}>, alloc::vec::into_iter::IntoIter<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>> as core::iter::traits::iterator::Iterator>::next:
   10,202,132 (0.1%)           /data/code/rust/library/core/src/iter/adapters/flatten.rs

>  38,713,173 (0.5%, 31.1%)  <rustc_span::span_encoding::Span as rustc_data_structures::stable_hasher::HashStable<rustc_query_system::ich::hcx::StableHashingContext>>::hash_stable:
   13,345,346 (0.2%)           /data/code/rust/compiler/rustc_span/src/lib.rs
    9,207,600 (0.1%)           /data/code/rust/compiler/rustc_data_structures/src/sip128.rs

>  38,342,643 (0.5%, 31.5%)  <rustc_resolve::Resolver>::traits_in_scope:
   10,583,851 (0.1%)           /data/code/rust/library/core/src/iter/traits/iterator.rs

>  38,117,862 (0.5%, 32.0%)  core::fmt::write:
   23,921,806 (0.3%)           /data/code/rust/library/core/src/fmt/mod.rs

>  37,950,498 (0.5%, 32.5%)  <rustc_lexer::cursor::Cursor>::advance_token:
   22,977,609 (0.3%)           /data/code/rust/compiler/rustc_lexer/src/lib.rs

>  37,803,199 (0.5%, 33.0%)  <rustc_infer::traits::util::Elaborator<rustc_middle::ty::predicate::Clause> as core::iter::traits::iterator::Iterator>::next:
   24,827,099 (0.3%)           /data/code/rust/compiler/rustc_infer/src/traits/util.rs

>  36,888,135 (0.5%, 33.4%)  <hashbrown::raw::RawTable<(rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId)>>::reserve_rehash::<hashbrown::map::make_hasher<rustc_query_system::dep_graph::dep_node::DepNode, rustc_span::def_id::DefId, core::hash::BuildHasherDefault<rustc_hash::FxHasher>>::{closure#0}>:
   17,956,887 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs

>  36,202,630 (0.5%, 33.9%)  <rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<8>:
   18,908,380 (0.2%)           /data/code/rust/library/core/src/num/mod.rs
   15,910,710 (0.2%)           /data/code/rust/compiler/rustc_data_structures/src/sip128.rs

>  35,117,678 (0.4%, 34.3%)  stacker::remaining_stack:
   21,460,802 (0.3%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stacker-0.1.15/src/lib.rs

>  33,654,659 (0.4%, 34.8%)  <rustc_ast::token::TokenKind as core::cmp::PartialEq>::eq:
   33,241,148 (0.4%)           /data/code/rust/compiler/rustc_ast/src/token.rs

>  33,012,908 (0.4%, 35.2%)  <alloc::string::String as core::fmt::Write>::write_str:
   17,911,350 (0.2%)           /data/code/rust/library/alloc/src/string.rs

>  32,713,656 (0.4%, 35.6%)  _int_realloc:
   31,928,676 (0.4%)           /usr/src/debug/glibc/glibc/malloc/malloc.c

>  32,086,891 (0.4%, 36.0%)  <rustc_trait_selection::traits::select::SelectionContext>::evaluate_trait_predicate_recursively:
   17,863,499 (0.2%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs

>  31,926,047 (0.4%, 36.4%)  <rustc_trait_selection::traits::select::SelectionContext>::confirm_candidate:
   13,283,704 (0.2%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/confirmation.rs

>  31,877,777 (0.4%, 36.8%)  <rustc_trait_selection::traits::select::SelectionContext>::impl_or_trait_obligations:
    9,641,508 (0.1%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs

>  31,154,193 (0.4%, 37.2%)  <&rustc_middle::ty::list::RawList<(), rustc_middle::ty::generic_args::GenericArg> as rustc_type_ir::fold::TypeFoldable<rustc_middle::ty::context::TyCtxt>>::try_fold_with::<rustc_infer::infer::freshen::TypeFreshener>:
   24,705,041 (0.3%)           /data/code/rust/compiler/rustc_middle/src/ty/generic_args.rs

>  31,098,343 (0.4%, 37.6%)  __rdl_alloc:
   26,655,358 (0.3%)           /data/code/rust/library/std/src/sys/pal/unix/alloc.rs

>  30,933,674 (0.4%, 37.9%)  <rustc_middle::ty::sty::Binder<rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt>> as core::hash::Hash>::hash::<rustc_hash::FxHasher>:
   12,487,518 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs

>  30,630,805 (0.4%, 38.3%)  <rustc_trait_selection::traits::select::SelectionContext>::candidate_from_obligation:
   22,211,773 (0.3%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs

>  29,290,805 (0.4%, 38.7%)  <rustc_expand::mbe::macro_parser::TtParser>::parse_tt::<rustc_expand::mbe::macro_rules::NoopTracker>:
   12,254,807 (0.2%)           /data/code/rust/compiler/rustc_expand/src/mbe/macro_parser.rs

>  28,622,086 (0.4%, 39.1%)  <rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt> as core::cmp::PartialEq>::eq:
   16,473,354 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs
    8,561,410 (0.1%)           /data/code/rust/library/core/src/mem/mod.rs

>  28,456,344 (0.4%, 39.4%)  unlink_chunk.isra.0:/usr/src/debug/glibc/glibc/malloc/malloc.c

>  28,126,523 (0.4%, 39.8%)  <rustc_infer::infer::InferCtxt>::enter_forall_and_leak_universe::<rustc_middle::ty::predicate::TraitPredicate>:
   15,536,876 (0.2%)           /data/code/rust/compiler/rustc_infer/src/infer/relate/higher_ranked.rs

>  27,842,720 (0.3%, 40.1%)  <hashbrown::raw::RawTable<(rustc_middle::ty::predicate::Predicate, ())>>::reserve_rehash::<hashbrown::map::make_hasher<rustc_middle::ty::predicate::Predicate, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>::{closure#0}>:
   15,837,187 (0.2%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs

>  27,808,690 (0.3%, 40.5%)  <rustc_trait_selection::traits::select::SelectionContext>::assemble_candidates:
   13,750,568 (0.2%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs

>  26,798,394 (0.3%, 40.8%)  core::slice::memchr::memchr_aligned:
   23,035,403 (0.3%)           /data/code/rust/library/core/src/slice/memchr.rs

>  26,549,054 (0.3%, 41.1%)  <rustc_middle::ty::sty::BoundVariableKind as rustc_type_ir::interner::CollectAndApply<rustc_middle::ty::sty::BoundVariableKind, &rustc_middle::ty::list::RawList<(), rustc_middle::ty::sty::BoundVariableKind>>>::collect_and_apply::<indexmap::map::iter::IntoValues<rustc_type_ir::BoundVar, rustc_middle::ty::sty::BoundVariableKind>, <rustc_middle::ty::context::TyCtxt>::mk_bound_variable_kinds_from_iter<indexmap::map::iter::IntoValues<rustc_type_ir::BoundVar, rustc_middle::ty::sty::BoundVariableKind>, rustc_middle::ty::sty::BoundVariableKind>::{closure#0}>:
   17,174,336 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/interner.rs

>  26,398,620 (0.3%, 41.5%)  <rustc_infer::infer::relate::type_relating::TypeRelating as rustc_middle::ty::relate::TypeRelation>::tys:
   16,733,158 (0.2%)           /data/code/rust/compiler/rustc_infer/src/infer/relate/type_relating.rs

>  25,760,228 (0.3%, 41.8%)  <rustc_span::caching_source_map_view::CachingSourceMapView>::span_data_to_lines_and_cols:
   19,742,230 (0.2%)           /data/code/rust/compiler/rustc_span/src/caching_source_map_view.rs

>  25,696,015 (0.3%, 42.1%)  rustc_expand::mbe::macro_rules::expand_macro:
   10,169,253 (0.1%)           /data/code/rust/compiler/rustc_expand/src/mbe/transcribe.rs

>  24,647,749 (0.3%, 42.4%)  <rustc_metadata::creader::CStore>::from_tcx:
   11,295,271 (0.1%)           /data/code/rust/compiler/rustc_metadata/src/creader.rs

>  24,453,604 (0.3%, 42.7%)  <pulldown_cmark::firstpass::FirstPass>::parse_line:
   20,377,187 (0.3%)           /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulldown-cmark-0.9.6/src/firstpass.rs

>  23,542,696 (0.3%, 43.0%)  <rustc_type_ir::predicate_kind::PredicateKind<rustc_middle::ty::context::TyCtxt> as rustc_type_ir::visit::TypeVisitableExt<rustc_middle::ty::context::TyCtxt>>::has_vars_bound_at_or_above:
   16,308,740 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs

>  23,235,468 (0.3%, 43.3%)  <rustc_middle::ty::predicate::TraitRef as rustc_infer::infer::at::ToTrace>::to_trace:
    8,077,230 (0.1%)           /data/code/rust/compiler/rustc_infer/src/infer/at.rs

>  22,991,548 (0.3%, 43.6%)  <rustc_data_structures::sip128::SipHasher128>::finish128:
   12,577,953 (0.2%)           /data/code/rust/library/core/src/num/mod.rs
    9,042,545 (0.1%)           /data/code/rust/compiler/rustc_data_structures/src/sip128.rs

>  22,970,194 (0.3%, 43.9%)  <rustc_metadata::creader::CrateMetadataRef>::imported_source_file:
   11,132,730 (0.1%)           /data/code/rust/compiler/rustc_metadata/src/rmeta/decoder.rs

>  22,951,680 (0.3%, 44.2%)  <rustc_span::symbol::Symbol>::as_str:
   12,193,080 (0.2%)           /data/code/rust/compiler/rustc_span/src/symbol.rs

>  22,741,866 (0.3%, 44.4%)  rustc_query_impl::plumbing::query_key_hash_verify::<rustc_query_impl::DynamicConfig<rustc_query_system::query::caches::DefIdCache<rustc_middle::query::erase::Erased<[u8; 16]>>, false, false, false>>::{closure#0}:
   15,702,717 (0.2%)           /data/code/rust/compiler/rustc_query_impl/src/plumbing.rs

>  21,776,464 (0.3%, 44.7%)  <rustdoc::html::highlight::Classifier>::highlight:
   10,603,338 (0.1%)           /data/code/rust/src/librustdoc/html/highlight.rs

>  21,740,697 (0.3%, 45.0%)  <rustc_metadata::rmeta::decoder::DecodeContext as rustc_span::SpanDecoder>::decode_symbol:
    8,713,887 (0.1%)           /data/code/rust/compiler/rustc_serialize/src/opaque.rs

>  20,690,899 (0.3%, 45.3%)  <rustdoc::html::escape::EscapeBodyText as core::fmt::Display>::fmt:
   10,295,016 (0.1%)           /data/code/rust/src/librustdoc/html/escape.rs

>  19,673,178 (0.2%, 45.5%)  <&rustc_middle::ty::list::RawList<(), rustc_middle::ty::generic_args::GenericArg> as rustc_type_ir::fold::TypeFoldable<rustc_middle::ty::context::TyCtxt>>::try_fold_with::<rustc_middle::ty::generic_args::ArgFolder>:
   15,978,216 (0.2%)           /data/code/rust/compiler/rustc_middle/src/ty/generic_args.rs

>  19,638,491 (0.2%, 45.7%)  <rustc_type_ir::ty_kind::TyKind<rustc_middle::ty::context::TyCtxt> as core::cmp::PartialEq>::eq:
   19,045,732 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/ty_kind.rs

>  19,545,288 (0.2%, 46.0%)  <rustc_infer::infer::at::At>::eq::<rustc_middle::ty::predicate::TraitRef>:
    8,503,560 (0.1%)           /data/code/rust/compiler/rustc_infer/src/infer/at.rs

>  19,536,750 (0.2%, 46.2%)  <rustc_metadata::rmeta::decoder::DecodeContext as rustc_span::SpanDecoder>::decode_span:
   12,511,810 (0.2%)           /data/code/rust/compiler/rustc_metadata/src/rmeta/decoder.rs

>  19,215,490 (0.2%, 46.5%)  <rustc_middle::ty::context::TyCtxt>::mk_bound_variable_kinds:
   15,790,887 (0.2%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs

>  19,068,396 (0.2%, 46.7%)  rustdoc::clean::clean_middle_ty:
   15,439,404 (0.2%)           /data/code/rust/src/librustdoc/clean/mod.rs

>  18,235,122 (0.2%, 46.9%)  <rustc_middle::ty::context::TyCtxt>::def_path_hash:
   10,955,685 (0.1%)           /data/code/rust/compiler/rustc_middle/src/ty/context.rs

>  18,066,409 (0.2%, 47.2%)  <rustc_type_ir::ty_kind::TyKind<rustc_middle::ty::context::TyCtxt> as core::hash::Hash>::hash::<rustc_hash::FxHasher>:
   12,614,457 (0.2%)           /data/code/rust/compiler/rustc_type_ir/src/ty_kind.rs

>  17,790,351 (0.2%, 47.4%)  _int_free_merge_chunk:/usr/src/debug/glibc/glibc/malloc/malloc.c

>  17,785,124 (0.2%, 47.6%)  <rustc_resolve::Resolver>::early_resolve_ident_in_lexical_scope:
   11,592,062 (0.1%)           /data/code/rust/compiler/rustc_resolve/src/ident.rs

>  17,776,776 (0.2%, 47.8%)  __rdl_dealloc:
    8,888,388 (0.1%)           /data/code/rust/library/std/src/sys/pal/unix/alloc.rs
    8,888,388 (0.1%)           /data/code/rust/library/std/src/alloc.rs

>  17,031,056 (0.2%, 48.0%)  <rustc_parse::lexer::StringReader>::next_token:
   15,054,546 (0.2%)           /data/code/rust/compiler/rustc_parse/src/lexer/mod.rs

>  16,855,036 (0.2%, 48.3%)  core::ptr::drop_in_place::<alloc::vec::into_iter::IntoIter<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>>:
    9,095,608 (0.1%)           /data/code/rust/library/core/src/ptr/mod.rs

>  16,829,330 (0.2%, 48.5%)  <rustc_span::span_encoding::Span>::ctxt:/data/code/rust/compiler/rustc_span/src/span_encoding.rs

>  16,474,497 (0.2%, 48.7%)  <rustc_ast::token::TokenKind as core::clone::Clone>::clone:
   12,850,497 (0.2%)           /data/code/rust/compiler/rustc_ast/src/token.rs

>  16,398,866 (0.2%, 48.9%)  <rustc_infer::infer::InferCtxtInner>::rollback_to:
   12,650,046 (0.2%)           /data/code/rust/compiler/rustc_infer/src/infer/snapshot/undo_log.rs

>  16,018,537 (0.2%, 49.1%)  __memcmp_avx2_movbe:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

>  14,936,654 (0.2%, 49.3%)  <rustdoc::html::highlight::PeekIter>::peek:
    8,304,664 (0.1%)           /data/code/rust/src/librustdoc/html/highlight.rs

>  14,708,528 (0.2%, 49.5%)  _int_free_create_chunk:/usr/src/debug/glibc/glibc/malloc/malloc.c

>  12,834,996 (0.2%, 49.6%)  <rustc_span::span_encoding::Span>::prepare_to_combine:
    9,291,377 (0.1%)           /data/code/rust/compiler/rustc_span/src/lib.rs

>  12,416,833 (0.2%, 49.8%)  rustc_middle::ty::relate::structurally_relate_tys::<rustc_infer::infer::relate::type_relating::TypeRelating>:
   11,516,195 (0.1%)           /data/code/rust/compiler/rustc_middle/src/ty/relate.rs

>  12,168,324 (0.2%, 49.9%)  rustc_trait_selection::traits::normalize::normalize_with_depth_to::<rustc_middle::ty::Ty>:
    8,700,660 (0.1%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/normalize.rs

>  12,038,251 (0.2%, 50.1%)  <rustc_parse::lexer::tokentrees::TokenTreesReader>::bump:
    9,962,578 (0.1%)           /data/code/rust/compiler/rustc_parse/src/lexer/tokentrees.rs

>  12,037,758 (0.2%, 50.2%)  <rustc_trait_selection::traits::select::SelectionContext>::poly_select:
   10,606,878 (0.1%)           /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs

>  11,513,962 (0.1%, 50.4%)  <rustc_infer::infer::type_variable::TypeVariableTable>::replace_if_possible:
   10,049,343 (0.1%)           /data/code/rust/compiler/rustc_infer/src/infer/type_variable.rs

>  11,493,076 (0.1%, 50.5%)  rustdoc::html::highlight::write_code::<core::fmt::Formatter>::{closure#1}:
    8,286,042 (0.1%)           /data/code/rust/src/librustdoc/html/highlight.rs

>  11,150,239 (0.1%, 50.7%)  core::fmt::Formatter::pad:
    9,227,784 (0.1%)           /data/code/rust/library/core/src/fmt/mod.rs

>  10,930,744 (0.1%, 50.8%)  __memset_avx2_unaligned_erms:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>  10,210,676 (0.1%, 50.9%)  core::ptr::drop_in_place::<alloc::vec::Vec<rustc_infer::traits::Obligation<rustc_middle::ty::predicate::Predicate>>>:
    8,200,068 (0.1%)           /data/code/rust/library/core/src/ptr/mod.rs

>   9,595,036 (0.1%, 51.0%)  <rustc_ast::token::Token>::is_keyword:
    8,388,132 (0.1%)           /data/code/rust/compiler/rustc_ast/src/token.rs

>   9,440,964 (0.1%, 51.2%)  <rustc_infer::infer::InferCtxt>::super_combine_tys::<rustc_infer::infer::relate::type_relating::TypeRelating>:
    9,387,188 (0.1%)           /data/code/rust/compiler/rustc_infer/src/infer/relate/combine.rs

>   9,435,240 (0.1%, 51.3%)  <rustc_middle::ty::predicate::Clause>::as_trait_clause:/data/code/rust/compiler/rustc_middle/src/ty/predicate.rs

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_ast/src/token.rs
--------------------------------------------------------------------------------
Ir_______________ 

 4,581,236 (0.1%)  <unknown (line 0)>

-- line 13 ----------------------------------------
         .         use rustc_span::symbol::{kw, sym};
         .         #[allow(clippy::useless_attribute)] // FIXME: following use of `hidden_glob_reexports` incorrectly triggers `useless_attribute` lint.
         .         #[allow(hidden_glob_reexports)]
         .         use rustc_span::symbol::{Ident, Symbol};
         .         use rustc_span::{edition::Edition, ErrorGuaranteed, Span, DUMMY_SP};
         .         use std::borrow::Cow;
         .         use std::fmt;
         .         
   105,238 (0.0%)  #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]
         .         pub enum CommentKind {
         .             Line,
         .             Block,
         .         }
         .         
     1,962 (0.0%)  #[derive(Clone, PartialEq, Encodable, Decodable, Hash, Debug, Copy)]
         .         #[derive(HashStable_Generic)]
         .         pub enum BinOpToken {
         .             Plus,
         .             Minus,
         .             Star,
         .             Slash,
         .             Percent,
         .             Caret,
-- line 35 ----------------------------------------
-- line 37 ----------------------------------------
         .             Or,
         .             Shl,
         .             Shr,
         .         }
         .         
         .         /// Describes how a sequence of token trees is delimited.
         .         /// Cannot use `proc_macro::Delimiter` directly because this
         .         /// structure should implement some additional traits.
   358,504 (0.0%)  #[derive(Copy, Clone, Debug, PartialEq, Eq)]
     7,912 (0.0%)  #[derive(Encodable, Decodable, Hash, HashStable_Generic)]
         .         pub enum Delimiter {
         .             /// `( ... )`
         .             Parenthesis,
         .             /// `{ ... }`
         .             Brace,
         .             /// `[ ... ]`
         .             Bracket,
         .             /// `Ø ... Ø`
-- line 54 ----------------------------------------
-- line 58 ----------------------------------------
         .             /// Invisible delimiters might not survive roundtrip of a token stream through a string.
         .             Invisible,
         .         }
         .         
         .         // Note that the suffix is *not* considered when deciding the `LitKind` in this
         .         // type. This means that float literals like `1f32` are classified by this type
         .         // as `Int`. Only upon conversion to `ast::LitKind` will such a literal be
         .         // given the `Float` kind.
    17,450 (0.0%)  #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]
         .         pub enum LitKind {
         .             Bool, // AST only, must never appear in a `Token`
         .             Byte,
         .             Char,
         .             Integer, // e.g. `1`, `1u8`, `1f32`
         .             Float,   // e.g. `1.`, `1.0`, `1e3f32`
         .             Str,
         .             StrRaw(u8), // raw string delimited by `n` hash symbols
-- line 74 ----------------------------------------
-- line 75 ----------------------------------------
         .             ByteStr,
         .             ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols
         .             CStr,
         .             CStrRaw(u8),
         .             Err(ErrorGuaranteed),
         .         }
         .         
         .         /// A literal token.
    86,378 (0.0%)  #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]
         .         pub struct Lit {
        32 (0.0%)      pub kind: LitKind,
         8 (0.0%)      pub symbol: Symbol,
         .             pub suffix: Option<Symbol>,
         .         }
         .         
         .         impl Lit {
         .             pub fn new(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Lit {
         .                 Lit { kind, symbol, suffix }
         .             }
         .         
-- line 94 ----------------------------------------
-- line 101 ----------------------------------------
         .                         Some(sym) => sym == sym::f32 || sym == sym::f64,
         .                         None => false,
         .                     },
         .                     _ => false,
         .                 }
         .             }
         .         
         .             /// Keep this in sync with `Token::can_begin_literal_maybe_minus` excluding unary negation.
    23,256 (0.0%)      pub fn from_token(token: &Token) -> Option<Lit> {
   126,783 (0.0%)          match token.uninterpolate().kind {
    30,978 (0.0%)              Ident(name, IdentIsRaw::No) if name.is_bool_lit() => Some(Lit::new(Bool, name, None)),
    17,531 (0.0%)              Literal(token_lit) => Some(token_lit),
       390 (0.0%)              Interpolated(ref nt)
       650 (0.0%)                  if let NtExpr(expr) | NtLiteral(expr) = &nt.0
         .                             && let ast::ExprKind::Lit(token_lit) = expr.kind =>
         .                     {
         .                         Some(token_lit)
         .                     }
     3,199 (0.0%)              _ => None,
         .                 }
    15,504 (0.0%)      }
         .         }
         .         
         .         impl fmt::Display for Lit {
       440 (0.0%)      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
       330 (0.0%)          let Lit { kind, symbol, suffix } = *self;
       165 (0.0%)          match kind {
         .                     Byte => write!(f, "b'{symbol}'")?,
         .                     Char => write!(f, "'{symbol}'")?,
       150 (0.0%)              Str => write!(f, "\"{symbol}\"")?,
         .                     StrRaw(n) => write!(
         .                         f,
         .                         "r{delim}\"{string}\"{delim}",
         .                         delim = "#".repeat(n as usize),
         .                         string = symbol
         .                     )?,
         .                     ByteStr => write!(f, "b\"{symbol}\"")?,
         .                     ByteStrRaw(n) => write!(
-- line 138 ----------------------------------------
-- line 140 ----------------------------------------
         .                         "br{delim}\"{string}\"{delim}",
         .                         delim = "#".repeat(n as usize),
         .                         string = symbol
         .                     )?,
         .                     CStr => write!(f, "c\"{symbol}\"")?,
         .                     CStrRaw(n) => {
         .                         write!(f, "cr{delim}\"{symbol}\"{delim}", delim = "#".repeat(n as usize))?
         .                     }
        15 (0.0%)              Integer | Float | Bool | Err(_) => write!(f, "{symbol}")?,
         .                 }
         .         
       110 (0.0%)          if let Some(suffix) = suffix {
         .                     write!(f, "{suffix}")?;
         .                 }
         .         
         .                 Ok(())
       385 (0.0%)      }
         .         }
         .         
         .         impl LitKind {
         .             /// An English article for the literal token kind.
         .             pub fn article(self) -> &'static str {
         .                 match self {
         .                     Integer | Err(_) => "an",
         .                     _ => "a",
-- line 164 ----------------------------------------
-- line 175 ----------------------------------------
         .                     Str | StrRaw(..) => "string",
         .                     ByteStr | ByteStrRaw(..) => "byte string",
         .                     CStr | CStrRaw(..) => "C string",
         .                     Err(_) => "error",
         .                 }
         .             }
         .         
         .             pub(crate) fn may_have_suffix(self) -> bool {
     1,104 (0.0%)          matches!(self, Integer | Float | Err(_))
         .             }
         .         }
         .         
         .         pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: IdentIsRaw) -> bool {
         .             let ident_token = Token::new(Ident(name, is_raw), span);
         .         
    17,304 (0.0%)      !ident_token.is_reserved_ident()
     5,756 (0.0%)          || ident_token.is_path_segment_keyword()
         .                 || [
         .                     kw::Async,
         .                     kw::Do,
         .                     kw::Box,
         .                     kw::Break,
         .                     kw::Const,
         .                     kw::Continue,
         .                     kw::False,
-- line 199 ----------------------------------------
-- line 213 ----------------------------------------
         .                     kw::Static,
         .                 ]
         .                 .contains(&name)
         .         }
         .         
         .         fn ident_can_begin_type(name: Symbol, span: Span, is_raw: IdentIsRaw) -> bool {
         .             let ident_token = Token::new(Ident(name, is_raw), span);
         .         
     6,450 (0.0%)      !ident_token.is_reserved_ident()
     1,128 (0.0%)          || ident_token.is_path_segment_keyword()
         .                 || [kw::Underscore, kw::For, kw::Impl, kw::Fn, kw::Unsafe, kw::Extern, kw::Typeof, kw::Dyn]
         .                     .contains(&name)
         .         }
         .         
    13,655 (0.0%)  #[derive(PartialEq, Encodable, Decodable, Debug, Copy, Clone, HashStable_Generic)]
         .         pub enum IdentIsRaw {
         .             No,
         .             Yes,
         .         }
         .         
         .         impl From<bool> for IdentIsRaw {
         .             fn from(b: bool) -> Self {
         .                 if b { Self::Yes } else { Self::No }
-- line 235 ----------------------------------------
-- line 239 ----------------------------------------
         .         impl From<IdentIsRaw> for bool {
         .             fn from(is_raw: IdentIsRaw) -> bool {
         .                 matches!(is_raw, IdentIsRaw::Yes)
         .             }
         .         }
         .         
         .         // SAFETY: due to the `Clone` impl below, all fields of all variants other than
         .         // `Interpolated` must impl `Copy`.
30,276,179 (0.4%)  #[derive(PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]
    42,656 (0.0%)  pub enum TokenKind {
         .             /* Expression-operator symbols. */
         .             /// `=`
         .             Eq,
         .             /// `<`
         .             Lt,
         .             /// `<=`
         .             Le,
         .             /// `==`
-- line 256 ----------------------------------------
-- line 312 ----------------------------------------
         .         
         .             /* Literals */
         .             Literal(Lit),
         .         
         .             /// Identifier token.
         .             /// Do not forget about `NtIdent` when you want to match on identifiers.
         .             /// It's recommended to use `Token::(ident,uninterpolate,uninterpolated_span)` to
         .             /// treat regular and interpolated identifiers in the same way.
    45,590 (0.0%)      Ident(Symbol, IdentIsRaw),
         .             /// Lifetime identifier token.
         .             /// Do not forget about `NtLifetime` when you want to match on lifetime identifiers.
         .             /// It's recommended to use `Token::(lifetime,uninterpolate,uninterpolated_span)` to
         .             /// treat regular and interpolated lifetime identifiers in the same way.
         .             Lifetime(Symbol),
         .         
         .             /// An embedded AST node, as produced by a macro. This only exists for
         .             /// historical reasons. We'd like to get rid of it, for multiple reasons.
-- line 328 ----------------------------------------
-- line 340 ----------------------------------------
         .             /// similarly to symbols in string literal tokens.
         .             DocComment(CommentKind, ast::AttrStyle, Symbol),
         .         
         .             /// End Of File
         .             Eof,
         .         }
         .         
         .         impl Clone for TokenKind {
 3,624,000 (0.0%)      fn clone(&self) -> Self {
         .                 // `TokenKind` would impl `Copy` if it weren't for `Interpolated`. So
         .                 // for all other variants, this implementation of `clone` is just like
         .                 // a copy. This is faster than the `derive(Clone)` version which has a
         .                 // separate path for every variant.
 3,629,091 (0.0%)          match self {
   166,497 (0.0%)              Interpolated(nt) => Interpolated(nt.clone()),
         .                     _ => unsafe { std::ptr::read(self) },
         .                 }
 5,436,000 (0.1%)      }
         .         }
         .         
 3,608,259 (0.0%)  #[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]
         .         pub struct Token {
     1,635 (0.0%)      pub kind: TokenKind,
         .             pub span: Span,
         .         }
         .         
         .         impl TokenKind {
         .             pub fn lit(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> TokenKind {
         .                 Literal(Lit::new(kind, symbol, suffix))
         .             }
         .         
         .             /// An approximation to proc-macro-style single-character operators used by rustc parser.
         .             /// If the operator token can be broken into two tokens, the first of which is single-character,
         .             /// then this function performs that operation, otherwise it returns `None`.
         .             pub fn break_two_token_op(&self) -> Option<(TokenKind, TokenKind)> {
   128,330 (0.0%)          Some(match *self {
         .                     Le => (Lt, Eq),
         .                     EqEq => (Eq, Eq),
         .                     Ne => (Not, Eq),
         .                     Ge => (Gt, Eq),
         .                     AndAnd => (BinOp(And), BinOp(And)),
         .                     OrOr => (BinOp(Or), BinOp(Or)),
         .                     BinOp(Shl) => (Lt, Lt),
         .                     BinOp(Shr) => (Gt, Gt),
-- line 383 ----------------------------------------
-- line 398 ----------------------------------------
         .                     LArrow => (Lt, BinOp(Minus)),
         .                     FatArrow => (Eq, Gt),
         .                     _ => return None,
         .                 })
         .             }
         .         
         .             /// Returns tokens that are likely to be typed accidentally instead of the current token.
         .             /// Enables better error recovery when the wrong token is found.
    13,585 (0.0%)      pub fn similar_tokens(&self) -> Option<Vec<TokenKind>> {
    19,019 (0.0%)          match *self {
         .                     Comma => Some(vec![Dot, Lt, Semi]),
         .                     Semi => Some(vec![Colon, Comma]),
         .                     Colon => Some(vec![Semi]),
    21,736 (0.0%)              FatArrow => Some(vec![Eq, RArrow, Ge, Gt]),
         .                     _ => None,
         .                 }
    13,585 (0.0%)      }
         .         
         .             pub fn should_end_const_arg(&self) -> bool {
    16,103 (0.0%)          matches!(self, Gt | Ge | BinOp(Shr) | BinOpEq(Shr))
         .             }
         .         }
         .         
         .         impl Token {
         .             pub fn new(kind: TokenKind, span: Span) -> Self {
    43,945 (0.0%)          Token { kind, span }
         .             }
         .         
         .             /// Some token that will be thrown away later.
         .             pub fn dummy() -> Self {
         .                 Token::new(TokenKind::Question, DUMMY_SP)
         .             }
         .         
         .             /// Recovers a `Token` from an `Ident`. This creates a raw identifier if necessary.
         .             pub fn from_ast_ident(ident: Ident) -> Self {
       372 (0.0%)          Token::new(Ident(ident.name, ident.is_raw_guess().into()), ident.span)
         .             }
         .         
         .             /// For interpolated tokens, returns a span of the fragment to which the interpolated
         .             /// token refers. For all other tokens this is just a regular span.
         .             /// It is particularly important to use this for identifiers and lifetimes
         .             /// for which spans affect name resolution and edition checks.
         .             /// Note that keywords are also identifiers, so they should use this
         .             /// if they keep spans or perform edition checks.
    34,456 (0.0%)      pub fn uninterpolated_span(&self) -> Span {
    34,456 (0.0%)          match &self.kind {
       933 (0.0%)              Interpolated(nt) => nt.0.use_span(),
    16,917 (0.0%)              _ => self.span,
         .                 }
    33,834 (0.0%)      }
         .         
   249,785 (0.0%)      pub fn is_range_separator(&self) -> bool {
         .                 [DotDot, DotDotDot, DotDotEq].contains(&self.kind)
       115 (0.0%)      }
         .         
         .             pub fn is_punct(&self) -> bool {
   267,166 (0.0%)          match self.kind {
         .                     Eq | Lt | Le | EqEq | Ne | Ge | Gt | AndAnd | OrOr | Not | Tilde | BinOp(_)
         .                     | BinOpEq(_) | At | Dot | DotDot | DotDotDot | DotDotEq | Comma | Semi | Colon
         .                     | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar | Question | SingleQuote => true,
         .         
         .                     OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)
         .                     | Lifetime(..) | Interpolated(..) | Eof => false,
         .                 }
         .             }
         .         
         .             pub fn is_like_plus(&self) -> bool {
    55,819 (0.0%)          matches!(self.kind, BinOp(Plus) | BinOpEq(Plus))
         .             }
         .         
         .             /// Returns `true` if the token can appear at the start of an expression.
   121,902 (0.0%)      pub fn can_begin_expr(&self) -> bool {
   165,854 (0.0%)          match self.uninterpolate().kind {
    43,260 (0.0%)              Ident(name, is_raw)              =>
     8,652 (0.0%)                  ident_can_begin_expr(name, self.span, is_raw), // value name or keyword
         .                     OpenDelim(..)                     | // tuple, array or block
         .                     Literal(..)                       | // literal
         .                     Not                               | // operator not
         .                     BinOp(Minus)                      | // unary minus
         .                     BinOp(Star)                       | // dereference
         .                     BinOp(Or) | OrOr                  | // closure
         .                     BinOp(And)                        | // reference
         .                     AndAnd                            | // double reference
         .                     // DotDotDot is no longer supported, but we need some way to display the error
         .                     DotDot | DotDotDot | DotDotEq     | // range notation
         .                     Lt | BinOp(Shl)                   | // associated path
         .                     ModSep                            | // global path
         .                     Lifetime(..)                      | // labeled loop
         .                     Pound                             => true, // expression attributes
    12,240 (0.0%)              Interpolated(ref nt) => matches!(&nt.0, NtLiteral(..) |
         .                         NtExpr(..)    |
         .                         NtBlock(..)   |
         .                         NtPath(..)),
         .                     _ => false,
         .                 }
   142,219 (0.0%)      }
         .         
         .             /// Returns `true` if the token can appear at the start of a pattern.
         .             ///
         .             /// Shamelessly borrowed from `can_begin_expr`, only used for diagnostics right now.
         .             pub fn can_begin_pattern(&self) -> bool {
         .                 match self.uninterpolate().kind {
         .                     Ident(name, is_raw)              =>
         .                         ident_can_begin_expr(name, self.span, is_raw), // value name or keyword
-- line 501 ----------------------------------------
-- line 512 ----------------------------------------
         .                         NtPat(..)     |
         .                         NtBlock(..)   |
         .                         NtPath(..)),
         .                     _ => false,
         .                 }
         .             }
         .         
         .             /// Returns `true` if the token can appear at the start of a type.
    25,944 (0.0%)      pub fn can_begin_type(&self) -> bool {
    38,150 (0.0%)          match self.uninterpolate().kind {
    16,125 (0.0%)              Ident(name, is_raw)        =>
     3,225 (0.0%)                  ident_can_begin_type(name, self.span, is_raw), // type name or keyword
         .                     OpenDelim(Delimiter::Parenthesis) | // tuple
         .                     OpenDelim(Delimiter::Bracket)     | // array
         .                     Not                         | // never
         .                     BinOp(Star)                 | // raw pointer
         .                     BinOp(And)                  | // reference
         .                     AndAnd                      | // double reference
         .                     Question                    | // maybe bound in trait object
         .                     Lifetime(..)                | // lifetime bound in trait object
         .                     Lt | BinOp(Shl)             | // associated path
         .                     ModSep                      => true, // global path
     2,030 (0.0%)              Interpolated(ref nt) => matches!(&nt.0, NtTy(..) | NtPath(..)),
         .                     // For anonymous structs or unions, which only appear in specific positions
         .                     // (type of struct fields or union fields), we don't consider them as regular types
         .                     _ => false,
         .                 }
    30,268 (0.0%)      }
         .         
         .             /// Returns `true` if the token can appear at the start of a const param.
     5,996 (0.0%)      pub fn can_begin_const_arg(&self) -> bool {
    14,990 (0.0%)          match self.kind {
         .                     OpenDelim(Delimiter::Brace) => true,
     2,044 (0.0%)              Interpolated(ref nt) => matches!(&nt.0, NtExpr(..) | NtBlock(..) | NtLiteral(..)),
     4,974 (0.0%)              _ => self.can_begin_literal_maybe_minus(),
         .                 }
     1,022 (0.0%)      }
         .         
         .             /// Returns `true` if the token can appear at the start of an item.
         .             pub fn can_begin_item(&self) -> bool {
         .                 match self.kind {
         .                     Ident(name, _) => [
         .                         kw::Fn,
         .                         kw::Use,
         .                         kw::Struct,
-- line 556 ----------------------------------------
-- line 578 ----------------------------------------
         .             }
         .         
         .             /// Returns `true` if the token is any literal, a minus (which can prefix a literal,
         .             /// for example a '-42', or one of the boolean idents).
         .             ///
         .             /// In other words, would this token be a valid start of `parse_literal_maybe_minus`?
         .             ///
         .             /// Keep this in sync with and `Lit::from_token`, excluding unary negation.
     5,086 (0.0%)      pub fn can_begin_literal_maybe_minus(&self) -> bool {
    41,917 (0.0%)          match self.uninterpolate().kind {
         .                     Literal(..) | BinOp(Minus) => true,
     4,302 (0.0%)              Ident(name, IdentIsRaw::No) if name.is_bool_lit() => true,
         .                     Interpolated(ref nt) => match &nt.0 {
         .                         NtLiteral(_) => true,
         .                         NtExpr(e) => match &e.kind {
         .                             ast::ExprKind::Lit(_) => true,
         .                             ast::ExprKind::Unary(ast::UnOp::Neg, e) => {
         .                                 matches!(&e.kind, ast::ExprKind::Lit(_))
         .                             }
         .                             _ => false,
         .                         },
         .                         _ => false,
         .                     },
         .                     _ => false,
         .                 }
     5,086 (0.0%)      }
         .         
         .             /// A convenience function for matching on identifiers during parsing.
         .             /// Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token
         .             /// into the regular identifier or lifetime token it refers to,
         .             /// otherwise returns the original token.
         .             pub fn uninterpolate(&self) -> Cow<'_, Token> {
   322,130 (0.0%)          match &self.kind {
    94,993 (0.0%)              Interpolated(nt) => match &nt.0 {
         .                         NtIdent(ident, is_raw) => {
     9,717 (0.0%)                      Cow::Owned(Token::new(Ident(ident.name, *is_raw), ident.span))
         .                         }
         .                         NtLifetime(ident) => Cow::Owned(Token::new(Lifetime(ident.name), ident.span)),
         .                         _ => Cow::Borrowed(self),
         .                     },
         .                     _ => Cow::Borrowed(self),
         .                 }
         .             }
         .         
         .             /// Returns an identifier if this token is an identifier.
         .             #[inline]
         .             pub fn ident(&self) -> Option<(Ident, IdentIsRaw)> {
         .                 // We avoid using `Token::uninterpolate` here because it's slow.
 7,036,278 (0.1%)          match &self.kind {
 2,260,503 (0.0%)              &Ident(name, is_raw) => Some((Ident::new(name, self.span), is_raw)),
   144,826 (0.0%)              Interpolated(nt) => match &nt.0 {
    33,497 (0.0%)                  NtIdent(ident, is_raw) => Some((*ident, *is_raw)),
         .                         _ => None,
         .                     },
         .                     _ => None,
         .                 }
         .             }
         .         
         .             /// Returns a lifetime identifier if this token is a lifetime.
         .             #[inline]
         .             pub fn lifetime(&self) -> Option<Ident> {
         .                 // We avoid using `Token::uninterpolate` here because it's slow.
   955,757 (0.0%)          match &self.kind {
     2,694 (0.0%)              &Lifetime(name) => Some(Ident::new(name, self.span)),
    13,082 (0.0%)              Interpolated(nt) => match &nt.0 {
     4,626 (0.0%)                  NtLifetime(ident) => Some(*ident),
         .                         _ => None,
         .                     },
         .                     _ => None,
         .                 }
         .             }
         .         
         .             /// Returns `true` if the token is an identifier.
         .             pub fn is_ident(&self) -> bool {
         .                 self.ident().is_some()
    52,433 (0.0%)      }
         .         
         .             /// Returns `true` if the token is a lifetime.
         .             pub fn is_lifetime(&self) -> bool {
         .                 self.lifetime().is_some()
    21,120 (0.0%)      }
         .         
         .             /// Returns `true` if the token is an identifier whose name is the given
         .             /// string slice.
    67,918 (0.0%)      pub fn is_ident_named(&self, name: Symbol) -> bool {
         .                 self.ident().is_some_and(|(ident, _)| ident.name == name)
    67,918 (0.0%)      }
         .         
         .             /// Returns `true` if the token is an interpolated path.
         .             fn is_whole_path(&self) -> bool {
   163,161 (0.0%)          if let Interpolated(nt) = &self.kind
     8,801 (0.0%)              && let NtPath(..) = &nt.0
         .                 {
         .                     return true;
         .                 }
         .         
         .                 false
         .             }
         .         
         .             /// Would `maybe_whole_expr` in `parser.rs` return `Ok(..)`?
         .             /// That is, is this a pre-parsed expression dropped into the token stream
         .             /// (which happens while parsing the result of macro expansion)?
         .             pub fn is_whole_expr(&self) -> bool {
        42 (0.0%)          if let Interpolated(nt) = &self.kind
         .                     && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtBlock(_) = &nt.0
         .                 {
         .                     return true;
         .                 }
         .         
         .                 false
         .             }
         .         
         .             /// Is the token an interpolated block (`$b:block`)?
         .             pub fn is_whole_block(&self) -> bool {
    14,546 (0.0%)          if let Interpolated(nt) = &self.kind
       212 (0.0%)              && let NtBlock(..) = &nt.0
         .                 {
         .                     return true;
         .                 }
         .         
         .                 false
         .             }
         .         
         .             /// Returns `true` if the token is either the `mut` or `const` keyword.
         .             pub fn is_mutability(&self) -> bool {
         .                 self.is_keyword(kw::Mut) || self.is_keyword(kw::Const)
         .             }
         .         
    23,990 (0.0%)      pub fn is_qpath_start(&self) -> bool {
   118,370 (0.0%)          self == &Lt || self == &BinOp(Shl)
         .             }
         .         
   380,912 (0.0%)      pub fn is_path_start(&self) -> bool {
   108,832 (0.0%)          self == &ModSep
   108,774 (0.0%)              || self.is_qpath_start()
         .                     || self.is_whole_path()
   104,784 (0.0%)              || self.is_path_segment_keyword()
    76,053 (0.0%)              || self.is_ident() && !self.is_reserved_ident()
   380,912 (0.0%)      }
         .         
         .             /// Returns `true` if the token is a given keyword, `kw`.
 1,326,696 (0.0%)      pub fn is_keyword(&self, kw: Symbol) -> bool {
         .                 self.is_non_raw_ident_where(|id| id.name == kw)
 1,326,696 (0.0%)      }
         .         
         .             /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.
     1,582 (0.0%)      pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {
       854 (0.0%)          self.is_keyword(kw)
         .                     || (case == Case::Insensitive
         .                         && self.is_non_raw_ident_where(|id| {
        10 (0.0%)                      id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()
         .                         }))
     1,582 (0.0%)      }
         .         
         .             pub fn is_path_segment_keyword(&self) -> bool {
         .                 self.is_non_raw_ident_where(Ident::is_path_segment_keyword)
     6,442 (0.0%)      }
         .         
         .             /// Returns true for reserved identifiers used internally for elided lifetimes,
         .             /// unnamed method parameters, crate root module, error recovery etc.
     6,398 (0.0%)      pub fn is_special_ident(&self) -> bool {
         .                 self.is_non_raw_ident_where(Ident::is_special)
     6,398 (0.0%)      }
         .         
         .             /// Returns `true` if the token is a keyword used in the language.
         .             pub fn is_used_keyword(&self) -> bool {
         .                 self.is_non_raw_ident_where(Ident::is_used_keyword)
     3,199 (0.0%)      }
         .         
         .             /// Returns `true` if the token is a keyword reserved for possible future use.
         .             pub fn is_unused_keyword(&self) -> bool {
         .                 self.is_non_raw_ident_where(Ident::is_unused_keyword)
     3,199 (0.0%)      }
         .         
         .             /// Returns `true` if the token is either a special identifier or a keyword.
         .             pub fn is_reserved_ident(&self) -> bool {
         .                 self.is_non_raw_ident_where(Ident::is_reserved)
       723 (0.0%)      }
         .         
         .             /// Returns `true` if the token is the identifier `true` or `false`.
    12,896 (0.0%)      pub fn is_bool_lit(&self) -> bool {
         .                 self.is_non_raw_ident_where(|id| id.name.is_bool_lit())
    12,896 (0.0%)      }
         .         
         .             pub fn is_numeric_lit(&self) -> bool {
         .                 matches!(
         .                     self.kind,
         .                     Literal(Lit { kind: LitKind::Integer, .. }) | Literal(Lit { kind: LitKind::Float, .. })
         .                 )
         .             }
         .         
         .             /// Returns `true` if the token is the integer literal.
         .             pub fn is_integer_lit(&self) -> bool {
         .                 matches!(self.kind, Literal(Lit { kind: LitKind::Integer, .. }))
         .             }
         .         
         .             /// Returns `true` if the token is a non-raw identifier for which `pred` holds.
         .             pub fn is_non_raw_ident_where(&self, pred: impl FnOnce(Ident) -> bool) -> bool {
 1,511,881 (0.0%)          match self.ident() {
   354,241 (0.0%)              Some((id, IdentIsRaw::No)) => pred(id),
         .                     _ => false,
         .                 }
         .             }
         .         
   942,129 (0.0%)      pub fn glue(&self, joint: &Token) -> Option<Token> {
   523,405 (0.0%)          let kind = match self.kind {
     4,308 (0.0%)              Eq => match joint.kind {
         .                         Eq => EqEq,
         .                         Gt => FatArrow,
         .                         _ => return None,
         .                     },
    10,438 (0.0%)              Lt => match joint.kind {
         .                         Eq => Le,
         .                         Lt => BinOp(Shl),
         .                         Le => BinOpEq(Shl),
         .                         BinOp(Minus) => LArrow,
         .                         _ => return None,
         .                     },
    11,668 (0.0%)              Gt => match joint.kind {
         .                         Eq => Ge,
         .                         Gt => BinOp(Shr),
         .                         Ge => BinOpEq(Shr),
         .                         _ => return None,
         .                     },
     6,964 (0.0%)              Not => match joint.kind {
         .                         Eq => Ne,
         .                         _ => return None,
         .                     },
    40,591 (0.0%)              BinOp(op) => match joint.kind {
         .                         Eq => BinOpEq(op),
       298 (0.0%)                  BinOp(And) if op == And => AndAnd,
       172 (0.0%)                  BinOp(Or) if op == Or => OrOr,
     2,136 (0.0%)                  Gt if op == Minus => RArrow,
         .                         _ => return None,
         .                     },
    44,141 (0.0%)              Dot => match joint.kind {
         .                         Dot => DotDot,
         .                         DotDot => DotDotDot,
         .                         _ => return None,
         .                     },
     2,061 (0.0%)              DotDot => match joint.kind {
         .                         Dot => DotDotDot,
         .                         Eq => DotDotEq,
         .                         _ => return None,
         .                     },
    16,996 (0.0%)              Colon => match joint.kind {
         .                         Colon => ModSep,
         .                         _ => return None,
         .                     },
         .                     SingleQuote => match joint.kind {
         .                         Ident(name, IdentIsRaw::No) => Lifetime(Symbol::intern(&format!("'{name}"))),
         .                         _ => return None,
         .                     },
         .         
         .                     Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot
         .                     | DotDotEq | Comma | Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar
         .                     | Question | OpenDelim(..) | CloseDelim(..) | Literal(..) | Ident(..)
         .                     | Lifetime(..) | Interpolated(..) | DocComment(..) | Eof => return None,
         .                 };
         .         
   115,990 (0.0%)          Some(Token::new(kind, self.span.to(joint.span)))
   837,448 (0.0%)      }
         .         }
         .         
         .         impl PartialEq<TokenKind> for Token {
         .             #[inline]
         .             fn eq(&self, rhs: &TokenKind) -> bool {
 5,123,084 (0.1%)          self.kind == *rhs
         .             }
         .         }
         .         
         .         #[derive(Clone, Encodable, Decodable)]
         .         /// For interpolation during macro expansion.
         .         pub enum Nonterminal {
         .             NtItem(P<ast::Item>),
         .             NtBlock(P<ast::Block>),
-- line 853 ----------------------------------------
-- line 888 ----------------------------------------
         .         
         .         impl NonterminalKind {
         .             /// The `edition` closure is used to get the edition for the given symbol. Doing
         .             /// `span.edition()` is expensive, so we do it lazily.
         .             pub fn from_symbol(
         .                 symbol: Symbol,
         .                 edition: impl FnOnce() -> Edition,
         .             ) -> Option<NonterminalKind> {
     9,738 (0.0%)          Some(match symbol {
         .                     sym::item => NonterminalKind::Item,
         .                     sym::block => NonterminalKind::Block,
         .                     sym::stmt => NonterminalKind::Stmt,
         .                     sym::pat => match edition() {
         .                         Edition::Edition2015 | Edition::Edition2018 => {
         .                             NonterminalKind::PatParam { inferred: true }
         .                         }
         .                         Edition::Edition2021 | Edition::Edition2024 => NonterminalKind::PatWithOr,
-- line 904 ----------------------------------------
-- line 939 ----------------------------------------
         .         impl fmt::Display for NonterminalKind {
         .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         .                 write!(f, "{}", self.symbol())
         .             }
         .         }
         .         
         .         impl Nonterminal {
         .             pub fn use_span(&self) -> Span {
     1,555 (0.0%)          match self {
         .                     NtItem(item) => item.span,
         .                     NtBlock(block) => block.span,
         .                     NtStmt(stmt) => stmt.span,
         .                     NtPat(pat) => pat.span,
         .                     NtExpr(expr) | NtLiteral(expr) => expr.span,
         .                     NtTy(ty) => ty.span,
        97 (0.0%)              NtIdent(ident, _) | NtLifetime(ident) => ident.span,
         .                     NtMeta(attr_item) => attr_item.span(),
         .                     NtPath(path) => path.span,
         .                     NtVis(vis) => vis.span,
         .                 }
       311 (0.0%)      }
         .         
         .             pub fn descr(&self) -> &'static str {
       650 (0.0%)          match self {
         .                     NtItem(..) => "item",
         .                     NtBlock(..) => "block",
         .                     NtStmt(..) => "statement",
         .                     NtPat(..) => "pattern",
         .                     NtExpr(..) => "expression",
         .                     NtLiteral(..) => "literal",
         .                     NtTy(..) => "type",
         .                     NtIdent(..) => "identifier",
-- line 970 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_data_structures/src/sip128.rs
--------------------------------------------------------------------------------
Ir_______________ 

   570,486 (0.0%)  <unknown (line 0)>

-- line 95 ----------------------------------------
         .         // SipHash operates. Note that for variable-sized copies which are known to be
         .         // less than 8 bytes, this function will perform more work than necessary unless
         .         // the compiler is able to optimize the extra work away.
         .         #[inline]
         .         unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {
         .             debug_assert!(count <= 8);
         .         
         .             unsafe {
   180,990 (0.0%)          if count == 8 {
         .                     ptr::copy_nonoverlapping(src, dst, 8);
         .                     return;
         .                 }
         .         
         .                 let mut i = 0;
   231,591 (0.0%)          if i.debug_strict_add(3) < count {
         .                     ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);
         .                     i = i.debug_strict_add(4);
         .                 }
         .         
   215,116 (0.0%)          if i.debug_strict_add(1) < count {
         .                     ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);
         .                     i = i.debug_strict_add(2)
         .                 }
         .         
   185,976 (0.0%)          if i < count {
   188,349 (0.0%)              *dst.add(i) = *src.add(i);
         .                     i = i.debug_strict_add(1);
         .                 }
         .         
         .                 debug_assert_eq!(i, count);
         .             }
         .         }
         .         
         .         // # Implementation
-- line 128 ----------------------------------------
-- line 204 ----------------------------------------
         .                     *hasher.buf.get_unchecked_mut(BUFFER_SPILL_INDEX) = MaybeUninit::zeroed();
         .                 }
         .         
         .                 hasher
         .             }
         .         
         .             #[inline]
         .             pub fn short_write<const LEN: usize>(&mut self, bytes: [u8; LEN]) {
 2,649,802 (0.0%)          let nbuf = self.nbuf;
         .                 debug_assert!(LEN <= 8);
         .                 debug_assert!(nbuf < BUFFER_SIZE);
         .                 debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);
         .         
 9,199,018 (0.1%)          if nbuf.debug_strict_add(LEN) < BUFFER_SIZE {
         .                     unsafe {
         .                         // The memcpy call is optimized away because the size is known.
         .                         let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
         .                         ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);
         .                     }
         .         
 5,632,452 (0.1%)              self.nbuf = nbuf.debug_strict_add(LEN);
         .         
         .                     return;
         .                 }
         .         
   897,292 (0.0%)          unsafe { self.short_write_process_buffer(bytes) }
         .             }
         .         
         .             // A specialized write function for values with size <= 8 that should only
         .             // be called when the write would cause the buffer to fill.
         .             //
         .             // SAFETY: the write of `x` into `self.buf` starting at byte offset
         .             // `self.nbuf` must cause `self.buf` to become fully initialized (and not
         .             // overflow) if it wasn't already.
         .             #[inline(never)]
   561,738 (0.0%)      unsafe fn short_write_process_buffer<const LEN: usize>(&mut self, bytes: [u8; LEN]) {
         .                 unsafe {
   280,869 (0.0%)              let nbuf = self.nbuf;
         .                     debug_assert!(LEN <= 8);
         .                     debug_assert!(nbuf < BUFFER_SIZE);
         .                     debug_assert!(nbuf + LEN >= BUFFER_SIZE);
         .                     debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);
         .         
         .                     // Copy first part of input into end of buffer, possibly into spill
         .                     // element. The memcpy call is optimized away because the size is known.
         .                     let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
         .                     ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);
         .         
         .                     // Process buffer.
         .                     for i in 0..BUFFER_CAPACITY {
 2,808,690 (0.0%)                  let elem = self.buf.get_unchecked(i).assume_init().to_le();
 2,246,952 (0.0%)                  self.state.v3 ^= elem;
         .                         Sip13Rounds::c_rounds(&mut self.state);
 2,527,821 (0.0%)                  self.state.v0 ^= elem;
         .                     }
         .         
         .                     // Copy remaining input into start of buffer by copying LEN - 1
         .                     // elements from spill (at most LEN - 1 bytes could have overflowed
         .                     // into the spill). The memcpy call is optimized away because the size
         .                     // is known. And the whole copy is optimized away for LEN == 1.
         .                     let dst = self.buf.as_mut_ptr() as *mut u8;
         .                     let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;
         .                     ptr::copy_nonoverlapping(src, dst, LEN - 1);
         .         
         .                     // This function should only be called when the write fills the buffer.
         .                     // Therefore, when LEN == 1, the new `self.nbuf` must be zero.
         .                     // LEN is statically known, so the branch is optimized away.
   280,869 (0.0%)              self.nbuf =
         .                         if LEN == 1 { 0 } else { nbuf.debug_strict_add(LEN).debug_strict_sub(BUFFER_SIZE) };
   280,869 (0.0%)              self.processed = self.processed.debug_strict_add(BUFFER_SIZE);
         .                 }
   561,738 (0.0%)      }
         .         
         .             // A write function for byte slices.
         .             #[inline]
         .             fn slice_write(&mut self, msg: &[u8]) {
         .                 let length = msg.len();
    14,577 (0.0%)          let nbuf = self.nbuf;
         .                 debug_assert!(nbuf < BUFFER_SIZE);
         .         
   228,255 (0.0%)          if nbuf.debug_strict_add(length) < BUFFER_SIZE {
         .                     unsafe {
         .                         let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
         .         
   206,240 (0.0%)                  if length <= 8 {
         .                             copy_nonoverlapping_small(msg.as_ptr(), dst, length);
         .                         } else {
         .                             // This memcpy is *not* optimized away.
         .                             ptr::copy_nonoverlapping(msg.as_ptr(), dst, length);
         .                         }
         .                     }
         .         
   118,057 (0.0%)              self.nbuf = nbuf.debug_strict_add(length);
         .         
         .                     return;
         .                 }
         .         
    34,943 (0.0%)          unsafe { self.slice_write_process_buffer(msg) }
         .             }
         .         
         .             // A write function for byte slices that should only be called when the
         .             // write would cause the buffer to fill.
         .             //
         .             // SAFETY: `self.buf` must be initialized up to the byte offset `self.nbuf`,
         .             // and `msg` must contain enough bytes to initialize the rest of the element
         .             // containing the byte offset `self.nbuf`.
         .             #[inline(never)]
         .             unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {
         .                 unsafe {
         .                     let length = msg.len();
     9,123 (0.0%)              let nbuf = self.nbuf;
         .                     debug_assert!(nbuf < BUFFER_SIZE);
         .                     debug_assert!(nbuf + length >= BUFFER_SIZE);
         .         
         .                     // Always copy first part of input into current element of buffer.
         .                     // This function should only be called when the write fills the buffer,
         .                     // so we know that there is enough input to fill the current element.
    27,369 (0.0%)              let valid_in_elem = nbuf % ELEM_SIZE;
         .                     let needed_in_elem = ELEM_SIZE.debug_strict_sub(valid_in_elem);
         .         
         .                     let src = msg.as_ptr();
         .                     let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
         .                     copy_nonoverlapping_small(src, dst, needed_in_elem);
         .         
         .                     // Process buffer.
         .         
         .                     // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /
         .                     // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.
         .                     // We know that is true, because last step ensured we have a full
         .                     // element in the buffer.
    54,738 (0.0%)              let last = (nbuf / ELEM_SIZE).debug_strict_add(1);
         .         
         .                     for i in 0..last {
    70,161 (0.0%)                  let elem = self.buf.get_unchecked(i).assume_init().to_le();
    70,161 (0.0%)                  self.state.v3 ^= elem;
         .                         Sip13Rounds::c_rounds(&mut self.state);
    70,161 (0.0%)                  self.state.v0 ^= elem;
         .                     }
         .         
         .                     // Process the remaining element-sized chunks of input.
         .                     let mut processed = needed_in_elem;
         .                     let input_left = length.debug_strict_sub(processed);
     8,481 (0.0%)              let elems_left = input_left / ELEM_SIZE;
     9,123 (0.0%)              let extra_bytes_left = input_left % ELEM_SIZE;
         .         
         .                     for _ in 0..elems_left {
         .                         let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();
     5,314 (0.0%)                  self.state.v3 ^= elem;
         .                         Sip13Rounds::c_rounds(&mut self.state);
     5,314 (0.0%)                  self.state.v0 ^= elem;
         .                         processed = processed.debug_strict_add(ELEM_SIZE);
         .                     }
         .         
         .                     // Copy remaining input into start of buffer.
         .                     let src = msg.as_ptr().add(processed);
         .                     let dst = self.buf.as_mut_ptr() as *mut u8;
         .                     copy_nonoverlapping_small(src, dst, extra_bytes_left);
         .         
     9,123 (0.0%)              self.nbuf = extra_bytes_left;
     9,123 (0.0%)              self.processed = self.processed.debug_strict_add(nbuf.debug_strict_add(processed));
         .                 }
     9,123 (0.0%)      }
         .         
         .             #[inline]
   248,874 (0.0%)      pub fn finish128(mut self) -> (u64, u64) {
         .                 debug_assert!(self.nbuf < BUFFER_SIZE);
         .         
         .                 // Process full elements in buffer.
   398,706 (0.0%)          let last = self.nbuf / ELEM_SIZE;
         .         
         .                 // Since we're consuming self, avoid updating members for a potential
         .                 // performance gain.
   531,608 (0.0%)          let mut state = self.state;
         .         
         .                 for i in 0..last {
   381,003 (0.0%)              let elem = unsafe { self.buf.get_unchecked(i).assume_init().to_le() };
   381,003 (0.0%)              state.v3 ^= elem;
         .                     Sip13Rounds::c_rounds(&mut state);
   381,003 (0.0%)              state.v0 ^= elem;
         .                 }
         .         
         .                 // Get remaining partial element.
   265,804 (0.0%)          let elem = if self.nbuf % ELEM_SIZE != 0 {
         .                     unsafe {
         .                         // Ensure element is initialized by writing zero bytes. At most
         .                         // `ELEM_SIZE - 1` are required given the above check. It's safe
         .                         // to write this many because we have the spill and we maintain
         .                         // `self.nbuf` such that this write will start before the spill.
         .                         let dst = (self.buf.as_mut_ptr() as *mut u8).add(self.nbuf);
         .                         ptr::write_bytes(dst, 0, ELEM_SIZE - 1);
   215,344 (0.0%)                  self.buf.get_unchecked(last).assume_init().to_le()
         .                     }
         .                 } else {
         .                     0
         .                 };
         .         
         .                 // Finalize the hash.
         .                 let length = self.processed.debug_strict_add(self.nbuf);
   265,804 (0.0%)          let b: u64 = ((length as u64 & 0xff) << 56) | elem;
         .         
   132,902 (0.0%)          state.v3 ^= b;
         .                 Sip13Rounds::c_rounds(&mut state);
   132,902 (0.0%)          state.v0 ^= b;
         .         
   132,902 (0.0%)          state.v2 ^= 0xee;
         .                 Sip13Rounds::d_rounds(&mut state);
   387,560 (0.0%)          let _0 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
         .         
   121,756 (0.0%)          state.v1 ^= 0xdd;
         .                 Sip13Rounds::d_rounds(&mut state);
   365,268 (0.0%)          let _1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
         .         
         .                 (_0, _1)
   248,874 (0.0%)      }
         .         }
         .         
         .         impl Hasher for SipHasher128 {
         .             #[inline]
         .             fn write_u8(&mut self, i: u8) {
         .                 self.short_write(i.to_ne_bytes());
         .             }
         .         
-- line 425 ----------------------------------------
-- line 487 ----------------------------------------
         .         }
         .         
         .         #[derive(Debug, Clone, Default)]
         .         struct Sip13Rounds;
         .         
         .         impl Sip13Rounds {
         .             #[inline]
         .             fn c_rounds(state: &mut State) {
12,211,835 (0.2%)          compress!(state);
         .             }
         .         
         .             #[inline]
         .             fn d_rounds(state: &mut State) {
 1,018,632 (0.0%)          compress!(state);
 1,018,632 (0.0%)          compress!(state);
   763,974 (0.0%)          compress!(state);
         .             }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_expand/src/mbe/macro_parser.rs
--------------------------------------------------------------------------------
Ir______________ 

  942,061 (0.0%)  <unknown (line 0)>

-- line 167 ----------------------------------------
        .                     MatcherLoc::Delimited => f.write_str("delimiter"),
        .                     MatcherLoc::Sequence { .. } => f.write_str("sequence start"),
        .                     MatcherLoc::SequenceKleeneOpNoSep { .. } => f.write_str("sequence end"),
        .                     MatcherLoc::SequenceKleeneOpAfterSep { .. } => f.write_str("sequence end"),
        .                 }
        .             }
        .         }
        .         
    2,085 (0.0%)  pub(super) fn compute_locs(matcher: &[TokenTree]) -> Vec<MatcherLoc> {
   15,590 (0.0%)      fn inner(
        .                 tts: &[TokenTree],
        .                 locs: &mut Vec<MatcherLoc>,
        .                 next_metavar: &mut usize,
        .                 seq_depth: usize,
        .             ) {
        .                 for tt in tts {
   35,615 (0.0%)              match tt {
        .                         TokenTree::Token(token) => {
    2,888 (0.0%)                      locs.push(MatcherLoc::Token { token: token.clone() });
        .                         }
        .                         TokenTree::Delimited(span, _, delimited) => {
      562 (0.0%)                      let open_token = Token::new(token::OpenDelim(delimited.delim), span.open);
      281 (0.0%)                      let close_token = Token::new(token::CloseDelim(delimited.delim), span.close);
        .         
      281 (0.0%)                      locs.push(MatcherLoc::Delimited);
    2,529 (0.0%)                      locs.push(MatcherLoc::Token { token: open_token });
    1,686 (0.0%)                      inner(&delimited.tts, locs, next_metavar, seq_depth);
    1,124 (0.0%)                      locs.push(MatcherLoc::Token { token: close_token });
        .                         }
        .                         TokenTree::Sequence(_, seq) => {
        .                             // We can't determine `idx_first_after` and construct the final
        .                             // `MatcherLoc::Sequence` until after `inner()` is called and the sequence end
        .                             // pieces are processed. So we push a dummy value (`Eof` is cheapest to
        .                             // construct) now, and overwrite it with the proper value below.
      861 (0.0%)                      let dummy = MatcherLoc::Eof;
        .                             locs.push(dummy);
        .         
    2,583 (0.0%)                      let next_metavar_orig = *next_metavar;
      861 (0.0%)                      let op = seq.kleene.op;
        .                             let idx_first = locs.len();
        .                             let idx_seq = idx_first - 1;
    4,305 (0.0%)                      inner(&seq.tts, locs, next_metavar, seq_depth + 1);
        .         
    1,722 (0.0%)                      if let Some(separator) = &seq.separator {
      568 (0.0%)                          locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });
      568 (0.0%)                          locs.push(MatcherLoc::SequenceKleeneOpAfterSep { idx_first });
        .                             } else {
    1,731 (0.0%)                          locs.push(MatcherLoc::SequenceKleeneOpNoSep { op, idx_first });
        .                             }
        .         
        .                             // Overwrite the dummy value pushed above with the proper value.
   15,498 (0.0%)                      locs[idx_seq] = MatcherLoc::Sequence {
        .                                 op,
      861 (0.0%)                          num_metavar_decls: seq.num_captures,
        .                                 idx_first_after: locs.len(),
        .                                 next_metavar: next_metavar_orig,
        .                                 seq_depth,
        .                             };
        .                         }
    9,600 (0.0%)                  &TokenTree::MetaVarDecl(span, bind, kind) => {
    7,200 (0.0%)                      locs.push(MatcherLoc::MetaVarDecl {
        .                                 span,
        .                                 bind,
        .                                 kind,
    1,200 (0.0%)                          next_metavar: *next_metavar,
        .                                 seq_depth,
        .                             });
    1,200 (0.0%)                      *next_metavar += 1;
        .                         }
        .                         TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),
        .                     }
        .                 }
   12,472 (0.0%)      }
        .         
        .             let mut locs = vec![];
    1,251 (0.0%)      let mut next_metavar = 0;
    2,085 (0.0%)      inner(matcher, &mut locs, &mut next_metavar, /* seq_depth */ 0);
        .         
        .             // A final entry is needed for eof.
      417 (0.0%)      locs.push(MatcherLoc::Eof);
        .         
    1,251 (0.0%)      locs
    1,668 (0.0%)  }
        .         
        .         /// A single matcher position, representing the state of matching.
        .         #[derive(Debug)]
        .         struct MatcherPos {
        .             /// The index into `TtParser::locs`, which represents the "dot".
        .             idx: usize,
        .         
        .             /// The matches made against metavar decls so far. On a successful match, this vector ends up
-- line 257 ----------------------------------------
-- line 269 ----------------------------------------
        .         #[cfg(all(any(target_arch = "x86_64", target_arch = "aarch64"), target_pointer_width = "64"))]
        .         rustc_data_structures::static_assert_size!(MatcherPos, 16);
        .         
        .         impl MatcherPos {
        .             /// Adds `m` as a named match for the `metavar_idx`-th metavar. There are only two call sites,
        .             /// and both are hot enough to be always worth inlining.
        .             #[inline(always)]
        .             fn push_match(&mut self, metavar_idx: usize, seq_depth: usize, m: NamedMatch) {
  107,020 (0.0%)          let matches = Rc::make_mut(&mut self.matches);
  103,923 (0.0%)          match seq_depth {
        .                     0 => {
        .                         // We are not within a sequence. Just append `m`.
   58,526 (0.0%)                  assert_eq!(metavar_idx, matches.len());
        .                         matches.push(m);
        .                     }
        .                     _ => {
        .                         // We are within a sequence. Find the final `MatchedSeq` at the appropriate depth
        .                         // and append `m` to its vector.
   24,247 (0.0%)                  let mut curr = &mut matches[metavar_idx];
        .                         for _ in 0..seq_depth - 1 {
    3,248 (0.0%)                      match curr {
    3,248 (0.0%)                          MatchedSeq(seq) => curr = seq.last_mut().unwrap(),
        .                                 _ => unreachable!(),
        .                             }
        .                         }
   48,494 (0.0%)                  match curr {
  107,665 (0.0%)                      MatchedSeq(seq) => seq.push(m),
        .                             _ => unreachable!(),
        .                         }
        .                     }
        .                 }
        .             }
        .         }
        .         
        .         enum EofMatcherPositions {
-- line 303 ----------------------------------------
-- line 324 ----------------------------------------
        .         /// of metavars to the token trees they bind to.
        .         pub(crate) type NamedParseResult<F> = ParseResult<NamedMatches, F>;
        .         
        .         /// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.
        .         /// This represents the mapping of metavars to the token trees they bind to.
        .         pub(crate) type NamedMatches = FxHashMap<MacroRulesNormalizedIdent, NamedMatch>;
        .         
        .         /// Count how many metavars declarations are in `matcher`.
    6,032 (0.0%)  pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {
        .             matcher
        .                 .iter()
    5,382 (0.0%)          .map(|tt| match tt {
        .                     TokenTree::MetaVarDecl(..) => 1,
       77 (0.0%)              TokenTree::Sequence(_, seq) => seq.num_captures,
      165 (0.0%)              TokenTree::Delimited(.., delim) => count_metavar_decls(&delim.tts),
        .                     TokenTree::Token(..) => 0,
        .                     TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),
        .                 })
        .                 .sum()
    6,786 (0.0%)  }
        .         
        .         /// `NamedMatch` is a pattern-match result for a single metavar. All
        .         /// `MatchedNonterminal`s in the `NamedMatch` have the same non-terminal type
        .         /// (expr, item, etc).
        .         ///
        .         /// The in-memory structure of a particular `NamedMatch` represents the match
        .         /// that occurred when a particular subset of a matcher was applied to a
        .         /// particular token tree.
-- line 351 ----------------------------------------
-- line 384 ----------------------------------------
        .         ///     MatchedNonterminal(a),
        .         ///     MatchedNonterminal(b),
        .         ///     MatchedNonterminal(c),
        .         ///     MatchedNonterminal(d),
        .         ///     MatchedNonterminal(e),
        .         ///   ])
        .         /// ])
        .         /// ```
  178,447 (0.0%)  #[derive(Debug, Clone)]
        .         pub(crate) enum NamedMatch {
   21,777 (0.0%)      MatchedSeq(Vec<NamedMatch>),
        .             MatchedSingle(ParseNtResult<Lrc<(Nonterminal, Span)>>),
        .         }
        .         
        .         /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)
  250,874 (0.0%)  fn token_name_eq(t1: &Token, t2: &Token) -> bool {
  142,840 (0.0%)      if let (Some((ident1, is_raw1)), Some((ident2, is_raw2))) = (t1.ident(), t2.ident()) {
   56,772 (0.0%)          ident1.name == ident2.name && is_raw1 == is_raw2
   13,878 (0.0%)      } else if let (Some(ident1), Some(ident2)) = (t1.lifetime(), t2.lifetime()) {
        .                 ident1.name == ident2.name
        .             } else {
  213,026 (0.0%)          t1.kind == t2.kind
        .             }
   37,848 (0.0%)  }
        .         
        .         // Note: the vectors could be created and dropped within `parse_tt`, but to avoid excess
        .         // allocations we have a single vector for each kind that is cleared and reused repeatedly.
        .         pub struct TtParser {
        .             macro_name: Ident,
        .         
        .             /// The set of current mps to be processed. This should be empty by the end of a successful
        .             /// execution of `parse_tt_inner`.
-- line 415 ----------------------------------------
-- line 423 ----------------------------------------
        .             bb_mps: Vec<MatcherPos>,
        .         
        .             /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules
        .             /// that have no metavars.
        .             empty_matches: Rc<Vec<NamedMatch>>,
        .         }
        .         
        .         impl TtParser {
   39,354 (0.0%)      pub(super) fn new(macro_name: Ident) -> TtParser {
   95,574 (0.0%)          TtParser {
        .                     macro_name,
        .                     cur_mps: vec![],
        .                     next_mps: vec![],
        .                     bb_mps: vec![],
        .                     empty_matches: Rc::new(vec![]),
        .                 }
   28,110 (0.0%)      }
        .         
        .             pub(super) fn has_no_remaining_items_for_step(&self) -> bool {
        .                 self.cur_mps.is_empty()
        .             }
        .         
        .             /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will
        .             /// produce more mps in `next_mps` and `bb_mps`.
        .             ///
-- line 447 ----------------------------------------
-- line 455 ----------------------------------------
        .                 token: &Token,
        .                 approx_position: usize,
        .                 track: &mut T,
        .             ) -> Option<NamedParseResult<T::Failure>> {
        .                 // Matcher positions that would be valid if the macro invocation was over now. Only
        .                 // modified if `token == Eof`.
        .                 let mut eof_mps = EofMatcherPositions::None;
        .         
  498,434 (0.0%)          while let Some(mut mp) = self.cur_mps.pop() {
  996,868 (0.0%)              let matcher_loc = &matcher[mp.idx];
        .                     track.before_match_loc(self, matcher_loc);
        .         
1,246,085 (0.0%)              match matcher_loc {
        .                         MatcherLoc::Token { token: t } => {
        .                             // If it's a doc comment, we just ignore it and move on to the next tt in the
        .                             // matcher. This is a bug, but #95267 showed that existing programs rely on
        .                             // this behaviour, and changing it would require some care and a transition
        .                             // period.
        .                             //
        .                             // If the token matches, we can just advance the parser.
        .                             //
        .                             // Otherwise, this match has failed, there is nothing to do, and hopefully
        .                             // another mp in `cur_mps` will match.
  242,828 (0.0%)                      if matches!(t, Token { kind: DocComment(..), .. }) {
        .                                 mp.idx += 1;
        .                                 self.cur_mps.push(mp);
  728,484 (0.0%)                      } else if token_name_eq(t, token) {
  137,106 (0.0%)                          mp.idx += 1;
        .                                 self.next_mps.push(mp);
        .                             }
        .                         }
        .                         MatcherLoc::Delimited => {
        .                             // Entering the delimiter is trivial.
        .                             mp.idx += 1;
        .                             self.cur_mps.push(mp);
        .                         }
        .                         &MatcherLoc::Sequence {
   48,122 (0.0%)                      op,
   24,061 (0.0%)                      num_metavar_decls,
   48,122 (0.0%)                      idx_first_after,
   24,061 (0.0%)                      next_metavar,
   28,736 (0.0%)                      seq_depth,
        .                         } => {
        .                             // Install an empty vec for each metavar within the sequence.
   24,061 (0.0%)                      for metavar_idx in next_metavar..next_metavar + num_metavar_decls {
   77,155 (0.0%)                          mp.push_match(metavar_idx, seq_depth, MatchedSeq(vec![]));
        .                             }
        .         
   72,183 (0.0%)                      if matches!(op, KleeneOp::ZeroOrMore | KleeneOp::ZeroOrOne) {
        .                                 // Try zero matches of this sequence, by skipping over it.
        .                                 self.cur_mps.push(MatcherPos {
        .                                     idx: idx_first_after,
        .                                     matches: Rc::clone(&mp.matches),
        .                                 });
        .                             }
        .         
        .                             // Try one or more matches of this sequence, by entering it.
   96,244 (0.0%)                      mp.idx += 1;
   24,061 (0.0%)                      self.cur_mps.push(mp);
        .                         }
   44,464 (0.0%)                  &MatcherLoc::SequenceKleeneOpNoSep { op, idx_first } => {
        .                             // We are past the end of a sequence with no separator. Try ending the
        .                             // sequence. If that's not possible, `ending_mp` will fail quietly when it is
        .                             // processed next time around the loop.
        .                             let ending_mp = MatcherPos {
   22,232 (0.0%)                          idx: mp.idx + 1, // +1 skips the Kleene op
        .                                 matches: Rc::clone(&mp.matches),
        .                             };
        .                             self.cur_mps.push(ending_mp);
        .         
   22,232 (0.0%)                      if op != KleeneOp::ZeroOrOne {
        .                                 // Try another repetition.
   21,237 (0.0%)                          mp.idx = idx_first;
        .                                 self.cur_mps.push(mp);
        .                             }
        .                         }
        .                         MatcherLoc::SequenceSep { separator } => {
        .                             // We are past the end of a sequence with a separator but we haven't seen the
        .                             // separator yet. Try ending the sequence. If that's not possible, `ending_mp`
        .                             // will fail quietly when it is processed next time around the loop.
        .                             let ending_mp = MatcherPos {
    4,023 (0.0%)                          idx: mp.idx + 2, // +2 skips the separator and the Kleene op
        .                                 matches: Rc::clone(&mp.matches),
        .                             };
        .                             self.cur_mps.push(ending_mp);
        .         
   20,115 (0.0%)                      if token_name_eq(token, separator) {
        .                                 // The separator matches the current token. Advance past it.
    1,806 (0.0%)                          mp.idx += 1;
        .                                 self.next_mps.push(mp);
        .                             }
        .                         }
      903 (0.0%)                  &MatcherLoc::SequenceKleeneOpAfterSep { idx_first } => {
        .                             // We are past the sequence separator. This can't be a `?` Kleene op, because
        .                             // they don't permit separators. Try another repetition.
      903 (0.0%)                      mp.idx = idx_first;
        .                             self.cur_mps.push(mp);
        .                         }
   48,339 (0.0%)                  &MatcherLoc::MetaVarDecl { span, kind, .. } => {
        .                             // Built-in nonterminals never start with these tokens, so we can eliminate
        .                             // them from consideration. We use the span of the metavariable declaration
        .                             // to determine any edition-specific matching behavior for non-terminals.
   96,678 (0.0%)                      if let Some(kind) = kind {
  290,034 (0.0%)                          if Parser::nonterminal_may_begin_with(kind, token) {
        .                                     self.bb_mps.push(mp);
        .                                 }
        .                             } else {
        .                                 // E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.
        .                                 // Both this check and the one in `nameize` are necessary, surprisingly.
        .                                 return Some(Error(span, "missing fragment specifier".to_string()));
        .                             }
        .                         }
        .                         MatcherLoc::Eof => {
        .                             // We are past the matcher's end, and not in a sequence. Try to end things.
        .                             debug_assert_eq!(mp.idx, matcher.len() - 1);
   38,108 (0.0%)                      if *token == token::Eof {
   11,244 (0.0%)                          eof_mps = match eof_mps {
        .                                     EofMatcherPositions::None => EofMatcherPositions::One(mp),
        .                                     EofMatcherPositions::One(_) | EofMatcherPositions::Multiple => {
        .                                         EofMatcherPositions::Multiple
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                     }
   78,254 (0.0%)          }
        .         
        .                 // If we reached the end of input, check that there is EXACTLY ONE possible matcher.
        .                 // Otherwise, either the parse is ambiguous (which is an error) or there is a syntax error.
  291,820 (0.0%)          if *token == token::Eof {
   58,316 (0.0%)              Some(match eof_mps {
   16,866 (0.0%)                  EofMatcherPositions::One(mut eof_mp) => {
        .                             // Need to take ownership of the matches from within the `Rc`.
   11,244 (0.0%)                      Rc::make_mut(&mut eof_mp.matches);
    5,622 (0.0%)                      let matches = Rc::try_unwrap(eof_mp.matches).unwrap().into_iter();
        .                             self.nameize(matcher, matches)
        .                         }
        .                         EofMatcherPositions::Multiple => {
        .                             Error(token.span, "ambiguity: multiple successful parses".to_string())
        .                         }
        .                         EofMatcherPositions::None => Failure(T::build_failure(
        .                             Token::new(
        .                                 token::Eof,
    1,572 (0.0%)                          if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },
        .                             ),
        .                             approx_position,
        .                             "missing tokens in macro arguments",
        .                         )),
        .                     })
        .                 } else {
  280,052 (0.0%)              None
        .                 }
  443,090 (0.0%)      }
        .         
        .             /// Match the token stream from `parser` against `matcher`.
  477,096 (0.0%)      pub(super) fn parse_tt<'matcher, T: Tracker<'matcher>>(
        .                 &mut self,
        .                 parser: &mut Cow<'_, Parser<'_>>,
        .                 matcher: &'matcher [MatcherLoc],
        .                 track: &mut T,
        .             ) -> NamedParseResult<T::Failure> {
        .                 // A queue of possible matcher positions. We initialize it with the matcher position in
        .                 // which the "dot" is before the first token of the first token tree in `matcher`.
        .                 // `parse_tt_inner` then processes all of these possible matcher positions and produces
-- line 618 ----------------------------------------
-- line 624 ----------------------------------------
        .                 loop {
        .                     self.next_mps.clear();
        .                     self.bb_mps.clear();
        .         
        .                     // Process `cur_mps` until either we have finished the input or we need to get some
        .                     // parsing from the black-box parser done.
        .                     let res = self.parse_tt_inner(
        .                         matcher,
  291,820 (0.0%)                  &parser.token,
        .                         parser.approx_token_stream_pos(),
        .                         track,
        .                     );
  291,820 (0.0%)              if let Some(res) = res {
   47,072 (0.0%)                  return res;
        .                     }
        .         
        .                     // `parse_tt_inner` handled all of `cur_mps`, so it's empty.
  280,052 (0.0%)              assert!(self.cur_mps.is_empty());
        .         
        .                     // Error messages here could be improved with links to original rules.
  784,698 (0.0%)              match (self.next_mps.len(), self.bb_mps.len()) {
        .                         (0, 0) => {
        .                             // There are no possible next positions AND we aren't waiting for the black-box
        .                             // parser: syntax error.
   67,748 (0.0%)                      return Failure(T::build_failure(
        .                                 parser.token.clone(),
        .                                 parser.approx_token_stream_pos(),
        .                                 "no rules expected this token in macro call",
        .                             ));
        .                         }
        .         
        .                         (_, 0) => {
        .                             // Dump all possible `next_mps` into `cur_mps` for the next iteration. Then
        .                             // process the next token.
        .                             self.cur_mps.append(&mut self.next_mps);
  136,146 (0.0%)                      parser.to_mut().bump();
        .                         }
        .         
        .                         (0, 1) => {
        .                             // We need to call the black-box parser to get some nonterminal.
        .                             let mut mp = self.bb_mps.pop().unwrap();
  152,316 (0.0%)                      let loc = &matcher[mp.idx];
  190,395 (0.0%)                      if let &MatcherLoc::MetaVarDecl {
   76,158 (0.0%)                          span,
   38,079 (0.0%)                          kind: Some(kind),
   38,079 (0.0%)                          next_metavar,
   76,158 (0.0%)                          seq_depth,
        .                                 ..
        .                             } = loc
        .                             {
        .                                 // We use the span of the metavariable declaration to determine any
        .                                 // edition-specific matching behavior for non-terminals.
  342,711 (0.0%)                          let nt = match parser.to_mut().parse_nonterminal(kind) {
        .                                     Err(err) => {
        .                                         let guarantee = err.with_span_label(
        .                                             span,
        .                                             format!(
        .                                                 "while parsing argument for this `{kind}` macro fragment"
        .                                             ),
        .                                         )
        .                                         .emit();
        .                                         return ErrorReported(guarantee);
        .                                     }
  228,474 (0.0%)                              Ok(nt) => nt,
        .                                 };
        .                                 mp.push_match(
        .                                     next_metavar,
        .                                     seq_depth,
  380,790 (0.0%)                              MatchedSingle(nt.map_nt(|nt| (Lrc::new((nt, span))))),
        .                                 );
   38,079 (0.0%)                          mp.idx += 1;
        .                             } else {
        .                                 unreachable!()
        .                             }
   38,079 (0.0%)                      self.cur_mps.push(mp);
        .                         }
        .         
        .                         (_, _) => {
        .                             // Too many possibilities!
        .                             return self.ambiguity_error(matcher, parser.token.span);
        .                         }
        .                     }
        .         
  212,304 (0.0%)              assert!(!self.cur_mps.is_empty());
   67,748 (0.0%)          }
  318,064 (0.0%)      }
        .         
        .             fn ambiguity_error<F>(
        .                 &self,
        .                 matcher: &[MatcherLoc],
        .                 token_span: rustc_span::Span,
        .             ) -> NamedParseResult<F> {
        .                 let nts = self
        .                     .bb_mps
-- line 717 ----------------------------------------
-- line 742 ----------------------------------------
        .                 &self,
        .                 matcher: &[MatcherLoc],
        .                 mut res: I,
        .             ) -> NamedParseResult<F> {
        .                 // Make that each metavar has _exactly one_ binding. If so, insert the binding into the
        .                 // `NamedParseResult`. Otherwise, it's an error.
        .                 let mut ret_val = FxHashMap::default();
        .                 for loc in matcher {
  214,436 (0.0%)              if let &MatcherLoc::MetaVarDecl { span, bind, kind, .. } = loc {
        .                         if kind.is_some() {
   29,806 (0.0%)                      match ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {
        .                                 Vacant(spot) => spot.insert(res.next().unwrap()),
        .                                 Occupied(..) => {
        .                                     return Error(span, format!("duplicated bind name: {bind}"));
        .                                 }
        .                             };
        .                         } else {
        .                             // E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.
        .                             // Both this check and the one in `parse_tt_inner` are necessary, surprisingly.
        .                             return Error(span, "missing fragment specifier".to_string());
        .                         }
        .                     }
        .                 }
   67,464 (0.0%)          Success(ret_val)
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_expand/src/mbe/transcribe.rs
--------------------------------------------------------------------------------
Ir______________ 

1,830,791 (0.0%)  <unknown (line 0)>

-- line 19 ----------------------------------------
        .         use std::mem;
        .         
        .         // A Marker adds the given mark to the syntax context.
        .         struct Marker(LocalExpnId, Transparency, FxHashMap<SyntaxContext, SyntaxContext>);
        .         
        .         impl MutVisitor for Marker {
        .             const VISIT_TOKENS: bool = true;
        .         
1,974,930 (0.0%)      fn visit_span(&mut self, span: &mut Span) {
        .                 // `apply_mark` is a relatively expensive operation, both due to taking hygiene lock, and
        .                 // by itself. All tokens in a macro body typically have the same syntactic context, unless
        .                 // it's some advanced case with macro-generated macros. So if we cache the marked version
        .                 // of that context once, we'll typically have a 100% cache hit rate after that.
  789,972 (0.0%)          let Marker(expn_id, transparency, ref mut cache) = *self;
  394,986 (0.0%)          let data = span.data();
  197,493 (0.0%)          let marked_ctxt = *cache
  394,986 (0.0%)              .entry(data.ctxt)
   27,330 (0.0%)              .or_insert_with(|| data.ctxt.apply_mark(expn_id.to_expn_id(), transparency));
  197,493 (0.0%)          *span = data.with_ctxt(marked_ctxt);
1,579,944 (0.0%)      }
        .         }
        .         
        .         /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).
        .         enum Frame<'a> {
        .             Delimited {
        .                 tts: &'a [mbe::TokenTree],
        .                 idx: usize,
        .                 delim: Delimiter,
-- line 46 ----------------------------------------
-- line 53 ----------------------------------------
        .                 sep: Option<Token>,
        .                 kleene_op: KleeneOp,
        .             },
        .         }
        .         
        .         impl<'a> Frame<'a> {
        .             /// Construct a new frame around the delimited set of tokens.
        .             fn new(src: &'a mbe::Delimited, span: DelimSpan, spacing: DelimSpacing) -> Frame<'a> {
   21,872 (0.0%)          Frame::Delimited { tts: &src.tts, idx: 0, delim: src.delim, span, spacing }
        .             }
        .         }
        .         
        .         impl<'a> Iterator for Frame<'a> {
        .             type Item = &'a mbe::TokenTree;
        .         
        .             fn next(&mut self) -> Option<&'a mbe::TokenTree> {
1,040,520 (0.0%)          match self {
        .                     Frame::Delimited { tts, idx, .. } | Frame::Sequence { tts, idx, .. } => {
  260,130 (0.0%)                  let res = tts.get(*idx);
  520,260 (0.0%)                  *idx += 1;
        .                         res
        .                     }
        .                 }
        .             }
        .         }
        .         
        .         /// This can do Macro-By-Example transcription.
        .         /// - `interp` is a map of meta-variables to the tokens (non-terminals) they matched in the
-- line 80 ----------------------------------------
-- line 99 ----------------------------------------
        .         pub(super) fn transcribe<'a>(
        .             cx: &ExtCtxt<'a>,
        .             interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,
        .             src: &mbe::Delimited,
        .             src_span: DelimSpan,
        .             transparency: Transparency,
        .         ) -> PResult<'a, TokenStream> {
        .             // Nothing for us to transcribe...
   11,104 (0.0%)      if src.tts.is_empty() {
        .                 return Ok(TokenStream::default());
        .             }
        .         
        .             // We descend into the RHS (`src`), expanding things as we go. This stack contains the things
        .             // we have yet to expand/are still expanding. We start the stack off with the whole RHS. The
        .             // choice of spacing values doesn't matter.
        .             let mut stack: SmallVec<[Frame<'_>; 1]> =
   38,276 (0.0%)          smallvec![Frame::new(src, src_span, DelimSpacing::new(Spacing::Alone, Spacing::Alone))];
        .         
        .             // As we descend in the RHS, we will need to be able to match nested sequences of matchers.
        .             // `repeats` keeps track of where we are in matching at each level, with the last element being
        .             // the most deeply nested sequence. This is used as a stack.
        .             let mut repeats = Vec::new();
        .         
        .             // `result` contains resulting token stream from the TokenTree we just finished processing. At
        .             // the end, this will contain the full result of transcription, but at arbitrary points during
-- line 123 ----------------------------------------
-- line 127 ----------------------------------------
        .             // `result_stack` and clear `results`. We will then produce the results of transcribing the
        .             // TokenTree into `results`. Then, as we unwind back out of the `TokenTree`, we will pop the
        .             // `result_stack` and append `results` too it to produce the new `results` up to that point.
        .             //
        .             // Thus, if we try to pop the `result_stack` and it is empty, we have reached the top-level
        .             // again, and we are done transcribing.
        .             let mut result: Vec<TokenTree> = Vec::new();
        .             let mut result_stack = Vec::new();
   98,424 (0.0%)      let mut marker = Marker(cx.current_expansion.id, transparency, Default::default());
        .         
        .             loop {
        .                 // Look at the last frame on the stack.
        .                 // If it still has a TokenTree we have not looked at yet, use that tree.
  260,130 (0.0%)          let Some(tree) = stack.last_mut().unwrap().next() else {
        .                     // This else-case never produces a value for `tree` (it `continue`s or `return`s).
        .         
        .                     // Otherwise, if we have just reached the end of a sequence and we can keep repeating,
        .                     // go back to the beginning of the sequence.
  115,684 (0.0%)              if let Frame::Sequence { idx, sep, .. } = stack.last_mut().unwrap() {
   51,006 (0.0%)                  let (repeat_idx, repeat_len) = repeats.last_mut().unwrap();
   76,509 (0.0%)                  *repeat_idx += 1;
   25,503 (0.0%)                  if repeat_idx < repeat_len {
   19,351 (0.0%)                      *idx = 0;
   38,702 (0.0%)                      if let Some(sep) = sep {
      964 (0.0%)                          result.push(TokenTree::Token(sep.clone(), Spacing::Alone));
        .                             }
        .                             continue;
        .                         }
        .                     }
        .         
        .                     // We are done with the top of the stack. Pop it. Depending on what it was, we do
        .                     // different things. Note that the outermost item must be the delimited, wrapped RHS
        .                     // that was passed in originally to `transcribe`.
   76,982 (0.0%)              match stack.pop().unwrap() {
        .                         // Done with a sequence. Pop from repeats.
        .                         Frame::Sequence { .. } => {
        .                             repeats.pop();
        .                         }
        .         
        .                         // We are done processing a Delimited. If this is the top-level delimited, we are
        .                         // done. Otherwise, we unwind the result_stack to append what we have produced to
        .                         // any previous results.
   32,339 (0.0%)                  Frame::Delimited { delim, span, mut spacing, .. } => {
        .                             // Hack to force-insert a space after `]` in certain case.
        .                             // See discussion of the `hex-literal` crate in #114571.
  129,356 (0.0%)                      if delim == Delimiter::Bracket {
        .                                 spacing.close = Spacing::Alone;
        .                             }
   64,678 (0.0%)                      if result_stack.is_empty() {
        .                                 // No results left to compute! We are back at the top-level.
    5,468 (0.0%)                          return Ok(TokenStream::new(result));
        .                             }
        .         
        .                             // Step back into the parent Delimited.
  295,581 (0.0%)                      let tree = TokenTree::Delimited(span, spacing, delim, TokenStream::new(result));
   53,742 (0.0%)                      result = result_stack.pop().unwrap();
        .                             result.push(tree);
        .                         }
        .                     }
        .                     continue;
        .                 };
        .         
        .                 // At this point, we know we are in the middle of a TokenTree (the last one on `stack`).
        .                 // `tree` contains the next `TokenTree` to be processed.
1,820,592 (0.0%)          match tree {
        .                     // We are descending into a sequence. We first make sure that the matchers in the RHS
        .                     // and the matches in `interp` have the same shape. Otherwise, either the caller or the
        .                     // macro writer has made a mistake.
        .                     seq @ mbe::TokenTree::Sequence(_, delimited) => {
   97,713 (0.0%)                  match lockstep_iter_size(seq, interp, &repeats) {
        .                             LockstepIterSize::Unconstrained => {
        .                                 return Err(cx
        .                                     .dcx()
        .                                     .create_err(NoSyntaxVarsExprRepeat { span: seq.span() }));
        .                             }
        .         
        .                             LockstepIterSize::Contradiction(msg) => {
        .                                 // FIXME: this really ought to be caught at macro definition time... It
-- line 204 ----------------------------------------
-- line 205 ----------------------------------------
        .                                 // happens when two meta-variables are used in the same repetition in a
        .                                 // sequence, but they come from different sequence matchers and repeat
        .                                 // different amounts.
        .                                 return Err(cx
        .                                     .dcx()
        .                                     .create_err(MetaVarsDifSeqMatchers { span: seq.span(), msg }));
        .                             }
        .         
    8,883 (0.0%)                      LockstepIterSize::Constraint(len, _) => {
        .                                 // We do this to avoid an extra clone above. We know that this is a
        .                                 // sequence already.
        .                                 let mbe::TokenTree::Sequence(sp, seq) = seq else { unreachable!() };
        .         
        .                                 // Is the repetition empty?
   17,766 (0.0%)                          if len == 0 {
    5,462 (0.0%)                              if seq.kleene.op == KleeneOp::OneOrMore {
        .                                         // FIXME: this really ought to be caught at macro definition
        .                                         // time... It happens when the Kleene operator in the matcher and
        .                                         // the body for the same meta-variable do not match.
        .                                         return Err(cx
        .                                             .dcx()
        .                                             .create_err(MustRepeatOnce { span: sp.entire() }));
        .                                     }
        .                                 } else {
        .                                     // 0 is the initial counter (we have done 0 repetitions so far). `len`
        .                                     // is the total number of repetitions we should generate.
        .                                     repeats.push((0, len));
        .         
        .                                     // The first time we encounter the sequence we push it to the stack. It
        .                                     // then gets reused (see the beginning of the loop) until we are done
        .                                     // repeating.
   73,824 (0.0%)                              stack.push(Frame::Sequence {
        .                                         idx: 0,
        .                                         sep: seq.separator.clone(),
    6,152 (0.0%)                                  tts: &delimited.tts,
    6,152 (0.0%)                                  kleene_op: seq.kleene.op,
        .                                     });
        .                                 }
        .                             }
        .                         }
        .                     }
        .         
        .                     // Replace the meta-var with the matched token tree from the invocation.
  210,738 (0.0%)              mbe::TokenTree::MetaVar(mut sp, mut original_ident) => {
        .                         // Find the matched nonterminal from the macro invocation, and use it to replace
        .                         // the meta-var.
  245,861 (0.0%)                  let ident = MacroRulesNormalizedIdent::new(original_ident);
  280,984 (0.0%)                  if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {
  150,935 (0.0%)                      let tt = match cur_matched {
        .                                 MatchedSingle(ParseNtResult::Tt(tt)) => {
        .                                     // `tt`s are emitted into the output stream directly as "raw tokens",
        .                                     // without wrapping them into groups.
        .                                     maybe_use_metavar_location(cx, &stack, sp, tt, &mut marker)
        .                                 }
        .                                 MatchedSingle(ParseNtResult::Nt(nt)) => {
        .                                     // Other variables are emitted into the output stream as groups with
        .                                     // `Delimiter::Invisible` to maintain parsing priorities.
        .                                     // `Interpolated` is currently used for such groups in rustc parser.
   37,020 (0.0%)                              marker.visit_span(&mut sp);
   24,680 (0.0%)                              TokenTree::token_alone(token::Interpolated(nt.clone()), sp)
        .                                 }
        .                                 MatchedSeq(..) => {
        .                                     // We were unable to descend far enough. This is an error.
        .                                     return Err(cx.dcx().create_err(VarStillRepeating { span: sp, ident }));
        .                                 }
        .                             };
  667,337 (0.0%)                      result.push(tt)
        .                         } else {
        .                             // If we aren't able to match the meta-var, we push it back into the result but
        .                             // with modified syntax context. (I believe this supports nested macros).
        .                             marker.visit_span(&mut sp);
        .                             marker.visit_ident(&mut original_ident);
        .                             result.push(TokenTree::token_joint_hidden(token::Dollar, sp));
        .                             result.push(TokenTree::Token(
        .                                 Token::from_ast_ident(original_ident),
-- line 279 ----------------------------------------
-- line 287 ----------------------------------------
        .                         transcribe_metavar_expr(cx, expr, interp, &mut marker, &repeats, &mut result, sp)?;
        .                     }
        .         
        .                     // If we are entering a new delimiter, we push its contents to the `stack` to be
        .                     // processed, and we push all of the currently produced results to the `result_stack`.
        .                     // We will produce all of the results of the inside of the `Delimited` and then we will
        .                     // jump back out of the Delimited, pop the result_stack and add the new results back to
        .                     // the previous results (from outside the Delimited).
   53,742 (0.0%)              mbe::TokenTree::Delimited(mut span, spacing, delimited) => {
        .                         mut_visit::visit_delim_span(&mut span, &mut marker);
  134,355 (0.0%)                  stack.push(Frame::Delimited {
   26,871 (0.0%)                      tts: &delimited.tts,
   26,871 (0.0%)                      delim: delimited.delim,
        .                             idx: 0,
   80,613 (0.0%)                      span,
   26,871 (0.0%)                      spacing: *spacing,
        .                         });
        .                         result_stack.push(mem::take(&mut result));
        .                     }
        .         
        .                     // Nothing much to do here. Just push the token to the result, being careful to
        .                     // preserve syntax context.
        .                     mbe::TokenTree::Token(token) => {
        .                         let mut token = token.clone();
  394,233 (0.0%)                  mut_visit::visit_token(&mut token, &mut marker);
  788,466 (0.0%)                  let tt = TokenTree::Token(token, Spacing::Alone);
        .                         result.push(tt);
        .                     }
        .         
        .                     // There should be no meta-var declarations in the invocation of a macro.
        .                     mbe::TokenTree::MetaVarDecl(..) => panic!("unexpected `TokenTree::MetaVarDecl`"),
        .                 }
        .             }
   25,107 (0.0%)  }
        .         
        .         /// Store the metavariable span for this original span into a side table.
        .         /// FIXME: Try to put the metavariable span into `SpanData` instead of a side table (#118517).
        .         /// An optimal encoding for inlined spans will need to be selected to minimize regressions.
        .         /// The side table approach is relatively good, but not perfect due to collisions.
        .         /// In particular, collisions happen when token is passed as an argument through several macro
        .         /// calls, like in recursive macros.
        .         /// The old heuristic below is used to improve spans in case of collisions, but diagnostics are
-- line 328 ----------------------------------------
-- line 351 ----------------------------------------
        .         /// - The metavariable span comes from a different crate, then we prefer the more local span.
        .         fn maybe_use_metavar_location(
        .             cx: &ExtCtxt<'_>,
        .             stack: &[Frame<'_>],
        .             mut metavar_span: Span,
        .             orig_tt: &TokenTree,
        .             marker: &mut Marker,
        .         ) -> TokenTree {
  113,915 (0.0%)      let undelimited_seq = matches!(
   22,783 (0.0%)          stack.last(),
        .                 Some(Frame::Sequence {
   45,566 (0.0%)              tts: [_],
        .                     sep: None,
        .                     kleene_op: KleeneOp::ZeroOrMore | KleeneOp::OneOrMore,
        .                     ..
        .                 })
        .             );
        .             if undelimited_seq {
        .                 // Do not record metavar spans for tokens from undelimited sequences, for perf reasons.
        .                 return orig_tt.clone();
-- line 370 ----------------------------------------
-- line 410 ----------------------------------------
        .         }
        .         
        .         /// Lookup the meta-var named `ident` and return the matched token tree from the invocation using
        .         /// the set of matches `interpolations`.
        .         ///
        .         /// See the definition of `repeats` in the `transcribe` function. `repeats` is used to descend
        .         /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has
        .         /// made a mistake, and we return `None`.
  364,336 (0.0%)  fn lookup_cur_matched<'a>(
        .             ident: MacroRulesNormalizedIdent,
        .             interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,
        .             repeats: &[(usize, usize)],
        .         ) -> Option<&'a NamedMatch> {
        .             interpolations.get(&ident).map(|mut matched| {
  212,378 (0.0%)          for &(idx, _) in repeats {
   60,984 (0.0%)              match matched {
        .                         MatchedSingle(_) => break,
        .                         MatchedSeq(ads) => matched = ads.get(idx).unwrap(),
        .                     }
        .                 }
        .         
        .                 matched
        .             })
  409,878 (0.0%)  }
        .         
        .         /// An accumulator over a TokenTree to be used with `fold`. During transcription, we need to make
        .         /// sure that the size of each sequence and all of its nested sequences are the same as the sizes
        .         /// of all the matched (nested) sequences in the macro invocation. If they don't match, somebody
        .         /// has made a mistake (either the macro writer or caller).
        .         #[derive(Clone)]
        .         enum LockstepIterSize {
        .             /// No constraints on length of matcher. This is true for any TokenTree variants except a
-- line 441 ----------------------------------------
-- line 450 ----------------------------------------
        .             Contradiction(String),
        .         }
        .         
        .         impl LockstepIterSize {
        .             /// Find incompatibilities in matcher/invocation sizes.
        .             /// - `Unconstrained` is compatible with everything.
        .             /// - `Contradiction` is incompatible with everything.
        .             /// - `Constraint(len)` is only compatible with other constraints of the same length.
  110,604 (0.0%)      fn with(self, other: LockstepIterSize) -> LockstepIterSize {
   60,338 (0.0%)          match self {
        .                     LockstepIterSize::Unconstrained => other,
        .                     LockstepIterSize::Contradiction(_) => self,
   25,470 (0.0%)              LockstepIterSize::Constraint(l_len, l_id) => match other {
        .                         LockstepIterSize::Unconstrained => self,
        .                         LockstepIterSize::Contradiction(_) => other,
    4,212 (0.0%)                  LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,
        .                         LockstepIterSize::Constraint(r_len, r_id) => {
        .                             let msg = format!(
        .                                 "meta-variable `{}` repeats {} time{}, but `{}` repeats {} time{}",
        .                                 l_id,
        .                                 l_len,
        .                                 pluralize!(l_len),
        .                                 r_id,
        .                                 r_len,
        .                                 pluralize!(r_len),
        .                             );
        .                             LockstepIterSize::Contradiction(msg)
        .                         }
        .                     },
        .                 }
  110,604 (0.0%)      }
        .         }
        .         
        .         /// Given a `tree`, make sure that all sequences have the same length as the matches for the
        .         /// appropriate meta-vars in `interpolations`.
        .         ///
        .         /// Note that if `repeats` does not match the exact correct depth of a meta-var,
        .         /// `lookup_cur_matched` will return `None`, which is why this still works even in the presence of
        .         /// multiple nested matcher sequences.
        .         ///
        .         /// Example: `$($($x $y)+*);+` -- we need to make sure that `x` and `y` repeat the same amount as
        .         /// each other at the given depth when the macro was invoked. If they don't it might mean they were
        .         /// declared at depths which weren't equal or there was a compiler bug. For example, if we have 3 repetitions of
        .         /// the outer sequence and 4 repetitions of the inner sequence for `x`, we should have the same for
        .         /// `y`; otherwise, we can't transcribe them both at the given depth.
  273,170 (0.0%)  fn lockstep_iter_size(
        .             tree: &mbe::TokenTree,
        .             interpolations: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,
        .             repeats: &[(usize, usize)],
        .         ) -> LockstepIterSize {
        .             use mbe::TokenTree;
  245,853 (0.0%)      match tree {
        .                 TokenTree::Delimited(.., delimited) => {
    1,480 (0.0%)              delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {
   37,515 (0.0%)                  size.with(lockstep_iter_size(tt, interpolations, repeats))
        .                     })
        .                 }
        .                 TokenTree::Sequence(_, seq) => {
   10,654 (0.0%)              seq.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {
  238,995 (0.0%)                  size.with(lockstep_iter_size(tt, interpolations, repeats))
        .                     })
        .                 }
   41,676 (0.0%)          TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {
   10,419 (0.0%)              let name = MacroRulesNormalizedIdent::new(*name);
   83,352 (0.0%)              match lookup_cur_matched(name, interpolations, repeats) {
   20,838 (0.0%)                  Some(matched) => match matched {
        .                             MatchedSingle(_) => LockstepIterSize::Unconstrained,
   72,009 (0.0%)                      MatchedSeq(ads) => LockstepIterSize::Constraint(ads.len(), name),
        .                         },
        .                         _ => LockstepIterSize::Unconstrained,
        .                     }
        .                 }
        .                 TokenTree::MetaVarExpr(_, expr) => {
        .                     let default_rslt = LockstepIterSize::Unconstrained;
        .                     let Some(ident) = expr.ident() else {
        .                         return default_rslt;
-- line 525 ----------------------------------------
-- line 529 ----------------------------------------
        .                         Some(MatchedSeq(ads)) => {
        .                             default_rslt.with(LockstepIterSize::Constraint(ads.len(), name))
        .                         }
        .                         _ => default_rslt,
        .                     }
        .                 }
        .                 TokenTree::Token(..) => LockstepIterSize::Unconstrained,
        .             }
  218,536 (0.0%)  }
        .         
        .         /// Used solely by the `count` meta-variable expression, counts the outer-most repetitions at a
        .         /// given optional nested depth.
        .         ///
        .         /// For example, a macro parameter of `$( { $( $foo:ident ),* } )*` called with `{ a, b } { c }`:
        .         ///
        .         /// * `[ $( ${count(foo)} ),* ]` will return [2, 1] with a, b = 2 and c = 1
        .         /// * `[ $( ${count(foo, 0)} ),* ]` will be the same as `[ $( ${count(foo)} ),* ]`
-- line 545 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/at.rs
--------------------------------------------------------------------------------
Ir______________ 

      185 (0.0%)  <unknown (line 0)>

-- line 54 ----------------------------------------
        .         
        .         impl<'tcx> InferCtxt<'tcx> {
        .             #[inline]
        .             pub fn at<'a>(
        .                 &'a self,
        .                 cause: &'a ObligationCause<'tcx>,
        .                 param_env: ty::ParamEnv<'tcx>,
        .             ) -> At<'a, 'tcx> {
1,338,515 (0.0%)          At { infcx: self, cause, param_env }
        .             }
        .         
        .             /// Forks the inference context, creating a new inference context with the same inference
        .             /// variables in the same state. This can be used to "branch off" many tests from the same
        .             /// common state.
   11,330 (0.0%)      pub fn fork(&self) -> Self {
    4,532 (0.0%)          self.fork_with_intercrate(self.intercrate)
   11,330 (0.0%)      }
        .         
        .             /// Forks the inference context, creating a new inference context with the same inference
        .             /// variables in the same state, except possibly changing the intercrate mode. This can be
        .             /// used to "branch off" many tests from the same common state. Used in negative coherence.
   20,394 (0.0%)      pub fn fork_with_intercrate(&self, intercrate: bool) -> Self {
  117,832 (0.0%)          Self {
        .                     tcx: self.tcx,
        .                     defining_opaque_types: self.defining_opaque_types,
        .                     considering_regions: self.considering_regions,
        .                     skip_leak_check: self.skip_leak_check,
        .                     inner: self.inner.clone(),
        .                     lexical_region_resolutions: self.lexical_region_resolutions.clone(),
        .                     selection_cache: self.selection_cache.clone(),
        .                     evaluation_cache: self.evaluation_cache.clone(),
        .                     reported_trait_errors: self.reported_trait_errors.clone(),
        .                     reported_signature_mismatch: self.reported_signature_mismatch.clone(),
        .                     tainted_by_errors: self.tainted_by_errors.clone(),
    6,798 (0.0%)              err_count_on_creation: self.err_count_on_creation,
        .                     universe: self.universe.clone(),
        .                     intercrate,
    6,798 (0.0%)              next_trait_solver: self.next_trait_solver,
        .                     obligation_inspector: self.obligation_inspector.clone(),
        .                 }
   20,394 (0.0%)      }
        .         }
        .         
        .         pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
-- line 102 ----------------------------------------
-- line 106 ----------------------------------------
        .         impl<'a, 'tcx> At<'a, 'tcx> {
        .             /// Makes `actual <: expected`. For example, if type-checking a
        .             /// call like `foo(x)`, where `foo: fn(i32)`, you might have
        .             /// `sup(i32, x)`, since the "expected" type is the type that
        .             /// appears in the signature.
        .             ///
        .             /// See [`At::trace`] and [`Trace::sub`] for a version of
        .             /// this method that only requires `T: Relate<'tcx>`
  122,486 (0.0%)      pub fn sup<T>(
        .                 self,
        .                 define_opaque_types: DefineOpaqueTypes,
        .                 expected: T,
        .                 actual: T,
        .             ) -> InferResult<'tcx, ()>
        .             where
        .                 T: ToTrace<'tcx>,
        .             {
        .                 self.trace(expected, actual).sup(define_opaque_types, expected, actual)
   75,376 (0.0%)      }
        .         
        .             /// Makes `expected <: actual`.
        .             ///
        .             /// See [`At::trace`] and [`Trace::sub`] for a version of
        .             /// this method that only requires `T: Relate<'tcx>`
        .             pub fn sub<T>(
        .                 self,
        .                 define_opaque_types: DefineOpaqueTypes,
-- line 132 ----------------------------------------
-- line 138 ----------------------------------------
        .             {
        .                 self.trace(expected, actual).sub(define_opaque_types, expected, actual)
        .             }
        .         
        .             /// Makes `expected <: actual`.
        .             ///
        .             /// See [`At::trace`] and [`Trace::eq`] for a version of
        .             /// this method that only requires `T: Relate<'tcx>`
3,094,688 (0.0%)      pub fn eq<T>(
        .                 self,
        .                 define_opaque_types: DefineOpaqueTypes,
        .                 expected: T,
        .                 actual: T,
        .             ) -> InferResult<'tcx, ()>
        .             where
        .                 T: ToTrace<'tcx>,
        .             {
        .                 self.trace(expected, actual).eq(define_opaque_types, expected, actual)
1,905,247 (0.0%)      }
        .         
        .             pub fn relate<T>(
        .                 self,
        .                 define_opaque_types: DefineOpaqueTypes,
        .                 expected: T,
        .                 variance: ty::Variance,
        .                 actual: T,
        .             ) -> InferResult<'tcx, ()>
        .             where
        .                 T: ToTrace<'tcx>,
        .             {
      300 (0.0%)          match variance {
        .                     ty::Variance::Covariant => self.sub(define_opaque_types, expected, actual),
        .                     ty::Variance::Invariant => self.eq(define_opaque_types, expected, actual),
        .                     ty::Variance::Contravariant => self.sup(define_opaque_types, expected, actual),
        .         
        .                     // We could make this make sense but it's not readily
        .                     // exposed and I don't feel like dealing with it. Note
        .                     // that bivariance in general does a bit more than just
        .                     // *nothing*, it checks that the types are the same
-- line 176 ----------------------------------------
-- line 220 ----------------------------------------
        .             /// Sets the "trace" values that will be used for
        .             /// error-reporting, but doesn't actually perform any operation
        .             /// yet (this is useful when you want to set the trace using
        .             /// distinct values from those you wish to operate upon).
        .             pub fn trace<T>(self, expected: T, actual: T) -> Trace<'a, 'tcx>
        .             where
        .                 T: ToTrace<'tcx>,
        .             {
1,759,164 (0.0%)          let trace = ToTrace::to_trace(self.cause, true, expected, actual);
  496,048 (0.0%)          Trace { at: self, trace }
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> Trace<'a, 'tcx> {
        .             /// Makes `a <: b`.
        .             #[instrument(skip(self), level = "debug")]
        .             pub fn sub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>
        .             where
        .                 T: Relate<'tcx>,
        .             {
        .                 let Trace { at, trace } = self;
        .                 let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);
        .                 fields
        .                     .sub()
        .                     .relate(a, b)
      240 (0.0%)              .map(move |_| InferOk { value: (), obligations: fields.obligations })
        .             }
        .         
        .             /// Makes `a :> b`.
        .             #[instrument(skip(self), level = "debug")]
        .             pub fn sup<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>
        .             where
        .                 T: Relate<'tcx>,
        .             {
        .                 let Trace { at, trace } = self;
        .                 let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);
        .                 fields
        .                     .sup()
        .                     .relate(a, b)
   50,100 (0.0%)              .map(move |_| InferOk { value: (), obligations: fields.obligations })
        .             }
        .         
        .             /// Makes `a == b`.
        .             #[instrument(skip(self), level = "debug")]
        .             pub fn eq<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>
        .             where
        .                 T: Relate<'tcx>,
        .             {
        .                 let Trace { at, trace } = self;
        .                 let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);
        .                 fields
        .                     .equate(StructurallyRelateAliases::No)
  923,112 (0.0%)              .relate(a, b)
  736,504 (0.0%)              .map(move |_| InferOk { value: (), obligations: fields.obligations })
        .             }
        .         
        .             /// Equates `a` and `b` while structurally relating aliases. This should only
        .             /// be used inside of the next generation trait solver when relating rigid aliases.
        .             #[instrument(skip(self), level = "debug")]
        .             pub fn eq_structurally_relating_aliases<T>(self, a: T, b: T) -> InferResult<'tcx, ()>
        .             where
        .                 T: Relate<'tcx>,
-- line 281 ----------------------------------------
-- line 312 ----------------------------------------
        .                 fields
        .                     .glb()
        .                     .relate(a, b)
        .                     .map(move |t| InferOk { value: t, obligations: fields.obligations })
        .             }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {
    1,700 (0.0%)      fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
      850 (0.0%)          match (a, b) {
      680 (0.0%)              (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {
      850 (0.0%)                  ToTrace::to_trace(cause, a_is_expected, trait_ref_a, trait_ref_b)
        .                     }
        .                     (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {
        .                         ToTrace::to_trace(cause, a_is_expected, ty_a, ty_b)
        .                     }
        .                     (ImplSubject::Trait(_), ImplSubject::Inherent(_))
        .                     | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {
        .                         bug!("can not trace TraitRef and Ty");
        .                     }
        .                 }
    1,530 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
-- line 346 ----------------------------------------
-- line 348 ----------------------------------------
        .                 TypeTrace {
        .                     cause: cause.clone(),
        .                     values: Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {
      370 (0.0%)      fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
    1,110 (0.0%)          TypeTrace { cause: cause.clone(), values: Regions(ExpectedFound::new(a_is_expected, a, b)) }
      555 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for Const<'tcx> {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
-- line 371 ----------------------------------------
-- line 400 ----------------------------------------
        .                             bug!("relating different kinds: {a:?} {b:?}")
        .                         }
        .                     },
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {
    6,794 (0.0%)      fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
   20,382 (0.0%)          TypeTrace { cause: cause.clone(), values: Terms(ExpectedFound::new(a_is_expected, a, b)) }
   10,191 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {
2,538,558 (0.0%)      fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
3,461,670 (0.0%)          TypeTrace {
        .                     cause: cause.clone(),
  230,778 (0.0%)              values: PolyTraitRefs(ExpectedFound::new(
        .                         a_is_expected,
        .                         ty::Binder::dummy(a),
        .                         ty::Binder::dummy(b),
        .                     )),
        .                 }
1,846,224 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
-- line 441 ----------------------------------------
-- line 449 ----------------------------------------
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
   10,548 (0.0%)          TypeTrace { cause: cause.clone(), values: Aliases(ExpectedFound::new(a_is_expected, a, b)) }
    2,637 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::FnSig<'tcx> {
    1,950 (0.0%)      fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
        .             ) -> TypeTrace<'tcx> {
    3,900 (0.0%)          TypeTrace {
        .                     cause: cause.clone(),
        .                     values: PolySigs(ExpectedFound::new(
        .                         a_is_expected,
        .                         ty::Binder::dummy(a),
        .                         ty::Binder::dummy(b),
        .                     )),
        .                 }
    2,275 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToTrace<'tcx> for ty::PolyFnSig<'tcx> {
        .             fn to_trace(
        .                 cause: &ObligationCause<'tcx>,
        .                 a_is_expected: bool,
        .                 a: Self,
        .                 b: Self,
-- line 484 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/relate/combine.rs
--------------------------------------------------------------------------------
Ir______________ 

2,518,350 (0.0%)  <unknown (line 0)>

-- line 37 ----------------------------------------
        .             pub infcx: &'infcx InferCtxt<'tcx>,
        .             pub trace: TypeTrace<'tcx>,
        .             pub param_env: ty::ParamEnv<'tcx>,
        .             pub obligations: PredicateObligations<'tcx>,
        .             pub define_opaque_types: DefineOpaqueTypes,
        .         }
        .         
        .         impl<'tcx> InferCtxt<'tcx> {
1,467,578 (0.0%)      pub fn super_combine_tys<R>(
        .                 &self,
        .                 relation: &mut R,
        .                 a: Ty<'tcx>,
        .                 b: Ty<'tcx>,
        .             ) -> RelateResult<'tcx, Ty<'tcx>>
        .             where
        .                 R: ObligationEmittingRelation<'tcx>,
        .             {
        .                 debug_assert!(!a.has_escaping_bound_vars());
        .                 debug_assert!(!b.has_escaping_bound_vars());
        .         
5,350,462 (0.1%)          match (a.kind(), b.kind()) {
        .                     // Relate integral variables to other types
        .                     (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {
       28 (0.0%)                  self.inner
        .                             .borrow_mut()
        .                             .int_unification_table()
        .                             .unify_var_var(a_id, b_id)
        .                             .map_err(|e| int_unification_error(true, e))?;
       42 (0.0%)                  Ok(a)
        .                     }
      120 (0.0%)              (&ty::Infer(ty::IntVar(v_id)), &ty::Int(v)) => {
      360 (0.0%)                  self.unify_integral_variable(true, v_id, IntType(v))
        .                     }
        .                     (&ty::Int(v), &ty::Infer(ty::IntVar(v_id))) => {
        .                         self.unify_integral_variable(false, v_id, IntType(v))
        .                     }
      130 (0.0%)              (&ty::Infer(ty::IntVar(v_id)), &ty::Uint(v)) => {
      390 (0.0%)                  self.unify_integral_variable(true, v_id, UintType(v))
        .                     }
       10 (0.0%)              (&ty::Uint(v), &ty::Infer(ty::IntVar(v_id))) => {
       30 (0.0%)                  self.unify_integral_variable(false, v_id, UintType(v))
        .                     }
        .         
        .                     // Relate floating-point variables to other types
        .                     (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {
        .                         self.inner
        .                             .borrow_mut()
        .                             .float_unification_table()
        .                             .unify_var_var(a_id, b_id)
-- line 85 ----------------------------------------
-- line 104 ----------------------------------------
        .                     }
        .                     (_, ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)))
        .                     | (ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)), _)
        .                         if self.next_trait_solver() =>
        .                     {
        .                         bug!("We do not expect to encounter `Fresh` variables in the new solver")
        .                     }
        .         
   53,538 (0.0%)              (_, ty::Alias(..)) | (ty::Alias(..), _) if self.next_trait_solver() => {
        .                         match relation.structurally_relate_aliases() {
        .                             StructurallyRelateAliases::Yes => {
        .                                 ty::relate::structurally_relate_tys(relation, a, b)
        .                             }
        .                             StructurallyRelateAliases::No => {
        .                                 relation.register_type_relate_obligation(a, b);
        .                                 Ok(a)
        .                             }
-- line 120 ----------------------------------------
-- line 132 ----------------------------------------
        .                     // way later.
        .                     (&ty::Alias(ty::Opaque, _), _) | (_, &ty::Alias(ty::Opaque, _)) if self.intercrate => {
        .                         relation.register_predicates([ty::Binder::dummy(ty::PredicateKind::Ambiguous)]);
        .                         Ok(a)
        .                     }
        .         
        .                     _ => ty::relate::structurally_relate_tys(relation, a, b),
        .                 }
       98 (0.0%)      }
        .         
    7,587 (0.0%)      pub fn super_combine_consts<R>(
        .                 &self,
        .                 relation: &mut R,
        .                 a: ty::Const<'tcx>,
        .                 b: ty::Const<'tcx>,
        .             ) -> RelateResult<'tcx, ty::Const<'tcx>>
        .             where
        .                 R: ObligationEmittingRelation<'tcx>,
        .             {
        .                 debug!("{}.consts({:?}, {:?})", relation.tag(), a, b);
        .                 debug_assert!(!a.has_escaping_bound_vars());
        .                 debug_assert!(!b.has_escaping_bound_vars());
      843 (0.0%)          if a == b {
       76 (0.0%)              return Ok(a);
        .                 }
        .         
        .                 let a = self.shallow_resolve(a);
        .                 let b = self.shallow_resolve(b);
        .         
        .                 // We should never have to relate the `ty` field on `Const` as it is checked elsewhere that consts have the
        .                 // correct type for the generic param they are an argument for. However there have been a number of cases
        .                 // historically where asserting that the types are equal has found bugs in the compiler so this is valuable
        .                 // to check even if it is a bit nasty impl wise :(
        .                 //
        .                 // This probe is probably not strictly necessary but it seems better to be safe and not accidentally find
        .                 // ourselves with a check to find bugs being required for code to compile because it made inference progress.
        .                 self.probe(|_| {
    1,610 (0.0%)              if a.ty() == b.ty() {
        .                         return;
        .                     }
        .         
        .                     // We don't have access to trait solving machinery in `rustc_infer` so the logic for determining if the
        .                     // two const param's types are able to be equal has to go through a canonical query with the actual logic
        .                     // in `rustc_trait_selection`.
        .                     let canonical = self.canonicalize_query(
        .                         relation.param_env().and((a.ty(), b.ty())),
-- line 177 ----------------------------------------
-- line 184 ----------------------------------------
        .                             "cannot relate consts of different types (a={a:?}, b={b:?})",
        .                         ));
        .                         // We treat these constants as if they were of the same type, so that any
        .                         // such constants being used in impls make these impls match barring other mismatches.
        .                         // This helps with diagnostics down the road.
        .                     });
        .                 });
        .         
    9,760 (0.0%)          match (a.kind(), b.kind()) {
        .                     (
        .                         ty::ConstKind::Infer(InferConst::Var(a_vid)),
        .                         ty::ConstKind::Infer(InferConst::Var(b_vid)),
        .                     ) => {
        .                         self.inner.borrow_mut().const_unification_table().union(a_vid, b_vid);
        .                         Ok(a)
        .                     }
        .         
-- line 200 ----------------------------------------
-- line 221 ----------------------------------------
        .                     }
        .         
        .                     (ty::ConstKind::Infer(InferConst::Var(vid)), _) => {
        .                         self.instantiate_const_var(relation, true, vid, b)?;
        .                         Ok(b)
        .                     }
        .         
        .                     (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {
        8 (0.0%)                  self.instantiate_const_var(relation, false, vid, a)?;
        .                         Ok(a)
        .                     }
        .         
        .                     (ty::ConstKind::Infer(InferConst::EffectVar(vid)), _) => {
      130 (0.0%)                  Ok(self.unify_effect_variable(vid, b))
        .                     }
        .         
        .                     (_, ty::ConstKind::Infer(InferConst::EffectVar(vid))) => {
    5,061 (0.0%)                  Ok(self.unify_effect_variable(vid, a))
        .                     }
        .         
        .                     (ty::ConstKind::Unevaluated(..), _) | (_, ty::ConstKind::Unevaluated(..))
        .                         if self.tcx.features().generic_const_exprs || self.next_trait_solver() =>
        .                     {
        .                         match relation.structurally_relate_aliases() {
        .                             StructurallyRelateAliases::No => {
        .                                 relation.register_predicates([if self.next_trait_solver() {
-- line 246 ----------------------------------------
-- line 257 ----------------------------------------
        .                             }
        .                             StructurallyRelateAliases::Yes => {
        .                                 ty::relate::structurally_relate_consts(relation, a, b)
        .                             }
        .                         }
        .                     }
        .                     _ => ty::relate::structurally_relate_consts(relation, a, b),
        .                 }
    6,744 (0.0%)      }
        .         
    2,600 (0.0%)      fn unify_integral_variable(
        .                 &self,
        .                 vid_is_expected: bool,
        .                 vid: ty::IntVid,
        .                 val: ty::IntVarValue,
        .             ) -> RelateResult<'tcx, Ty<'tcx>> {
        .                 self.inner
        .                     .borrow_mut()
        .                     .int_unification_table()
        .                     .unify_var_value(vid, Some(val))
        .                     .map_err(|e| int_unification_error(vid_is_expected, e))?;
      520 (0.0%)          match val {
        .                     IntType(v) => Ok(Ty::new_int(self.tcx, v)),
        .                     UintType(v) => Ok(Ty::new_uint(self.tcx, v)),
        .                 }
    2,340 (0.0%)      }
        .         
        .             fn unify_float_variable(
        .                 &self,
        .                 vid_is_expected: bool,
        .                 vid: ty::FloatVid,
        .                 val: ty::FloatTy,
        .             ) -> RelateResult<'tcx, Ty<'tcx>> {
        .                 self.inner
        .                     .borrow_mut()
        .                     .float_unification_table()
        .                     .unify_var_value(vid, Some(ty::FloatVarValue(val)))
        .                     .map_err(|e| float_unification_error(vid_is_expected, e))?;
        .                 Ok(Ty::new_float(self.tcx, val))
        .             }
        .         
    5,992 (0.0%)      fn unify_effect_variable(&self, vid: ty::EffectVid, val: ty::Const<'tcx>) -> ty::Const<'tcx> {
        .                 self.inner
        .                     .borrow_mut()
        .                     .effect_unification_table()
        .                     .union_value(vid, EffectVarValue::Known(val));
        .                 val
    5,992 (0.0%)      }
        .         }
        .         
        .         impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {
        .             pub fn tcx(&self) -> TyCtxt<'tcx> {
        .                 self.infcx.tcx
        .             }
        .         
        .             pub fn equate<'a>(
-- line 312 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/relate/higher_ranked.rs
--------------------------------------------------------------------------------
Ir_______________ 

   237,717 (0.0%)  <unknown (line 0)>

-- line 14 ----------------------------------------
         .             /// this method has been called.
         .             ///
         .             /// This is the first step of checking subtyping when higher-ranked things are involved.
         .             /// For more details visit the relevant sections of the [rustc dev guide].
         .             ///
         .             /// `fn enter_forall` should be preferred over this method.
         .             ///
         .             /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html
16,877,220 (0.2%)      #[instrument(level = "debug", skip(self), ret)]
         .             pub fn enter_forall_and_leak_universe<T>(&self, binder: ty::Binder<'tcx, T>) -> T
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>> + Copy,
         .             {
 2,112,130 (0.0%)          if let Some(inner) = binder.no_bound_vars() {
         .                     return inner;
         .                 }
         .         
     2,277 (0.0%)          let next_universe = self.create_next_universe();
         .         
         .                 let delegate = FnMutDelegate {
     5,790 (0.0%)              regions: &mut |br: ty::BoundRegion| {
         .                         ty::Region::new_placeholder(
     2,338 (0.0%)                      self.tcx,
     2,338 (0.0%)                      ty::PlaceholderRegion { universe: next_universe, bound: br },
         .                         )
     3,507 (0.0%)              },
     1,522 (0.0%)              types: &mut |bound_ty: ty::BoundTy| {
         .                         Ty::new_placeholder(
         .                             self.tcx,
         .                             ty::PlaceholderType { universe: next_universe, bound: bound_ty },
         .                         )
         .                     },
     1,522 (0.0%)              consts: &mut |bound_var: ty::BoundVar, ty| {
         .                         ty::Const::new_placeholder(
         .                             self.tcx,
         .                             ty::PlaceholderConst { universe: next_universe, bound: bound_var },
         .                             ty,
         .                         )
         .                     },
         .                 };
         .         
         .                 debug!(?next_universe);
       761 (0.0%)          self.tcx.replace_bound_vars_uncached(binder, delegate)
         .             }
         .         
         .             /// Replaces all bound variables (lifetimes, types, and constants) bound by
         .             /// `binder` with placeholder variables in a new universe and then calls the
         .             /// closure `f` with the instantiated value. The new placeholders can only be
         .             /// named by inference variables created inside of the closure `f` or afterwards.
         .             ///
         .             /// This is the first step of checking subtyping when higher-ranked things are involved.
-- line 64 ----------------------------------------
-- line 71 ----------------------------------------
         .             pub fn enter_forall<T, U>(&self, forall: ty::Binder<'tcx, T>, f: impl FnOnce(T) -> U) -> U
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>> + Copy,
         .             {
         .                 // FIXME: currently we do nothing to prevent placeholders with the new universe being
         .                 // used after exiting `f`. For example region subtyping can result in outlives constraints
         .                 // that name placeholders created in this function. Nested goals from type relations can
         .                 // also contain placeholders created by this function.
 1,358,432 (0.0%)          let value = self.enter_forall_and_leak_universe(forall);
         .                 debug!(?value);
       392 (0.0%)          f(value)
         .             }
         .         
         .             /// See [RegionConstraintCollector::leak_check][1]. We only check placeholder
         .             /// leaking into `outer_universe`, i.e. placeholders which cannot be named by that
         .             /// universe.
         .             ///
         .             /// [1]: crate::infer::region_constraints::RegionConstraintCollector::leak_check
 1,663,956 (0.0%)      pub fn leak_check(
         .                 &self,
         .                 outer_universe: ty::UniverseIndex,
         .                 only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,
         .             ) -> RelateResult<'tcx, ()> {
         .                 // If the user gave `-Zno-leak-check`, or we have been
         .                 // configured to skip the leak check, then skip the leak check
         .                 // completely. The leak check is deprecated. Any legitimate
         .                 // subtyping errors that it would have caught will now be
         .                 // caught later on, during region checking. However, we
         .                 // continue to use it for a transition period.
 1,426,248 (0.0%)          if self.tcx.sess.opts.unstable_opts.no_leak_check || self.skip_leak_check {
       411 (0.0%)              return Ok(());
         .                 }
         .         
   474,594 (0.0%)          self.inner.borrow_mut().unwrap_region_constraints().leak_check(
         .                     self.tcx,
         .                     outer_universe,
         .                     self.universe(),
         .                     only_consider_snapshot,
         .                 )
 1,426,248 (0.0%)      }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/relate/type_relating.rs
--------------------------------------------------------------------------------
Ir______________ 

1,087,501 (0.0%)  <unknown (line 0)>

-- line 20 ----------------------------------------
        .         }
        .         
        .         impl<'combine, 'infcx, 'tcx> TypeRelating<'combine, 'infcx, 'tcx> {
        .             pub fn new(
        .                 f: &'combine mut CombineFields<'infcx, 'tcx>,
        .                 structurally_relate_aliases: StructurallyRelateAliases,
        .                 ambient_variance: ty::Variance,
        .             ) -> TypeRelating<'combine, 'infcx, 'tcx> {
  616,683 (0.0%)          TypeRelating { fields: f, structurally_relate_aliases, ambient_variance }
        .             }
        .         }
        .         
        .         impl<'tcx> TypeRelation<'tcx> for TypeRelating<'_, '_, 'tcx> {
        .             fn tag(&self) -> &'static str {
        .                 "TypeRelating"
        .             }
        .         
        .             fn tcx(&self) -> TyCtxt<'tcx> {
  667,681 (0.0%)          self.fields.infcx.tcx
        .             }
        .         
  339,548 (0.0%)      fn relate_item_args(
        .                 &mut self,
        .                 item_def_id: rustc_hir::def_id::DefId,
        .                 a_arg: ty::GenericArgsRef<'tcx>,
        .                 b_arg: ty::GenericArgsRef<'tcx>,
        .             ) -> RelateResult<'tcx, ty::GenericArgsRef<'tcx>> {
   61,736 (0.0%)          if self.ambient_variance == ty::Variance::Invariant {
        .                     // Avoid fetching the variance if we are in an invariant
        .                     // context; no need, and it can induce dependency cycles
        .                     // (e.g., #41849).
        .                     relate_args_invariantly(self, a_arg, b_arg)
        .                 } else {
        .                     let tcx = self.tcx();
        .                     let opt_variances = tcx.variances_of(item_def_id);
        .                     relate_args_with_variances(self, item_def_id, opt_variances, a_arg, b_arg, false)
        .                 }
  277,812 (0.0%)      }
        .         
  100,976 (0.0%)      fn relate_with_variance<T: Relate<'tcx>>(
        .                 &mut self,
        .                 variance: ty::Variance,
        .                 _info: ty::VarianceDiagInfo<'tcx>,
        .                 a: T,
        .                 b: T,
        .             ) -> RelateResult<'tcx, T> {
  275,149 (0.0%)          let old_ambient_variance = self.ambient_variance;
  697,738 (0.0%)          self.ambient_variance = self.ambient_variance.xform(variance);
        .                 debug!(?self.ambient_variance, "new ambient variance");
        .         
        .                 let r = if self.ambient_variance == ty::Bivariant { Ok(a) } else { self.relate(a, b) };
        .         
  297,462 (0.0%)          self.ambient_variance = old_ambient_variance;
  513,039 (0.0%)          r
   75,732 (0.0%)      }
        .         
6,622,554 (0.1%)      #[instrument(skip(self), level = "debug")]
        .             fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {
  389,562 (0.0%)          if a == b {
  219,868 (0.0%)              return Ok(a);
        .                 }
        .         
  559,256 (0.0%)          let infcx = self.fields.infcx;
  838,884 (0.0%)          let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);
  559,256 (0.0%)          let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);
        .         
4,481,602 (0.1%)          match (a.kind(), b.kind()) {
        .                     (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {
   25,755 (0.0%)                  match self.ambient_variance {
        .                             ty::Covariant => {
        .                                 // can't make progress on `A <: B` if both A and B are
        .                                 // type variables, so record an obligation.
        .                                 self.fields.obligations.push(Obligation::new(
        .                                     self.tcx(),
        .                                     self.fields.trace.cause.clone(),
        .                                     self.fields.param_env,
        .                                     ty::Binder::dummy(ty::PredicateKind::Subtype(ty::SubtypePredicate {
-- line 96 ----------------------------------------
-- line 110 ----------------------------------------
        .                                     ty::Binder::dummy(ty::PredicateKind::Subtype(ty::SubtypePredicate {
        .                                         a_is_expected: false,
        .                                         a: b,
        .                                         b: a,
        .                                     })),
        .                                 ));
        .                             }
        .                             ty::Invariant => {
    5,151 (0.0%)                          infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);
        .                             }
        .                             ty::Bivariant => {
        .                                 unreachable!("Expected bivariance to be handled in relate_with_variance")
        .                             }
        .                         }
        .                     }
        .         
   12,995 (0.0%)              (&ty::Infer(TyVar(a_vid)), _) => {
   90,965 (0.0%)                  infcx.instantiate_ty_var(self, true, a_vid, self.ambient_variance, b)?;
        .                     }
  207,312 (0.0%)              (_, &ty::Infer(TyVar(b_vid))) => {
  310,968 (0.0%)                  infcx.instantiate_ty_var(
        .                             self,
        .                             false,
        .                             b_vid,
        .                             self.ambient_variance.xform(ty::Contravariant),
        .                             a,
        .                         )?;
        .                     }
        .         
-- line 138 ----------------------------------------
-- line 157 ----------------------------------------
        .                         self.fields.obligations.extend(
        .                             infcx
        .                                 .handle_opaque_type(a, b, &self.fields.trace.cause, self.param_env())?
        .                                 .obligations,
        .                         );
        .                     }
        .         
        .                     _ => {
1,257,924 (0.0%)                  infcx.super_combine_tys(self, a, b)?;
        .                     }
        .                 }
        .         
  112,556 (0.0%)          Ok(a)
        .             }
        .         
  142,908 (0.0%)      fn regions(
        .                 &mut self,
        .                 a: ty::Region<'tcx>,
        .                 b: ty::Region<'tcx>,
        .             ) -> RelateResult<'tcx, ty::Region<'tcx>> {
        .                 debug!("{}.regions({:?}, {:?})", self.tag(), a, b);
   35,727 (0.0%)          let origin = SubregionOrigin::Subtype(Box::new(self.fields.trace.clone()));
        .         
   59,545 (0.0%)          match self.ambient_variance {
        .                     // Subtype(&'a u8, &'b u8) => Outlives('a: 'b) => SubRegion('b, 'a)
        .                     ty::Covariant => {
    2,425 (0.0%)                  self.fields
        .                             .infcx
        .                             .inner
        .                             .borrow_mut()
        .                             .unwrap_region_constraints()
        .                             .make_subregion(origin, b, a);
        .                     }
        .                     // Suptype(&'a u8, &'b u8) => Outlives('b: 'a) => SubRegion('a, 'b)
        .                     ty::Contravariant => {
   17,816 (0.0%)                  self.fields
        .                             .infcx
        .                             .inner
        .                             .borrow_mut()
        .                             .unwrap_region_constraints()
        .                             .make_subregion(origin, a, b);
        .                     }
        .                     ty::Invariant => {
    6,970 (0.0%)                  self.fields
        .                             .infcx
        .                             .inner
        .                             .borrow_mut()
        .                             .unwrap_region_constraints()
        .                             .make_eqregion(origin, a, b);
        .                     }
        .                     ty::Bivariant => {
        .                         unreachable!("Expected bivariance to be handled in relate_with_variance")
        .                     }
        .                 }
        .         
   23,818 (0.0%)          Ok(a)
  107,181 (0.0%)      }
        .         
    6,712 (0.0%)      fn consts(
        .                 &mut self,
        .                 a: ty::Const<'tcx>,
        .                 b: ty::Const<'tcx>,
        .             ) -> RelateResult<'tcx, ty::Const<'tcx>> {
    2,543 (0.0%)          self.fields.infcx.super_combine_consts(self, a, b)
    4,195 (0.0%)      }
        .         
       36 (0.0%)      fn binders<T>(
        .                 &mut self,
        .                 a: ty::Binder<'tcx, T>,
        .                 b: ty::Binder<'tcx, T>,
        .             ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>
        .             where
        .                 T: Relate<'tcx>,
        .             {
      641 (0.0%)          if a == b {
        .                     // Do nothing
       19 (0.0%)          } else if let Some(a) = a.no_bound_vars()
        6 (0.0%)              && let Some(b) = b.no_bound_vars()
        .                 {
        .                     self.relate(a, b)?;
        .                 } else {
       12 (0.0%)              let span = self.fields.trace.cause.span;
        6 (0.0%)              let infcx = self.fields.infcx;
        .         
       15 (0.0%)              match self.ambient_variance {
        .                         // Checks whether `for<..> sub <: for<..> sup` holds.
        .                         //
        .                         // For this to hold, **all** instantiations of the super type
        .                         // have to be a super type of **at least one** instantiation of
        .                         // the subtype.
        .                         //
        .                         // This is implemented by first entering a new universe.
        .                         // We then replace all bound variables in `sup` with placeholders,
-- line 249 ----------------------------------------
-- line 256 ----------------------------------------
        .                         // [rd]: https://rustc-dev-guide.rust-lang.org/borrow_check/region_inference/placeholders_and_universes.html
        .                         ty::Covariant => {
        .                             infcx.enter_forall(b, |b| {
        .                                 let a = infcx.instantiate_binder_with_fresh_vars(span, HigherRankedType, a);
        .                                 self.relate(a, b)
        .                             })?;
        .                         }
        .                         ty::Contravariant => {
       15 (0.0%)                      infcx.enter_forall(a, |a| {
       24 (0.0%)                          let b = infcx.instantiate_binder_with_fresh_vars(span, HigherRankedType, b);
        .                                 self.relate(a, b)
        .                             })?;
        .                         }
        .         
        .                         // When **equating** binders, we check that there is a 1-to-1
        .                         // correspondence between the bound vars in both types.
        .                         //
        .                         // We do so by separately instantiating one of the binders with
-- line 273 ----------------------------------------
-- line 290 ----------------------------------------
        .                             })?;
        .                         }
        .                         ty::Bivariant => {
        .                             unreachable!("Expected bivariance to be handled in relate_with_variance")
        .                         }
        .                     }
        .                 }
        .         
    3,876 (0.0%)          Ok(a)
       24 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ObligationEmittingRelation<'tcx> for TypeRelating<'_, '_, 'tcx> {
        .             fn span(&self) -> Span {
        .                 self.fields.trace.span()
        .             }
        .         
        .             fn param_env(&self) -> ty::ParamEnv<'tcx> {
-- line 307 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/snapshot/undo_log.rs
--------------------------------------------------------------------------------
Ir______________ 

1,145,109 (0.0%)  <unknown (line 0)>

-- line 31 ----------------------------------------
        .             PushRegionObligation,
        .         }
        .         
        .         macro_rules! impl_from {
        .             ($($ctor:ident ($ty:ty),)*) => {
        .                 $(
        .                 impl<'tcx> From<$ty> for UndoLog<'tcx> {
        .                     fn from(x: $ty) -> Self {
  573,674 (0.0%)                  UndoLog::$ctor(x.into())
        .                     }
        .                 }
        .                 )*
        .             }
        .         }
        .         
        .         // Upcast from a single kind of "undoable action" to the general enum
        .         impl_from! {
-- line 47 ----------------------------------------
-- line 55 ----------------------------------------
        .             EffectUnificationTable(sv::UndoLog<ut::Delegate<EffectVidKey<'tcx>>>),
        .         
        .             RegionUnificationTable(sv::UndoLog<ut::Delegate<RegionVidKey<'tcx>>>),
        .             ProjectionCache(traits::UndoLog<'tcx>),
        .         }
        .         
        .         /// The Rollback trait defines how to rollback a particular action.
        .         impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {
1,288,863 (0.0%)      fn reverse(&mut self, undo: UndoLog<'tcx>) {
1,432,070 (0.0%)          match undo {
        .                     UndoLog::OpaqueTypes(key, idx) => self.opaque_type_storage.remove(key, idx),
  283,614 (0.0%)              UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),
       10 (0.0%)              UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),
      984 (0.0%)              UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),
        .                     UndoLog::FloatUnificationTable(undo) => self.float_unification_storage.reverse(undo),
    3,169 (0.0%)              UndoLog::EffectUnificationTable(undo) => self.effect_unification_storage.reverse(undo),
   20,104 (0.0%)              UndoLog::RegionConstraintCollector(undo) => {
  160,832 (0.0%)                  self.region_constraint_storage.as_mut().unwrap().reverse(undo)
        .                     }
        .                     UndoLog::RegionUnificationTable(undo) => {
        .                         self.region_constraint_storage.as_mut().unwrap().unification_table.reverse(undo)
        .                     }
   93,762 (0.0%)              UndoLog::ProjectionCache(undo) => self.projection_cache.reverse(undo),
        .                     UndoLog::PushRegionObligation => {
        .                         self.region_obligations.pop();
        .                     }
        .                 }
  901,480 (0.0%)      }
        .         }
        .         
        .         /// The combined undo log for all the various unification tables. For each change to the storage
        .         /// for any kind of inference variable, we record an UndoLog entry in the vector here.
    4,532 (0.0%)  #[derive(Clone, Default)]
        .         pub(crate) struct InferCtxtUndoLogs<'tcx> {
        .             logs: Vec<UndoLog<'tcx>>,
        .             num_open_snapshots: usize,
        .         }
        .         
        .         /// The UndoLogs trait defines how we undo a particular kind of action (of type T). We can undo any
        .         /// action that is convertible into an UndoLog (per the From impls above).
        .         impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>
        .         where
        .             UndoLog<'tcx>: From<T>,
        .         {
        .             #[inline]
        .             fn num_open_snapshots(&self) -> usize {
   93,236 (0.0%)          self.num_open_snapshots
        .             }
        .         
        .             #[inline]
        .             fn push(&mut self, undo: T) {
   66,170 (0.0%)          if self.in_snapshot() {
        .                     self.logs.push(undo.into())
        .                 }
        .             }
        .         
        .             fn clear(&mut self) {
        .                 self.logs.clear();
  175,857 (0.0%)          self.num_open_snapshots = 0;
        .             }
        .         
        .             fn extend<J>(&mut self, undos: J)
        .             where
        .                 Self: Sized,
        .                 J: IntoIterator<Item = T>,
        .             {
        .                 if self.in_snapshot() {
        .                     self.logs.extend(undos.into_iter().map(UndoLog::from))
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> InferCtxtInner<'tcx> {
2,915,016 (0.0%)      pub fn rollback_to(&mut self, snapshot: Snapshot<'tcx>) {
        .                 debug!("rollback_to({})", snapshot.undo_len);
  364,377 (0.0%)          self.undo_log.assert_open_snapshot(&snapshot);
        .         
1,015,168 (0.0%)          while self.undo_log.logs.len() > snapshot.undo_len {
  143,207 (0.0%)              let undo = self.undo_log.logs.pop().unwrap();
  429,621 (0.0%)              self.reverse(undo);
        .                 }
        .         
        .                 self.type_variable_storage.finalize_rollback();
        .         
1,821,885 (0.0%)          if self.undo_log.num_open_snapshots == 1 {
        .                     // After the root snapshot the undo log should be empty.
        .                     assert!(snapshot.undo_len == 0);
        .                     assert!(self.undo_log.logs.is_empty());
        .                 }
        .         
  728,754 (0.0%)          self.undo_log.num_open_snapshots -= 1;
2,915,016 (0.0%)      }
        .         
  158,742 (0.0%)      pub fn commit(&mut self, snapshot: Snapshot<'tcx>) {
        .                 debug!("commit({})", snapshot.undo_len);
        .         
   52,914 (0.0%)          if self.undo_log.num_open_snapshots == 1 {
        .                     // The root snapshot. It's safe to clear the undo log because
        .                     // there's no snapshot further out that we might need to roll back
        .                     // to.
    9,604 (0.0%)              assert!(snapshot.undo_len == 0);
        .                     self.undo_log.logs.clear();
        .                 }
        .         
   52,914 (0.0%)          self.undo_log.num_open_snapshots -= 1;
  141,104 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> InferCtxtUndoLogs<'tcx> {
        .             pub fn start_snapshot(&mut self) -> Snapshot<'tcx> {
  764,030 (0.0%)          self.num_open_snapshots += 1;
        .                 Snapshot { undo_len: self.logs.len(), _marker: PhantomData }
        .             }
        .         
        .             pub(crate) fn region_constraints_in_snapshot(
        .                 &self,
        .                 s: &Snapshot<'tcx>,
        .             ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {
   54,862 (0.0%)          self.logs[s.undo_len..].iter().filter_map(|log| match log {
        .                     UndoLog::RegionConstraintCollector(log) => Some(log),
        .                     _ => None,
        .                 })
        .             }
        .         
        .             pub(crate) fn opaque_types_in_snapshot(&self, s: &Snapshot<'tcx>) -> bool {
   54,016 (0.0%)          self.logs[s.undo_len..].iter().any(|log| matches!(log, UndoLog::OpaqueTypes(..)))
        .             }
        .         
        .             fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {
        .                 // Failures here may indicate a failure to follow a stack discipline.
  728,754 (0.0%)          assert!(self.logs.len() >= snapshot.undo_len);
  728,754 (0.0%)          assert!(self.num_open_snapshots > 0);
        .             }
        .         }
        .         
        .         impl<'tcx> std::ops::Index<usize> for InferCtxtUndoLogs<'tcx> {
        .             type Output = UndoLog<'tcx>;
        .         
        .             fn index(&self, key: usize) -> &Self::Output {
        .                 &self.logs[key]
-- line 194 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/infer/type_variable.rs
--------------------------------------------------------------------------------
Ir______________ 

   66,749 (0.0%)  <unknown (line 0)>

-- line 14 ----------------------------------------
        .         use std::ops::Range;
        .         
        .         impl<'tcx> Rollback<sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>> for TypeVariableStorage<'tcx> {
        .             fn reverse(&mut self, undo: sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>) {
        .                 self.eq_relations.reverse(undo)
        .             }
        .         }
        .         
   15,862 (0.0%)  #[derive(Clone)]
        .         pub struct TypeVariableStorage<'tcx> {
        .             /// The origins of each type variable.
        .             values: IndexVec<TyVid, TypeVariableData>,
        .             /// Two variables are unified in `eq_relations` when we have a
        .             /// constraint `?X == ?Y`. This table also stores, for each key,
        .             /// the known value.
        .             eq_relations: ut::UnificationTableStorage<TyVidEqKey<'tcx>>,
        .         }
-- line 30 ----------------------------------------
-- line 63 ----------------------------------------
        .             LatticeVariable,
        .         }
        .         
        .         #[derive(Clone)]
        .         pub(crate) struct TypeVariableData {
        .             origin: TypeVariableOrigin,
        .         }
        .         
   34,230 (0.0%)  #[derive(Copy, Clone, Debug)]
        .         pub enum TypeVariableValue<'tcx> {
        .             Known { value: Ty<'tcx> },
        .             Unknown { universe: ty::UniverseIndex },
        .         }
        .         
        .         impl<'tcx> TypeVariableValue<'tcx> {
        .             /// If this value is known, returns the type it is known to be.
        .             /// Otherwise, `None`.
        .             pub fn known(&self) -> Option<Ty<'tcx>> {
  503,032 (0.0%)          match *self {
        .                     TypeVariableValue::Unknown { .. } => None,
        .                     TypeVariableValue::Known { value } => Some(value),
        .                 }
        .             }
        .         
        .             pub fn is_unknown(&self) -> bool {
        .                 match *self {
        .                     TypeVariableValue::Unknown { .. } => true,
-- line 89 ----------------------------------------
-- line 100 ----------------------------------------
        .                 }
        .             }
        .         
        .             #[inline]
        .             pub(crate) fn with_log<'a>(
        .                 &'a mut self,
        .                 undo_log: &'a mut InferCtxtUndoLogs<'tcx>,
        .             ) -> TypeVariableTable<'a, 'tcx> {
2,331,618 (0.0%)          TypeVariableTable { storage: self, undo_log }
        .             }
        .         
        .             #[inline]
        .             pub(crate) fn eq_relations_ref(&self) -> &ut::UnificationTableStorage<TyVidEqKey<'tcx>> {
        .                 &self.eq_relations
        .             }
        .         
        .             pub(super) fn finalize_rollback(&mut self) {
-- line 116 ----------------------------------------
-- line 126 ----------------------------------------
        .             /// `vid` has been unified with something else or not.
        .             pub fn var_origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {
        .                 self.storage.values[vid].origin
        .             }
        .         
        .             /// Records that `a == b`, depending on `dir`.
        .             ///
        .             /// Precondition: neither `a` nor `b` are known.
   41,208 (0.0%)      pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {
        .                 debug_assert!(self.probe(a).is_unknown());
        .                 debug_assert!(self.probe(b).is_unknown());
        .                 self.eq_relations().union(a, b);
   36,057 (0.0%)      }
        .         
        .             /// Instantiates `vid` with the type `ty`.
        .             ///
        .             /// Precondition: `vid` must not have been previously instantiated.
  583,362 (0.0%)      pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {
        .                 let vid = self.root_var(vid);
        .                 debug_assert!(!ty.is_ty_var(), "instantiating ty var with var: {vid:?} {ty:?}");
        .                 debug_assert!(self.probe(vid).is_unknown());
        .                 debug_assert!(
        .                     self.eq_relations().probe_value(vid).is_unknown(),
        .                     "instantiating type variable `{vid:?}` twice: new-value = {ty:?}, old-value={:?}",
        .                     self.eq_relations().probe_value(vid)
        .                 );
        .                 self.eq_relations().union_value(vid, TypeVariableValue::Known { value: ty });
  518,544 (0.0%)      }
        .         
        .             /// Creates a new type variable.
        .             ///
        .             /// - `diverging`: indicates if this is a "diverging" type
        .             ///   variable, e.g.,  one created as the type of a `return`
        .             ///   expression. The code in this module doesn't care if a
        .             ///   variable is diverging, but the main Rust type-checker will
        .             ///   sometimes "unify" such variables with the `!` or `()` types.
        .             /// - `origin`: indicates *why* the type variable was created.
        .             ///   The code in this module doesn't care, but it can be useful
        .             ///   for improving error messages.
  836,152 (0.0%)      pub fn new_var(
        .                 &mut self,
        .                 universe: ty::UniverseIndex,
        .                 origin: TypeVariableOrigin,
        .             ) -> ty::TyVid {
  209,038 (0.0%)          let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });
        .                 let index = self.storage.values.push(TypeVariableData { origin });
        .                 debug_assert_eq!(eq_key.vid, index);
        .         
        .                 debug!("new_var(index={:?}, universe={:?}, origin={:?})", eq_key.vid, universe, origin);
        .         
        .                 index
  940,671 (0.0%)      }
        .         
        .             /// Returns the number of type variables created thus far.
        .             pub fn num_vars(&self) -> usize {
    1,722 (0.0%)          self.storage.values.len()
        .             }
        .         
        .             /// Returns the "root" variable of `vid` in the `eq_relations`
        .             /// equivalence table. All type variables that have been equated
        .             /// will yield the same root variable (per the union-find
        .             /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==
        .             /// b` (transitively).
        .             pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {
        .                 self.eq_relations().find(vid).vid
        .             }
        .         
        .             /// Retrieves the type to which `vid` has been instantiated, if
        .             /// any.
  136,920 (0.0%)      pub fn probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {
        .                 self.inlined_probe(vid)
  136,920 (0.0%)      }
        .         
        .             /// An always-inlined variant of `probe`, for very hot call sites.
        .             #[inline(always)]
        .             pub fn inlined_probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {
        .                 self.eq_relations().inlined_probe_value(vid)
        .             }
        .         
        .             /// If `t` is a type-inference variable, and it has been
        .             /// instantiated, then return the with which it was
        .             /// instantiated. Otherwise, returns `t`.
3,914,792 (0.0%)      pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {
1,273,292 (0.0%)          match *t.kind() {
  231,168 (0.0%)              ty::Infer(ty::TyVar(v)) => match self.probe(v) {
        .                         TypeVariableValue::Unknown { .. } => t,
        .                         TypeVariableValue::Known { value } => value,
        .                     },
        .                     _ => t,
        .                 }
4,474,048 (0.1%)      }
        .         
        .             #[inline]
        .             fn eq_relations(&mut self) -> super::UnificationTable<'_, 'tcx, TyVidEqKey<'tcx>> {
  436,253 (0.0%)          self.storage.eq_relations.with_log(self.undo_log)
        .             }
        .         
        .             /// Returns a range of the type variables created during the snapshot.
   11,673 (0.0%)      pub fn vars_since_snapshot(
        .                 &mut self,
        .                 value_count: usize,
        .             ) -> (Range<TyVid>, Vec<TypeVariableOrigin>) {
        .                 let range = TyVid::from_usize(value_count)..TyVid::from_usize(self.num_vars());
    6,485 (0.0%)          (
        .                     range.start..range.end,
        .                     (range.start..range.end).map(|index| self.var_origin(index)).collect(),
        .                 )
   11,673 (0.0%)      }
        .         
        .             /// Returns indices of all variables that are not yet
        .             /// instantiated.
    3,825 (0.0%)      pub fn unresolved_variables(&mut self) -> Vec<ty::TyVid> {
        .                 (0..self.num_vars())
        .                     .filter_map(|i| {
        .                         let vid = ty::TyVid::from_usize(i);
    3,454 (0.0%)                  match self.probe(vid) {
        .                             TypeVariableValue::Unknown { .. } => Some(vid),
        .                             TypeVariableValue::Known { .. } => None,
        .                         }
        .                     })
        .                     .collect()
    3,825 (0.0%)      }
        .         }
        .         
        .         ///////////////////////////////////////////////////////////////////////////
        .         
        .         /// These structs (a newtyped TyVid) are used as the unification key
        .         /// for the `eq_relations`; they carry a `TypeVariableValue` along
        .         /// with them.
        .         #[derive(Copy, Clone, Debug, PartialEq, Eq)]
-- line 255 ----------------------------------------
-- line 281 ----------------------------------------
        .                 "TyVidEqKey"
        .             }
        .         }
        .         
        .         impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {
        .             type Error = ut::NoError;
        .         
        .             fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {
  155,346 (0.0%)          match (value1, value2) {
        .                     // We never equate two type variables, both of which
        .                     // have known types. Instead, we recursively equate
        .                     // those types.
        .                     (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {
        .                         bug!("equating two type variables, both of which have known types")
        .                     }
        .         
        .                     // If one side is known, prefer that one.
        .                     (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),
        .                     (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),
        .         
        .                     // If both sides are *unknown*, it hardly matters, does it?
        .                     (
    5,142 (0.0%)                  &TypeVariableValue::Unknown { universe: universe1 },
    5,142 (0.0%)                  &TypeVariableValue::Unknown { universe: universe2 },
        .                     ) => {
        .                         // If we unify two unbound variables, ?T and ?U, then whatever
        .                         // value they wind up taking (which must be the same value) must
        .                         // be nameable by both universes. Therefore, the resulting
        .                         // universe is the minimum of the two universes, because that is
        .                         // the one which contains the fewest names in scope.
        .                         let universe = cmp::min(universe1, universe2);
        .                         Ok(TypeVariableValue::Unknown { universe })
-- line 312 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_infer/src/traits/util.rs
--------------------------------------------------------------------------------
Ir______________ 

2,550,386 (0.0%)  <unknown (line 0)>

-- line 6 ----------------------------------------
        .         use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};
        .         use rustc_span::symbol::Ident;
        .         use rustc_span::Span;
        .         
        .         pub fn anonymize_predicate<'tcx>(
        .             tcx: TyCtxt<'tcx>,
        .             pred: ty::Predicate<'tcx>,
        .         ) -> ty::Predicate<'tcx> {
3,099,636 (0.0%)      let new = tcx.anonymize_bound_vars(pred.kind());
3,874,545 (0.0%)      tcx.reuse_or_mk_predicate(pred, new)
        .         }
        .         
        .         pub struct PredicateSet<'tcx> {
        .             tcx: TyCtxt<'tcx>,
        .             set: FxHashSet<ty::Predicate<'tcx>>,
        .         }
        .         
        .         impl<'tcx> PredicateSet<'tcx> {
  314,244 (0.0%)      pub fn new(tcx: TyCtxt<'tcx>) -> Self {
  523,740 (0.0%)          Self { tcx, set: Default::default() }
  209,496 (0.0%)      }
        .         
        .             /// Adds a predicate to the set.
        .             ///
        .             /// Returns whether the predicate was newly inserted. That is:
        .             /// - If the set did not previously contain this predicate, `true` is returned.
        .             /// - If the set already contained this predicate, `false` is returned,
        .             ///   and the set is not modified: original predicate is not replaced,
        .             ///   and the predicate passed as argument is dropped.
6,974,181 (0.1%)      pub fn insert(&mut self, pred: ty::Predicate<'tcx>) -> bool {
        .                 // We have to be careful here because we want
        .                 //
        .                 //    for<'a> Foo<&'a i32>
        .                 //
        .                 // and
        .                 //
        .                 //    for<'b> Foo<&'b i32>
        .                 //
        .                 // to be considered equivalent. So normalize all late-bound
        .                 // regions before we throw things into the underlying set.
1,549,818 (0.0%)          self.set.insert(anonymize_predicate(self.tcx, pred))
5,424,363 (0.1%)      }
        .         }
        .         
        .         impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {
        .             fn extend<I: IntoIterator<Item = ty::Predicate<'tcx>>>(&mut self, iter: I) {
        .                 for pred in iter {
        .                     self.insert(pred);
        .                 }
        .             }
-- line 55 ----------------------------------------
-- line 107 ----------------------------------------
        .             ) -> Self;
        .         }
        .         
        .         impl<'tcx> Elaboratable<'tcx> for PredicateObligation<'tcx> {
        .             fn predicate(&self) -> ty::Predicate<'tcx> {
        .                 self.predicate
        .             }
        .         
       10 (0.0%)      fn child(&self, clause: ty::Clause<'tcx>) -> Self {
       30 (0.0%)          Obligation {
        .                     cause: self.cause.clone(),
        5 (0.0%)              param_env: self.param_env,
        .                     recursion_depth: 0,
        .                     predicate: clause.as_predicate(),
        .                 }
       15 (0.0%)      }
        .         
    1,903 (0.0%)      fn child_with_derived_cause(
        .                 &self,
        .                 clause: ty::Clause<'tcx>,
        .                 span: Span,
        .                 parent_trait_pred: ty::PolyTraitPredicate<'tcx>,
        .                 index: usize,
        .             ) -> Self {
        .                 let cause = self.cause.clone().derived_cause(parent_trait_pred, |derived| {
    1,557 (0.0%)              traits::ImplDerivedObligation(Box::new(traits::ImplDerivedObligationCause {
        .                         derived,
      173 (0.0%)                  impl_or_alias_def_id: parent_trait_pred.def_id(),
        .                         impl_def_predicate_index: Some(index),
        .                         span,
        .                     }))
        .                 });
    1,384 (0.0%)          Obligation {
        .                     cause,
      173 (0.0%)              param_env: self.param_env,
        .                     recursion_depth: 0,
        .                     predicate: clause.as_predicate(),
        .                 }
    1,557 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Elaboratable<'tcx> for ty::Predicate<'tcx> {
        .             fn predicate(&self) -> ty::Predicate<'tcx> {
        .                 *self
        .             }
        .         
        .             fn child(&self, clause: ty::Clause<'tcx>) -> Self {
-- line 153 ----------------------------------------
-- line 220 ----------------------------------------
        .                 _span: Span,
        .                 _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,
        .                 _index: usize,
        .             ) -> Self {
        .                 clause
        .             }
        .         }
        .         
      780 (0.0%)  pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(
        .             tcx: TyCtxt<'tcx>,
        .             obligations: impl IntoIterator<Item = O>,
        .         ) -> Elaborator<'tcx, O> {
        .             let mut elaborator =
  893,667 (0.0%)          Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx), mode: Filter::All };
      234 (0.0%)      elaborator.extend_deduped(obligations);
1,250,551 (0.0%)      elaborator
      624 (0.0%)  }
        .         
        .         impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {
        .             fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = O>) {
        .                 // Only keep those bounds that we haven't already seen.
        .                 // This is necessary to prevent infinite recursion in some
        .                 // cases. One common case is when people define
        .                 // `trait Sized: Sized { }` rather than `trait Sized { }`.
        .                 // let visited = &mut self.visited;
2,234,913 (0.0%)          self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));
        .             }
        .         
        .             /// Filter to only the supertraits of trait predicates, i.e. only the predicates
        .             /// that have `Self` as their self type, instead of all implied predicates.
        .             pub fn filter_only_self(mut self) -> Self {
        .                 self.mode = Filter::OnlySelf;
      186 (0.0%)          self
        .             }
        .         
        .             /// Filter to only the supertraits of trait predicates that define the assoc_ty.
        .             pub fn filter_only_self_that_defines(mut self, assoc_ty: Ident) -> Self {
    2,170 (0.0%)          self.mode = Filter::OnlySelfThatDefines(assoc_ty);
        .                 self
        .             }
        .         
        .             fn elaborate(&mut self, elaboratable: &O) {
  807,676 (0.0%)          let tcx = self.visited.tcx;
        .         
        .                 // We only elaborate clauses.
1,212,254 (0.0%)          let Some(clause) = elaboratable.predicate().as_clause() else {
        .                     return;
        .                 };
        .         
1,211,514 (0.0%)          let bound_clause = clause.kind();
3,633,771 (0.0%)          match bound_clause.skip_binder() {
        .                     ty::ClauseKind::Trait(data) => {
        .                         // Negative trait bounds do not imply any supertrait bounds
  365,577 (0.0%)                  if data.polarity != ty::PredicatePolarity::Positive {
        .                             return;
        .                         }
        .                         // Get predicates implied by the trait, or only super predicates if we only care about self predicates.
2,925,388 (0.0%)                  let predicates = match self.mode {
1,451,333 (0.0%)                      Filter::All => tcx.implied_predicates_of(data.def_id()),
    7,112 (0.0%)                      Filter::OnlySelf => tcx.super_predicates_of(data.def_id()),
    1,736 (0.0%)                      Filter::OnlySelfThatDefines(ident) => {
    1,302 (0.0%)                          tcx.super_predicates_that_define_assoc_item((data.def_id(), ident))
        .                             }
        .                         };
        .         
        .                         let obligations =
        .                             predicates.predicates.iter().enumerate().map(|(index, &(clause, span))| {
    1,211 (0.0%)                          elaboratable.child_with_derived_cause(
  148,312 (0.0%)                              clause
   36,947 (0.0%)                                  .instantiate_supertrait(tcx, &bound_clause.rebind(data.trait_ref)),
        .                                     span,
      699 (0.0%)                              bound_clause.rebind(data),
        .                                     index,
        .                                 )
        .                             });
        .                         debug!(?data, ?obligations, "super_predicates");
        .                         self.extend_deduped(obligations);
        .                     }
   36,314 (0.0%)              ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {
        .                         // We know that `T: 'a` for some type `T`. We can
        .                         // often elaborate this. For example, if we know that
        .                         // `[U]: 'a`, that implies that `U: 'a`. Similarly, if
        .                         // we know `&'a U: 'b`, then we know that `'a: 'b` and
        .                         // `U: 'b`.
        .                         //
        .                         // We can basically ignore bound regions here. So for
        .                         // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to
        .                         // `'a: 'b`.
        .         
        .                         // Ignore `for<'a> T: 'a` -- we might in the future
        .                         // consider this as evidence that `T: 'static`, but
        .                         // I'm a bit wary of such constructions and so for now
        .                         // I want to be conservative. --nmatsakis
   72,628 (0.0%)                  if r_min.is_bound() {
        .                             return;
        .                         }
        .         
   36,314 (0.0%)                  let mut components = smallvec![];
  145,254 (0.0%)                  push_outlives_components(tcx, ty_max, &mut components);
        .                         self.extend_deduped(
  653,656 (0.0%)                      components
        .                                 .into_iter()
  242,675 (0.0%)                          .filter_map(|component| match component {
        .                                     Component::Region(r) => {
       26 (0.0%)                                  if r.is_bound() {
        .                                             None
        .                                         } else {
        .                                             Some(ty::ClauseKind::RegionOutlives(ty::OutlivesPredicate(
        .                                                 r, r_min,
        .                                             )))
        .                                         }
        .                                     }
        .         
        .                                     Component::Param(p) => {
   48,139 (0.0%)                                  let ty = Ty::new_param(tcx, p.index, p.name);
        .                                         Some(ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(ty, r_min)))
        .                                     }
        .         
        .                                     Component::Placeholder(p) => {
        .                                         let ty = Ty::new_placeholder(tcx, p);
        .                                         Some(ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(ty, r_min)))
        .                                     }
        .         
        .                                     Component::UnresolvedInferenceVariable(_) => None,
        .         
        .                                     Component::Alias(alias_ty) => {
        .                                         // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.
        .                                         // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.
        .                                         Some(ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(
    1,296 (0.0%)                                      alias_ty.to_ty(tcx),
        .                                             r_min,
        .                                         )))
        .                                     }
        .         
        .                                     Component::EscapingAlias(_) => {
        .                                         // We might be able to do more here, but we don't
        .                                         // want to deal with escaping vars right now.
        .                                         None
        .                                     }
        .                                 })
        .                                 .map(|clause| {
   48,511 (0.0%)                              elaboratable.child(bound_clause.rebind(clause).to_predicate(tcx))
        .                                 }),
        .                         );
        .                     }
        .                     ty::ClauseKind::RegionOutlives(..) => {
        .                         // Nothing to elaborate from `'a: 'b`.
        .                     }
        .                     ty::ClauseKind::WellFormed(..) => {
        .                         // Currently, we do not elaborate WF predicates,
-- line 369 ----------------------------------------
-- line 385 ----------------------------------------
        .         
        .         impl<'tcx, O: Elaboratable<'tcx>> Iterator for Elaborator<'tcx, O> {
        .             type Item = O;
        .         
        .             fn size_hint(&self) -> (usize, Option<usize>) {
        .                 (self.stack.len(), None)
        .             }
        .         
4,063,738 (0.1%)      fn next(&mut self) -> Option<Self::Item> {
        .                 // Extract next item from top-most stack frame, if any.
  417,995 (0.0%)          if let Some(obligation) = self.stack.pop() {
        .                     self.elaborate(&obligation);
  812,522 (0.0%)              Some(obligation)
        .                 } else {
    2,422 (0.0%)              None
        .                 }
4,058,768 (0.1%)      }
        .         }
        .         
        .         ///////////////////////////////////////////////////////////////////////////
        .         // Supertrait iterator
        .         ///////////////////////////////////////////////////////////////////////////
        .         
    5,816 (0.0%)  pub fn supertraits<'tcx>(
        .             tcx: TyCtxt<'tcx>,
        .             trait_ref: ty::PolyTraitRef<'tcx>,
        .         ) -> FilterToTraits<Elaborator<'tcx, ty::Predicate<'tcx>>> {
      727 (0.0%)      elaborate(tcx, [trait_ref.to_predicate(tcx)]).filter_only_self().filter_to_traits()
    5,089 (0.0%)  }
        .         
        .         pub fn transitive_bounds<'tcx>(
        .             tcx: TyCtxt<'tcx>,
        .             trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,
        .         ) -> FilterToTraits<Elaborator<'tcx, ty::Predicate<'tcx>>> {
        .             elaborate(tcx, trait_refs.map(|trait_ref| trait_ref.to_predicate(tcx)))
        .                 .filter_only_self()
        .                 .filter_to_traits()
-- line 421 ----------------------------------------
-- line 437 ----------------------------------------
        .         }
        .         
        .         ///////////////////////////////////////////////////////////////////////////
        .         // Other
        .         ///////////////////////////////////////////////////////////////////////////
        .         
        .         impl<'tcx> Elaborator<'tcx, ty::Predicate<'tcx>> {
        .             fn filter_to_traits(self) -> FilterToTraits<Self> {
   10,883 (0.0%)          FilterToTraits { base_iterator: self }
        .             }
        .         }
        .         
        .         /// A filter around an iterator of predicates that makes it yield up
        .         /// just trait references.
        .         pub struct FilterToTraits<I> {
        .             base_iterator: I,
        .         }
        .         
        .         impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {
        .             type Item = ty::PolyTraitRef<'tcx>;
        .         
        .             fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {
   11,032 (0.0%)          while let Some(pred) = self.base_iterator.next() {
        .                     if let Some(data) = pred.to_opt_poly_trait_pred() {
    3,295 (0.0%)                  return Some(data.map_bound(|t| t.trait_ref));
        .                     }
        .                 }
        .                 None
        .             }
        .         
        .             fn size_hint(&self) -> (usize, Option<usize>) {
        .                 let (_, upper) = self.base_iterator.size_hint();
        .                 (0, upper)
-- line 469 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_lexer/src/lib.rs
--------------------------------------------------------------------------------
Ir______________ 

5,954,989 (0.1%)  <unknown (line 0)>

-- line 42 ----------------------------------------
        .         #[derive(Debug)]
        .         pub struct Token {
        .             pub kind: TokenKind,
        .             pub len: u32,
        .         }
        .         
        .         impl Token {
        .             fn new(kind: TokenKind, len: u32) -> Token {
    7,818 (0.0%)          Token { kind, len }
        .             }
        .         }
        .         
        .         /// Enum representing common lexeme types.
2,242,609 (0.0%)  #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        .         pub enum TokenKind {
        .             // Multi-char tokens:
        .             /// "// comment"
        .             LineComment { doc_style: Option<DocStyle> },
        .         
        .             /// `/* block comment */`
        .             ///
        .             /// Block comments can be recursive, so a sequence like `/* /* */`
-- line 63 ----------------------------------------
-- line 221 ----------------------------------------
        .             /// Literal doesn't contain a prefix.
        .             Decimal = 10,
        .             /// Literal starts with "0x".
        .             Hexadecimal = 16,
        .         }
        .         
        .         /// `rustc` allows files to have a shebang, e.g. "#!/usr/bin/rustrun",
        .         /// but shebang isn't a part of rust syntax.
   11,296 (0.0%)  pub fn strip_shebang(input: &str) -> Option<usize> {
        .             // Shebang must start with `#!` literally, without any preceding whitespace.
        .             // For simplicity we consider any line starting with `#!` a shebang,
        .             // regardless of restrictions put on shebangs by specific platforms.
        .             if let Some(input_tail) = input.strip_prefix("#!") {
        .                 // Ok, this is a shebang but if the next non-whitespace token is `[`,
        .                 // then it may be valid Rust code, so consider it Rust code.
        .                 let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok| {
      828 (0.0%)              !matches!(
        .                         tok,
        .                         TokenKind::Whitespace
        .                             | TokenKind::LineComment { doc_style: None }
        .                             | TokenKind::BlockComment { doc_style: None, .. }
        .                     )
        .                 });
      276 (0.0%)          if next_non_whitespace_token != Some(TokenKind::OpenBracket) {
        .                     // No other choice than to consider this a shebang.
        .                     return Some(2 + input_tail.lines().next().unwrap_or_default().len());
        .                 }
        .             }
        .             None
   12,708 (0.0%)  }
        .         
        .         /// Validates a raw string literal. Used for getting more information about a
        .         /// problem with a `RawStr`/`RawByteStr` with a `None` field.
        .         #[inline]
        .         pub fn validate_raw_str(input: &str, prefix_len: u32) -> Result<(), RawStrError> {
        .             debug_assert!(!input.is_empty());
        .             let mut cursor = Cursor::new(input);
        .             // Move past the leading `r` or `br`.
-- line 258 ----------------------------------------
-- line 261 ----------------------------------------
        .             }
        .             cursor.raw_double_quoted_string(prefix_len).map(|_| ())
        .         }
        .         
        .         /// Creates an iterator that produces tokens from the input string.
        .         pub fn tokenize(input: &str) -> impl Iterator<Item = Token> + '_ {
        .             let mut cursor = Cursor::new(input);
        .             std::iter::from_fn(move || {
      276 (0.0%)          let token = cursor.advance_token();
      552 (0.0%)          if token.kind != TokenKind::Eof { Some(token) } else { None }
        .             })
        .         }
        .         
        .         /// True if `c` is considered a whitespace according to Rust language definition.
        .         /// See [Rust language reference](https://doc.rust-lang.org/reference/whitespace.html)
        .         /// for definitions of these classes.
        .         pub fn is_whitespace(c: char) -> bool {
        .             // This is Pattern_White_Space.
        .             //
        .             // Note that this set is stable (ie, it doesn't change with different
        .             // Unicode versions), so it's ok to just hard-code the values.
        .         
1,208,545 (0.0%)      matches!(
        .                 c,
        .                 // Usual ASCII suspects
        .                 '\u{0009}'   // \t
        .                 | '\u{000A}' // \n
        .                 | '\u{000B}' // vertical tab
        .                 | '\u{000C}' // form feed
        .                 | '\u{000D}' // \r
        .                 | '\u{0020}' // space
-- line 291 ----------------------------------------
-- line 301 ----------------------------------------
        .                 | '\u{2028}' // LINE SEPARATOR
        .                 | '\u{2029}' // PARAGRAPH SEPARATOR
        .             )
        .         }
        .         
        .         /// True if `c` is valid as a first character of an identifier.
        .         /// See [Rust language reference](https://doc.rust-lang.org/reference/identifiers.html) for
        .         /// a formal definition of valid identifier name.
    1,644 (0.0%)  pub fn is_id_start(c: char) -> bool {
        .             // This is XID_Start OR '_' (which formally is not a XID_Start).
   30,030 (0.0%)      c == '_' || unicode_xid::UnicodeXID::is_xid_start(c)
    1,096 (0.0%)  }
        .         
        .         /// True if `c` is valid as a non-first character of an identifier.
        .         /// See [Rust language reference](https://doc.rust-lang.org/reference/identifiers.html) for
        .         /// a formal definition of valid identifier name.
       14 (0.0%)  pub fn is_id_continue(c: char) -> bool {
        .             unicode_xid::UnicodeXID::is_xid_continue(c)
       14 (0.0%)  }
        .         
        .         /// The passed string is lexically an identifier.
       36 (0.0%)  pub fn is_ident(string: &str) -> bool {
        .             let mut chars = string.chars();
        .             if let Some(start) = chars.next() {
        .                 is_id_start(start) && chars.all(is_id_continue)
        .             } else {
        .                 false
        .             }
       42 (0.0%)  }
        .         
        .         impl Cursor<'_> {
        .             /// Parses a token from the input string.
4,307,202 (0.1%)      pub fn advance_token(&mut self) -> Token {
3,688,151 (0.0%)          let first_char = match self.bump() {
        .                     Some(c) => c,
        .                     None => return Token::new(TokenKind::Eof, 0),
        .                 };
1,315,272 (0.0%)          let token_kind = match first_char {
        .                     // Slash, comment or block comment.
   28,228 (0.0%)              '/' => match self.first() {
   70,270 (0.0%)                  '/' => self.line_comment(),
      384 (0.0%)                  '*' => self.block_comment(),
        .                         _ => Slash,
        .                     },
        .         
        .                     // Whitespace sequence.
        .                     c if is_whitespace(c) => self.whitespace(),
        .         
        .                     // Raw identifier, raw string literal or identifier.
   15,132 (0.0%)              'r' => match (self.first(), self.second()) {
        .                         ('#', c1) if is_id_start(c1) => self.raw_ident(),
        .                         ('#', _) | ('"', _) => {
        6 (0.0%)                      let res = self.raw_double_quoted_string(1);
        .                             let suffix_start = self.pos_within_token();
        .                             if res.is_ok() {
        .                                 self.eat_literal_suffix();
        .                             }
        .                             let kind = RawStr { n_hashes: res.ok() };
        .                             Literal { kind, suffix_start }
        .                         }
        .                         _ => self.ident_or_unknown_prefix(),
-- line 361 ----------------------------------------
-- line 375 ----------------------------------------
        .                         None,
        .                     ),
        .         
        .                     // Identifier (this should be checked after other variant that can
        .                     // start as identifier).
        .                     c if is_id_start(c) => self.ident_or_unknown_prefix(),
        .         
        .                     // Numeric literal.
  676,689 (0.0%)              c @ '0'..='9' => {
   63,510 (0.0%)                  let literal_kind = self.number(c);
        .                         let suffix_start = self.pos_within_token();
        .                         self.eat_literal_suffix();
        .                         TokenKind::Literal { kind: literal_kind, suffix_start }
        .                     }
        .         
        .                     // One-symbol tokens.
        .                     ';' => Semi,
        .                     ',' => Comma,
-- line 392 ----------------------------------------
-- line 411 ----------------------------------------
        .                     '&' => And,
        .                     '|' => Or,
        .                     '+' => Plus,
        .                     '*' => Star,
        .                     '^' => Caret,
        .                     '%' => Percent,
        .         
        .                     // Lifetime or character literal.
   11,736 (0.0%)              '\'' => self.lifetime_or_char(),
        .         
        .                     // String literal.
        .                     '"' => {
   28,650 (0.0%)                  let terminated = self.double_quoted_string();
        .                         let suffix_start = self.pos_within_token();
   11,460 (0.0%)                  if terminated {
        .                             self.eat_literal_suffix();
        .                         }
        .                         let kind = Str { terminated };
        .                         Literal { kind, suffix_start }
        .                     }
        .                     // Identifier starting with an emoji. Only lexed for graceful error recovery.
        .                     c if !c.is_ascii() && c.is_emoji_char() => self.fake_ident_or_unknown_prefix(),
        .                     _ => Unknown,
        .                 };
        .                 let res = Token::new(token_kind, self.pos_within_token());
        .                 self.reset_pos_within_token();
2,379,860 (0.0%)          res
3,828,624 (0.0%)      }
        .         
        .             fn line_comment(&mut self) -> TokenKind {
        .                 debug_assert!(self.prev() == '/' && self.first() == '/');
        .                 self.bump();
        .         
   21,084 (0.0%)          let doc_style = match self.first() {
        .                     // `//!` is an inner line doc comment.
        .                     '!' => Some(DocStyle::Inner),
        .                     // `////` (more than 3 slashes) is not considered a doc comment.
   17,560 (0.0%)              '/' if self.second() != '/' => Some(DocStyle::Outer),
        .                     _ => None,
        .                 };
        .         
       19 (0.0%)          self.eat_while(|c| c != '\n');
        .                 LineComment { doc_style }
    7,027 (0.0%)      }
        .         
        .             fn block_comment(&mut self) -> TokenKind {
        .                 debug_assert!(self.prev() == '/' && self.first() == '*');
        .                 self.bump();
        .         
      128 (0.0%)          let doc_style = match self.first() {
        .                     // `/*!` is an inner block doc comment.
        .                     '!' => Some(DocStyle::Inner),
        .                     // `/***` (more than 2 stars) is not considered a doc comment.
        .                     // `/**/` is not considered a doc comment.
        .                     '*' if !matches!(self.second(), '*' | '/') => Some(DocStyle::Outer),
        .                     _ => None,
        .                 };
        .         
        .                 let mut depth = 1usize;
  173,250 (0.0%)          while let Some(c) = self.bump() {
        .                     match c {
      144 (0.0%)                  '/' if self.first() == '*' => {
        .                             self.bump();
        .                             depth += 1;
        .                         }
      116 (0.0%)                  '*' if self.first() == '/' => {
        .                             self.bump();
        .                             depth -= 1;
       64 (0.0%)                      if depth == 0 {
        .                                 // This block comment is closed, so for a construction like "/* */ */"
        .                                 // there will be a successfully parsed block comment "/* */"
        .                                 // and " */" will be processed separately.
        .                                 break;
        .                             }
        .                         }
        .                         _ => (),
        .                     }
        .                 }
        .         
        .                 BlockComment { doc_style, terminated: depth == 0 }
       96 (0.0%)      }
        .         
        .             fn whitespace(&mut self) -> TokenKind {
        .                 debug_assert!(is_whitespace(self.prev()));
        .                 self.eat_while(is_whitespace);
        .                 Whitespace
        .             }
        .         
        .             fn raw_ident(&mut self) -> TokenKind {
-- line 499 ----------------------------------------
-- line 500 ----------------------------------------
        .                 debug_assert!(self.prev() == 'r' && self.first() == '#' && is_id_start(self.second()));
        .                 // Eat "#" symbol.
        .                 self.bump();
        .                 // Eat the identifier part of RawIdent.
        .                 self.eat_identifier();
        .                 RawIdent
        .             }
        .         
  611,000 (0.0%)      fn ident_or_unknown_prefix(&mut self) -> TokenKind {
        .                 debug_assert!(is_id_start(self.prev()));
        .                 // Start is already eaten, eat the rest of identifier.
  122,200 (0.0%)          self.eat_while(is_id_continue);
        .                 // Known prefixes must have been handled earlier. So if
        .                 // we see a prefix here, it is definitely an unknown prefix.
  244,398 (0.0%)          match self.first() {
        .                     '#' | '"' | '\'' => UnknownPrefix,
  122,199 (0.0%)              c if !c.is_ascii() && c.is_emoji_char() => self.fake_ident_or_unknown_prefix(),
        .                     _ => Ident,
        .                 }
  488,800 (0.0%)      }
        .         
        .             fn fake_ident_or_unknown_prefix(&mut self) -> TokenKind {
        .                 // Start is already eaten, eat the rest of identifier.
        .                 self.eat_while(|c| {
        .                     unicode_xid::UnicodeXID::is_xid_continue(c)
        .                         || (!c.is_ascii() && c.is_emoji_char())
        .                         || c == '\u{200d}'
        .                 });
-- line 527 ----------------------------------------
-- line 534 ----------------------------------------
        .             }
        .         
        .             fn c_or_byte_string(
        .                 &mut self,
        .                 mk_kind: impl FnOnce(bool) -> LiteralKind,
        .                 mk_kind_raw: impl FnOnce(Option<u8>) -> LiteralKind,
        .                 single_quoted: Option<fn(bool) -> LiteralKind>,
        .             ) -> TokenKind {
   86,288 (0.0%)          match (self.first(), self.second(), single_quoted) {
        .                     ('\'', _, Some(mk_kind)) => {
        .                         self.bump();
      420 (0.0%)                  let terminated = self.single_quoted_string();
        .                         let suffix_start = self.pos_within_token();
      210 (0.0%)                  if terminated {
        .                             self.eat_literal_suffix();
        .                         }
        .                         let kind = mk_kind(terminated);
        .                         Literal { kind, suffix_start }
        .                     }
        .                     ('"', _, _) => {
        .                         self.bump();
    2,208 (0.0%)                  let terminated = self.double_quoted_string();
        .                         let suffix_start = self.pos_within_token();
    1,104 (0.0%)                  if terminated {
        .                             self.eat_literal_suffix();
        .                         }
        .                         let kind = mk_kind(terminated);
        .                         Literal { kind, suffix_start }
        .                     }
        .                     ('r', '"', _) | ('r', '#', _) => {
        .                         self.bump();
        .                         let res = self.raw_double_quoted_string(2);
-- line 565 ----------------------------------------
-- line 569 ----------------------------------------
        .                         }
        .                         let kind = mk_kind_raw(res.ok());
        .                         Literal { kind, suffix_start }
        .                     }
        .                     _ => self.ident_or_unknown_prefix(),
        .                 }
        .             }
        .         
   57,159 (0.0%)      fn number(&mut self, first_digit: char) -> LiteralKind {
        .                 debug_assert!('0' <= self.prev() && self.prev() <= '9');
        .                 let mut base = Base::Decimal;
   12,702 (0.0%)          if first_digit == '0' {
        .                     // Attempt to parse encoding base.
    6,783 (0.0%)              match self.first() {
        .                         'b' => {
        .                             base = Base::Binary;
        .                             self.bump();
       30 (0.0%)                      if !self.eat_decimal_digits() {
        .                                 return Int { base, empty_int: true };
        .                             }
        .                         }
        .                         'o' => {
        .                             base = Base::Octal;
        .                             self.bump();
       60 (0.0%)                      if !self.eat_decimal_digits() {
        .                                 return Int { base, empty_int: true };
        .                             }
        .                         }
        .                         'x' => {
        .                             base = Base::Hexadecimal;
        .                             self.bump();
        .                             if !self.eat_hexadecimal_digits() {
        .                                 return Int { base, empty_int: true };
        .                             }
        .                         }
        .                         // Not a base prefix; consume additional digits.
    2,571 (0.0%)                  '0'..='9' | '_' => {
        .                             self.eat_decimal_digits();
        .                         }
        .         
        .                         // Also not a base prefix; nothing more to do here.
        .                         '.' | 'e' | 'E' => {}
        .         
        .                         // Just a 0.
        .                         _ => return Int { base, empty_int: false },
        .                     }
        .                 } else {
        .                     // No base prefix, parse number in the usual way.
        .                     self.eat_decimal_digits();
        .                 };
        .         
   32,956 (0.0%)          match self.first() {
        .                     // Don't be greedy if this is actually an
        .                     // integer literal followed by field/method access or a range pattern
        .                     // (`0..2` and `12.foo()`)
      772 (0.0%)              '.' if self.second() != '.' && !is_id_start(self.second()) => {
        .                         // might have stuff after the ., and if it does, it needs to start
        .                         // with a number
        .                         self.bump();
        .                         let mut empty_exponent = false;
        .                         if self.first().is_digit(10) {
      316 (0.0%)                      self.eat_decimal_digits();
      474 (0.0%)                      match self.first() {
        .                                 'e' | 'E' => {
        .                                     self.bump();
        .                                     empty_exponent = !self.eat_float_exponent();
        .                                 }
        .                                 _ => (),
        .                             }
        .                         }
        .                         Float { base, empty_exponent }
        .                     }
        .                     'e' | 'E' => {
        .                         self.bump();
       16 (0.0%)                  let empty_exponent = !self.eat_float_exponent();
        .                         Float { base, empty_exponent }
        .                     }
        .                     _ => Int { base, empty_int: false },
        .                 }
   82,575 (0.0%)      }
        .         
   10,269 (0.0%)      fn lifetime_or_char(&mut self) -> TokenKind {
        .                 debug_assert!(self.prev() == '\'');
        .         
    8,802 (0.0%)          let can_be_a_lifetime = if self.second() == '\'' {
        .                     // It's surely not a lifetime.
        .                     false
        .                 } else {
        .                     // If the first symbol is valid for identifier, it can be a lifetime.
        .                     // Also check if it's a number for a better error reporting (so '0 will
        .                     // be reported as invalid lifetime and not as unterminated char literal).
        .                     is_id_start(self.first()) || self.first().is_digit(10)
        .                 };
        .         
        .                 if !can_be_a_lifetime {
    1,176 (0.0%)              let terminated = self.single_quoted_string();
        .                     let suffix_start = self.pos_within_token();
    1,176 (0.0%)              if terminated {
        .                         self.eat_literal_suffix();
        .                     }
        .                     let kind = Char { terminated };
        .                     return Literal { kind, suffix_start };
        .                 }
        .         
        .                 // Either a lifetime or a character literal with
        .                 // length greater than 1.
        .         
        .                 let starts_with_number = self.first().is_digit(10);
        .         
        .                 // Skip the literal contents.
        .                 // First symbol can be a number (which isn't a valid identifier start),
        .                 // so skip it without any checks.
        .                 self.bump();
    1,758 (0.0%)          self.eat_while(is_id_continue);
        .         
        .                 // Check if after skipping literal contents we've met a closing
        .                 // single quote (which means that user attempted to create a
        .                 // string with single quotes).
    1,758 (0.0%)          if self.first() == '\'' {
        .                     self.bump();
        .                     let kind = Char { terminated: true };
        .                     Literal { kind, suffix_start: self.pos_within_token() }
        .                 } else {
        .                     Lifetime { starts_with_number }
        .                 }
   16,137 (0.0%)      }
        .         
    1,386 (0.0%)      fn single_quoted_string(&mut self) -> bool {
        .                 debug_assert!(self.prev() == '\'');
        .                 // Check if it's a one-symbol literal.
    4,775 (0.0%)          if self.second() == '\'' && self.first() != '\\' {
        .                     self.bump();
        .                     self.bump();
        .                     return true;
        .                 }
        .         
        .                 // Literal has more than one symbol.
        .         
        .                 // Parse until either quotes are terminated or error is detected.
        .                 loop {
      523 (0.0%)              match self.first() {
        .                         // Quotes are terminated, finish parsing.
        .                         '\'' => {
        .                             self.bump();
        .                             return true;
        .                         }
        .                         // Probably beginning of the comment, which we don't want to include
        .                         // to the error report.
        .                         '/' => break,
-- line 717 ----------------------------------------
-- line 727 ----------------------------------------
        .                         // Skip the character.
        .                         _ => {
        .                             self.bump();
        .                         }
        .                     }
        .                 }
        .                 // String was not terminated.
        .                 false
    1,386 (0.0%)      }
        .         
        .             /// Eats double-quoted string and returns true
        .             /// if string is terminated.
   12,564 (0.0%)      fn double_quoted_string(&mut self) -> bool {
        .                 debug_assert!(self.prev() == '"');
       66 (0.0%)          while let Some(c) = self.bump() {
  343,524 (0.0%)              match c {
        .                         '"' => {
        .                             return true;
        .                         }
    9,940 (0.0%)                  '\\' if self.first() == '\\' || self.first() == '"' => {
        .                             // Bump again to skip escaped character.
        .                             self.bump();
        .                         }
        .                         _ => (),
        .                     }
        .                 }
        .                 // End of file reached.
        .                 false
    6,282 (0.0%)      }
        .         
        .             /// Eats the double-quoted string and returns `n_hashes` and an error if encountered.
       16 (0.0%)      fn raw_double_quoted_string(&mut self, prefix_len: u32) -> Result<u8, RawStrError> {
        .                 // Wrap the actual function to handle the error with too many hashes.
        .                 // This way, it eats the whole raw string.
        .                 let n_hashes = self.raw_string_unvalidated(prefix_len)?;
        .                 // Only up to 255 `#`s are allowed in raw strings
        .                 match u8::try_from(n_hashes) {
        6 (0.0%)              Ok(num) => Ok(num),
        .                     Err(_) => Err(RawStrError::TooManyDelimiters { found: n_hashes }),
        .                 }
       14 (0.0%)      }
        .         
        .             fn raw_string_unvalidated(&mut self, prefix_len: u32) -> Result<u32, RawStrError> {
        .                 debug_assert!(self.prev() == 'r');
        .                 let start_pos = self.pos_within_token();
        .                 let mut possible_terminator_offset = None;
        .                 let mut max_hashes = 0;
        .         
        .                 // Count opening '#' symbols.
        .                 let mut eaten = 0;
        8 (0.0%)          while self.first() == '#' {
        2 (0.0%)              eaten += 1;
        .                     self.bump();
        .                 }
        .                 let n_start_hashes = eaten;
        .         
        .                 // Check that string is started.
        8 (0.0%)          match self.bump() {
        .                     Some('"') => (),
        .                     c => {
        .                         let c = c.unwrap_or(EOF_CHAR);
        .                         return Err(RawStrError::InvalidStarter { bad_char: c });
        .                     }
        .                 }
        .         
        .                 // Skip the string contents and on each '#' character met, check if this is
        .                 // a raw string termination.
        .                 loop {
       40 (0.0%)              self.eat_while(|c| c != '"');
        .         
        .                     if self.is_eof() {
        .                         return Err(RawStrError::NoTerminator {
        .                             expected: n_start_hashes,
        .                             found: max_hashes,
        .                             possible_terminator_offset,
        .                         });
        .                     }
-- line 803 ----------------------------------------
-- line 806 ----------------------------------------
        .                     self.bump();
        .         
        .                     // Check that amount of closing '#' symbols
        .                     // is equal to the amount of opening ones.
        .                     // Note that this will not consume extra trailing `#` characters:
        .                     // `r###"abcde"####` is lexed as a `RawStr { n_hashes: 3 }`
        .                     // followed by a `#` token.
        .                     let mut n_end_hashes = 0;
       28 (0.0%)              while self.first() == '#' && n_end_hashes < n_start_hashes {
        2 (0.0%)                  n_end_hashes += 1;
        .                         self.bump();
        .                     }
        .         
       20 (0.0%)              if n_end_hashes == n_start_hashes {
        .                         return Ok(n_start_hashes);
       72 (0.0%)              } else if n_end_hashes > max_hashes {
        .                         // Keep track of possible terminators to give a hint about
        .                         // where there might be a missing terminator
        .                         possible_terminator_offset =
        .                             Some(self.pos_within_token() - start_pos - n_end_hashes + prefix_len);
        .                         max_hashes = n_end_hashes;
        .                     }
        .                 }
        .             }
        .         
   10,504 (0.0%)      fn eat_decimal_digits(&mut self) -> bool {
        .                 let mut has_digits = false;
        .                 loop {
   14,990 (0.0%)              match self.first() {
        .                         '_' => {
        .                             self.bump();
        .                         }
   35,140 (0.0%)                  '0'..='9' => {
        .                             has_digits = true;
        .                             self.bump();
        .                         }
        .                         _ => break,
        .                     }
        .                 }
   10,504 (0.0%)          has_digits
    5,252 (0.0%)      }
        .         
        .             fn eat_hexadecimal_digits(&mut self) -> bool {
        .                 let mut has_digits = false;
        .                 loop {
    5,103 (0.0%)              match self.first() {
        .                         '_' => {
        .                             self.bump();
        .                         }
    6,408 (0.0%)                  '0'..='9' | 'a'..='f' | 'A'..='F' => {
        .                             has_digits = true;
        .                             self.bump();
        .                         }
        .                         _ => break,
        .                     }
        .                 }
      526 (0.0%)          has_digits
        .             }
        .         
        .             /// Eats the float exponent. Returns true if at least one digit was met,
        .             /// and returns false otherwise.
        .             fn eat_float_exponent(&mut self) -> bool {
        .                 debug_assert!(self.prev() == 'e' || self.prev() == 'E');
        8 (0.0%)          if self.first() == '-' || self.first() == '+' {
        .                     self.bump();
        .                 }
        4 (0.0%)          self.eat_decimal_digits()
        .             }
        .         
        .             // Eats the suffix of the literal, e.g. "u8".
        .             fn eat_literal_suffix(&mut self) {
   60,939 (0.0%)          self.eat_identifier();
        .             }
        .         
        .             // Eats the identifier. Note: succeeds on `_`, which isn't a valid
        .             // identifier.
   53,312 (0.0%)      fn eat_identifier(&mut self) {
        .                 if !is_id_start(self.first()) {
        .                     return;
        .                 }
        .                 self.bump();
        .         
      408 (0.0%)          self.eat_while(is_id_continue);
   52,904 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_metadata/src/creader.rs
--------------------------------------------------------------------------------
Ir______________ 

   22,657 (0.0%)  <unknown (line 0)>

-- line 118 ----------------------------------------
        .             pub cdata: &'a CrateMetadata,
        .             pub cstore: &'a CStore,
        .         }
        .         
        .         impl std::ops::Deref for CrateMetadataRef<'_> {
        .             type Target = CrateMetadata;
        .         
        .             fn deref(&self) -> &Self::Target {
   18,300 (0.0%)          self.cdata
        .             }
        .         }
        .         
        .         struct CrateDump<'a>(&'a CStore);
        .         
        .         impl<'a> std::fmt::Debug for CrateDump<'a> {
        .             fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        .                 writeln!(fmt, "resolved crates:")?;
-- line 134 ----------------------------------------
-- line 148 ----------------------------------------
        .                         writeln!(fmt, "   rmeta: {}", rmeta.0.display())?;
        .                     }
        .                 }
        .                 Ok(())
        .             }
        .         }
        .         
        .         impl CStore {
3,475,468 (0.0%)      pub fn from_tcx(tcx: TyCtxt<'_>) -> FreezeReadGuard<'_, CStore> {
        .                 FreezeReadGuard::map(tcx.untracked().cstore.read(), |cstore| {
2,606,601 (0.0%)              cstore.as_any().downcast_ref::<CStore>().expect("`tcx.cstore` is not a `CStore`")
        .                 })
5,213,202 (0.1%)      }
        .         
    5,520 (0.0%)      pub fn from_tcx_mut(tcx: TyCtxt<'_>) -> FreezeWriteGuard<'_, CStore> {
        .                 FreezeWriteGuard::map(tcx.untracked().cstore.write(), |cstore| {
    1,380 (0.0%)              cstore.untracked_as_any().downcast_mut().expect("`tcx.cstore` is not a `CStore`")
        .                 })
    4,830 (0.0%)      }
        .         
        .             fn intern_stable_crate_id(&mut self, root: &CrateRoot) -> Result<CrateNum, CrateError> {
      104 (0.0%)          assert_eq!(self.metas.len(), self.stable_crate_ids.len());
        .                 let num = CrateNum::new(self.stable_crate_ids.len());
      260 (0.0%)          if let Some(&existing) = self.stable_crate_ids.get(&root.stable_crate_id()) {
        .                     // Check for (potential) conflicts with the local crate
        .                     if existing == LOCAL_CRATE {
        .                         Err(CrateError::SymbolConflictsCurrent(root.name()))
        .                     } else if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name())
        .                     {
        .                         let crate_name0 = root.name();
        .                         Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1))
        .                     } else {
-- line 179 ----------------------------------------
-- line 198 ----------------------------------------
        .             }
        .         
        .             pub(crate) fn get_crate_data_mut(&mut self, cnum: CrateNum) -> &mut CrateMetadata {
        .                 self.metas[cnum].as_mut().unwrap_or_else(|| panic!("Failed to get crate data for {cnum:?}"))
        .             }
        .         
        .             fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {
        .                 assert!(self.metas[cnum].is_none(), "Overwriting crate metadata entry");
      104 (0.0%)          self.metas[cnum] = Some(Box::new(data));
        .             }
        .         
        .             pub(crate) fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {
        .                 self.metas
        .                     .iter_enumerated()
        .                     .filter_map(|(cnum, data)| data.as_deref().map(|data| (cnum, data)))
        .             }
        .         
-- line 214 ----------------------------------------
-- line 284 ----------------------------------------
        .                 if level != lint::Level::Allow {
        .                     let unused_externs =
        .                         self.unused_externs.iter().map(|ident| ident.to_ident_string()).collect::<Vec<_>>();
        .                     let unused_externs = unused_externs.iter().map(String::as_str).collect::<Vec<&str>>();
        .                     tcx.dcx().emit_unused_externs(level, json_unused_externs.is_loud(), &unused_externs);
        .                 }
        .             }
        .         
        9 (0.0%)      pub fn new(
        .                 metadata_loader: Box<MetadataLoaderDyn>,
        .                 local_stable_crate_id: StableCrateId,
        .             ) -> CStore {
        .                 let mut stable_crate_ids = StableCrateIdMap::default();
        .                 stable_crate_ids.insert(local_stable_crate_id, LOCAL_CRATE);
       18 (0.0%)          CStore {
        .                     metadata_loader,
        .                     // We add an empty entry for LOCAL_CRATE (which maps to zero) in
        .                     // order to make array indices in `metas` match with the
        .                     // corresponding `CrateNum`. This first entry will always remain
        .                     // `None`.
        .                     metas: IndexVec::from_iter(iter::once(None)),
        .                     injected_panic_runtime: None,
        .                     allocator_kind: None,
        .                     alloc_error_handler_kind: None,
        .                     has_global_allocator: false,
        .                     has_alloc_error_handler: false,
        .                     stable_crate_ids,
        .                     unused_externs: Vec::new(),
        .                 }
        7 (0.0%)      }
        .         }
        .         
        .         impl<'a, 'tcx> CrateLoader<'a, 'tcx> {
        .             pub fn new(
        .                 tcx: TyCtxt<'tcx>,
        .                 cstore: &'a mut CStore,
        .                 used_extern_options: &'a mut FxHashSet<Symbol>,
        .             ) -> Self {
    2,760 (0.0%)          CrateLoader { tcx, cstore, used_extern_options }
        .             }
        .         
        .             fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {
    2,612 (0.0%)          for (cnum, data) in self.cstore.iter_crate_data() {
   17,878 (0.0%)              if data.name() != name {
        .                         trace!("{} did not match {}", data.name(), name);
        .                         continue;
        .                     }
        .         
    1,306 (0.0%)              match hash {
      578 (0.0%)                  Some(hash) if hash == data.hash() => return Some(cnum),
        .                         Some(hash) => {
        .                             debug!("actual hash {} did not match expected {}", hash, data.hash());
        .                             continue;
        .                         }
        .                         None => {}
        .                     }
        .         
        .                     // When the hash is None we're dealing with a top-level dependency
-- line 341 ----------------------------------------
-- line 343 ----------------------------------------
        .                     // this library. Even though an upstream library may have loaded
        .                     // something of the same name, we have to make sure it was loaded
        .                     // from the exact same location as well.
        .                     //
        .                     // We're also sure to compare *paths*, not actual byte slices. The
        .                     // `source` stores paths which are normalized which may be different
        .                     // from the strings on the command line.
        .                     let source = self.cstore.get_crate_data(cnum).cdata.source();
    6,084 (0.0%)              if let Some(entry) = self.sess.opts.externs.get(name.as_str()) {
        .                         // Only use `--extern crate_name=path` here, not `--extern crate_name`.
    4,980 (0.0%)                  if let Some(mut files) = entry.files() {
        .                             if files.any(|l| {
        .                                 let l = l.canonicalized();
        .                                 source.dylib.as_ref().map(|(p, _)| p) == Some(l)
        .                                     || source.rlib.as_ref().map(|(p, _)| p) == Some(l)
        .                                     || source.rmeta.as_ref().map(|(p, _)| p) == Some(l)
        .                             }) {
        .                                 return Some(cnum);
        .                             }
-- line 361 ----------------------------------------
-- line 364 ----------------------------------------
        .                     }
        .         
        .                     // Alright, so we've gotten this far which means that `data` has the
        .                     // right name, we don't have a hash, and we don't have a --extern
        .                     // pointing for ourselves. We're still not quite yet done because we
        .                     // have to make sure that this crate was found in the crate lookup
        .                     // path (this is a top-level dependency) as we don't want to
        .                     // implicitly load anything inside the dependency lookup path.
      688 (0.0%)              let prev_kind = source
        .                         .dylib
        .                         .as_ref()
        .                         .or(source.rlib.as_ref())
        .                         .or(source.rmeta.as_ref())
        .                         .expect("No sources for crate")
        .                         .1;
        .                     if kind.matches(prev_kind) {
        .                         return Some(cnum);
-- line 380 ----------------------------------------
-- line 389 ----------------------------------------
        .                 None
        .             }
        .         
        .             // The `dependency` type is determined by the command line arguments(`--extern`) and
        .             // `private_dep`. However, sometimes the directly dependent crate is not specified by
        .             // `--extern`, in this case, `private-dep` is none during loading. This is equivalent to the
        .             // scenario where the command parameter is set to `public-dependency`
        .             fn is_private_dep(&self, name: &str, private_dep: Option<bool>) -> bool {
    5,591 (0.0%)          self.sess.opts.externs.get(name).map_or(private_dep.unwrap_or(false), |e| e.is_private_dep)
        .                     && private_dep.unwrap_or(true)
        .             }
        .         
        .             fn register_crate(
        .                 &mut self,
        .                 host_lib: Option<Library>,
        .                 root: Option<&CratePaths>,
        .                 lib: Library,
        .                 dep_kind: CrateDepKind,
        .                 name: Symbol,
        .                 private_dep: Option<bool>,
        .             ) -> Result<CrateNum, CrateError> {
        .                 let _prof_timer =
      364 (0.0%)              self.sess.prof.generic_activity_with_arg("metadata_register_crate", name.as_str());
        .         
      936 (0.0%)          let Library { source, metadata } = lib;
      104 (0.0%)          let crate_root = metadata.get_root();
        .                 let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());
      104 (0.0%)          let private_dep = self.is_private_dep(name.as_str(), private_dep);
        .         
        .                 // Claim this crate number and cache it
      208 (0.0%)          let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;
        .         
       52 (0.0%)          info!(
        .                     "register crate `{}` (cnum = {}. private_dep = {})",
        .                     crate_root.name(),
        .                     cnum,
        .                     private_dep
        .                 );
        .         
        .                 // Maintain a reference to the top most crate.
        .                 // Stash paths for top-most crate locally if necessary.
        .                 let crate_paths;
       52 (0.0%)          let root = if let Some(root) = root {
        .                     root
        .                 } else {
       52 (0.0%)              crate_paths = CratePaths::new(crate_root.name(), source.clone());
        .                     &crate_paths
        .                 };
        .         
      100 (0.0%)          let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, dep_kind)?;
        .         
        .                 let raw_proc_macros = if crate_root.is_proc_macro_crate() {
        .                     let temp_root;
       10 (0.0%)              let (dlsym_source, dlsym_root) = match &host_lib {
        .                         Some(host_lib) => (&host_lib.source, {
        .                             temp_root = host_lib.metadata.get_root();
        .                             &temp_root
        .                         }),
        .                         None => (&source, &crate_root),
        .                     };
        .                     let dlsym_dylib = dlsym_source.dylib.as_ref().expect("no dylib for a proc-macro crate");
        .                     Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.stable_crate_id())?)
        2 (0.0%)          } else {
        .                     None
        .                 };
        .         
        .                 let crate_metadata = CrateMetadata::new(
      104 (0.0%)              self.sess,
        .                     self.cstore,
      312 (0.0%)              metadata,
      104 (0.0%)              crate_root,
        .                     raw_proc_macros,
      104 (0.0%)              cnum,
        .                     cnum_map,
        .                     dep_kind,
      624 (0.0%)              source,
        .                     private_dep,
        .                     host_hash,
        .                 );
        .         
      208 (0.0%)          self.cstore.set_crate_data(cnum, crate_metadata);
        .         
      208 (0.0%)          Ok(cnum)
      169 (0.0%)      }
        .         
        .             fn load_proc_macro<'b>(
        .                 &self,
        .                 locator: &mut CrateLocator<'b>,
        .                 path_kind: PathKind,
        .                 host_hash: Option<Svh>,
        .             ) -> Result<Option<(LoadResult, Option<Library>)>, CrateError>
        .             where
        .                 'a: 'b,
        .             {
        .                 // Use a new crate locator so trying to load a proc macro doesn't affect the error
        .                 // message we emit
        .                 let mut proc_macro_locator = locator.clone();
        .         
        .                 // Try to load a proc macro
        4 (0.0%)          proc_macro_locator.is_proc_macro = true;
        .         
        .                 // Load the proc macro crate for the target
       44 (0.0%)          let (locator, target_result) = if self.sess.opts.unstable_opts.dual_proc_macros {
        .                     proc_macro_locator.reset();
        .                     let result = match self.load(&mut proc_macro_locator)? {
        .                         Some(LoadResult::Previous(cnum)) => {
        .                             return Ok(Some((LoadResult::Previous(cnum), None)));
        .                         }
        .                         Some(LoadResult::Loaded(library)) => Some(LoadResult::Loaded(library)),
        .                         None => return Ok(None),
        .                     };
-- line 499 ----------------------------------------
-- line 502 ----------------------------------------
        .                     // so we want it to affect the error message
        .                     (locator, result)
        .                 } else {
        .                     (&mut proc_macro_locator, None)
        .                 };
        .         
        .                 // Load the proc macro crate for the host
        .         
        4 (0.0%)          locator.reset();
        4 (0.0%)          locator.is_proc_macro = true;
        4 (0.0%)          locator.target = &self.sess.host;
       32 (0.0%)          locator.triple = TargetTriple::from_triple(config::host_triple());
       28 (0.0%)          locator.filesearch = self.sess.host_filesearch(path_kind);
        .         
       52 (0.0%)          let Some(host_result) = self.load(locator)? else {
        .                     return Ok(None);
        .                 };
        .         
       42 (0.0%)          Ok(Some(if self.sess.opts.unstable_opts.dual_proc_macros {
        .                     let host_result = match host_result {
        .                         LoadResult::Previous(..) => {
        .                             panic!("host and target proc macros must be loaded in lock-step")
        .                         }
        .                         LoadResult::Loaded(library) => library,
        .                     };
        .                     (target_result.unwrap(), Some(host_result))
        .                 } else {
        .                     (host_result, None)
        .                 }))
        6 (0.0%)      }
        .         
    7,425 (0.0%)      fn resolve_crate(
        .                 &mut self,
        .                 name: Symbol,
        .                 span: Span,
        .                 dep_kind: CrateDepKind,
        .             ) -> Option<CrateNum> {
      675 (0.0%)          self.used_extern_options.insert(name);
    5,400 (0.0%)          match self.maybe_resolve_crate(name, dep_kind, None) {
      675 (0.0%)              Ok(cnum) => {
    2,700 (0.0%)                  self.cstore.set_used_recursively(cnum);
        .                         Some(cnum)
        .                     }
        .                     Err(err) => {
        .                         let missing_core =
        .                             self.maybe_resolve_crate(sym::core, CrateDepKind::Explicit, None).is_err();
        .                         err.report(self.sess, span, missing_core);
        .                         None
        .                     }
        .                 }
    6,075 (0.0%)      }
        .         
   23,508 (0.0%)      fn maybe_resolve_crate<'b>(
        .                 &'b mut self,
        .                 name: Symbol,
        .                 mut dep_kind: CrateDepKind,
        .                 dep: Option<(&'b CratePaths, &'b CrateDep)>,
        .             ) -> Result<CrateNum, CrateError> {
    1,306 (0.0%)          info!("resolving crate `{}`", name);
    1,697 (0.0%)          if !name.as_str().is_ascii() {
        .                     return Err(CrateError::NonAsciiName(name));
        .                 }
    6,790 (0.0%)          let (root, hash, host_hash, extra_filename, path_kind, private_dep) = match dep {
        .                     Some((root, dep)) => (
        .                         Some(root),
    2,468 (0.0%)                  Some(dep.hash),
    2,468 (0.0%)                  dep.host_hash,
    2,468 (0.0%)                  Some(&dep.extra_filename[..]),
        .                         PathKind::Dependency,
    3,702 (0.0%)                  Some(dep.is_private),
        .                     ),
        .                     None => (None, None, None, None, PathKind::Crate, None),
        .                 };
    3,940 (0.0%)          let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {
    6,270 (0.0%)              (LoadResult::Previous(cnum), None)
        .                 } else {
       52 (0.0%)              info!("falling back to a load");
        .                     let mut locator = CrateLocator::new(
      156 (0.0%)                  self.sess,
      104 (0.0%)                  &*self.cstore.metadata_loader,
       52 (0.0%)                  name,
        .                         // The all loop is because `--crate-type=rlib --crate-type=rlib` is
        .                         // legal and produces both inside this type.
        .                         self.tcx.crate_types().iter().all(|c| *c == CrateType::Rlib),
        .                         hash,
        .                         extra_filename,
        .                         false, // is_host
        .                         path_kind,
        .                     );
        .         
      416 (0.0%)              match self.load(&mut locator)? {
    1,000 (0.0%)                  Some(res) => (res, None),
        .                         None => {
        .                             dep_kind = CrateDepKind::MacrosOnly;
        8 (0.0%)                      match self.load_proc_macro(&mut locator, path_kind, host_hash)? {
       74 (0.0%)                          Some(res) => res,
        .                                 None => return Err(locator.into_error(root.cloned())),
        .                             }
        .                         }
        .                     }
       52 (0.0%)          };
        .         
      106 (0.0%)          match result {
        .                     (LoadResult::Previous(cnum), None) => {
        .                         // When `private_dep` is none, it indicates the directly dependent crate. If it is
        .                         // not specified by `--extern` on command line parameters, it may be
        .                         // `private-dependency` when `register_crate` is called for the first time. Then it must be updated to
        .                         // `public-dependency` here.
    2,508 (0.0%)                  let private_dep = self.is_private_dep(name.as_str(), private_dep);
    3,762 (0.0%)                  let data = self.cstore.get_crate_data_mut(cnum);
        .                         if data.is_proc_macro_crate() {
        .                             dep_kind = CrateDepKind::MacrosOnly;
        .                         }
        .                         data.set_dep_kind(cmp::max(data.dep_kind(), dep_kind));
        .                         data.update_and_private_dep(private_dep);
    3,762 (0.0%)                  Ok(cnum)
        .                     }
    1,664 (0.0%)              (LoadResult::Loaded(library), host_library) => {
      104 (0.0%)                  self.register_crate(host_library, root, library, dep_kind, name, private_dep)
        .                     }
        .                     _ => panic!(),
        .                 }
   10,448 (0.0%)      }
        .         
      648 (0.0%)      fn load(&self, locator: &mut CrateLocator<'_>) -> Result<Option<LoadResult>, CrateError> {
    1,150 (0.0%)          let Some(library) = locator.maybe_load_library_crate()? else {
        .                     return Ok(None);
        .                 };
        .         
        .                 // In the case that we're loading a crate, but not matching
        .                 // against a hash, we could load a crate which has the same hash
        .                 // as an already loaded crate. If this is the case prevent
        .                 // duplicates by just using the first crate.
        .                 //
        .                 // Note that we only do this for target triple crates, though, as we
        .                 // don't want to match a host crate against an equivalent target one
        .                 // already loaded.
       52 (0.0%)          let root = library.metadata.get_root();
        .                 // FIXME: why is this condition necessary? It was adding in #33625 but I
        .                 // don't know why and the original author doesn't remember ...
        .                 let can_reuse_cratenum =
      364 (0.0%)              locator.triple == self.sess.opts.target_triple || locator.is_proc_macro;
      884 (0.0%)          Ok(Some(if can_reuse_cratenum {
      884 (0.0%)              let mut result = LoadResult::Loaded(library);
    1,329 (0.0%)              for (cnum, data) in self.cstore.iter_crate_data() {
    1,277 (0.0%)                  if data.name() == root.name() && root.hash() == data.hash() {
        .                             assert!(locator.hash.is_none());
        .                             info!("load success, going to previous cnum: {}", cnum);
        .                             result = LoadResult::Previous(cnum);
        .                             break;
        .                         }
        .                     }
    1,040 (0.0%)              result
        .                 } else {
        .                     LoadResult::Loaded(library)
        .                 }))
      484 (0.0%)      }
        .         
        .             // Go through the crate metadata and load any crates that it references
        .             fn resolve_crate_deps(
        .                 &mut self,
        .                 root: &CratePaths,
        .                 crate_root: &CrateRoot,
        .                 metadata: &MetadataBlob,
        .                 krate: CrateNum,
-- line 666 ----------------------------------------
-- line 669 ----------------------------------------
        .                 debug!("resolving deps of external crate");
        .                 if crate_root.is_proc_macro_crate() {
        .                     return Ok(CrateNumMap::new());
        .                 }
        .         
        .                 // The map from crate numbers in the crate we're resolving to local crate numbers.
        .                 // We map 0 and all other holes in the map to our parent crate. The "additional"
        .                 // self-dependencies should be harmless.
      100 (0.0%)          let deps = crate_root.decode_crate_deps(metadata);
      100 (0.0%)          let mut crate_num_map = CrateNumMap::with_capacity(1 + deps.len());
        .                 crate_num_map.push(krate);
    7,437 (0.0%)          for dep in deps {
      617 (0.0%)              info!(
        .                         "resolving dep crate {} hash: `{}` extra filename: `{}`",
        .                         dep.name, dep.hash, dep.extra_filename
        .                     );
    1,851 (0.0%)              let dep_kind = match dep_kind {
        .                         CrateDepKind::MacrosOnly => CrateDepKind::MacrosOnly,
        .                         _ => dep.kind,
        .                     };
    3,702 (0.0%)              let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;
        .                     crate_num_map.push(cnum);
    1,234 (0.0%)          }
        .         
        .                 debug!("resolve_crate_deps: cnum_map for {:?} is {:?}", krate, crate_num_map);
      345 (0.0%)          Ok(crate_num_map)
        .             }
        .         
        .             fn dlsym_proc_macros(
        .                 &self,
        .                 path: &Path,
        .                 stable_crate_id: StableCrateId,
        .             ) -> Result<&'static [ProcMacro], CrateError> {
        6 (0.0%)          let sym_name = self.sess.generate_proc_macro_decls_symbol(stable_crate_id);
        6 (0.0%)          Ok(unsafe { *load_symbol_from_dylib::<*const &[ProcMacro]>(path, &sym_name)? })
        .             }
        .         
        .             fn inject_panic_runtime(&mut self, krate: &ast::Crate) {
        .                 // If we're only compiling an rlib, then there's no need to select a
        .                 // panic runtime, so we just skip this section entirely.
        .                 let any_non_rlib = self.tcx.crate_types().iter().any(|ct| *ct != CrateType::Rlib);
        .                 if !any_non_rlib {
        1 (0.0%)              info!("panic runtime injection skipped, only generating rlib");
        .                     return;
        .                 }
        .         
        .                 // If we need a panic runtime, we try to find an existing one here. At
        .                 // the same time we perform some general validation of the DAG we've got
        .                 // going such as ensuring everything has a compatible panic strategy.
        .                 //
        .                 // The logic for finding the panic runtime here is pretty much the same
-- line 719 ----------------------------------------
-- line 777 ----------------------------------------
        .                         .emit_err(errors::NoPanicStrategy { crate_name: name, strategy: desired_strategy });
        .                 }
        .         
        .                 self.cstore.injected_panic_runtime = Some(cnum);
        .                 self.inject_dependency_if(cnum, "a panic runtime", &|data| data.needs_panic_runtime());
        .             }
        .         
        .             fn inject_profiler_runtime(&mut self, krate: &ast::Crate) {
        3 (0.0%)          if self.sess.opts.unstable_opts.no_profiler_runtime
        1 (0.0%)              || !(self.sess.instrument_coverage()
        2 (0.0%)                  || self.sess.opts.unstable_opts.profile
        .                         || self.sess.opts.cg.profile_generate.enabled())
        .                 {
        .                     return;
        .                 }
        .         
        .                 info!("loading profiler");
        .         
        .                 let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);
-- line 795 ----------------------------------------
-- line 804 ----------------------------------------
        .         
        .                 // Sanity check the loaded crate to ensure it is indeed a profiler runtime
        .                 if !data.is_profiler_runtime() {
        .                     self.dcx().emit_err(errors::NotProfilerRuntime { crate_name: name });
        .                 }
        .             }
        .         
        .             fn inject_allocator_crate(&mut self, krate: &ast::Crate) {
        1 (0.0%)          self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {
        3 (0.0%)              [span1, span2, ..] => {
        .                         self.dcx().emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });
        .                         true
        .                     }
        3 (0.0%)              spans => !spans.is_empty(),
        .                 };
        1 (0.0%)          self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(krate) {
        2 (0.0%)              [span1, span2, ..] => {
        .                         self.dcx()
        .                             .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });
        .                         true
        .                     }
        .                     spans => !spans.is_empty(),
        .                 };
        .         
        .                 // Check to see if we actually need an allocator. This desire comes
        .                 // about through the `#![needs_allocator]` attribute and is typically
        .                 // written down in liballoc.
        6 (0.0%)          if !attr::contains_name(&krate.attrs, sym::needs_allocator)
        1 (0.0%)              && !self.cstore.iter_crate_data().any(|(_, data)| data.needs_allocator())
        .                 {
        .                     return;
        .                 }
        .         
        .                 // At this point we've determined that we need an allocator. Let's see
        .                 // if our compilation session actually needs an allocator based on what
        .                 // we're emitting.
        1 (0.0%)          let all_rlib = self.tcx.crate_types().iter().all(|ct| matches!(*ct, CrateType::Rlib));
        .                 if all_rlib {
        .                     return;
        .                 }
        .         
        .                 // Ok, we need an allocator. Not only that but we're actually going to
        .                 // create an artifact that needs one linked in. Let's go find the one
        .                 // that we're going to link in.
        .                 //
-- line 848 ----------------------------------------
-- line 900 ----------------------------------------
        .                 } else {
        .                     // The alloc crate provides a default allocation error handler if
        .                     // one isn't specified.
        .                     self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Default);
        .                 }
        .             }
        .         
        .             fn inject_forced_externs(&mut self) {
       75 (0.0%)          for (name, entry) in self.sess.opts.externs.iter() {
       30 (0.0%)              if entry.force {
        .                         let name_interned = Symbol::intern(name);
        .                         if !self.used_extern_options.contains(&name_interned) {
        .                             self.resolve_crate(name_interned, DUMMY_SP, CrateDepKind::Explicit);
        .                         }
        .                     }
        .                 }
        .             }
        .         
-- line 917 ----------------------------------------
-- line 954 ----------------------------------------
        .                 }
        .             }
        .         
        .             #[allow(rustc::untranslatable_diagnostic)] // FIXME: make this translatable
        .             fn report_unused_deps(&mut self, krate: &ast::Crate) {
        .                 // Make a point span rather than covering the whole file
        .                 let span = krate.spans.inner_span.shrink_to_lo();
        .                 // Complain about anything left over
       88 (0.0%)          for (name, entry) in self.sess.opts.externs.iter() {
       30 (0.0%)              if let ExternLocation::FoundInLibrarySearchDirectories = entry.location {
        .                         // Don't worry about pathless `--extern foo` sysroot references
        .                         continue;
        .                     }
       60 (0.0%)              if entry.nounused_dep || entry.force {
        .                         // We're not worried about this one
        .                         continue;
        .                     }
       15 (0.0%)              let name_interned = Symbol::intern(name);
        .                     if self.used_extern_options.contains(&name_interned) {
        .                         continue;
        .                     }
        .         
        .                     // Got a real unused --extern
        .                     if self.sess.opts.json_unused_externs.is_enabled() {
        .                         self.cstore.unused_externs.push(name_interned);
        .                         continue;
-- line 979 ----------------------------------------
-- line 990 ----------------------------------------
        .                                 name),
        .                         );
        .                 }
        .             }
        .         
        .             fn report_future_incompatible_deps(&self, krate: &ast::Crate) {
        .                 let name = self.tcx.crate_name(LOCAL_CRATE);
        .         
        2 (0.0%)          if name.as_str() == "wasm_bindgen" {
        .                     let major = env::var("CARGO_PKG_VERSION_MAJOR")
        .                         .ok()
        .                         .and_then(|major| u64::from_str(&major).ok());
        .                     let minor = env::var("CARGO_PKG_VERSION_MINOR")
        .                         .ok()
        .                         .and_then(|minor| u64::from_str(&minor).ok());
        .                     let patch = env::var("CARGO_PKG_VERSION_PATCH")
        .                         .ok()
-- line 1006 ----------------------------------------
-- line 1025 ----------------------------------------
        .                         lint::builtin::WASM_C_ABI,
        .                         span,
        .                         ast::CRATE_NODE_ID,
        .                         crate::fluent_generated::metadata_wasm_c_abi,
        .                     );
        .                 }
        .             }
        .         
       10 (0.0%)      pub fn postprocess(&mut self, krate: &ast::Crate) {
        .                 self.inject_forced_externs();
        .                 self.inject_profiler_runtime(krate);
        7 (0.0%)          self.inject_allocator_crate(krate);
        .                 self.inject_panic_runtime(krate);
        .         
        2 (0.0%)          self.report_unused_deps(krate);
        .                 self.report_future_incompatible_deps(krate);
        .         
        1 (0.0%)          info!("{:?}", CrateDump(self.cstore));
        8 (0.0%)      }
        .         
       10 (0.0%)      pub fn process_extern_crate(
        .                 &mut self,
        .                 item: &ast::Item,
        .                 def_id: LocalDefId,
        .                 definitions: &Definitions,
        .             ) -> Option<CrateNum> {
        2 (0.0%)          match item.kind {
        1 (0.0%)              ast::ItemKind::ExternCrate(orig_name) => {
        .                         debug!(
        .                             "resolving extern crate stmt. ident: {} orig_name: {:?}",
        .                             item.ident, orig_name
        .                         );
        2 (0.0%)                  let name = match orig_name {
        .                             Some(orig_name) => {
        .                                 validate_crate_name(self.sess, orig_name, Some(item.span));
        .                                 orig_name
        .                             }
        1 (0.0%)                      None => item.ident.name,
        .                         };
        2 (0.0%)                  let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {
        .                             CrateDepKind::MacrosOnly
        .                         } else {
        .                             CrateDepKind::Explicit
        .                         };
        .         
       10 (0.0%)                  let cnum = self.resolve_crate(name, item.span, dep_kind)?;
        .         
        6 (0.0%)                  let path_len = definitions.def_path(def_id).data.len();
        3 (0.0%)                  self.cstore.update_extern_crate(
        .                             cnum,
        6 (0.0%)                      ExternCrate {
        .                                 src: ExternCrateSource::Extern(def_id.to_def_id()),
        .                                 span: item.span,
        .                                 path_len,
        .                                 dependency_of: LOCAL_CRATE,
        .                             },
        .                         );
        .                         Some(cnum)
        .                     }
        .                     _ => bug!(),
        .                 }
        9 (0.0%)      }
        .         
    4,718 (0.0%)      pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {
    1,348 (0.0%)          let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit)?;
        .         
    3,370 (0.0%)          self.cstore.update_extern_crate(
        .                     cnum,
    3,370 (0.0%)              ExternCrate {
        .                         src: ExternCrateSource::Path,
        .                         span,
        .                         // to have the least priority in `update_extern_crate`
        .                         path_len: usize::MAX,
        .                         dependency_of: LOCAL_CRATE,
        .                     },
        .                 );
        .         
        .                 Some(cnum)
    3,370 (0.0%)      }
        .         
       84 (0.0%)      pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {
       42 (0.0%)          self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()
       42 (0.0%)      }
        .         }
        .         
        .         fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {
        .             struct Finder {
        .                 name: Symbol,
        .                 spans: Vec<Span>,
        .             }
        .             impl<'ast> visit::Visitor<'ast> for Finder {
   26,990 (0.0%)          fn visit_item(&mut self, item: &'ast ast::Item) {
    2,699 (0.0%)              if item.ident.name == self.name
        .                         && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)
        .                     {
        .                         self.spans.push(item.span);
        .                     }
        .                     visit::walk_item(self, item)
   21,592 (0.0%)          }
        .             }
        .         
        4 (0.0%)      let name = Symbol::intern(&global_fn_name(sym::alloc));
        4 (0.0%)      let mut f = Finder { name, spans: Vec::new() };
        .             visit::walk_crate(&mut f, krate);
        3 (0.0%)      f.spans
        .         }
        .         
        .         fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {
        .             struct Finder {
        .                 name: Symbol,
        .                 spans: Vec<Span>,
        .             }
        .             impl<'ast> visit::Visitor<'ast> for Finder {
   26,990 (0.0%)          fn visit_item(&mut self, item: &'ast ast::Item) {
    2,699 (0.0%)              if item.ident.name == self.name
        .                         && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)
        .                     {
        .                         self.spans.push(item.span);
        .                     }
        .                     visit::walk_item(self, item)
   21,592 (0.0%)          }
        .             }
        .         
        3 (0.0%)      let name = Symbol::intern(alloc_error_handler_name(AllocatorKind::Global));
        4 (0.0%)      let mut f = Finder { name, spans: Vec::new() };
        .             visit::walk_crate(&mut f, krate);
        3 (0.0%)      f.spans
        .         }
        .         
        .         fn format_dlopen_err(e: &(dyn std::error::Error + 'static)) -> String {
        .             e.sources().map(|e| format!(": {e}")).collect()
        .         }
        .         
        .         // On Windows the compiler would sometimes intermittently fail to open the
        .         // proc-macro DLL with `Error::LoadLibraryExW`. It is suspected that something in the
        .         // system still holds a lock on the file, so we retry a few times before calling it
        .         // an error.
       24 (0.0%)  fn load_dylib(path: &Path, max_attempts: usize) -> Result<libloading::Library, String> {
        4 (0.0%)      assert!(max_attempts > 0);
        .         
        8 (0.0%)      let mut last_error = None;
        .         
        .             for attempt in 0..max_attempts {
        .                 match unsafe { libloading::Library::new(&path) } {
        .                     Ok(lib) => {
        .                         if attempt > 0 {
        .                             debug!(
        .                                 "Loaded proc-macro `{}` after {} attempts.",
        .                                 path.display(),
        .                                 attempt + 1
        .                             );
        .                         }
        8 (0.0%)                  return Ok(lib);
        .                     }
        .                     Err(err) => {
        .                         // Only try to recover from this specific error.
        .                         if !matches!(err, libloading::Error::LoadLibraryExW { .. }) {
        .                             let err = format_dlopen_err(&err);
        .                             // We include the path of the dylib in the error ourselves, so
        .                             // if it's in the error, we strip it.
        .                             if let Some(err) = err.strip_prefix(&format!(": {}", path.display())) {
-- line 1185 ----------------------------------------
-- line 1199 ----------------------------------------
        .         
        .             let last_error = last_error.unwrap();
        .             let message = if let Some(src) = last_error.source() {
        .                 format!("{} ({src}) (retried {max_attempts} times)", format_dlopen_err(&last_error))
        .             } else {
        .                 format!("{} (retried {max_attempts} times)", format_dlopen_err(&last_error))
        .             };
        .             Err(message)
       18 (0.0%)  }
        .         
        .         pub enum DylibError {
        .             DlOpen(String, String),
        .             DlSym(String, String),
        .         }
        .         
        .         impl From<DylibError> for CrateError {
        .             fn from(err: DylibError) -> CrateError {
-- line 1215 ----------------------------------------
-- line 1222 ----------------------------------------
        .         
        .         pub unsafe fn load_symbol_from_dylib<T: Copy>(
        .             path: &Path,
        .             sym_name: &str,
        .         ) -> Result<T, DylibError> {
        .             // Make sure the path contains a / or the linker will search for it.
        .             let path = try_canonicalize(path).unwrap();
        .             let lib =
       14 (0.0%)          load_dylib(&path, 5).map_err(|err| DylibError::DlOpen(path.display().to_string(), err))?;
        .         
        .             let sym = unsafe { lib.get::<T>(sym_name.as_bytes()) }
        .                 .map_err(|err| DylibError::DlSym(path.display().to_string(), format_dlopen_err(&err)))?;
        .         
        .             // Intentionally leak the dynamic library. We can't ever unload it
        .             // since the library can make things that will live arbitrarily long.
        .             let sym = unsafe { sym.into_raw() };
        .             std::mem::forget(lib);
-- line 1238 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_metadata/src/rmeta/decoder.rs
--------------------------------------------------------------------------------
Ir______________ 

1,520,906 (0.0%)  <unknown (line 0)>

-- line 119 ----------------------------------------
        .             // --- Data used only for improving diagnostics ---
        .             /// Information about the `extern crate` item or path that caused this crate to be loaded.
        .             /// If this is `None`, then the crate was injected (e.g., by the allocator).
        .             extern_crate: Option<ExternCrate>,
        .         }
        .         
        .         /// Holds information about a rustc_span::SourceFile imported from another crate.
        .         /// See `imported_source_file()` for more information.
1,224,918 (0.0%)  #[derive(Clone)]
        .         struct ImportedSourceFile {
        .             /// This SourceFile's byte-offset within the source_map of its original crate
        .             original_start_pos: rustc_span::BytePos,
        .             /// The end of this SourceFile within the source_map of its original crate
        .             original_end_pos: rustc_span::BytePos,
        .             /// The imported SourceFile's representation within the local source_map
        .             translated_source_file: Lrc<rustc_span::SourceFile>,
        .         }
-- line 135 ----------------------------------------
-- line 158 ----------------------------------------
        .                 None
        .             }
        .             fn tcx(self) -> Option<TyCtxt<'tcx>> {
        .                 None
        .             }
        .         
        .             fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {
        .                 let tcx = self.tcx();
2,836,505 (0.0%)          DecodeContext {
        .                     opaque: MemDecoder::new(self.blob(), pos),
        .                     cdata: self.cdata(),
        .                     blob: self.blob(),
  211,284 (0.0%)              sess: self.sess().or(tcx.map(|tcx| tcx.sess)),
        .                     tcx,
        .                     lazy_state: LazyState::NoNode,
        .                     alloc_decoding_session: self
        .                         .cdata()
  329,619 (0.0%)                  .map(|cdata| cdata.cdata.alloc_decoding_state.new_decoding_session()),
        .                 }
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {
        .             #[inline]
        .             fn blob(self) -> &'a MetadataBlob {
        .                 self
-- line 183 ----------------------------------------
-- line 195 ----------------------------------------
        .                 let (_, sess) = self;
        .                 Some(sess)
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> Metadata<'a, 'tcx> for CrateMetadataRef<'a> {
        .             #[inline]
        .             fn blob(self) -> &'a MetadataBlob {
   52,264 (0.0%)          &self.cdata.blob
        .             }
        .             #[inline]
        .             fn cdata(self) -> Option<CrateMetadataRef<'a>> {
        .                 Some(self)
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, &'tcx Session) {
        .             #[inline]
        .             fn blob(self) -> &'a MetadataBlob {
   99,846 (0.0%)          &self.0.cdata.blob
        .             }
        .             #[inline]
        .             fn cdata(self) -> Option<CrateMetadataRef<'a>> {
        .                 Some(self.0)
        .             }
        .             #[inline]
        .             fn sess(self) -> Option<&'tcx Session> {
        .                 Some(self.1)
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, TyCtxt<'tcx>) {
        .             #[inline]
        .             fn blob(self) -> &'a MetadataBlob {
  178,688 (0.0%)          &self.0.cdata.blob
        .             }
        .             #[inline]
        .             fn cdata(self) -> Option<CrateMetadataRef<'a>> {
        .                 Some(self.0)
        .             }
        .             #[inline]
        .             fn tcx(self) -> Option<TyCtxt<'tcx>> {
        .                 Some(self.1)
-- line 237 ----------------------------------------
-- line 240 ----------------------------------------
        .         
        .         impl<T: ParameterizedOverTcx> LazyValue<T> {
        .             #[inline]
        .             fn decode<'a, 'tcx, M: Metadata<'a, 'tcx>>(self, metadata: M) -> T::Value<'tcx>
        .             where
        .                 T::Value<'tcx>: Decodable<DecodeContext<'a, 'tcx>>,
        .             {
        .                 let mut dcx = metadata.decoder(self.position.get());
  806,485 (0.0%)          dcx.lazy_state = LazyState::NodeStart(self.position);
   83,444 (0.0%)          T::Value::decode(&mut dcx)
        .             }
        .         }
        .         
        .         struct DecodeIterator<'a, 'tcx, T> {
        .             elem_counter: std::ops::Range<usize>,
        .             dcx: DecodeContext<'a, 'tcx>,
        .             _phantom: PhantomData<fn() -> T>,
        .         }
        .         
        .         impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Iterator for DecodeIterator<'a, 'tcx, T> {
        .             type Item = T;
        .         
        .             #[inline(always)]
        .             fn next(&mut self) -> Option<Self::Item> {
  392,216 (0.0%)          self.elem_counter.next().map(|_| T::decode(&mut self.dcx))
        .             }
        .         
        .             #[inline(always)]
        .             fn size_hint(&self) -> (usize, Option<usize>) {
   67,822 (0.0%)          self.elem_counter.size_hint()
        .             }
        .         }
        .         
        .         impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> ExactSizeIterator
        .             for DecodeIterator<'a, 'tcx, T>
        .         {
        .             fn len(&self) -> usize {
        .                 self.elem_counter.len()
-- line 277 ----------------------------------------
-- line 289 ----------------------------------------
        .                 self,
        .                 metadata: M,
        .             ) -> DecodeIterator<'a, 'tcx, T::Value<'tcx>>
        .             where
        .                 T::Value<'tcx>: Decodable<DecodeContext<'a, 'tcx>>,
        .             {
        .                 let mut dcx = metadata.decoder(self.position.get());
        .                 dcx.lazy_state = LazyState::NodeStart(self.position);
  732,139 (0.0%)          DecodeIterator { elem_counter: (0..self.num_elems), dcx, _phantom: PhantomData }
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> DecodeContext<'a, 'tcx> {
        .             #[inline]
        .             fn tcx(&self) -> TyCtxt<'tcx> {
  932,742 (0.0%)          let Some(tcx) = self.tcx else {
        .                     bug!(
        .                         "No TyCtxt found for decoding. \
        .                         You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`."
        .                     );
        .                 };
        .                 tcx
        .             }
        .         
        .             #[inline]
        .             pub fn blob(&self) -> &'a MetadataBlob {
       52 (0.0%)          self.blob
        .             }
        .         
        .             #[inline]
        .             pub fn cdata(&self) -> CrateMetadataRef<'a> {
        .                 debug_assert!(self.cdata.is_some(), "missing CrateMetadata in DecodeContext");
2,050,393 (0.0%)          self.cdata.unwrap()
        .             }
        .         
        .             #[inline]
        .             fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {
        .                 self.cdata().map_encoded_cnum_to_current(cnum)
        .             }
        .         
        .             #[inline]
      297 (0.0%)      fn read_lazy_offset_then<T>(&mut self, f: impl Fn(NonZero<usize>) -> T) -> T {
        .                 let distance = self.read_usize();
   26,809 (0.0%)          let position = match self.lazy_state {
        .                     LazyState::NoNode => bug!("read_lazy_with_meta: outside of a metadata node"),
      150 (0.0%)              LazyState::NodeStart(start) => {
        .                         let start = start.get();
      300 (0.0%)                  assert!(distance <= start);
        .                         start - distance
        .                     }
   15,405 (0.0%)              LazyState::Previous(last_pos) => last_pos.get() + distance,
        .                 };
        .                 let position = NonZero::new(position).unwrap();
   22,794 (0.0%)          self.lazy_state = LazyState::Previous(position);
        .                 f(position)
      297 (0.0%)      }
        .         
        .             fn read_lazy<T>(&mut self) -> LazyValue<T> {
        .                 self.read_lazy_offset_then(|pos| LazyValue::from_position(pos))
        .             }
        .         
        .             fn read_lazy_array<T>(&mut self, len: usize) -> LazyArray<T> {
      880 (0.0%)          self.read_lazy_offset_then(|pos| LazyArray::from_position_and_num_elems(pos, len))
        .             }
        .         
        .             fn read_lazy_table<I, T>(&mut self, width: usize, len: usize) -> LazyTable<I, T> {
        .                 self.read_lazy_offset_then(|pos| LazyTable::from_position_and_encoded_size(pos, width, len))
        .             }
        .         
        .             #[inline]
        .             pub fn read_raw_bytes(&mut self, len: usize) -> &[u8] {
-- line 359 ----------------------------------------
-- line 372 ----------------------------------------
        .             }
        .         
        .             fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>
        .             where
        .                 F: FnOnce(&mut Self) -> Ty<'tcx>,
        .             {
        .                 let tcx = self.tcx();
        .         
  101,428 (0.0%)          let key = ty::CReaderCacheKey { cnum: Some(self.cdata().cnum), pos: shorthand };
        .         
  182,116 (0.0%)          if let Some(&ty) = tcx.ty_rcache.borrow().get(&key) {
        .                     return ty;
        .                 }
        .         
        .                 let ty = or_insert_with(self);
        .                 tcx.ty_rcache.borrow_mut().insert(key, ty);
        .                 ty
        .             }
        .         
        .             fn with_position<F, R>(&mut self, pos: usize, f: F) -> R
        .             where
        .                 F: FnOnce(&mut Self) -> R,
        .             {
   31,749 (0.0%)          let new_opaque = MemDecoder::new(self.opaque.data(), pos);
        .                 let old_opaque = mem::replace(&mut self.opaque, new_opaque);
        .                 let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);
        .                 let r = f(self);
  831,295 (0.0%)          self.opaque = old_opaque;
  311,139 (0.0%)          self.lazy_state = old_state;
        .                 r
        .             }
        .         
        .             fn decode_alloc_id(&mut self) -> rustc_middle::mir::interpret::AllocId {
        .                 if let Some(alloc_decoding_session) = self.alloc_decoding_session {
        .                     alloc_decoding_session.decode_alloc_id(self)
        .                 } else {
        .                     bug!("Attempting to decode interpret::AllocId without CrateMetadata")
-- line 408 ----------------------------------------
-- line 414 ----------------------------------------
        .             #[inline]
        .             fn decode(d: &mut DecodeContext<'a, 'tcx>) -> ExpnIndex {
        .                 ExpnIndex::from_u32(d.read_u32())
        .             }
        .         }
        .         
        .         impl<'a, 'tcx> SpanDecoder for DecodeContext<'a, 'tcx> {
        .             fn decode_attr_id(&mut self) -> rustc_span::AttrId {
   97,286 (0.0%)          let sess = self.sess.expect("can't decode AttrId without Session");
  194,572 (0.0%)          sess.psess.attr_id_generator.mk_attr_id()
        .             }
        .         
  827,236 (0.0%)      fn decode_crate_num(&mut self) -> CrateNum {
        .                 let cnum = CrateNum::from_u32(self.read_u32());
        .                 self.map_encoded_cnum_to_current(cnum)
  827,236 (0.0%)      }
        .         
        .             fn decode_def_index(&mut self) -> DefIndex {
        .                 DefIndex::from_u32(self.read_u32())
        .             }
        .         
1,837,665 (0.0%)      fn decode_def_id(&mut self) -> DefId {
  481,384 (0.0%)          DefId { krate: Decodable::decode(self), index: Decodable::decode(self) }
1,470,132 (0.0%)      }
        .         
1,639,976 (0.0%)      fn decode_syntax_context(&mut self) -> SyntaxContext {
        .                 let cdata = self.cdata();
        .         
  614,991 (0.0%)          let Some(sess) = self.sess else {
        .                     bug!(
        .                         "Cannot decode SyntaxContext without Session.\
        .                         You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`."
        .                     );
        .                 };
        .         
        .                 let cname = cdata.root.name();
        .                 rustc_span::hygiene::decode_syntax_context(self, &cdata.hygiene_context, |_, id| {
-- line 450 ----------------------------------------
-- line 451 ----------------------------------------
        .                     debug!("SpecializedDecoder<SyntaxContext>: decoding {}", id);
        .                     cdata
        .                         .root
        .                         .syntax_contexts
        .                         .get(cdata, id)
        .                         .unwrap_or_else(|| panic!("Missing SyntaxContext {id:?} for crate {cname:?}"))
        .                         .decode((cdata, sess))
        .                 })
1,844,973 (0.0%)      }
        .         
  273,256 (0.0%)      fn decode_expn_id(&mut self) -> ExpnId {
        .                 let local_cdata = self.cdata();
        .         
  102,471 (0.0%)          let Some(sess) = self.sess else {
        .                     bug!(
        .                         "Cannot decode ExpnId without Session. \
        .                         You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`."
        .                     );
        .                 };
        .         
        .                 let cnum = CrateNum::decode(self);
        .                 let index = u32::decode(self);
        .         
        .                 let expn_id = rustc_span::hygiene::decode_expn_id(cnum, index, |expn_id| {
        .                     let ExpnId { krate: cnum, local_id: index } = expn_id;
        .                     // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s
        .                     // are stored in the owning crate, to avoid duplication.
        .                     debug_assert_ne!(cnum, LOCAL_CRATE);
   17,435 (0.0%)              let crate_data = if cnum == local_cdata.cnum {
        .                         local_cdata
        .                     } else {
        .                         local_cdata.cstore.get_crate_data(cnum)
        .                     };
        .                     let expn_data = crate_data
        .                         .root
        .                         .expn_data
        .                         .get(crate_data, index)
-- line 487 ----------------------------------------
-- line 488 ----------------------------------------
        .                         .unwrap()
        .                         .decode((crate_data, sess));
        .                     let expn_hash = crate_data
        .                         .root
        .                         .expn_hashes
        .                         .get(crate_data, index)
        .                         .unwrap()
        .                         .decode((crate_data, sess));
  191,785 (0.0%)              (expn_data, expn_hash)
        .                 });
        .                 expn_id
  341,570 (0.0%)      }
        .         
3,268,800 (0.0%)      fn decode_span(&mut self) -> Span {
        .                 let start = self.position();
        .                 let tag = SpanTag(self.peek_byte());
1,634,400 (0.0%)          let data = if tag.kind() == SpanKind::Indirect {
        .                     // Skip past the tag we just peek'd.
        .                     self.read_u8();
        .                     // indirect tag lengths are safe to access, since they're (0, 8)
        .                     let bytes_needed = tag.length().unwrap().0 as usize;
  134,510 (0.0%)              let mut total = [0u8; usize::BITS as usize / 8];
        .                     total[..bytes_needed].copy_from_slice(self.read_raw_bytes(bytes_needed));
  134,510 (0.0%)              let offset_or_position = usize::from_le_bytes(total);
  538,040 (0.0%)              let position = if tag.is_relative_offset() {
        .                         start - offset_or_position
        .                     } else {
        .                         offset_or_position
        .                     };
        .                     self.with_position(position, SpanData::decode)
        .                 } else {
  548,180 (0.0%)              SpanData::decode(self)
        .                 };
4,903,200 (0.1%)          Span::new(data.lo, data.hi, data.ctxt, data.parent)
        .             }
        .         
1,678,092 (0.0%)      fn decode_symbol(&mut self) -> Symbol {
        .                 let tag = self.read_u8();
        .         
1,574,211 (0.0%)          match tag {
        .                     SYMBOL_STR => {
   94,628 (0.0%)                  let s = self.read_str();
  283,884 (0.0%)                  Symbol::intern(s)
        .                     }
        .                     SYMBOL_OFFSET => {
        .                         // read str offset
        .                         let pos = self.read_usize();
        .         
        .                         // move to str offset and read
        .                         self.opaque.with_position(pos, |d| {
        .                             let s = d.read_str();
  167,074 (0.0%)                      Symbol::intern(s)
        .                         })
        .                     }
        .                     SYMBOL_PREINTERNED => {
        .                         let symbol_index = self.read_u32();
  820,540 (0.0%)                  Symbol::new_from_decoded(symbol_index)
        .                     }
        .                     _ => unreachable!(),
        .                 }
  668,296 (0.0%)      }
        .         }
        .         
        .         impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SpanData {
3,268,800 (0.0%)      fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> SpanData {
        .                 let tag = SpanTag::decode(decoder);
        .                 let ctxt = tag.context().unwrap_or_else(|| SyntaxContext::decode(decoder));
        .         
  817,200 (0.0%)          if tag.kind() == SpanKind::Partial {
        .                     return DUMMY_SP.with_ctxt(ctxt).data();
        .                 }
        .         
        .                 debug_assert!(tag.kind() == SpanKind::Local || tag.kind() == SpanKind::Foreign);
        .         
        .                 let lo = BytePos::decode(decoder);
        .                 let len = tag.length().unwrap_or_else(|| BytePos::decode(decoder));
        .                 let hi = lo + len;
        .         
1,224,918 (0.0%)          let Some(sess) = decoder.sess else {
        .                     bug!(
        .                         "Cannot decode Span without Session. \
        .                         You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`."
        .                     )
        .                 };
        .         
        .                 // Index of the file in the corresponding crate's list of encoded files.
        .                 let metadata_index = u32::decode(decoder);
-- line 574 ----------------------------------------
-- line 596 ----------------------------------------
        .                 // a transitive dependency.
        .                 //
        .                 // When we encode a foreign span, we adjust its 'lo' and 'high' values
        .                 // to be based on the *foreign* crate (e.g. crate C), not the crate
        .                 // we are writing metadata for (e.g. crate B). This allows us to
        .                 // treat the 'local' and 'foreign' cases almost identically during deserialization:
        .                 // we can call `imported_source_file` for the proper crate, and binary search
        .                 // through the returned slice using our span.
1,224,918 (0.0%)          let source_file = if tag.kind() == SpanKind::Local {
  795,114 (0.0%)              decoder.cdata().imported_source_file(metadata_index, sess)
        .                 } else {
        .                     // When we encode a proc-macro crate, all `Span`s should be encoded
        .                     // with `TAG_VALID_SPAN_LOCAL`
        .                     if decoder.cdata().root.is_proc_macro_crate() {
        .                         // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE
        .                         // since we don't have `cnum_map` populated.
        .                         let cnum = u32::decode(decoder);
        .                         panic!(
-- line 613 ----------------------------------------
-- line 619 ----------------------------------------
        .                     // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above
        .                     let cnum = CrateNum::decode(decoder);
        .                     debug!(
        .                         "SpecializedDecoder<Span>::specialized_decode: loading source files from cnum {:?}",
        .                         cnum
        .                     );
        .         
        .                     let foreign_data = decoder.cdata().cstore.get_crate_data(cnum);
   53,745 (0.0%)              foreign_data.imported_source_file(metadata_index, sess)
        .                 };
        .         
        .                 // Make sure our span is well-formed.
        .                 debug_assert!(
        .                     lo + source_file.original_start_pos <= source_file.original_end_pos,
        .                     "Malformed encoded span: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}",
        .                     lo,
        .                     source_file.original_start_pos,
-- line 635 ----------------------------------------
-- line 640 ----------------------------------------
        .                 debug_assert!(
        .                     hi + source_file.original_start_pos <= source_file.original_end_pos,
        .                     "Malformed encoded span: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}",
        .                     hi,
        .                     source_file.original_start_pos,
        .                     source_file.original_end_pos
        .                 );
        .         
  408,306 (0.0%)          let lo = lo + source_file.translated_source_file.start_pos;
        .                 let hi = hi + source_file.translated_source_file.start_pos;
        .         
        .                 // Do not try to decode parent for foreign spans.
2,041,530 (0.0%)          SpanData { lo, hi, ctxt, parent: None }
3,677,400 (0.0%)      }
        .         }
        .         
        .         impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Clause<'tcx>, Span)] {
        .             fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {
        .                 ty::codec::RefDecodable::decode(d)
        .             }
        .         }
        .         
-- line 661 ----------------------------------------
-- line 664 ----------------------------------------
        .                 decoder.read_lazy()
        .             }
        .         }
        .         
        .         impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyArray<T> {
        .             #[inline]
        .             fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {
        .                 let len = decoder.read_usize();
    6,032 (0.0%)          if len == 0 { LazyArray::default() } else { decoder.read_lazy_array(len) }
        .             }
        .         }
        .         
        .         impl<'a, 'tcx, I: Idx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyTable<I, T> {
    8,736 (0.0%)      fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {
        .                 let width = decoder.read_usize();
        .                 let len = decoder.read_usize();
        .                 decoder.read_lazy_table(width, len)
    8,736 (0.0%)      }
        .         }
        .         
        .         implement_ty_decoder!(DecodeContext<'a, 'tcx>);
        .         
        .         impl MetadataBlob {
        .             pub(crate) fn check_compatibility(
        .                 &self,
        .                 cfg_version: &'static str,
        .             ) -> Result<(), Option<String>> {
       55 (0.0%)          if !self.blob().starts_with(METADATA_HEADER) {
        .                     if self.blob().starts_with(b"rust") {
        .                         return Err(Some("<unknown rustc version>".to_owned()));
        .                     }
        .                     return Err(None);
        .                 }
        .         
        .                 let found_version =
        .                     LazyValue::<String>::from_position(NonZero::new(METADATA_HEADER.len() + 8).unwrap())
        .                         .decode(self);
       55 (0.0%)          if rustc_version(cfg_version) != found_version {
        .                     return Err(Some(found_version));
        .                 }
        .         
        .                 Ok(())
        .             }
        .         
        .             fn root_pos(&self) -> NonZero<usize> {
        .                 let offset = METADATA_HEADER.len();
        .                 let pos_bytes = self.blob()[offset..][..8].try_into().unwrap();
        .                 let pos = u64::from_le_bytes(pos_bytes);
        .                 NonZero::new(pos as usize).unwrap()
        .             }
        .         
        .             pub(crate) fn get_header(&self) -> CrateHeader {
      110 (0.0%)          let pos = self.root_pos();
        .                 LazyValue::<CrateHeader>::from_position(pos).decode(self)
        .             }
        .         
      416 (0.0%)      pub(crate) fn get_root(&self) -> CrateRoot {
      208 (0.0%)          let pos = self.root_pos();
        .                 LazyValue::<CrateRoot>::from_position(pos).decode(self)
      312 (0.0%)      }
        .         
        .             pub(crate) fn list_crate_metadata(
        .                 &self,
        .                 out: &mut dyn io::Write,
        .                 ls_kinds: &[String],
        .             ) -> io::Result<()> {
        .                 let root = self.get_root();
        .         
-- line 731 ----------------------------------------
-- line 917 ----------------------------------------
        .         }
        .         
        .         impl CrateRoot {
        .             pub(crate) fn is_proc_macro_crate(&self) -> bool {
        .                 self.proc_macro_data.is_some()
        .             }
        .         
        .             pub(crate) fn name(&self) -> Symbol {
  409,994 (0.0%)          self.header.name
        .             }
        .         
        .             pub(crate) fn hash(&self) -> Svh {
        .                 self.header.hash
        .             }
        .         
        .             pub(crate) fn stable_crate_id(&self) -> StableCrateId {
        4 (0.0%)          self.stable_crate_id
        .             }
        .         
        .             pub(crate) fn decode_crate_deps<'a>(
        .                 &self,
        .                 metadata: &'a MetadataBlob,
        .             ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {
        .                 self.crate_deps.decode(metadata)
        .             }
-- line 941 ----------------------------------------
-- line 956 ----------------------------------------
        .                     .unwrap()
        .                     .macros
        .                     .decode(self)
        .                     .position(|i| i == id)
        .                     .unwrap();
        .                 &self.raw_proc_macros.unwrap()[pos]
        .             }
        .         
  288,648 (0.0%)      fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {
   96,216 (0.0%)          let def_key = self.def_key(item_index);
  128,288 (0.0%)          def_key.disambiguated_data.data.get_opt_name().or_else(|| {
        .                     if def_key.disambiguated_data.data == DefPathData::Ctor {
      492 (0.0%)                  let parent_index = def_key.parent.expect("no parent for a constructor");
    3,444 (0.0%)                  self.def_key(parent_index).disambiguated_data.data.get_opt_name()
        .                     } else {
        .                         None
        .                     }
        .                 })
  160,360 (0.0%)      }
        .         
        .             fn item_name(self, item_index: DefIndex) -> Symbol {
  109,205 (0.0%)          self.opt_item_name(item_index).expect("no encoded ident for item")
        .             }
        .         
        .             fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {
   40,476 (0.0%)          let name = self.opt_item_name(item_index)?;
        .                 let span = self
        .                     .root
        .                     .tables
        .                     .def_ident_span
        .                     .get(self, item_index)
        .                     .unwrap_or_else(|| self.missing("def_ident_span", item_index))
        .                     .decode((self, sess));
        .                 Some(Ident::new(name, span))
        .             }
        .         
  131,547 (0.0%)      fn item_ident(self, item_index: DefIndex, sess: &Session) -> Ident {
        .                 self.opt_item_ident(item_index, sess).expect("no encoded ident for item")
   80,952 (0.0%)      }
        .         
        .             #[inline]
        .             pub(super) fn map_encoded_cnum_to_current(self, cnum: CrateNum) -> CrateNum {
1,857,754 (0.0%)          if cnum == LOCAL_CRATE { self.cnum } else { self.cnum_map[cnum] }
        .             }
        .         
  479,264 (0.0%)      fn def_kind(self, item_id: DefIndex) -> DefKind {
        .                 self.root
        .                     .tables
        .                     .def_kind
        .                     .get(self, item_id)
        .                     .unwrap_or_else(|| self.missing("def_kind", item_id))
  359,448 (0.0%)      }
        .         
   46,937 (0.0%)      fn get_span(self, index: DefIndex, sess: &Session) -> Span {
        .                 self.root
        .                     .tables
        .                     .def_span
        .                     .get(self, index)
        .                     .unwrap_or_else(|| self.missing("def_span", index))
        .                     .decode((self, sess))
   34,136 (0.0%)      }
        .         
        .             fn load_proc_macro(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> SyntaxExtension {
        .                 let (name, kind, helper_attrs) = match *self.raw_proc_macro(id) {
        .                     ProcMacro::CustomDerive { trait_name, attributes, client } => {
        .                         let helper_attrs =
        .                             attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();
        .                         (
        .                             trait_name,
-- line 1024 ----------------------------------------
-- line 1049 ----------------------------------------
        .                 )
        .             }
        .         
        .             fn get_explicit_item_bounds(
        .                 self,
        .                 index: DefIndex,
        .                 tcx: TyCtxt<'tcx>,
        .             ) -> ty::EarlyBinder<&'tcx [(ty::Clause<'tcx>, Span)]> {
      340 (0.0%)          let lazy = self.root.tables.explicit_item_bounds.get(self, index);
      170 (0.0%)          let output = if lazy.is_default() {
        .                     &mut []
        .                 } else {
       82 (0.0%)              tcx.arena.alloc_from_iter(lazy.decode((self, tcx)))
        .                 };
        .                 ty::EarlyBinder::bind(&*output)
        .             }
        .         
        .             fn get_explicit_item_super_predicates(
        .                 self,
        .                 index: DefIndex,
        .                 tcx: TyCtxt<'tcx>,
        .             ) -> ty::EarlyBinder<&'tcx [(ty::Clause<'tcx>, Span)]> {
       40 (0.0%)          let lazy = self.root.tables.explicit_item_super_predicates.get(self, index);
       20 (0.0%)          let output = if lazy.is_default() {
        .                     &mut []
        .                 } else {
       10 (0.0%)              tcx.arena.alloc_from_iter(lazy.decode((self, tcx)))
        .                 };
        .                 ty::EarlyBinder::bind(&*output)
        .             }
        .         
    2,915 (0.0%)      fn get_variant(
        .                 self,
        .                 kind: DefKind,
        .                 index: DefIndex,
        .                 parent_did: DefId,
        .             ) -> (VariantIdx, ty::VariantDef) {
    1,620 (0.0%)          let adt_kind = match kind {
        .                     DefKind::Variant => ty::AdtKind::Enum,
        .                     DefKind::Struct => ty::AdtKind::Struct,
        .                     DefKind::Union => ty::AdtKind::Union,
        .                     _ => bug!(),
        .                 };
        .         
        .                 let data = self.root.tables.variant_data.get(self, index).unwrap().decode(self);
        .         
        .                 let variant_did =
      530 (0.0%)              if adt_kind == ty::AdtKind::Enum { Some(self.local_def_id(index)) } else { None };
      265 (0.0%)          let ctor = data.ctor.map(|(kind, index)| (kind, self.local_def_id(index)));
        .         
    2,385 (0.0%)          (
      530 (0.0%)              data.idx,
    5,300 (0.0%)              ty::VariantDef::new(
        .                         self.item_name(index),
        .                         variant_did,
      795 (0.0%)                  ctor,
      265 (0.0%)                  data.discr,
        .                         self.get_associated_item_or_field_def_ids(index)
        .                             .map(|did| ty::FieldDef {
        .                                 did,
        .                                 name: self.item_name(did.index),
      840 (0.0%)                          vis: self.get_visibility(did.index),
        .                             })
        .                             .collect(),
        .                         adt_kind,
        .                         parent_did,
        .                         false,
      265 (0.0%)                  data.is_non_exhaustive,
        .                         // FIXME: unnamed fields in crate metadata is unimplemented yet.
        .                         false,
        .                     ),
        .                 )
    2,120 (0.0%)      }
        .         
        .             fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::AdtDef<'tcx> {
      486 (0.0%)          let kind = self.def_kind(item_id);
        .                 let did = self.local_def_id(item_id);
        .         
      369 (0.0%)          let adt_kind = match kind {
        .                     DefKind::Enum => ty::AdtKind::Enum,
        .                     DefKind::Struct => ty::AdtKind::Struct,
        .                     DefKind::Union => ty::AdtKind::Union,
        .                     _ => bug!("get_adt_def called on a non-ADT {:?}", did),
        .                 };
        .                 let repr = self.root.tables.repr_options.get(self, item_id).unwrap().decode(self);
        .         
        .                 let mut variants: Vec<_> = if let ty::AdtKind::Enum = adt_kind {
       36 (0.0%)              self.root
        .                         .tables
        .                         .module_children_non_reexports
        .                         .get(self, item_id)
        .                         .expect("variants are not encoded for an enum")
        9 (0.0%)                  .decode(self)
        .                         .filter_map(|index| {
      672 (0.0%)                      let kind = self.def_kind(index);
      448 (0.0%)                      match kind {
        .                                 DefKind::Ctor(..) => None,
    2,240 (0.0%)                          _ => Some(self.get_variant(kind, index, did)),
        .                             }
        .                         })
        .                         .collect()
        .                 } else {
    1,377 (0.0%)              std::iter::once(self.get_variant(kind, item_id, did)).collect()
        .                 };
        .         
        9 (0.0%)          variants.sort_by_key(|(idx, _)| *idx);
        .         
    1,296 (0.0%)          tcx.mk_adt_def(
      648 (0.0%)              did,
        .                     adt_kind,
      164 (0.0%)              variants.into_iter().map(|(_, variant)| variant).collect(),
        .                     repr,
        .                     false,
        .                 )
        .             }
        .         
  143,264 (0.0%)      fn get_visibility(self, id: DefIndex) -> Visibility<DefId> {
        .                 self.root
        .                     .tables
        .                     .visibility
        .                     .get(self, id)
        .                     .unwrap_or_else(|| self.missing("visibility", id))
        .                     .decode(self)
        .                     .map_id(|index| self.local_def_id(index))
  104,192 (0.0%)      }
        .         
        .             fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {
  107,040 (0.0%)          self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode_from_cdata(self))
        .             }
        .         
   10,692 (0.0%)      fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {
        .                 self.root
        .                     .tables
        .                     .expn_that_defined
        .                     .get(self, id)
        .                     .unwrap_or_else(|| self.missing("expn_that_defined", id))
        .                     .decode((self, sess))
    7,776 (0.0%)      }
        .         
        .             fn get_debugger_visualizers(self) -> Vec<DebuggerVisualizerFile> {
        .                 self.root.debugger_visualizers.decode(self).collect::<Vec<_>>()
        .             }
        .         
        .             /// Iterates over all the stability attributes in the given crate.
        .             fn get_lib_features(self) -> LibFeatures {
        .                 LibFeatures {
-- line 1194 ----------------------------------------
-- line 1206 ----------------------------------------
        .             /// feature is a stability implication).
        .             fn get_stability_implications(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Symbol)] {
        .                 tcx.arena.alloc_from_iter(self.root.stability_implications.decode(self))
        .             }
        .         
        .             /// Iterates over the language items in the given crate.
        .             fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, LangItem)] {
        .                 tcx.arena.alloc_from_iter(
       52 (0.0%)              self.root
        .                         .lang_items
        .                         .decode(self)
        .                         .map(move |(def_index, index)| (self.local_def_id(def_index), index)),
        .                 )
        .             }
        .         
        .             fn get_stripped_cfg_items(self, cnum: CrateNum, tcx: TyCtxt<'tcx>) -> &'tcx [StrippedCfgItem] {
        .                 let item_names = self
-- line 1222 ----------------------------------------
-- line 1239 ----------------------------------------
        .                         id_to_name.insert(id, name);
        .                         (name, id)
        .                     })
        .                     .collect();
        .                 DiagnosticItems { id_to_name, name_to_id }
        .             }
        .         
        .             fn get_mod_child(self, id: DefIndex, sess: &Session) -> ModChild {
   40,204 (0.0%)          let ident = self.item_ident(id, sess);
   40,204 (0.0%)          let res = Res::Def(self.def_kind(id), self.local_def_id(id));
   40,204 (0.0%)          let vis = self.get_visibility(id);
        .         
   40,204 (0.0%)          ModChild { ident, res, vis, reexport_chain: Default::default() }
        .             }
        .         
        .             /// Iterates over all named children of the given module,
        .             /// including both proper items and reexports.
        .             /// Module here is understood in name resolution sense - it can be a `mod` item,
        .             /// or a crate root, or an enum, or a trait.
        .             fn get_module_children(
        .                 self,
        .                 id: DefIndex,
        .                 sess: &'a Session,
        .             ) -> impl Iterator<Item = ModChild> + 'a {
  203,148 (0.0%)          iter::from_coroutine(move || {
    2,175 (0.0%)              if let Some(data) = &self.root.proc_macro_data {
        .                         // If we are loading as a proc macro, we want to return
        .                         // the view of this crate as a proc macro crate.
        2 (0.0%)                  if id == CRATE_DEF_INDEX {
       38 (0.0%)                      for child_index in data.macros.decode(self) {
       36 (0.0%)                          yield self.get_mod_child(child_index, sess);
        .                             }
        .                         }
        .                     } else {
        .                         // Iterate over all children.
    2,169 (0.0%)                  let non_reexports = self.root.tables.module_children_non_reexports.get(self, id);
   13,014 (0.0%)                  for child_index in non_reexports.unwrap().decode(self) {
   40,168 (0.0%)                      yield self.get_mod_child(child_index, sess);
        .                         }
        .         
    1,446 (0.0%)                  let reexports = self.root.tables.module_children_reexports.get(self, id);
        .                         if !reexports.is_default() {
  120,098 (0.0%)                      for reexport in reexports.decode((self, sess)) {
  115,410 (0.0%)                          yield reexport;
        .                             }
        .                         }
        .                     }
        .                 })
        .             }
        .         
        .             fn is_ctfe_mir_available(self, id: DefIndex) -> bool {
        .                 self.root.tables.mir_for_ctfe.get(self, id).is_some()
-- line 1290 ----------------------------------------
-- line 1294 ----------------------------------------
        .                 self.root.tables.optimized_mir.get(self, id).is_some()
        .             }
        .         
        .             fn cross_crate_inlinable(self, id: DefIndex) -> bool {
        .                 self.root.tables.cross_crate_inlinable.get(self, id)
        .             }
        .         
        .             fn get_fn_has_self_parameter(self, id: DefIndex, sess: &'a Session) -> bool {
   67,852 (0.0%)          self.root
        .                     .tables
        .                     .fn_arg_names
        .                     .get(self, id)
        .                     .expect("argument names not encoded for a function")
        .                     .decode((self, sess))
        .                     .nth(0)
        .                     .is_some_and(|ident| ident.name == kw::SelfLower)
        .             }
        .         
        .             fn get_associated_item_or_field_def_ids(
        .                 self,
        .                 id: DefIndex,
        .             ) -> impl Iterator<Item = DefId> + 'a {
   63,895 (0.0%)          self.root
        .                     .tables
        .                     .associated_item_or_field_def_ids
        .                     .get(self, id)
        .                     .unwrap_or_else(|| self.missing("associated_item_or_field_def_ids", id))
        .                     .decode(self)
        .                     .map(move |child_index| self.local_def_id(child_index))
        .             }
        .         
        .             fn get_associated_item(self, id: DefIndex, sess: &'a Session) -> ty::AssocItem {
        .                 let name = if self.root.tables.opt_rpitit_info.get(self, id).is_some() {
        .                     kw::Empty
        .                 } else {
        .                     self.item_name(id)
        .                 };
  158,679 (0.0%)          let (kind, has_self) = match self.def_kind(id) {
        .                     DefKind::AssocConst => (ty::AssocKind::Const, false),
        .                     DefKind::AssocFn => (ty::AssocKind::Fn, self.get_fn_has_self_parameter(id, sess)),
        .                     DefKind::AssocTy => (ty::AssocKind::Type, false),
        .                     _ => bug!("cannot get associated-item of `{:?}`", self.def_key(id)),
        .                 };
        .                 let container = self.root.tables.assoc_container.get(self, id).unwrap();
        .                 let opt_rpitit_info =
        .                     self.root.tables.opt_rpitit_info.get(self, id).map(|d| d.decode(self));
        .         
  342,528 (0.0%)          ty::AssocItem {
        .                     name,
        .                     kind,
        .                     def_id: self.local_def_id(id),
        .                     trait_item_def_id: self.get_trait_item_def_id(id),
        .                     container,
        .                     fn_has_self_parameter: has_self,
        .                     opt_rpitit_info,
        .                 }
-- line 1349 ----------------------------------------
-- line 1354 ----------------------------------------
        .                     DefKind::Struct | DefKind::Variant => {
        .                         let vdata = self.root.tables.variant_data.get(self, node_id).unwrap().decode(self);
        .                         vdata.ctor.map(|(kind, index)| (kind, self.local_def_id(index)))
        .                     }
        .                     _ => None,
        .                 }
        .             }
        .         
  441,727 (0.0%)      fn get_item_attrs(
        .                 self,
        .                 id: DefIndex,
        .                 sess: &'a Session,
        .             ) -> impl Iterator<Item = ast::Attribute> + 'a {
  135,916 (0.0%)          self.root
        .                     .tables
        .                     .attributes
        .                     .get(self, id)
        .                     .unwrap_or_else(|| {
        .                         // Structure and variant constructors don't have any attributes encoded for them,
        .                         // but we assume that someone passing a constructor ID actually wants to look at
        .                         // the attributes on the corresponding struct or variant.
        8 (0.0%)                  let def_key = self.def_key(id);
        2 (0.0%)                  assert_eq!(def_key.disambiguated_data.data, DefPathData::Ctor);
        2 (0.0%)                  let parent_id = def_key.parent.expect("no parent for a constructor");
        6 (0.0%)                  self.root
        .                             .tables
        .                             .attributes
        .                             .get(self, parent_id)
        .                             .expect("no encoded attributes for a structure or variant")
        .                     })
        .                     .decode((self, sess))
  271,832 (0.0%)      }
        .         
        .             fn get_inherent_implementations_for_type(
        .                 self,
        .                 tcx: TyCtxt<'tcx>,
        .                 id: DefIndex,
        .             ) -> &'tcx [DefId] {
        .                 tcx.arena.alloc_from_iter(
        .                     self.root
-- line 1393 ----------------------------------------
-- line 1396 ----------------------------------------
        .                         .get(self, id)
        .                         .decode(self)
        .                         .map(|index| self.local_def_id(index)),
        .                 )
        .             }
        .         
        .             /// Decodes all traits in the crate (for rustdoc and rustc diagnostics).
        .             fn get_traits(self) -> impl Iterator<Item = DefId> + 'a {
      104 (0.0%)          self.root.traits.decode(self).map(move |index| self.local_def_id(index))
        .             }
        .         
        .             /// Decodes all trait impls in the crate (for rustdoc).
        .             fn get_trait_impls(self) -> impl Iterator<Item = DefId> + 'a {
        .                 self.cdata.trait_impls.values().flat_map(move |impls| {
        .                     impls.decode(self).map(move |(impl_index, _)| self.local_def_id(impl_index))
        .                 })
        .             }
        .         
        .             fn get_incoherent_impls(self, tcx: TyCtxt<'tcx>, simp: SimplifiedType) -> &'tcx [DefId] {
        .                 if let Some(impls) = self.cdata.incoherent_impls.get(&simp) {
      272 (0.0%)              tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))
        .                 } else {
        .                     &[]
        .                 }
        .             }
        .         
        .             fn get_implementations_of_trait(
        .                 self,
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_def_id: DefId,
        .             ) -> &'tcx [(DefId, Option<SimplifiedType>)] {
   30,680 (0.0%)          if self.trait_impls.is_empty() {
        .                     return &[];
        .                 }
        .         
        .                 // Do a reverse lookup beforehand to avoid touching the crate_num
        .                 // hash map in the loop below.
   25,370 (0.0%)          let key = match self.reverse_translate_def_id(trait_def_id) {
        .                     Some(def_id) => (def_id.krate.as_u32(), def_id.index),
        .                     None => return &[],
        .                 };
        .         
        .                 if let Some(impls) = self.trait_impls.get(&key) {
      875 (0.0%)              tcx.arena.alloc_from_iter(
      875 (0.0%)                  impls
        .                             .decode(self)
   54,873 (0.0%)                      .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty)),
        .                     )
        .                 } else {
        .                     &[]
        .                 }
        .             }
        .         
        .             fn get_native_libraries(self, sess: &'a Session) -> impl Iterator<Item = NativeLib> + 'a {
        .                 self.root.native_libraries.decode((self, sess))
-- line 1450 ----------------------------------------
-- line 1482 ----------------------------------------
        .             fn exported_symbols(
        .                 self,
        .                 tcx: TyCtxt<'tcx>,
        .             ) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportInfo)] {
        .                 tcx.arena.alloc_from_iter(self.root.exported_symbols.decode((self, tcx)))
        .             }
        .         
        .             fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {
      340 (0.0%)          match self.def_kind(id) {
        .                     DefKind::Macro(_) => {
        .                         let macro_rules = self.root.tables.is_macro_rules.get(self, id);
        .                         let body =
        .                             self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess));
        .                         ast::MacroDef { macro_rules, body: ast::ptr::P(body) }
        .                     }
        .                     _ => bug!(),
        .                 }
        .             }
        .         
        .             #[inline]
3,097,716 (0.0%)      fn def_key(self, index: DefIndex) -> DefKey {
  774,429 (0.0%)          *self
        .                     .def_key_cache
        .                     .lock()
        .                     .entry(index)
        .                     .or_insert_with(|| self.root.tables.def_keys.get(self, index).unwrap().decode(self))
2,065,144 (0.0%)      }
        .         
        .             // Returns the path leading to the thing with this `id`.
        .             fn def_path(self, id: DefIndex) -> DefPath {
        .                 debug!("def_path(cnum={:?}, id={:?})", self.cnum, id);
   63,850 (0.0%)          DefPath::make(self.cnum, id, |parent| self.def_key(parent))
        .             }
        .         
        .             #[inline]
        .             fn def_path_hash(self, index: DefIndex) -> DefPathHash {
        .                 // This is a hack to workaround the fact that we can't easily encode/decode a Hash64
        .                 // into the FixedSizeEncoding, as Hash64 lacks a Default impl. A future refactor to
        .                 // relax the Default restriction will likely fix this.
        .                 let fingerprint = Fingerprint::new(
  622,171 (0.0%)              self.root.stable_crate_id.as_u64(),
        .                     self.root.tables.def_path_hashes.get(self, index),
        .                 );
2,488,684 (0.0%)          DefPathHash::new(self.root.stable_crate_id, fingerprint.split().1)
        .             }
        .         
        .             #[inline]
        .             fn def_path_hash_to_def_index(self, hash: DefPathHash) -> DefIndex {
        .                 self.def_path_hash_map.def_path_hash_to_def_index(&hash)
        .             }
        .         
        .             fn expn_hash_to_expn_id(self, sess: &Session, index_guess: u32, hash: ExpnHash) -> ExpnId {
-- line 1533 ----------------------------------------
-- line 1583 ----------------------------------------
        .             ///
        .             /// Note that imported SourceFiles do not actually contain the source code of the
        .             /// file they represent, just information about length, line breaks, and
        .             /// multibyte characters. This information is enough to generate valid debuginfo
        .             /// for items inlined from other crates.
        .             ///
        .             /// Proc macro crates don't currently export spans, so this function does not have
        .             /// to work for them.
4,899,672 (0.1%)      fn imported_source_file(self, source_file_index: u32, sess: &Session) -> ImportedSourceFile {
        .                 fn filter<'a>(sess: &Session, path: Option<&'a Path>) -> Option<&'a Path> {
        .                     path.filter(|_| {
        .                         // Only spend time on further checks if we have what to translate *to*.
        .                         sess.opts.real_rust_source_base_dir.is_some()
        .                         // Some tests need the translation to be always skipped.
        .                         && sess.opts.unstable_opts.translate_remapped_path_to_local_path
        .                     })
        .                     .filter(|virtual_dir| {
-- line 1599 ----------------------------------------
-- line 1605 ----------------------------------------
        .                 }
        .         
        .                 let try_to_translate_virtual_to_real = |name: &mut rustc_span::FileName| {
        .                     // Translate the virtual `/rustc/$hash` prefix back to a real directory
        .                     // that should hold actual sources, where possible.
        .                     //
        .                     // NOTE: if you update this, you might need to also update bootstrap's code for generating
        .                     // the `rust-src` component in `Src::run` in `src/bootstrap/dist.rs`.
   10,611 (0.0%)              let virtual_rust_source_base_dir = [
        .                         filter(sess, option_env!("CFG_VIRTUAL_RUST_SOURCE_BASE_DIR").map(Path::new)),
        .                         filter(sess, sess.opts.unstable_opts.simulate_remapped_rust_src_base.as_deref()),
        .                     ];
        .         
        .                     debug!(
        .                         "try_to_translate_virtual_to_real(name={:?}): \
        .                          virtual_rust_source_base_dir={:?}, real_rust_source_base_dir={:?}",
        .                         name, virtual_rust_source_base_dir, sess.opts.real_rust_source_base_dir,
-- line 1621 ----------------------------------------
-- line 1672 ----------------------------------------
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                     }
        .                 };
        .         
        .                 let mut import_info = self.cdata.source_map_import_info.lock();
1,224,918 (0.0%)          for _ in import_info.len()..=(source_file_index as usize) {
        .                     import_info.push(None);
        .                 }
  408,306 (0.0%)          import_info[source_file_index as usize]
        .                     .get_or_insert_with(|| {
        .                         let source_file_to_import = self
        .                             .root
        .                             .source_map
        .                             .get(self, source_file_index)
        .                             .expect("missing source file")
        .                             .decode(self);
        .         
        .                         // We can't reuse an existing SourceFile, so allocate a new one
        .                         // containing the information we need.
        .                         let original_end_pos = source_file_to_import.end_position();
        .                         let rustc_span::SourceFile {
    7,074 (0.0%)                      mut name,
    7,074 (0.0%)                      src_hash,
        .                             start_pos: original_start_pos,
        .                             source_len,
    9,432 (0.0%)                      lines,
        .                             multibyte_chars,
        .                             non_narrow_chars,
        .                             normalized_pos,
        .                             stable_id,
        .                             ..
        .                         } = source_file_to_import;
        .         
        .                         // If this file is under $sysroot/lib/rustlib/src/
        .                         // and the user wish to simulate remapping with -Z simulate-remapped-rust-src-base,
        .                         // then we change `name` to a similar state as if the rust was bootstrapped
        .                         // with `remap-debuginfo = true`.
        .                         // This is useful for testing so that tests about the effects of
        .                         // `try_to_translate_virtual_to_real` don't have to worry about how the
        .                         // compiler is bootstrapped.
    2,358 (0.0%)                  if let Some(virtual_dir) = &sess.opts.unstable_opts.simulate_remapped_rust_src_base
        .                             && let Some(real_dir) = &sess.opts.real_rust_source_base_dir
        .                             && let rustc_span::FileName::Real(ref mut old_name) = name
        .                         {
        .                             let relative_path = match old_name {
        .                                 rustc_span::RealFileName::LocalPath(local) => {
        .                                     local.strip_prefix(real_dir).ok()
        .                                 }
        .                                 rustc_span::RealFileName::Remapped { virtual_name, .. } => {
-- line 1723 ----------------------------------------
-- line 1738 ----------------------------------------
        .                             }
        .                         }
        .         
        .                         // If this file's path has been remapped to `/rustc/$hash`,
        .                         // we might be able to reverse that (also see comments above,
        .                         // on `try_to_translate_virtual_to_real`).
        .                         try_to_translate_virtual_to_real(&mut name);
        .         
   15,327 (0.0%)                  let local_version = sess.source_map().new_imported_source_file(
        .                             name,
        .                             src_hash,
        .                             stable_id,
        .                             source_len.to_u32(),
    1,179 (0.0%)                      self.cnum,
    9,432 (0.0%)                      lines,
    4,716 (0.0%)                      multibyte_chars,
    4,716 (0.0%)                      non_narrow_chars,
   12,969 (0.0%)                      normalized_pos,
        .                             source_file_index,
        .                         );
        .                         debug!(
        .                             "CrateMetaData::imported_source_files alloc \
        .                                  source_file {:?} original (start_pos {:?} source_len {:?}) \
        .                                  translated (start_pos {:?} source_len {:?})",
        .                             local_version.name,
        .                             original_start_pos,
-- line 1763 ----------------------------------------
-- line 1768 ----------------------------------------
        .         
        .                         ImportedSourceFile {
        .                             original_start_pos,
        .                             original_end_pos,
        .                             translated_source_file: local_version,
        .                         }
        .                     })
        .                     .clone()
3,266,448 (0.0%)      }
        .         
        .             fn get_attr_flags(self, index: DefIndex) -> AttrFlags {
        .                 self.root.tables.attr_flags.get(self, index)
        .             }
        .         
        .             fn get_intrinsic(self, index: DefIndex) -> Option<ty::IntrinsicDef> {
        .                 self.root.tables.intrinsic.get(self, index).map(|d| d.decode(self))
        .             }
-- line 1784 ----------------------------------------
-- line 1811 ----------------------------------------
        .                 raw_proc_macros: Option<&'static [ProcMacro]>,
        .                 cnum: CrateNum,
        .                 cnum_map: CrateNumMap,
        .                 dep_kind: CrateDepKind,
        .                 source: CrateSource,
        .                 private_dep: bool,
        .                 host_hash: Option<Svh>,
        .             ) -> CrateMetadata {
       52 (0.0%)          let trait_impls = root
        .                     .impls
        .                     .decode((&blob, sess))
        .                     .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))
        .                     .collect();
        .                 let alloc_decoding_state =
      178 (0.0%)              AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());
        .                 let dependencies = cnum_map.iter().copied().collect();
        .         
        .                 // Pre-decode the DefPathHash->DefIndex table. This is a cheap operation
        .                 // that does not copy any data. It just does some data verification.
       52 (0.0%)          let def_path_hash_map = root.def_path_hash_map.decode(&blob);
        .         
    4,784 (0.0%)          let mut cdata = CrateMetadata {
      208 (0.0%)              blob,
        .                     root,
      104 (0.0%)              trait_impls,
        .                     incoherent_impls: Default::default(),
        .                     raw_proc_macros,
        .                     source_map_import_info: Lock::new(Vec::new()),
      208 (0.0%)              def_path_hash_map,
        .                     expn_hash_map: Default::default(),
      312 (0.0%)              alloc_decoding_state,
        .                     cnum,
        .                     cnum_map,
        .                     dependencies,
        .                     dep_kind,
        .                     source: Lrc::new(source),
        .                     private_dep,
        .                     host_hash,
        .                     used: false,
        .                     extern_crate: None,
        .                     hygiene_context: Default::default(),
        .                     def_key_cache: Default::default(),
        .                 };
        .         
        .                 // Need `CrateMetadataRef` to decode `DefId`s in simplified types.
      416 (0.0%)          cdata.incoherent_impls = cdata
        .                     .root
        .                     .incoherent_impls
        .                     .decode(CrateMetadataRef { cdata: &cdata, cstore })
        .                     .map(|incoherent_impls| (incoherent_impls.self_ty, incoherent_impls.impls))
        .                     .collect();
        .         
      104 (0.0%)          cdata
        .             }
        .         
        .             pub(crate) fn dependencies(&self) -> impl Iterator<Item = CrateNum> + '_ {
        .                 self.dependencies.iter().copied()
        .             }
        .         
        .             pub(crate) fn add_dependency(&mut self, cnum: CrateNum) {
        .                 self.dependencies.push(cnum);
        .             }
        .         
        .             pub(crate) fn update_extern_crate(&mut self, new_extern_crate: ExternCrate) -> bool {
        .                 let update =
        .                     Some(new_extern_crate.rank()) > self.extern_crate.as_ref().map(ExternCrate::rank);
    1,314 (0.0%)          if update {
      216 (0.0%)              self.extern_crate = Some(new_extern_crate);
        .                 }
        .                 update
        .             }
        .         
        .             pub(crate) fn source(&self) -> &CrateSource {
        .                 &*self.source
        .             }
        .         
        .             pub(crate) fn dep_kind(&self) -> CrateDepKind {
        .                 self.dep_kind
        .             }
        .         
        .             pub(crate) fn set_dep_kind(&mut self, dep_kind: CrateDepKind) {
    1,254 (0.0%)          self.dep_kind = dep_kind;
        .             }
        .         
        .             pub(crate) fn update_and_private_dep(&mut self, private_dep: bool) {
    6,270 (0.0%)          self.private_dep &= private_dep;
        .             }
        .         
        .             pub(crate) fn used(&self) -> bool {
       52 (0.0%)          self.used
        .             }
        .         
        .             pub(crate) fn required_panic_strategy(&self) -> Option<PanicStrategy> {
        .                 self.root.required_panic_strategy
        .             }
        .         
        .             pub(crate) fn needs_panic_runtime(&self) -> bool {
        .                 self.root.needs_panic_runtime
-- line 1908 ----------------------------------------
-- line 1912 ----------------------------------------
        .                 self.root.panic_runtime
        .             }
        .         
        .             pub(crate) fn is_profiler_runtime(&self) -> bool {
        .                 self.root.profiler_runtime
        .             }
        .         
        .             pub(crate) fn needs_allocator(&self) -> bool {
        9 (0.0%)          self.root.needs_allocator
        .             }
        .         
        .             pub(crate) fn has_global_allocator(&self) -> bool {
        .                 self.root.has_global_allocator
        .             }
        .         
        .             pub(crate) fn has_alloc_error_handler(&self) -> bool {
        .                 self.root.has_alloc_error_handler
-- line 1928 ----------------------------------------
-- line 1932 ----------------------------------------
        .                 self.root.has_default_lib_allocator
        .             }
        .         
        .             pub(crate) fn is_proc_macro_crate(&self) -> bool {
        .                 self.root.is_proc_macro_crate()
        .             }
        .         
        .             pub(crate) fn name(&self) -> Symbol {
   10,875 (0.0%)          self.root.header.name
        .             }
        .         
        .             pub(crate) fn hash(&self) -> Svh {
        .                 self.root.header.hash
        .             }
        .         
        .             fn num_def_ids(&self) -> usize {
        .                 self.root.tables.def_keys.size()
        .             }
        .         
        .             fn local_def_id(&self, index: DefIndex) -> DefId {
  124,624 (0.0%)          DefId { krate: self.cnum, index }
        .             }
        .         
        .             // Translate a DefId from the current compilation environment to a DefId
        .             // for an external crate.
        .             fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {
        .                 for (local, &global) in self.cnum_map.iter_enumerated() {
   76,738 (0.0%)              if global == did.krate {
        .                         return Some(DefId { krate: local, index: did.index });
        .                     }
        .                 }
        .         
        .                 None
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/query/plumbing.rs
--------------------------------------------------------------------------------
Ir_______________ 

 2,158,384 (0.0%)  <unknown (line 0)>

-- line 114 ----------------------------------------
         .             pub fn ensure_with_value(self) -> TyCtxtEnsureWithValue<'tcx> {
         .                 TyCtxtEnsureWithValue { tcx: self }
         .             }
         .         
         .             /// Returns a transparent wrapper for `TyCtxt` which uses
         .             /// `span` as the location of queries performed through it.
         .             #[inline(always)]
         .             pub fn at(self, span: Span) -> TyCtxtAt<'tcx> {
     3,867 (0.0%)          TyCtxtAt { tcx: self, span }
         .             }
         .         
         .             pub fn try_mark_green(self, dep_node: &dep_graph::DepNode) -> bool {
         .                 (self.query_system.fns.try_mark_green)(self, dep_node)
         .             }
         .         }
         .         
         .         #[inline]
41,194,600 (0.5%)  pub fn query_get_at<'tcx, Cache>(
         .             tcx: TyCtxt<'tcx>,
         .             execute_query: fn(TyCtxt<'tcx>, Span, Cache::Key, QueryMode) -> Option<Cache::Value>,
         .             query_cache: &Cache,
         .             span: Span,
         .             key: Cache::Key,
         .         ) -> Cache::Value
         .         where
         .             Cache: QueryCache,
         .         {
         .             let key = key.into_query_param();
         .             match try_get_cached(tcx, query_cache, &key) {
 3,605,632 (0.0%)          Some(value) => value,
 3,316,901 (0.0%)          None => execute_query(tcx, span, key, QueryMode::Get).unwrap(),
         .             }
34,002,663 (0.4%)  }
         .         
         .         #[inline]
         .         pub fn query_ensure<'tcx, Cache>(
         .             tcx: TyCtxt<'tcx>,
         .             execute_query: fn(TyCtxt<'tcx>, Span, Cache::Key, QueryMode) -> Option<Cache::Value>,
         .             query_cache: &Cache,
         .             key: Cache::Key,
         .             check_cache: bool,
         .         ) where
         .             Cache: QueryCache,
         .         {
         .             let key = key.into_query_param();
         .             if try_get_cached(tcx, query_cache, &key).is_none() {
    39,676 (0.0%)          execute_query(tcx, DUMMY_SP, key, QueryMode::Ensure { check_cache });
         .             }
         .         }
         .         
         .         #[inline]
    62,429 (0.0%)  pub fn query_ensure_error_guaranteed<'tcx, Cache, T>(
         .             tcx: TyCtxt<'tcx>,
         .             execute_query: fn(TyCtxt<'tcx>, Span, Cache::Key, QueryMode) -> Option<Cache::Value>,
         .             query_cache: &Cache,
         .             key: Cache::Key,
         .             check_cache: bool,
         .         ) -> Result<(), ErrorGuaranteed>
         .         where
         .             Cache: QueryCache<Value = super::erase::Erase<Result<T, ErrorGuaranteed>>>,
         .             Result<T, ErrorGuaranteed>: EraseType,
         .         {
         .             let key = key.into_query_param();
         .             if let Some(res) = try_get_cached(tcx, query_cache, &key) {
         .                 super::erase::restore(res).map(drop)
         .             } else {
    23,880 (0.0%)          execute_query(tcx, DUMMY_SP, key, QueryMode::Ensure { check_cache })
         .                     .map(super::erase::restore)
         .                     .map(|res| res.map(drop))
         .                     // Either we actually executed the query, which means we got a full `Result`,
         .                     // or we can just assume the query succeeded, because it was green in the
         .                     // incremental cache. If it is green, that means that the previous compilation
         .                     // that wrote to the incremental cache compiles successfully. That is only
         .                     // possible if the cache entry was `Ok(())`, so we emit that here, without
         .                     // actually encoding the `Result` in the cache or loading it from there.
         .                     .unwrap_or(Ok(()))
         .             }
    60,759 (0.0%)  }
         .         
         .         macro_rules! query_ensure {
         .             ([]$($args:tt)*) => {
         .                 query_ensure($($args)*)
         .             };
         .             ([(ensure_forwards_result_if_red) $($rest:tt)*]$($args:tt)*) => {
         .                 query_ensure_error_guaranteed($($args)*).map(|_| ())
         .             };
-- line 199 ----------------------------------------
-- line 310 ----------------------------------------
         .                         #[inline(always)]
         .                         pub fn provided_to_erased<'tcx>(
         .                             _tcx: TyCtxt<'tcx>,
         .                             value: ProvidedValue<'tcx>,
         .                         ) -> Erase<Value<'tcx>> {
         .                             erase(query_if_arena!([$($modifiers)*]
         .                                 {
         .                                     if mem::needs_drop::<ProvidedValue<'tcx>>() {
   200,309 (0.0%)                                  &*_tcx.query_system.arenas.$name.alloc(value)
         .                                     } else {
         .                                         &*_tcx.arena.dropless.alloc(value)
         .                                     }
         .                                 }
         .                                 (value)
         .                             ))
         .                         }
         .         
-- line 326 ----------------------------------------
-- line 361 ----------------------------------------
         .                 pub struct QueryArenas<'tcx> {
         .                     $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]
         .                         (TypedArena<<$V as Deref>::Target>)
         .                         ()
         .                     ),)*
         .                 }
         .         
         .                 impl Default for QueryArenas<'_> {
         3 (0.0%)              fn default() -> Self {
       197 (0.0%)                  Self {
         .                             $($name: query_if_arena!([$($modifiers)*]
         .                                 (Default::default())
         .                                 ()
         .                             ),)*
         .                         }
         2 (0.0%)              }
         .                 }
         .         
     2,196 (0.0%)          #[derive(Default)]
         .                 pub struct QueryCaches<'tcx> {
        95 (0.0%)              $($(#[$attr])* pub $name: queries::$name::Storage<'tcx>,)*
         .                 }
         .         
         .                 impl<'tcx> TyCtxtEnsure<'tcx> {
         .                     $($(#[$attr])*
         .                     #[inline(always)]
         .                     pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> ensure_result!([$($modifiers)*][$V]) {
     9,409 (0.0%)                  query_ensure!(
         .                             [$($modifiers)*]
         .                             self.tcx,
    20,073 (0.0%)                      self.tcx.query_system.fns.engine.$name,
     6,869 (0.0%)                      &self.tcx.query_system.caches.$name,
         .                             key.into_query_param(),
         .                             false,
         .                         )
         .                     })*
         .                 }
         .         
         .                 impl<'tcx> TyCtxtEnsureWithValue<'tcx> {
         .                     $($(#[$attr])*
         .                     #[inline(always)]
         .                     pub fn $name(self, key: query_helper_param_ty!($($K)*)) {
         .                         query_ensure(
         .                             self.tcx,
        14 (0.0%)                      self.tcx.query_system.fns.engine.$name,
         .                             &self.tcx.query_system.caches.$name,
         .                             key.into_query_param(),
         .                             true,
         .                         );
         .                     })*
         .                 }
         .         
         .                 impl<'tcx> TyCtxt<'tcx> {
-- line 413 ----------------------------------------
-- line 436 ----------------------------------------
         .                 }
         .         
         .                 pub struct DynamicQueries<'tcx> {
         .                     $(
         .                         pub $name: DynamicQuery<'tcx, queries::$name::Storage<'tcx>>,
         .                     )*
         .                 }
         .         
        22 (0.0%)          #[derive(Default)]
         .                 pub struct QueryStates<'tcx> {
         .                     $(
         .                         pub $name: QueryState<$($K)*>,
         .                     )*
         .                 }
         .         
         .                 pub struct Providers {
         .                     $(pub $name: for<'tcx> fn(
-- line 452 ----------------------------------------
-- line 455 ----------------------------------------
         .                     ) -> queries::$name::ProvidedValue<'tcx>,)*
         .                 }
         .         
         .                 pub struct ExternProviders {
         .                     $(pub $name: separate_provide_extern_decl!([$($modifiers)*][$name]),)*
         .                 }
         .         
         .                 impl Default for Providers {
         3 (0.0%)              fn default() -> Self {
       578 (0.0%)                  Providers {
         .                             $($name: |_, key| bug!(
         .                                 "`tcx.{}({:?})` is not supported for this key;\n\
         .                                 hint: Queries can be either made to the local crate, or the external crate. \
         .                                 This error means you tried to use it for one that's not supported.\n\
         .                                 If that's not the case, {} was likely never assigned to a provider function.\n",
         .                                 stringify!($name),
         .                                 key,
         .                                 stringify!($name),
         .                             ),)*
         .                         }
         2 (0.0%)              }
         .                 }
         .         
         .                 impl Default for ExternProviders {
         3 (0.0%)              fn default() -> Self {
       202 (0.0%)                  ExternProviders {
         .                             $($name: separate_provide_extern_default!([$($modifiers)*][$name]),)*
         .                         }
         2 (0.0%)              }
         .                 }
         .         
         .                 impl Copy for Providers {}
         .                 impl Clone for Providers {
         .                     fn clone(&self) -> Self { *self }
         .                 }
         .         
         .                 impl Copy for ExternProviders {}
-- line 491 ----------------------------------------
-- line 517 ----------------------------------------
         .         }
         .         
         .         macro_rules! define_feedable {
         .             ($($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {
         .                 $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {
         .                     $(#[$attr])*
         .                     #[inline(always)]
         .                     pub fn $name(self, value: queries::$name::ProvidedValue<'tcx>) {
    37,903 (0.0%)                  let key = self.key().into_query_param();
         .         
         .                         let tcx = self.tcx;
         .                         let erased = queries::$name::provided_to_erased(tcx, value);
         .                         let value = restore::<$V>(erased);
         .                         let cache = &tcx.query_system.caches.$name;
         .         
         .                         let hasher: Option<fn(&mut StableHashingContext<'_>, &_) -> _> = hash_result!([$($modifiers)*]);
         .                         match try_get_cached(tcx, cache, &key) {
-- line 533 ----------------------------------------
-- line 554 ----------------------------------------
         .                                     bug!(
         .                                         "Trying to feed an already recorded value for query {} key={key:?}:\nold value: {old:?}\nnew value: {value:?}",
         .                                         stringify!($name),
         .                                     )
         .                                 }
         .                             }
         .                             None => {
         .                                 let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::dep_kinds::$name, &key);
    15,760 (0.0%)                          let dep_node_index = tcx.dep_graph.with_feed_task(
         .                                     dep_node,
         .                                     tcx,
         .                                     key,
         .                                     &value,
         .                                     hash_result!([$($modifiers)*]),
         .                                 );
    54,425 (0.0%)                          cache.complete(key, erased, dep_node_index);
         .                             }
         .                         }
         .                     }
         .                 })*
         .             }
         .         }
         .         
         .         // Each of these queries corresponds to a function pointer field in the
-- line 577 ----------------------------------------
-- line 596 ----------------------------------------
         .             /// user call `to_def_id` to convert between them everywhere else.
         .             pub trait IntoQueryParam<P> {
         .                 fn into_query_param(self) -> P;
         .             }
         .         
         .             impl<P> IntoQueryParam<P> for P {
         .                 #[inline(always)]
         .                 fn into_query_param(self) -> P {
    41,230 (0.0%)              self
         .                 }
         .             }
         .         
         .             impl<'a, P: Copy> IntoQueryParam<P> for &'a P {
         .                 #[inline(always)]
         .                 fn into_query_param(self) -> P {
        64 (0.0%)              *self
         .                 }
         .             }
         .         
         .             impl IntoQueryParam<LocalDefId> for OwnerId {
         .                 #[inline(always)]
         .                 fn into_query_param(self) -> LocalDefId {
         .                     self.def_id
         .                 }
-- line 619 ----------------------------------------

       202 (0.0%)  <bogus line 2253>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ Information recorded about lines past the end of '/data/code/rust/compiler/rustc_middle/src/query/plumbing.rs'.
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/context.rs
--------------------------------------------------------------------------------
Ir_______________ 

 9,284,765 (0.1%)  <unknown (line 0)>

-- line 170 ----------------------------------------
         .             fields: InternedSet<'tcx, List<FieldIdx>>,
         .             local_def_ids: InternedSet<'tcx, List<LocalDefId>>,
         .             captures: InternedSet<'tcx, List<&'tcx ty::CapturedPlace<'tcx>>>,
         .             offset_of: InternedSet<'tcx, List<(VariantIdx, FieldIdx)>>,
         .         }
         .         
         .         impl<'tcx> CtxtInterners<'tcx> {
         .             fn new(arena: &'tcx WorkerLocal<Arena<'tcx>>) -> CtxtInterners<'tcx> {
       139 (0.0%)          CtxtInterners {
         .                     arena,
         .                     type_: Default::default(),
         .                     const_lists: Default::default(),
         .                     args: Default::default(),
         .                     type_lists: Default::default(),
         .                     region: Default::default(),
         .                     poly_existential_predicates: Default::default(),
         .                     canonical_var_infos: Default::default(),
-- line 186 ----------------------------------------
-- line 201 ----------------------------------------
         .                     captures: Default::default(),
         .                     offset_of: Default::default(),
         .                 }
         .             }
         .         
         .             /// Interns a type. (Use `mk_*` functions instead, where possible.)
         .             #[allow(rustc::usage_of_ty_tykind)]
         .             #[inline(never)]
 8,086,128 (0.1%)      fn intern_ty(&self, kind: TyKind<'tcx>, sess: &Session, untracked: &Untracked) -> Ty<'tcx> {
         .                 Ty(Interned::new_unchecked(
   673,844 (0.0%)              self.type_
         .                         .intern(kind, |kind| {
    48,588 (0.0%)                      let flags = super::flags::FlagComputation::for_kind(&kind);
         .                             let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);
         .         
    48,588 (0.0%)                      InternedInSet(self.arena.alloc(WithCachedTypeInfo {
         .                                 internee: kind,
         .                                 stable_hash,
         .                                 flags: flags.flags,
         .                                 outer_exclusive_binder: flags.outer_exclusive_binder,
         .                             }))
         .                         })
         .                         .0,
         .                 ))
 6,064,596 (0.1%)      }
         .         
         .             /// Interns a const. (Use `mk_*` functions instead, where possible.)
         .             #[allow(rustc::usage_of_ty_tykind)]
         .             #[inline(never)]
    80,784 (0.0%)      fn intern_const(
         .                 &self,
         .                 data: ty::ConstData<'tcx>,
         .                 sess: &Session,
         .                 untracked: &Untracked,
         .             ) -> Const<'tcx> {
         .                 Const(Interned::new_unchecked(
     6,732 (0.0%)              self.const_
         .                         .intern(data, |data: ConstData<'_>| {
       262 (0.0%)                      let flags = super::flags::FlagComputation::for_const(&data.kind, data.ty);
         .                             let stable_hash = self.stable_hash(&flags, sess, untracked, &data);
         .         
       262 (0.0%)                      InternedInSet(self.arena.alloc(WithCachedTypeInfo {
         .                                 internee: data,
         .                                 stable_hash,
         .                                 flags: flags.flags,
         .                                 outer_exclusive_binder: flags.outer_exclusive_binder,
         .                             }))
         .                         })
         .                         .0,
         .                 ))
    60,588 (0.0%)      }
         .         
         .             fn stable_hash<'a, T: HashStable<StableHashingContext<'a>>>(
         .                 &self,
         .                 flags: &ty::flags::FlagComputation,
         .                 sess: &'a Session,
         .                 untracked: &'a Untracked,
         .                 val: &T,
         .             ) -> Fingerprint {
         .                 // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.
         .                 // Without incremental, we rarely stable-hash types, so let's not do it proactively.
    91,636 (0.0%)          if flags.flags.intersects(TypeFlags::HAS_INFER) || sess.opts.incremental.is_none() {
         .                     Fingerprint::ZERO
         .                 } else {
         .                     let mut hasher = StableHasher::new();
         .                     let mut hcx = StableHashingContext::new(sess, untracked);
         .                     val.hash_stable(&mut hcx, &mut hasher);
         .                     hasher.finish()
         .                 }
         .             }
         .         
         .             /// Interns a predicate. (Use `mk_predicate` instead, where possible.)
         .             #[inline(never)]
 8,535,804 (0.1%)      fn intern_predicate(
         .                 &self,
         .                 kind: Binder<'tcx, PredicateKind<'tcx>>,
         .                 sess: &Session,
         .                 untracked: &Untracked,
         .             ) -> Predicate<'tcx> {
         .                 Predicate(Interned::new_unchecked(
   711,317 (0.0%)              self.predicate
         .                         .intern(kind, |kind| {
    42,786 (0.0%)                      let flags = super::flags::FlagComputation::for_predicate(kind);
         .         
         .                             let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);
         .         
    42,786 (0.0%)                      InternedInSet(self.arena.alloc(WithCachedTypeInfo {
         .                                 internee: kind,
         .                                 stable_hash,
         .                                 flags: flags.flags,
         .                                 outer_exclusive_binder: flags.outer_exclusive_binder,
         .                             }))
         .                         })
         .                         .0,
         .                 ))
 6,401,853 (0.1%)      }
         .         
         .             fn intern_clauses(&self, clauses: &[Clause<'tcx>]) -> Clauses<'tcx> {
   366,324 (0.0%)          if clauses.is_empty() {
         .                     ListWithCachedTypeInfo::empty()
         .                 } else {
    99,137 (0.0%)              self.clauses
    99,137 (0.0%)                  .intern_ref(clauses, || {
         .                             let flags = super::flags::FlagComputation::for_clauses(clauses);
         .         
         .                             InternedInSet(ListWithCachedTypeInfo::from_arena(
         .                                 &*self.arena,
         .                                 flags.into(),
         .                                 clauses,
         .                             ))
         .                         })
-- line 311 ----------------------------------------
-- line 394 ----------------------------------------
         .         }
         .         
         .         impl<'tcx> CommonTypes<'tcx> {
         .             fn new(
         .                 interners: &CtxtInterners<'tcx>,
         .                 sess: &Session,
         .                 untracked: &Untracked,
         .             ) -> CommonTypes<'tcx> {
       666 (0.0%)          let mk = |ty| interners.intern_ty(ty, sess, untracked);
         .         
         .                 let ty_vars =
       300 (0.0%)              (0..NUM_PREINTERNED_TY_VARS).map(|n| mk(Infer(ty::TyVar(TyVid::from(n))))).collect();
         .                 let fresh_tys: Vec<_> =
        81 (0.0%)              (0..NUM_PREINTERNED_FRESH_TYS).map(|n| mk(Infer(ty::FreshTy(n)))).collect();
         .                 let fresh_int_tys: Vec<_> =
        12 (0.0%)              (0..NUM_PREINTERNED_FRESH_INT_TYS).map(|n| mk(Infer(ty::FreshIntTy(n)))).collect();
         .                 let fresh_float_tys: Vec<_> =
        12 (0.0%)              (0..NUM_PREINTERNED_FRESH_FLOAT_TYS).map(|n| mk(Infer(ty::FreshFloatTy(n)))).collect();
         .         
        57 (0.0%)          CommonTypes {
         5 (0.0%)              unit: mk(Tuple(List::empty())),
         3 (0.0%)              bool: mk(Bool),
         3 (0.0%)              char: mk(Char),
         3 (0.0%)              never: mk(Never),
         3 (0.0%)              isize: mk(Int(ty::IntTy::Isize)),
         3 (0.0%)              i8: mk(Int(ty::IntTy::I8)),
         3 (0.0%)              i16: mk(Int(ty::IntTy::I16)),
         3 (0.0%)              i32: mk(Int(ty::IntTy::I32)),
         3 (0.0%)              i64: mk(Int(ty::IntTy::I64)),
         3 (0.0%)              i128: mk(Int(ty::IntTy::I128)),
         3 (0.0%)              usize: mk(Uint(ty::UintTy::Usize)),
         3 (0.0%)              u8: mk(Uint(ty::UintTy::U8)),
         3 (0.0%)              u16: mk(Uint(ty::UintTy::U16)),
         3 (0.0%)              u32: mk(Uint(ty::UintTy::U32)),
         3 (0.0%)              u64: mk(Uint(ty::UintTy::U64)),
         3 (0.0%)              u128: mk(Uint(ty::UintTy::U128)),
         3 (0.0%)              f16: mk(Float(ty::FloatTy::F16)),
         3 (0.0%)              f32: mk(Float(ty::FloatTy::F32)),
         3 (0.0%)              f64: mk(Float(ty::FloatTy::F64)),
         3 (0.0%)              f128: mk(Float(ty::FloatTy::F128)),
         3 (0.0%)              str_: mk(Str),
         4 (0.0%)              self_param: mk(ty::Param(ty::ParamTy { index: 0, name: kw::SelfUpper })),
         .         
         1 (0.0%)              trait_object_dummy_self: fresh_tys[0],
         .         
         .                     ty_vars,
         .                     fresh_tys,
         .                     fresh_int_tys,
         .                     fresh_float_tys,
         .                 }
         .             }
         .         }
         .         
         .         impl<'tcx> CommonLifetimes<'tcx> {
         .             fn new(interners: &CtxtInterners<'tcx>) -> CommonLifetimes<'tcx> {
         .                 let mk = |r| {
         .                     Region(Interned::new_unchecked(
     2,168 (0.0%)                  interners.region.intern(r, |r| InternedInSet(interners.arena.alloc(r))).0,
         .                     ))
         .                 };
         .         
         .                 let re_vars =
     1,000 (0.0%)              (0..NUM_PREINTERNED_RE_VARS).map(|n| mk(ty::ReVar(ty::RegionVid::from(n)))).collect();
         .         
         .                 let re_late_bounds = (0..NUM_PREINTERNED_RE_LATE_BOUNDS_I)
         .                     .map(|i| {
         .                         (0..NUM_PREINTERNED_RE_LATE_BOUNDS_V)
         .                             .map(|v| {
       160 (0.0%)                          mk(ty::ReBound(
         .                                     ty::DebruijnIndex::from(i),
         .                                     ty::BoundRegion { var: ty::BoundVar::from(v), kind: ty::BrAnon },
         .                                 ))
         .                             })
         .                             .collect()
         .                     })
         .                     .collect();
         .         
        11 (0.0%)          CommonLifetimes {
         1 (0.0%)              re_static: mk(ty::ReStatic),
         1 (0.0%)              re_erased: mk(ty::ReErased),
         .                     re_vars,
         .                     re_late_bounds,
         .                 }
         .             }
         .         }
         .         
         .         impl<'tcx> CommonConsts<'tcx> {
         .             fn new(
         .                 interners: &CtxtInterners<'tcx>,
         .                 types: &CommonTypes<'tcx>,
         .                 sess: &Session,
         .                 untracked: &Untracked,
         .             ) -> CommonConsts<'tcx> {
         .                 let mk_const = |c| {
        11 (0.0%)              interners.intern_const(
         .                         c, sess, // This is only used to create a stable hashing context.
         .                         untracked,
         .                     )
         .                 };
         .         
         .                 CommonConsts {
         9 (0.0%)              unit: mk_const(ty::ConstData {
         .                         kind: ty::ConstKind::Value(ty::ValTree::zst()),
         .                         ty: types.unit,
         .                     }),
         8 (0.0%)              true_: mk_const(ty::ConstData {
         .                         kind: ty::ConstKind::Value(ty::ValTree::Leaf(ty::ScalarInt::TRUE)),
         .                         ty: types.bool,
         .                     }),
         8 (0.0%)              false_: mk_const(ty::ConstData {
         .                         kind: ty::ConstKind::Value(ty::ValTree::Leaf(ty::ScalarInt::FALSE)),
         .                         ty: types.bool,
         .                     }),
         .                 }
         .             }
         .         }
         .         
         .         /// This struct contains information regarding a free parameter region,
-- line 511 ----------------------------------------
-- line 555 ----------------------------------------
         .         
         .         /// Some workarounds to use cases that cannot use `create_def`.
         .         /// Do not add new ways to create `TyCtxtFeed` without consulting
         .         /// with T-compiler and making an analysis about why your addition
         .         /// does not cause incremental compilation issues.
         .         impl<'tcx> TyCtxt<'tcx> {
         .             /// Can only be fed before queries are run, and is thus exempt from any
         .             /// incremental issues. Do not use except for the initial query feeding.
         3 (0.0%)      pub fn feed_unit_query(self) -> TyCtxtFeed<'tcx, ()> {
         .                 self.dep_graph.assert_ignored();
         .                 TyCtxtFeed { tcx: self, key: () }
         4 (0.0%)      }
         .         
         .             /// Can only be fed before queries are run, and is thus exempt from any
         .             /// incremental issues. Do not use except for the initial query feeding.
         3 (0.0%)      pub fn feed_local_crate(self) -> TyCtxtFeed<'tcx, CrateNum> {
         .                 self.dep_graph.assert_ignored();
         .                 TyCtxtFeed { tcx: self, key: LOCAL_CRATE }
         5 (0.0%)      }
         .         
         .             /// Only used in the resolver to register the `CRATE_DEF_ID` `DefId` and feed
         .             /// some queries for it. It will panic if used twice.
        10 (0.0%)      pub fn create_local_crate_def_id(self, span: Span) -> TyCtxtFeed<'tcx, LocalDefId> {
         1 (0.0%)          let key = self.untracked().source_span.push(span);
         2 (0.0%)          assert_eq!(key, CRATE_DEF_ID);
         .                 TyCtxtFeed { tcx: self, key }
         9 (0.0%)      }
         .         
         .             /// In order to break cycles involving `AnonConst`, we need to set the expected type by side
         .             /// effect. However, we do not want this as a general capability, so this interface restricts
         .             /// to the only allowed case.
         .             pub fn feed_anon_const_type(self, key: LocalDefId, value: ty::EarlyBinder<Ty<'tcx>>) {
         .                 debug_assert_eq!(self.def_kind(key), DefKind::AnonConst);
         .                 TyCtxtFeed { tcx: self, key }.type_of(value)
         .             }
-- line 589 ----------------------------------------
-- line 599 ----------------------------------------
         .             pub fn downgrade(self) -> Feed<'tcx, KEY> {
         .                 Feed { _tcx: PhantomData, key: self.key }
         .             }
         .         }
         .         
         .         impl<'tcx, KEY: Copy> Feed<'tcx, KEY> {
         .             #[inline(always)]
         .             pub fn key(&self) -> KEY {
       167 (0.0%)          self.key
         .             }
         .         
         .             #[inline(always)]
         .             pub fn upgrade(self, tcx: TyCtxt<'tcx>) -> TyCtxtFeed<'tcx, KEY> {
         .                 TyCtxtFeed { tcx, key: self.key }
         .             }
         .         }
         .         
         .         impl<'tcx> TyCtxtFeed<'tcx, LocalDefId> {
         .             #[inline(always)]
         .             pub fn def_id(&self) -> LocalDefId {
     7,175 (0.0%)          self.key
         .             }
         .         
         .             // Caller must ensure that `self.key` ID is indeed an owner.
         .             pub fn feed_owner_id(&self) -> TyCtxtFeed<'tcx, hir::OwnerId> {
         .                 TyCtxtFeed { tcx: self.tcx, key: hir::OwnerId { def_id: self.key } }
         .             }
         .         
         .             // Fills in all the important parts needed by HIR queries
-- line 627 ----------------------------------------
-- line 658 ----------------------------------------
         .         /// `GlobalCtxt`, and in practice `TyCtxt` is passed around everywhere, and all
         .         /// operations are done via `TyCtxt`. A `TyCtxt` is obtained for a `GlobalCtxt`
         .         /// by calling `enter` with a closure `f`. That function creates both the
         .         /// `TyCtxt`, and an `ImplicitCtxt` around it that is put into TLS. Within `f`:
         .         /// - The `ImplicitCtxt` is available implicitly via TLS.
         .         /// - The `TyCtxt` is available explicitly via the `tcx` parameter, and also
         .         ///   implicitly within the `ImplicitCtxt`. Explicit access is preferred when
         .         ///   possible.
        21 (0.0%)  #[derive(Copy, Clone)]
         .         #[rustc_diagnostic_item = "TyCtxt"]
         .         #[rustc_pass_by_value]
         .         pub struct TyCtxt<'tcx> {
         .             gcx: &'tcx GlobalCtxt<'tcx>,
         .         }
         .         
         .         // Explicitly implement `DynSync` and `DynSend` for `TyCtxt` to short circuit trait resolution.
         .         #[cfg(parallel_compiler)]
-- line 674 ----------------------------------------
-- line 752 ----------------------------------------
         .             pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,
         .         
         .             current_gcx: CurrentGcx,
         .         }
         .         
         .         impl<'tcx> GlobalCtxt<'tcx> {
         .             /// Installs `self` in a `TyCtxt` and `ImplicitCtxt` for the duration of
         .             /// `f`.
        21 (0.0%)      pub fn enter<F, R>(&'tcx self, f: F) -> R
         .             where
         .                 F: FnOnce(TyCtxt<'tcx>) -> R,
         .             {
         .                 let icx = tls::ImplicitCtxt::new(self);
         .         
         .                 // Reset `current_gcx` to `None` when we exit.
         .                 let _on_drop = defer(move || {
        10 (0.0%)              *self.current_gcx.value.write() = None;
         .                 });
         .         
         .                 // Set this `GlobalCtxt` as the current one.
         .                 {
         .                     let mut guard = self.current_gcx.value.write();
         .                     assert!(guard.is_none(), "no `GlobalCtxt` is currently set");
        16 (0.0%)              *guard = Some(self as *const _ as *const ());
         .                 }
         .         
        25 (0.0%)          tls::enter_context(&icx, || f(icx.tcx))
        18 (0.0%)      }
         .         
         9 (0.0%)      pub fn finish(&self) -> FileEncodeResult {
         1 (0.0%)          self.dep_graph.finish_encoding()
         9 (0.0%)      }
         .         }
         .         
         .         /// This is used to get a reference to a `GlobalCtxt` if one is available.
         .         ///
         .         /// This is needed to allow the deadlock handler access to `GlobalCtxt` to look for query cycles.
         .         /// It cannot use the `TLV` global because that's only guaranteed to be defined on the thread
         .         /// creating the `GlobalCtxt`. Other threads have access to the `TLV` only inside Rayon jobs, but
         .         /// the deadlock handler is not called inside such a job.
         1 (0.0%)  #[derive(Clone)]
         .         pub struct CurrentGcx {
         .             /// This stores a pointer to a `GlobalCtxt`. This is set to `Some` inside `GlobalCtxt::enter`
         .             /// and reset to `None` when that function returns or unwinds.
         .             value: Lrc<RwLock<Option<*const ()>>>,
         .         }
         .         
         .         #[cfg(parallel_compiler)]
         .         unsafe impl DynSend for CurrentGcx {}
         .         #[cfg(parallel_compiler)]
         .         unsafe impl DynSync for CurrentGcx {}
         .         
         .         impl CurrentGcx {
         2 (0.0%)      pub fn new() -> Self {
         .                 Self { value: Lrc::new(RwLock::new(None)) }
         2 (0.0%)      }
         .         
         .             pub fn access<R>(&self, f: impl for<'tcx> FnOnce(&'tcx GlobalCtxt<'tcx>) -> R) -> R {
         .                 let read_guard = self.value.read();
         .                 let gcx: *const GlobalCtxt<'_> = read_guard.unwrap() as *const _;
         .                 // SAFETY: We hold the read lock for the `GlobalCtxt` pointer. That prevents
         .                 // `GlobalCtxt::enter` from returning as it would first acquire the write lock.
         .                 // This ensures the `GlobalCtxt` is live during `f`.
         .                 f(unsafe { &*gcx })
-- line 815 ----------------------------------------
-- line 834 ----------------------------------------
         .                     bug!(
         .                         "body_codegen_fn_attrs called on unexpected definition: {:?} {:?}",
         .                         def_id,
         .                         def_kind
         .                     )
         .                 }
         .             }
         .         
        45 (0.0%)      pub fn alloc_steal_thir(self, thir: Thir<'tcx>) -> &'tcx Steal<Thir<'tcx>> {
         5 (0.0%)          self.arena.alloc(Steal::new(thir))
        45 (0.0%)      }
         .         
       135 (0.0%)      pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {
        15 (0.0%)          self.arena.alloc(Steal::new(mir))
       135 (0.0%)      }
         .         
        30 (0.0%)      pub fn alloc_steal_promoted(
         .                 self,
         .                 promoted: IndexVec<Promoted, Body<'tcx>>,
         .             ) -> &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {
         6 (0.0%)          self.arena.alloc(Steal::new(promoted))
        25 (0.0%)      }
         .         
     5,460 (0.0%)      pub fn mk_adt_def(
         .                 self,
         .                 did: DefId,
         .                 kind: AdtKind,
         .                 variants: IndexVec<VariantIdx, ty::VariantDef>,
         .                 repr: ReprOptions,
         .                 is_anonymous: bool,
         .             ) -> ty::AdtDef<'tcx> {
       780 (0.0%)          self.mk_adt_def_from_data(ty::AdtDefData::new(
         .                     self,
         .                     did,
         .                     kind,
         .                     variants,
         .                     repr,
         .                     is_anonymous,
         .                 ))
     3,120 (0.0%)      }
         .         
         .             /// Allocates a read-only byte or string literal for `mir::interpret`.
         .             pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {
         .                 // Create an allocation that just contains these bytes.
         .                 let alloc = interpret::Allocation::from_bytes_byte_aligned_immutable(bytes);
         .                 let alloc = self.mk_const_alloc(alloc);
         .                 self.reserve_and_set_memory_alloc(alloc)
         .             }
         .         
         .             /// Returns a range of the start/end indices specified with the
         .             /// `rustc_layout_scalar_valid_range` attribute.
         .             // FIXME(eddyb) this is an awkward spot for this method, maybe move it?
     2,010 (0.0%)      pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {
     2,680 (0.0%)          let get = |name| {
     1,072 (0.0%)              let Some(attr) = self.get_attr(def_id, name) else {
         .                         return Bound::Unbounded;
         .                     };
         .                     debug!("layout_scalar_valid_range: attr={:?}", attr);
        16 (0.0%)              if let Some(
         8 (0.0%)                  &[
         .                             ast::NestedMetaItem::Lit(ast::MetaItemLit {
        20 (0.0%)                          kind: ast::LitKind::Int(a, _),
         .                                 ..
         .                             }),
         .                         ],
        12 (0.0%)              ) = attr.meta_item_list().as_deref()
         .                     {
         .                         Bound::Included(a.get())
         .                     } else {
         .                         self.dcx().span_delayed_bug(
         .                             attr.span,
         .                             "invalid rustc_layout_scalar_valid_range attribute",
         .                         );
         .                         Bound::Unbounded
         .                     }
     3,484 (0.0%)          };
     1,072 (0.0%)          (
       938 (0.0%)              get(sym::rustc_layout_scalar_valid_range_start),
     1,072 (0.0%)              get(sym::rustc_layout_scalar_valid_range_end),
         .                 )
     1,206 (0.0%)      }
         .         
         .             pub fn lift<T: Lift<'tcx>>(self, value: T) -> Option<T::Lifted> {
    27,141 (0.0%)          value.lift_to_tcx(self)
         .             }
         .         
         .             /// Creates a type context. To use the context call `fn enter` which
         .             /// provides a `TyCtxt`.
         .             ///
         .             /// By only providing the `TyCtxt` inside of the closure we enforce that the type
         .             /// context and any interned alue (types, args, etc.) can only be used while `ty::tls`
         .             /// has a valid reference to the context, to allow formatting values that need it.
        88 (0.0%)      pub fn create_global_ctxt(
         .                 s: &'tcx Session,
         .                 crate_types: Vec<CrateType>,
         .                 stable_crate_id: StableCrateId,
         .                 arena: &'tcx WorkerLocal<Arena<'tcx>>,
         .                 hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,
         .                 untracked: Untracked,
         .                 dep_graph: DepGraph,
         .                 query_kinds: &'tcx [DepKindStruct<'tcx>],
         .                 query_system: QuerySystem<'tcx>,
         .                 hooks: crate::hooks::Providers,
         .                 current_gcx: CurrentGcx,
         .             ) -> GlobalCtxt<'tcx> {
         1 (0.0%)          let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {
         .                     s.dcx().emit_fatal(err);
         .                 });
         .                 let interners = CtxtInterners::new(arena);
         .                 let common_types = CommonTypes::new(&interners, s, &untracked);
         .                 let common_lifetimes = CommonLifetimes::new(&interners);
         .                 let common_consts = CommonConsts::new(&interners, &common_types, s, &untracked);
         .         
       135 (0.0%)          GlobalCtxt {
         .                     sess: s,
         8 (0.0%)              crate_types,
         .                     stable_crate_id,
         .                     arena,
         .                     hir_arena,
         2 (0.0%)              interners,
         2 (0.0%)              dep_graph,
         .                     hooks,
         .                     prof: s.prof.clone(),
         2 (0.0%)              types: common_types,
         9 (0.0%)              lifetimes: common_lifetimes,
         .                     consts: common_consts,
         4 (0.0%)              untracked,
         4 (0.0%)              query_system,
         .                     query_kinds,
         .                     ty_rcache: Default::default(),
         .                     pred_rcache: Default::default(),
         .                     selection_cache: Default::default(),
         .                     evaluation_cache: Default::default(),
         .                     new_solver_evaluation_cache: Default::default(),
         .                     new_solver_coherence_evaluation_cache: Default::default(),
         .                     canonical_param_env_cache: Default::default(),
         6 (0.0%)              data_layout,
         .                     alloc_map: Lock::new(interpret::AllocMap::new()),
         5 (0.0%)              current_gcx,
         .                 }
         9 (0.0%)      }
         .         
         .             pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {
         .                 self.sess.consider_optimizing(|| self.crate_name(LOCAL_CRATE), msg)
         .             }
         .         
         .             /// Obtain all lang items of this crate and all dependencies (recursively)
 2,554,356 (0.0%)      pub fn lang_items(self) -> &'tcx rustc_hir::lang_items::LanguageItems {
         .                 self.get_lang_items(())
 2,189,448 (0.0%)      }
         .         
         .             /// Gets a `Ty` representing the [`LangItem::OrderingEnum`]
         .             #[track_caller]
         .             pub fn ty_ordering_enum(self, span: Option<Span>) -> Ty<'tcx> {
         .                 let ordering_enum = self.require_lang_item(hir::LangItem::OrderingEnum, span);
         .                 self.type_of(ordering_enum).no_bound_vars().unwrap()
         .             }
         .         
-- line 991 ----------------------------------------
-- line 1000 ----------------------------------------
         .                 self.diagnostic_items(id.krate).id_to_name.get(&id).copied()
         .             }
         .         
         .             /// Check whether the diagnostic item with the given `name` has the given `DefId`.
         .             pub fn is_diagnostic_item(self, name: Symbol, did: DefId) -> bool {
         .                 self.diagnostic_items(did.krate).name_to_id.get(&name) == Some(&did)
         .             }
         .         
        20 (0.0%)      pub fn is_coroutine(self, def_id: DefId) -> bool {
         .                 self.coroutine_kind(def_id).is_some()
        10 (0.0%)      }
         .         
         .             /// Returns the movability of the coroutine of `def_id`, or panics
         .             /// if given a `def_id` that is not a coroutine.
         .             pub fn coroutine_movability(self, def_id: DefId) -> hir::Movability {
         .                 self.coroutine_kind(def_id).expect("expected a coroutine").movability()
         .             }
         .         
         .             /// Returns `true` if the node pointed to by `def_id` is a coroutine for an async construct.
-- line 1018 ----------------------------------------
-- line 1040 ----------------------------------------
         .             /// Returns `true` if the node pointed to by `def_id` is a coroutine for a `async gen` construct.
         .             pub fn coroutine_is_async_gen(self, def_id: DefId) -> bool {
         .                 matches!(
         .                     self.coroutine_kind(def_id),
         .                     Some(hir::CoroutineKind::Desugared(hir::CoroutineDesugaring::AsyncGen, _))
         .                 )
         .             }
         .         
     6,734 (0.0%)      pub fn stability(self) -> &'tcx stability::Index {
         .                 self.stability_index(())
     5,772 (0.0%)      }
         .         
 1,278,403 (0.0%)      pub fn features(self) -> &'tcx rustc_feature::Features {
         .                 self.features_query(())
 1,095,774 (0.0%)      }
         .         
 2,595,528 (0.0%)      pub fn def_key(self, id: impl IntoQueryParam<DefId>) -> rustc_hir::definitions::DefKey {
         .                 let id = id.into_query_param();
         .                 // Accessing the DefKey is ok, since it is part of DefPathHash.
         .                 if let Some(id) = id.as_local() {
         .                     self.definitions_untracked().def_key(id)
         .                 } else {
   422,622 (0.0%)              self.cstore_untracked().def_key(id)
         .                 }
 2,595,528 (0.0%)      }
         .         
         .             /// Converts a `DefId` into its fully expanded `DefPath` (every
         .             /// `DefId` is really just an interned `DefPath`).
         .             ///
         .             /// Note that if `id` is not local to this crate, the result will
         .             ///  be a non-local `DefPath`.
    36,670 (0.0%)      pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {
         .                 // Accessing the DefPath is ok, since it is part of DefPathHash.
         .                 if let Some(id) = id.as_local() {
       548 (0.0%)              self.definitions_untracked().def_path(id)
         .                 } else {
     6,786 (0.0%)              self.cstore_untracked().def_path(id)
         .                 }
    33,003 (0.0%)      }
         .         
         .             #[inline]
 3,779,262 (0.0%)      pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {
         .                 // Accessing the DefPathHash is ok, it is incr. comp. stable.
         .                 if let Some(def_id) = def_id.as_local() {
         .                     self.definitions_untracked().def_path_hash(def_id)
         .                 } else {
 1,517,967 (0.0%)              self.cstore_untracked().def_path_hash(def_id)
         .                 }
 3,779,262 (0.0%)      }
         .         
         .             #[inline]
         .             pub fn crate_types(self) -> &'tcx [CrateType] {
    11,555 (0.0%)          &self.crate_types
         .             }
         .         
         .             pub fn metadata_kind(self) -> MetadataKind {
         .                 self.crate_types()
         .                     .iter()
    15,249 (0.0%)              .map(|ty| match *ty {
         .                         CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => {
         .                             MetadataKind::None
         .                         }
         .                         CrateType::Rlib => MetadataKind::Uncompressed,
         .                         CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,
         .                     })
         .                     .max()
         .                     .unwrap_or(MetadataKind::None)
         .             }
         .         
         .             pub fn needs_metadata(self) -> bool {
         .                 self.metadata_kind() != MetadataKind::None
         .             }
         .         
         3 (0.0%)      pub fn needs_crate_hash(self) -> bool {
         .                 // Why is the crate hash needed for these configurations?
         .                 // - debug_assertions: for the "fingerprint the result" check in
         .                 //   `rustc_query_system::query::plumbing::execute_job`.
         .                 // - incremental: for query lookups.
         .                 // - needs_metadata: for putting into crate metadata.
         .                 // - instrument_coverage: for putting into coverage data (see
         .                 //   `hash_mir_source`).
         .                 cfg!(debug_assertions)
    10,167 (0.0%)              || self.sess.opts.incremental.is_some()
     5,083 (0.0%)              || self.needs_metadata()
         .                     || self.sess.instrument_coverage()
         3 (0.0%)      }
         .         
         .             #[inline]
         .             pub fn stable_crate_id(self, crate_num: CrateNum) -> StableCrateId {
         .                 if crate_num == LOCAL_CRATE {
         .                     self.stable_crate_id
         .                 } else {
         .                     self.cstore_untracked().stable_crate_id(crate_num)
         .                 }
-- line 1133 ----------------------------------------
-- line 1187 ----------------------------------------
         .                     // Don't print the whole stable crate id. That's just
         .                     // annoying in debug output.
         .                     stable_crate_id.as_u64() >> (8 * 6),
         .                     self.def_path(def_id).to_string_no_crate_verbose()
         .                 )
         .             }
         .         
         .             pub fn dcx(self) -> &'tcx DiagCtxt {
   143,312 (0.0%)          self.sess.dcx()
         .             }
         .         }
         .         
         .         impl<'tcx> TyCtxtAt<'tcx> {
         .             /// Create a new definition within the incr. comp. engine.
    11,601 (0.0%)      pub fn create_def(
         .                 self,
         .                 parent: LocalDefId,
         .                 name: Symbol,
         .                 def_kind: DefKind,
         .             ) -> TyCtxtFeed<'tcx, LocalDefId> {
     5,156 (0.0%)          let feed = self.tcx.create_def(parent, name, def_kind);
         .         
     1,289 (0.0%)          feed.def_span(self.span);
         .                 feed
    12,890 (0.0%)      }
         .         }
         .         
         .         impl<'tcx> TyCtxt<'tcx> {
         .             /// `tcx`-dependent operations performed for every created definition.
   101,568 (0.0%)      pub fn create_def(
         .                 self,
         .                 parent: LocalDefId,
         .                 name: Symbol,
         .                 def_kind: DefKind,
         .             ) -> TyCtxtFeed<'tcx, LocalDefId> {
         .                 let data = def_kind.def_path_data(name);
         .                 // The following call has the side effect of modifying the tables inside `definitions`.
         .                 // These very tables are relied on by the incr. comp. engine to decode DepNodes and to
-- line 1224 ----------------------------------------
-- line 1229 ----------------------------------------
         .                 // - has been created by this call to `create_def`.
         .                 // As a consequence, this LocalDefId is always re-created before it is needed by the incr.
         .                 // comp. engine itself.
         .                 //
         .                 // This call also writes to the value of `source_span` and `expn_that_defined` queries.
         .                 // This is fine because:
         .                 // - those queries are `eval_always` so we won't miss their result changing;
         .                 // - this write will have happened before these queries are called.
    25,392 (0.0%)          let def_id = self.untracked.definitions.write().create_def(parent, data);
         .         
         .                 // This function modifies `self.definitions` using a side-effect.
         .                 // We need to ensure that these side effects are re-run by the incr. comp. engine.
         .                 // Depending on the forever-red node will tell the graph that the calling query
         .                 // needs to be re-evaluated.
     8,464 (0.0%)          self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);
         .         
         .                 let feed = TyCtxtFeed { tcx: self, key: def_id };
         .                 feed.def_kind(def_kind);
         .                 // Unique types created for closures participate in type privacy checking.
         .                 // They have visibilities inherited from the module they are defined in.
         .                 // Visibilities for opaque types are meaningless, but still provided
         .                 // so that all items have visibilities.
    33,640 (0.0%)          if matches!(def_kind, DefKind::Closure | DefKind::OpaqueTy) {
         .                     let parent_mod = self.parent_module_from_def_id(def_id).to_def_id();
         .                     feed.visibility(ty::Visibility::Restricted(parent_mod));
         .                 }
         .         
         .                 feed
    84,640 (0.0%)      }
         .         
         .             pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {
         .                 // Create a dependency to the red node to be sure we re-execute this when the amount of
         .                 // definitions change.
         .                 self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);
         .         
         .                 let definitions = &self.untracked.definitions;
         .                 std::iter::from_coroutine(|| {
-- line 1265 ----------------------------------------
-- line 1309 ----------------------------------------
         .             /// Give out access to the untracked data without any sanity checks.
         .             pub fn untracked(self) -> &'tcx Untracked {
         .                 &self.untracked
         .             }
         .             /// Note that this is *untracked* and should only be used within the query
         .             /// system if the result is otherwise tracked through queries
         .             #[inline]
         .             pub fn definitions_untracked(self) -> FreezeReadGuard<'tcx, Definitions> {
       274 (0.0%)          self.untracked.definitions.read()
         .             }
         .         
         .             /// Note that this is *untracked* and should only be used within the query
         .             /// system if the result is otherwise tracked through queries
         .             #[inline]
         .             pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {
         .                 self.untracked.source_span.get(def_id).unwrap_or(DUMMY_SP)
         .             }
         .         
         .             #[inline(always)]
         .             pub fn with_stable_hashing_context<R>(
         .                 self,
         .                 f: impl FnOnce(StableHashingContext<'_>) -> R,
         .             ) -> R {
   328,748 (0.0%)          f(StableHashingContext::new(self.sess, &self.untracked))
         .             }
         .         
         .             pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {
         .                 self.query_system.on_disk_cache.as_ref().map_or(Ok(0), |c| c.serialize(self, encoder))
         .             }
         .         
         .             #[inline]
         .             pub fn local_crate_exports_generics(self) -> bool {
-- line 1340 ----------------------------------------
-- line 1459 ----------------------------------------
         .                     self,
         .                     self.lifetimes.re_static,
         .                     self.type_of(self.require_lang_item(LangItem::PanicLocation, None))
         .                         .instantiate(self, self.mk_args(&[self.lifetimes.re_static.into()])),
         .                 )
         .             }
         .         
         .             /// Returns a displayable description and article for the given `def_id` (e.g. `("a", "struct")`).
    17,856 (0.0%)      pub fn article_and_description(self, def_id: DefId) -> (&'static str, &'static str) {
         .                 let kind = self.def_kind(def_id);
    26,784 (0.0%)          (self.def_kind_descr_article(kind, def_id), self.def_kind_descr(kind, def_id))
    13,392 (0.0%)      }
         .         
         .             pub fn type_length_limit(self) -> Limit {
         .                 self.limits(()).type_length_limit
         .             }
         .         
 2,423,820 (0.0%)      pub fn recursion_limit(self) -> Limit {
         .                 self.limits(()).recursion_limit
 2,077,560 (0.0%)      }
         .         
         .             pub fn move_size_limit(self) -> Limit {
         .                 self.limits(()).move_size_limit
         .             }
         .         
     2,040 (0.0%)      pub fn all_traits(self) -> impl Iterator<Item = DefId> + 'tcx {
         .                 iter::once(LOCAL_CRATE)
         .                     .chain(self.crates(()).iter().copied())
         .                     .flat_map(move |cnum| self.traits(cnum).iter().copied())
     1,836 (0.0%)      }
         .         
         .             #[inline]
     1,986 (0.0%)      pub fn local_visibility(self, def_id: LocalDefId) -> Visibility {
   119,823 (0.0%)          self.visibility(def_id).expect_local()
         .             }
         .         
         .             /// Returns the origin of the opaque type `def_id`.
       108 (0.0%)      #[instrument(skip(self), level = "trace", ret)]
         .             pub fn opaque_type_origin(self, def_id: LocalDefId) -> hir::OpaqueTyOrigin {
       135 (0.0%)          self.hir().expect_item(def_id).expect_opaque_ty().origin
         .             }
         .         }
         .         
         .         /// A trait implemented for all `X<'a>` types that can be safely and
         .         /// efficiently converted to `X<'tcx>` as long as they are part of the
         .         /// provided `TyCtxt<'tcx>`.
         .         /// This can be done, for example, for `Ty<'tcx>` or `GenericArgsRef<'tcx>`
         .         /// by looking them up in their respective interners.
-- line 1506 ----------------------------------------
-- line 1520 ----------------------------------------
         .             type Lifted: fmt::Debug + 'tcx;
         .             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;
         .         }
         .         
         .         macro_rules! nop_lift {
         .             ($set:ident; $ty:ty => $lifted:ty) => {
         .                 impl<'a, 'tcx> Lift<'tcx> for $ty {
         .                     type Lifted = $lifted;
    73,730 (0.0%)              fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {
         .                         // Assert that the set has the right type.
         .                         // Given an argument that has an interned type, the return type has the type of
         .                         // the corresponding interner set. This won't actually return anything, we're
         .                         // just doing this to compute said type!
         .                         fn _intern_set_ty_from_interned_ty<'tcx, Inner>(
         .                             _x: Interned<'tcx, Inner>,
         .                         ) -> InternedSet<'tcx, Inner> {
         .                             unreachable!()
-- line 1536 ----------------------------------------
-- line 1540 ----------------------------------------
         .                             // If `x` is a newtype around an `Interned<T>`, then `interner` is an
         .                             // interner of appropriate type. (Ideally we'd also check that `x` is a
         .                             // newtype with just that one field. Not sure how to do that.)
         .                             let interner = _intern_set_ty_from_interned_ty(x.0);
         .                             // Now check that this is the same type as `interners.$set`.
         .                             _type_eq(&interner, &tcx.interners.$set);
         .                         }
         .         
     7,373 (0.0%)                  tcx.interners
         .                             .$set
         .                             .contains_pointer_to(&InternedInSet(&*self.0.0))
         .                             // SAFETY: `self` is interned and therefore valid
         .                             // for the entire lifetime of the `TyCtxt`.
         .                             .then(|| unsafe { mem::transmute(self) })
    58,984 (0.0%)              }
         .                 }
         .             };
         .         }
         .         
         .         macro_rules! nop_list_lift {
         .             ($set:ident; $ty:ty => $lifted:ty) => {
         .                 impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {
         .                     type Lifted = &'tcx List<$lifted>;
    15,066 (0.0%)              fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {
         .                         // Assert that the set has the right type.
         .                         if false {
         .                             let _x: &InternedSet<'tcx, List<$lifted>> = &tcx.interners.$set;
         .                         }
         .         
     5,022 (0.0%)                  if self.is_empty() {
         .                             return Some(List::empty());
         .                         }
     2,511 (0.0%)                  tcx.interners
         .                             .$set
         .                             .contains_pointer_to(&InternedInSet(self))
         .                             .then(|| unsafe { mem::transmute(self) })
    15,066 (0.0%)              }
         .                 }
         .             };
         .         }
         .         
         .         nop_lift! {type_; Ty<'a> => Ty<'tcx>}
         .         nop_lift! {region; Region<'a> => Region<'tcx>}
         .         nop_lift! {const_; Const<'a> => Const<'tcx>}
         .         nop_lift! {pat; Pattern<'a> => Pattern<'tcx>}
-- line 1584 ----------------------------------------
-- line 1775 ----------------------------------------
         .             }
         .         }
         .         
         .         impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {}
         .         
         .         impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, WithCachedTypeInfo<T>> {
         .             fn hash<H: Hasher>(&self, s: &mut H) {
         .                 // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.
   237,621 (0.0%)          self.0.internee.hash(s)
         .             }
         .         }
         .         
         .         impl<'tcx, T> Borrow<[T]> for InternedInSet<'tcx, List<T>> {
         .             fn borrow(&self) -> &[T] {
         .                 &self.0[..]
         .             }
         .         }
-- line 1791 ----------------------------------------
-- line 1847 ----------------------------------------
         .                 }
         .         
         .                 impl<'tcx> Eq for InternedInSet<'tcx, $ty> {}
         .         
         .                 impl<'tcx> Hash for InternedInSet<'tcx, $ty> {
         .                     fn hash<H: Hasher>(&self, s: &mut H) {
         .                         // The `Borrow` trait requires that `x.borrow().hash(s) ==
         .                         // x.hash(s)`.
    58,216 (0.0%)                  self.0.hash(s)
         .                     }
         .                 }
         .         
         .                 impl<'tcx> TyCtxt<'tcx> {
   560,813 (0.0%)              $vis fn $method(self, v: $ty) -> $ret_ty {
    57,680 (0.0%)                  $ret_ctor(Interned::new_unchecked(self.interners.$name.intern(v, |v| {
    30,262 (0.0%)                      InternedInSet(self.interners.arena.alloc(v))
         .                         }).0))
   519,120 (0.0%)              }
         .                 })+
         .             }
         .         }
         .         
         .         // Functions with a `mk_` prefix are intended for use outside this file and
         .         // crate. Functions with an `intern_` prefix are intended for use within this
         .         // crate only, and have a corresponding `mk_` function.
         .         direct_interners! {
-- line 1872 ----------------------------------------
-- line 1879 ----------------------------------------
         .                 ExternalConstraints -> ExternalConstraints<'tcx>,
         .             predefined_opaques_in_body: pub mk_predefined_opaques_in_body(PredefinedOpaquesData<'tcx>):
         .                 PredefinedOpaques -> PredefinedOpaques<'tcx>,
         .         }
         .         
         .         macro_rules! slice_interners {
         .             ($($field:ident: $vis:vis $method:ident($ty:ty)),+ $(,)?) => (
         .                 impl<'tcx> TyCtxt<'tcx> {
18,404,440 (0.2%)              $($vis fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {
 4,601,960 (0.1%)                  if v.is_empty() {
         .                             List::empty()
         .                         } else {
 1,436,284 (0.0%)                      self.interners.$field.intern_ref(v, || {
   212,046 (0.0%)                          InternedInSet(List::from_arena(&*self.arena, (), v))
         .                             }).0
         .                         }
20,704,995 (0.3%)              })+
         .                 }
         .             );
         .         }
         .         
         .         // These functions intern slices. They all have a corresponding
         .         // `mk_foo_from_iter` function that interns an iterator. The slice version
         .         // should be used when possible, because it's faster.
         .         slice_interners!(
-- line 1903 ----------------------------------------
-- line 1924 ----------------------------------------
         .                 Ty::new_fn_ptr(
         .                     self,
         .                     sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }),
         .                 )
         .             }
         .         
         .             /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`
         .             /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.
     2,412 (0.0%)      pub fn trait_may_define_assoc_item(self, trait_def_id: DefId, assoc_name: Ident) -> bool {
         .                 self.super_traits_of(trait_def_id).any(|trait_did| {
       202 (0.0%)              self.associated_items(trait_did)
         .                         .filter_by_name_unhygienic(assoc_name.name)
       298 (0.0%)                  .any(|item| self.hygienic_eq(assoc_name, item.ident(self), trait_did))
         .                 })
     1,809 (0.0%)      }
         .         
         .             /// Given a `ty`, return whether it's an `impl Future<...>`.
         .             pub fn ty_is_opaque_future(self, ty: Ty<'_>) -> bool {
         .                 let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind() else { return false };
         .                 let future_trait = self.require_lang_item(LangItem::Future, None);
         .         
         .                 self.explicit_item_super_predicates(def_id).skip_binder().iter().any(|&(predicate, _)| {
         .                     let ty::ClauseKind::Trait(trait_predicate) = predicate.kind().skip_binder() else {
-- line 1946 ----------------------------------------
-- line 1952 ----------------------------------------
         .             }
         .         
         .             /// Computes the def-ids of the transitive supertraits of `trait_def_id`. This (intentionally)
         .             /// does not compute the full elaborated super-predicates but just the set of def-ids. It is used
         .             /// to identify which traits may define a given associated type to help avoid cycle errors.
         .             /// Returns a `DefId` iterator.
         .             fn super_traits_of(self, trait_def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {
         .                 let mut set = FxHashSet::default();
       804 (0.0%)          let mut stack = vec![trait_def_id];
         .         
         .                 set.insert(trait_def_id);
         .         
         .                 iter::from_fn(move || -> Option<DefId> {
         .                     let trait_did = stack.pop()?;
       202 (0.0%)              let generic_predicates = self.super_predicates_of(trait_did);
         .         
         .                     for (predicate, _) in generic_predicates.predicates {
       174 (0.0%)                  if let ty::ClauseKind::Trait(data) = predicate.kind().skip_binder() {
         .                             if set.insert(data.def_id()) {
         .                                 stack.push(data.def_id());
         .                             }
         .                         }
         .                     }
         .         
         .                     Some(trait_did)
         .                 })
-- line 1977 ----------------------------------------
-- line 1995 ----------------------------------------
         .                         _ => bug!(),
         .                     };
         .                     self.mk_fn_sig(params, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)
         .                 })
         .             }
         .         
         .             #[inline]
         .             pub fn mk_predicate(self, binder: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {
 1,594,569 (0.0%)          self.interners.intern_predicate(
         .                     binder,
   711,247 (0.0%)              self.sess,
         .                     // This is only used to create a stable hashing context.
 1,361,013 (0.0%)              &self.untracked,
         .                 )
         .             }
         .         
         .             #[inline]
 8,355,288 (0.1%)      pub fn reuse_or_mk_predicate(
         .                 self,
         .                 pred: Predicate<'tcx>,
         .                 binder: Binder<'tcx, PredicateKind<'tcx>>,
         .             ) -> Predicate<'tcx> {
 1,616,166 (0.0%)          if pred.kind() != binder { self.mk_predicate(binder) } else { pred }
 6,962,740 (0.1%)      }
         .         
     2,072 (0.0%)      pub fn check_args_compatible(self, def_id: DefId, args: &'tcx [ty::GenericArg<'tcx>]) -> bool {
     3,108 (0.0%)          self.check_args_compatible_inner(def_id, args, false)
         .             }
         .         
    29,008 (0.0%)      fn check_args_compatible_inner(
         .                 self,
         .                 def_id: DefId,
         .                 args: &'tcx [ty::GenericArg<'tcx>],
         .                 nested: bool,
         .             ) -> bool {
         .                 let generics = self.generics_of(def_id);
         .         
         .                 // IATs themselves have a weird arg setup (self + own args), but nested items *in* IATs
         .                 // (namely: opaques, i.e. ATPITs) do not.
     4,144 (0.0%)          let own_args = if !nested
     2,072 (0.0%)              && let DefKind::AssocTy = self.def_kind(def_id)
     4,144 (0.0%)              && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(def_id))
         .                 {
         .                     if generics.params.len() + 1 != args.len() {
         .                         return false;
         .                     }
         .         
         .                     if !matches!(args[0].unpack(), ty::GenericArgKind::Type(_)) {
         .                         return false;
         .                     }
         .         
         .                     &args[1..]
         .                 } else {
     4,144 (0.0%)              if generics.count() != args.len() {
         .                         return false;
         .                     }
         .         
         .                     let (parent_args, own_args) = args.split_at(generics.parent_count);
         .         
     7,252 (0.0%)              if let Some(parent) = generics.parent
     5,180 (0.0%)                  && !self.check_args_compatible_inner(parent, parent_args, true)
         .                     {
         .                         return false;
         .                     }
         .         
         .                     own_args
         .                 };
         .         
    12,432 (0.0%)          for (param, arg) in std::iter::zip(&generics.params, own_args) {
    15,915 (0.0%)              match (&param.kind, arg.unpack()) {
         .                         (ty::GenericParamDefKind::Type { .. }, ty::GenericArgKind::Type(_))
         .                         | (ty::GenericParamDefKind::Lifetime, ty::GenericArgKind::Lifetime(_))
         .                         | (ty::GenericParamDefKind::Const { .. }, ty::GenericArgKind::Const(_)) => {}
         .                         _ => return false,
         .                     }
         .                 }
         .         
         .                 true
    16,576 (0.0%)      }
         .         
         .             /// With `cfg(debug_assertions)`, assert that args are compatible with their generics,
         .             /// and print out the args if not.
         .             pub fn debug_assert_args_compatible(self, def_id: DefId, args: &'tcx [ty::GenericArg<'tcx>]) {
         .                 if cfg!(debug_assertions) {
         .                     if !self.check_args_compatible(def_id, args) {
         .                         if let DefKind::AssocTy = self.def_kind(def_id)
         .                             && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(def_id))
-- line 2081 ----------------------------------------
-- line 2114 ----------------------------------------
         .             ) -> GenericArgsRef<'tcx> {
         .                 let args = self.mk_args_from_iter(args.into_iter().map(Into::into));
         .                 self.debug_assert_args_compatible(def_id, args);
         .                 args
         .             }
         .         
         .             #[inline]
         .             pub fn mk_ct_from_kind(self, kind: ty::ConstKind<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {
    20,846 (0.0%)          self.interners.intern_const(
    17,590 (0.0%)              ty::ConstData { kind, ty },
     5,606 (0.0%)              self.sess,
         .                     // This is only used to create a stable hashing context.
    11,212 (0.0%)              &self.untracked,
         .                 )
         .             }
         .         
         .             // Avoid this in favour of more specific `Ty::new_*` methods, where possible.
         .             #[allow(rustc::usage_of_ty_tykind)]
         .             #[inline]
         .             pub fn mk_ty_from_kind(self, st: TyKind<'tcx>) -> Ty<'tcx> {
 1,549,395 (0.0%)          self.interners.intern_ty(
         .                     st,
   505,004 (0.0%)              self.sess,
         .                     // This is only used to create a stable hashing context.
   955,741 (0.0%)              &self.untracked,
         .                 )
         .             }
         .         
    56,553 (0.0%)      pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {
    39,545 (0.0%)          match param.kind {
         .                     GenericParamDefKind::Lifetime => {
         .                         ty::Region::new_early_param(self, param.to_early_bound_region_data()).into()
         .                     }
    15,302 (0.0%)              GenericParamDefKind::Type { .. } => Ty::new_param(self, param.index, param.name).into(),
         .                     GenericParamDefKind::Const { .. } => ty::Const::new_param(
         .                         self,
         6 (0.0%)                  ParamConst { index: param.index, name: param.name },
         6 (0.0%)                  self.type_of(param.def_id)
         .                             .no_bound_vars()
         .                             .expect("const parameter types cannot be generic"),
         .                     )
         .                     .into(),
         .                 }
    48,474 (0.0%)      }
         .         
        12 (0.0%)      pub fn mk_place_field(self, place: Place<'tcx>, f: FieldIdx, ty: Ty<'tcx>) -> Place<'tcx> {
        20 (0.0%)          self.mk_place_elem(place, PlaceElem::Field(f, ty))
        12 (0.0%)      }
         .         
         .             pub fn mk_place_deref(self, place: Place<'tcx>) -> Place<'tcx> {
         .                 self.mk_place_elem(place, PlaceElem::Deref)
         .             }
         .         
         .             pub fn mk_place_downcast(
         .                 self,
         .                 place: Place<'tcx>,
-- line 2169 ----------------------------------------
-- line 2186 ----------------------------------------
         .         
         .             pub fn mk_place_index(self, place: Place<'tcx>, index: Local) -> Place<'tcx> {
         .                 self.mk_place_elem(place, PlaceElem::Index(index))
         .             }
         .         
         .             /// This method copies `Place`'s projection, add an element and reintern it. Should not be used
         .             /// to build a full `Place` it's just a convenient way to grab a projection and modify it in
         .             /// flight.
        44 (0.0%)      pub fn mk_place_elem(self, place: Place<'tcx>, elem: PlaceElem<'tcx>) -> Place<'tcx> {
         4 (0.0%)          let mut projection = place.projection.to_vec();
         .                 projection.push(elem);
         .         
         8 (0.0%)          Place { local: place.local, projection: self.mk_place_elems(&projection) }
        40 (0.0%)      }
         .         
    84,792 (0.0%)      pub fn mk_poly_existential_predicates(
         .                 self,
         .                 eps: &[PolyExistentialPredicate<'tcx>],
         .             ) -> &'tcx List<PolyExistentialPredicate<'tcx>> {
    21,198 (0.0%)          assert!(!eps.is_empty());
         .                 assert!(
         .                     eps.array_windows()
    76,904 (0.0%)                  .all(|[a, b]| a.skip_binder().stable_cmp(self, &b.skip_binder())
         .                             != Ordering::Greater)
         .                 );
         .                 self.intern_poly_existential_predicates(eps)
    95,391 (0.0%)      }
         .         
 1,465,296 (0.0%)      pub fn mk_clauses(self, clauses: &[Clause<'tcx>]) -> Clauses<'tcx> {
         .                 // FIXME consider asking the input slice to be sorted to avoid
         .                 // re-interning permutations, in which case that would be asserted
         .                 // here.
         .                 self.interners.intern_clauses(clauses)
 1,648,458 (0.0%)      }
         .         
     3,400 (0.0%)      pub fn mk_local_def_ids(self, clauses: &[LocalDefId]) -> &'tcx List<LocalDefId> {
         .                 // FIXME consider asking the input slice to be sorted to avoid
         .                 // re-interning permutations, in which case that would be asserted
         .                 // here.
         .                 self.intern_local_def_ids(clauses)
     3,825 (0.0%)      }
         .         
         .             pub fn mk_local_def_ids_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<LocalDefId, &'tcx List<LocalDefId>>,
         .             {
         .                 T::collect_and_apply(iter, |xs| self.mk_local_def_ids(xs))
         .             }
-- line 2234 ----------------------------------------
-- line 2251 ----------------------------------------
         .             {
         .                 T::collect_and_apply(iter, |xs| self.mk_const_list(xs))
         .             }
         .         
         .             // Unlike various other `mk_*_from_iter` functions, this one uses `I:
         .             // IntoIterator` instead of `I: Iterator`, and it doesn't have a slice
         .             // variant, because of the need to combine `inputs` and `output`. This
         .             // explains the lack of `_from_iter` suffix.
    13,454 (0.0%)      pub fn mk_fn_sig<I, T>(
         .                 self,
         .                 inputs: I,
         .                 output: I::Item,
         .                 c_variadic: bool,
         .                 unsafety: hir::Unsafety,
         .                 abi: abi::Abi,
         .             ) -> T::Output
         .             where
         .                 I: IntoIterator<Item = T>,
         .                 T: CollectAndApply<Ty<'tcx>, ty::FnSig<'tcx>>,
         .             {
     9,665 (0.0%)          T::collect_and_apply(inputs.into_iter().chain(iter::once(output)), |xs| ty::FnSig {
     2,003 (0.0%)              inputs_and_output: self.mk_type_list(xs),
         .                     c_variadic,
         .                     unsafety,
         .                     abi,
         .                 })
     7,688 (0.0%)      }
         .         
         .             pub fn mk_poly_existential_predicates_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<
         .                         PolyExistentialPredicate<'tcx>,
         .                         &'tcx List<PolyExistentialPredicate<'tcx>>,
         .                     >,
         .             {
    10,093 (0.0%)          T::collect_and_apply(iter, |xs| self.mk_poly_existential_predicates(xs))
         .             }
         .         
         .             pub fn mk_clauses_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<Clause<'tcx>, Clauses<'tcx>>,
         .             {
   190,099 (0.0%)          T::collect_and_apply(iter, |xs| self.mk_clauses(xs))
         .             }
         .         
         .             pub fn mk_type_list_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<Ty<'tcx>, &'tcx List<Ty<'tcx>>>,
         .             {
    80,868 (0.0%)          T::collect_and_apply(iter, |xs| self.mk_type_list(xs))
         .             }
         .         
         .             pub fn mk_args_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>,
         .             {
 3,512,221 (0.0%)          T::collect_and_apply(iter, |xs| self.mk_args(xs))
         .             }
         .         
         .             pub fn mk_canonical_var_infos_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<CanonicalVarInfo<'tcx>, &'tcx List<CanonicalVarInfo<'tcx>>>,
         .             {
         .                 T::collect_and_apply(iter, |xs| self.mk_canonical_var_infos(xs))
         .             }
         .         
         .             pub fn mk_place_elems_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>,
         .             {
    27,712 (0.0%)          T::collect_and_apply(iter, |xs| self.mk_place_elems(xs))
         .             }
         .         
         .             pub fn mk_fields_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<FieldIdx, &'tcx List<FieldIdx>>,
         .             {
         .                 T::collect_and_apply(iter, |xs| self.mk_fields(xs))
-- line 2335 ----------------------------------------
-- line 2351 ----------------------------------------
         .                 self.mk_args_from_iter(iter::once(self_ty.into()).chain(rest))
         .             }
         .         
         .             pub fn mk_bound_variable_kinds_from_iter<I, T>(self, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,
         .             {
 5,078,288 (0.1%)          T::collect_and_apply(iter, |xs| self.mk_bound_variable_kinds(xs))
         .             }
         .         
         .             /// Emit a lint at `span` from a lint struct (some type that implements `LintDiagnostic`,
         .             /// typically generated by `#[derive(LintDiagnostic)]`).
         .             #[track_caller]
         .             pub fn emit_node_span_lint(
         .                 self,
         .                 lint: &'static Lint,
-- line 2367 ----------------------------------------
-- line 2384 ----------------------------------------
         .             pub fn node_span_lint(
         .                 self,
         .                 lint: &'static Lint,
         .                 hir_id: HirId,
         .                 span: impl Into<MultiSpan>,
         .                 msg: impl Into<DiagMessage>,
         .                 decorate: impl for<'a, 'b> FnOnce(&'b mut Diag<'a, ()>),
         .             ) {
       306 (0.0%)          let (level, src) = self.lint_level_at_node(lint, hir_id);
        76 (0.0%)          lint_level(self.sess, lint, level, src, Some(span.into()), msg, decorate);
         .             }
         .         
         .             /// Find the crate root and the appropriate span where `use` and outer attributes can be
         .             /// inserted at.
         .             pub fn crate_level_attribute_injection_span(self, hir_id: HirId) -> Option<Span> {
         .                 for (_hir_id, node) in self.hir().parent_iter(hir_id) {
         .                     if let hir::Node::Crate(m) = node {
         .                         return Some(m.spans.inject_use_span.shrink_to_lo());
-- line 2401 ----------------------------------------
-- line 2457 ----------------------------------------
         .                 id: HirId,
         .                 msg: impl Into<DiagMessage>,
         .                 decorate: impl for<'a, 'b> FnOnce(&'b mut Diag<'a, ()>),
         .             ) {
         .                 let (level, src) = self.lint_level_at_node(lint, id);
         .                 lint_level(self.sess, lint, level, src, None, msg, decorate);
         .             }
         .         
     5,568 (0.0%)      pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx [TraitCandidate]> {
         .                 let map = self.in_scope_traits_map(id.owner)?;
         .                 let candidates = map.get(&id.local_id)?;
     1,856 (0.0%)          Some(candidates)
     3,712 (0.0%)      }
         .         
    65,080 (0.0%)      pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {
         .                 debug!(?id, "named_region");
         .                 self.named_variable_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())
    45,556 (0.0%)      }
         .         
    27,906 (0.0%)      pub fn is_late_bound(self, id: HirId) -> bool {
         .                 self.is_late_bound_map(id.owner).is_some_and(|set| set.contains(&id.local_id))
    18,604 (0.0%)      }
         .         
    35,464 (0.0%)      pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {
    12,896 (0.0%)          self.mk_bound_variable_kinds(
         .                     &self
         .                         .late_bound_vars_map(id.owner)
         .                         .and_then(|map| map.get(&id.local_id).cloned())
         .                         .unwrap_or_else(|| {
         .                             bug!("No bound vars found for {}", self.hir().node_to_string(id))
         .                         }),
         .                 )
    25,792 (0.0%)      }
         .         
         .             /// Given the def-id of an early-bound lifetime on an opaque corresponding to
         .             /// a duplicated captured lifetime, map it back to the early- or late-bound
         .             /// lifetime of the function from which it originally as captured. If it is
         .             /// a late-bound lifetime, this will represent the liberated (`ReLateParam`) lifetime
         .             /// of the signature.
         .             // FIXME(RPITIT): if we ever synthesize new lifetimes for RPITITs and not just
         .             // re-use the generics of the opaque, this function will need to be tweaked slightly.
       117 (0.0%)      pub fn map_opaque_lifetime_to_parent_lifetime(
         .                 self,
         .                 mut opaque_lifetime_param_def_id: LocalDefId,
         .             ) -> ty::Region<'tcx> {
         .                 debug_assert!(
         .                     matches!(self.def_kind(opaque_lifetime_param_def_id), DefKind::LifetimeParam),
         .                     "{opaque_lifetime_param_def_id:?} is a {}",
         .                     self.def_descr(opaque_lifetime_param_def_id.to_def_id())
         .                 );
         .         
         .                 loop {
         .                     let parent = self.local_parent(opaque_lifetime_param_def_id);
         .                     let hir::OpaqueTy { lifetime_mapping, .. } =
        60 (0.0%)                  self.hir_node_by_def_id(parent).expect_item().expect_opaque_ty();
         .         
        20 (0.0%)              let Some((lifetime, _)) = lifetime_mapping
         .                         .iter()
         .                         .find(|(_, duplicated_param)| *duplicated_param == opaque_lifetime_param_def_id)
         .                     else {
         .                         bug!("duplicated lifetime param should be present");
         .                     };
         .         
       108 (0.0%)              match self.named_bound_var(lifetime.hir_id) {
         4 (0.0%)                  Some(resolve_bound_vars::ResolvedArg::EarlyBound(ebv)) => {
         .                             let new_parent = self.parent(ebv);
         .         
         .                             // If we map to another opaque, then it should be a parent
         .                             // of the opaque we mapped from. Continue mapping.
         2 (0.0%)                      if matches!(self.def_kind(new_parent), DefKind::OpaqueTy) {
         .                                 debug_assert_eq!(self.parent(parent.to_def_id()), new_parent);
         .                                 opaque_lifetime_param_def_id = ebv.expect_local();
         .                                 continue;
         .                             }
         .         
         .                             let generics = self.generics_of(new_parent);
         .                             return ty::Region::new_early_param(
         .                                 self,
-- line 2534 ----------------------------------------
-- line 2536 ----------------------------------------
         .                                     def_id: ebv,
         .                                     index: generics
         .                                         .param_def_id_to_index(self, ebv)
         .                                         .expect("early-bound var should be present in fn generics"),
         .                                     name: self.hir().name(self.local_def_id_to_hir_id(ebv.expect_local())),
         .                                 },
         .                             );
         .                         }
        45 (0.0%)                  Some(resolve_bound_vars::ResolvedArg::LateBound(_, _, lbv)) => {
         .                             let new_parent = self.parent(lbv);
         .                             return ty::Region::new_late_param(
         .                                 self,
         .                                 new_parent,
         .                                 ty::BoundRegionKind::BrNamed(
         .                                     lbv,
        27 (0.0%)                              self.hir().name(self.local_def_id_to_hir_id(lbv.expect_local())),
         .                                 ),
         .                             );
         .                         }
         .                         Some(resolve_bound_vars::ResolvedArg::Error(guar)) => {
         .                             return ty::Region::new_error(self, guar);
         .                         }
         .                         _ => {
         .                             return ty::Region::new_error_with_message(
         .                                 self,
         .                                 lifetime.ident.span,
         .                                 "cannot resolve lifetime",
         .                             );
         .                         }
         .                     }
         .                 }
        72 (0.0%)      }
         .         
         .             /// Whether the `def_id` counts as const fn in the current crate, considering all active
         .             /// feature gates
    27,500 (0.0%)      pub fn is_const_fn(self, def_id: DefId) -> bool {
     5,500 (0.0%)          if self.is_const_fn_raw(def_id) {
        93 (0.0%)              match self.lookup_const_stability(def_id) {
         .                         Some(stability) if stability.is_const_unstable() => {
         .                             // has a `rustc_const_unstable` attribute, check whether the user enabled the
         .                             // corresponding feature gate.
         8 (0.0%)                      self.features()
         .                                 .declared_lib_features
         .                                 .iter()
         .                                 .any(|&(sym, _)| sym == stability.feature)
         .                         }
         .                         // functions without const stability are either stable user written
         .                         // const fn or the user is using feature gates and we thus don't
         .                         // care what they do
         .                         _ => true,
         .                     }
         .                 } else {
         .                     false
         .                 }
    19,250 (0.0%)      }
         .         
         .             /// Whether the trait impl is marked const. This does not consider stability or feature gates.
         .             pub fn is_const_trait_impl_raw(self, def_id: DefId) -> bool {
         .                 let Some(local_def_id) = def_id.as_local() else { return false };
         .                 let node = self.hir_node_by_def_id(local_def_id);
         .         
     1,508 (0.0%)          matches!(
         .                     node,
         .                     hir::Node::Item(hir::Item {
       377 (0.0%)                  kind: hir::ItemKind::Impl(hir::Impl { generics, .. }),
         .                         ..
     1,559 (0.0%)              }) if generics.params.iter().any(|p| matches!(p.kind, hir::GenericParamKind::Const { is_host_effect: true, .. }))
         .                 )
     2,262 (0.0%)      }
         .         
         .             pub fn intrinsic(self, def_id: impl IntoQueryParam<DefId> + Copy) -> Option<ty::IntrinsicDef> {
     3,596 (0.0%)          match self.def_kind(def_id) {
         .                     DefKind::Fn | DefKind::AssocFn => {}
         .                     _ => return None,
         .                 }
         .                 self.intrinsic_raw(def_id)
         .             }
         .         
   211,156 (0.0%)      pub fn next_trait_solver_globally(self) -> bool {
   211,156 (0.0%)          self.sess.opts.unstable_opts.next_solver.map_or(false, |c| c.globally)
   211,156 (0.0%)      }
         .         
       288 (0.0%)      pub fn next_trait_solver_in_coherence(self) -> bool {
       288 (0.0%)          self.sess.opts.unstable_opts.next_solver.map_or(false, |c| c.coherence)
       288 (0.0%)      }
         .         
    88,758 (0.0%)      pub fn is_impl_trait_in_trait(self, def_id: DefId) -> bool {
         .                 self.opt_rpitit_info(def_id).is_some()
    59,172 (0.0%)      }
         .         
         .             /// Named module children from all kinds of items, including imports.
         .             /// In addition to regular items this list also includes struct and variant constructors, and
         .             /// items inside `extern {}` blocks because all of them introduce names into parent module.
         .             ///
         .             /// Module here is understood in name resolution sense - it can be a `mod` item,
         .             /// or a crate root, or an enum, or a trait.
         .             ///
         .             /// This is not a query, making it a query causes perf regressions
         .             /// (probably due to hashing spans in `ModChild`ren).
    38,772 (0.0%)      pub fn module_children_local(self, def_id: LocalDefId) -> &'tcx [ModChild] {
         .                 self.resolutions(()).module_children.get(&def_id).map_or(&[], |v| &v[..])
    30,156 (0.0%)      }
         .         
        28 (0.0%)      pub fn resolver_for_lowering(self) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {
         .                 self.resolver_for_lowering_raw(()).0
        24 (0.0%)      }
         .         
         .             /// Given an `impl_id`, return the trait it implements.
         .             /// Return `None` if this is an inherent impl.
       468 (0.0%)      pub fn impl_trait_ref(
         .                 self,
         .                 def_id: impl IntoQueryParam<DefId>,
         .             ) -> Option<ty::EarlyBinder<ty::TraitRef<'tcx>>> {
       234 (0.0%)          Some(self.impl_trait_header(def_id)?.trait_ref)
     1,233 (0.0%)      }
         .         
         .             pub fn impl_polarity(self, def_id: impl IntoQueryParam<DefId>) -> ty::ImplPolarity {
         .                 self.impl_trait_header(def_id).map_or(ty::ImplPolarity::Positive, |h| h.polarity)
         .             }
         .         }
         .         
         .         /// Parameter attributes that can only be determined by examining the body of a function instead
         .         /// of just its signature.
-- line 2658 ----------------------------------------
-- line 2674 ----------------------------------------
         .                 |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;
         .             providers.names_imported_by_glob_use = |tcx, id| {
         .                 tcx.arena.alloc(UnordSet::from(
         .                     tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default(),
         .                 ))
         .             };
         .         
         .             providers.extern_mod_stmt_cnum =
         1 (0.0%)          |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();
         .             providers.is_panic_runtime =
         .                 |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);
         .             providers.is_compiler_builtins =
         6 (0.0%)          |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);
         .             providers.has_panic_handler = |tcx, LocalCrate| {
         .                 // We want to check if the panic handler was defined in this crate
         .                 tcx.lang_items().panic_impl().is_some_and(|did| did.is_local())
         .             };
         .             providers.source_span = |tcx, def_id| tcx.untracked.source_span.get(def_id).unwrap_or(DUMMY_SP);
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/fold.rs
--------------------------------------------------------------------------------
Ir_______________ 

    30,852 (0.0%)  <unknown (line 0)>

-- line 86 ----------------------------------------
         .         }
         .         
         .         impl<'a, 'tcx> RegionFolder<'a, 'tcx> {
         .             #[inline]
         .             pub fn new(
         .                 tcx: TyCtxt<'tcx>,
         .                 fold_region_fn: &'a mut dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,
         .             ) -> RegionFolder<'a, 'tcx> {
    99,655 (0.0%)          RegionFolder { tcx, current_index: ty::INNERMOST, fold_region_fn }
         .             }
         .         }
         .         
         .         impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for RegionFolder<'a, 'tcx> {
         .             fn interner(&self) -> TyCtxt<'tcx> {
         .                 self.tcx
         .             }
         .         
     1,480 (0.0%)      fn fold_binder<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 &mut self,
         .                 t: ty::Binder<'tcx, T>,
         .             ) -> ty::Binder<'tcx, T> {
         .                 self.current_index.shift_in(1);
       925 (0.0%)          let t = t.super_fold_with(self);
         .                 self.current_index.shift_out(1);
     1,110 (0.0%)          t
     1,480 (0.0%)      }
         .         
    17,081 (0.0%)      #[instrument(skip(self), level = "debug", ret)]
         .             fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {
    17,078 (0.0%)          match *r {
         1 (0.0%)              ty::ReBound(debruijn, _) if debruijn < self.current_index => {
         .                         debug!(?self.current_index, "skipped bound region");
         .                         r
         .                     }
         .                     _ => {
         .                         debug!(?self.current_index, "folding free region");
    59,766 (0.0%)                  (self.fold_region_fn)(r, self.current_index)
         .                     }
         .                 }
         .             }
         .         }
         .         
         .         ///////////////////////////////////////////////////////////////////////////
         .         // Bound vars replacer
         .         
-- line 130 ----------------------------------------
-- line 136 ----------------------------------------
         .         
         .         pub struct FnMutDelegate<'a, 'tcx> {
         .             pub regions: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),
         .             pub types: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),
         .             pub consts: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a),
         .         }
         .         
         .         impl<'a, 'tcx> BoundVarReplacerDelegate<'tcx> for FnMutDelegate<'a, 'tcx> {
    58,596 (0.0%)      fn replace_region(&mut self, br: ty::BoundRegion) -> ty::Region<'tcx> {
   136,724 (0.0%)          (self.regions)(br)
    58,596 (0.0%)      }
    41,469 (0.0%)      fn replace_ty(&mut self, bt: ty::BoundTy) -> Ty<'tcx> {
    96,761 (0.0%)          (self.types)(bt)
    41,469 (0.0%)      }
         4 (0.0%)      fn replace_const(&mut self, bv: ty::BoundVar, ty: Ty<'tcx>) -> ty::Const<'tcx> {
        12 (0.0%)          (self.consts)(bv, ty)
         .             }
         .         }
         .         
         .         /// Replaces the escaping bound vars (late bound regions or bound types) in a type.
         .         struct BoundVarReplacer<'tcx, D> {
         .             tcx: TyCtxt<'tcx>,
         .         
         .             /// As with `RegionFolder`, represents the index of a binder *just outside*
-- line 159 ----------------------------------------
-- line 160 ----------------------------------------
         .             /// the ones we have visited.
         .             current_index: ty::DebruijnIndex,
         .         
         .             delegate: D,
         .         }
         .         
         .         impl<'tcx, D: BoundVarReplacerDelegate<'tcx>> BoundVarReplacer<'tcx, D> {
         .             fn new(tcx: TyCtxt<'tcx>, delegate: D) -> Self {
   254,952 (0.0%)          BoundVarReplacer { tcx, current_index: ty::INNERMOST, delegate }
         .             }
         .         }
         .         
         .         impl<'tcx, D> TypeFolder<TyCtxt<'tcx>> for BoundVarReplacer<'tcx, D>
         .         where
         .             D: BoundVarReplacerDelegate<'tcx>,
         .         {
         .             fn interner(&self) -> TyCtxt<'tcx> {
         .                 self.tcx
         .             }
         .         
    32,736 (0.0%)      fn fold_binder<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 &mut self,
         .                 t: ty::Binder<'tcx, T>,
         .             ) -> ty::Binder<'tcx, T> {
         .                 self.current_index.shift_in(1);
    20,464 (0.0%)          let t = t.super_fold_with(self);
         .                 self.current_index.shift_out(1);
    24,556 (0.0%)          t
    32,736 (0.0%)      }
         .         
         .             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {
   116,459 (0.0%)          match *t.kind() {
    45,478 (0.0%)              ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {
    57,874 (0.0%)                  let ty = self.delegate.replace_ty(bound_ty);
         .                         debug_assert!(!ty.has_vars_bound_above(ty::INNERMOST));
    13,823 (0.0%)                  ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32())
         .                     }
    83,501 (0.0%)              _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),
         .                     _ => t,
         .                 }
         .             }
         .         
         .             fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {
    43,048 (0.0%)          match *r {
    63,718 (0.0%)              ty::ReBound(debruijn, br) if debruijn == self.current_index => {
    62,385 (0.0%)                  let region = self.delegate.replace_region(br);
    43,490 (0.0%)                  if let ty::ReBound(debruijn1, br) = *region {
         .                             // If the callback returns a bound region,
         .                             // that region should always use the INNERMOST
         .                             // debruijn index. Then we adjust it to the
         .                             // correct depth.
     1,274 (0.0%)                      assert_eq!(debruijn1, ty::INNERMOST);
       637 (0.0%)                      ty::Region::new_bound(self.tcx, debruijn, br)
         .                         } else {
         .                             region
         .                         }
         .                     }
         .                     _ => r,
         .                 }
         .             }
         .         
         .             fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {
       214 (0.0%)          match ct.kind() {
         2 (0.0%)              ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {
         2 (0.0%)                  let ct = self.delegate.replace_const(bound_const, ct.ty());
         .                         debug_assert!(!ct.has_vars_bound_above(ty::INNERMOST));
         2 (0.0%)                  ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32())
         .                     }
         .                     _ => ct.super_fold_with(self),
         .                 }
         .             }
         .         
         .             fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {
    70,860 (0.0%)          if p.has_vars_bound_at_or_above(self.current_index) { p.super_fold_with(self) } else { p }
         .             }
         .         }
         .         
         .         impl<'tcx> TyCtxt<'tcx> {
         .             /// Replaces all regions bound by the given `Binder` with the
         .             /// results returned by the closure; the closure is expected to
         .             /// return a free region (relative to this binder), and hence the
         .             /// binder is removed in the return type. The closure is invoked
-- line 241 ----------------------------------------
-- line 267 ----------------------------------------
         .                 self,
         .                 value: Binder<'tcx, T>,
         .                 mut replace_regions: F,
         .             ) -> T
         .             where
         .                 F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,
         .                 T: TypeFoldable<TyCtxt<'tcx>>,
         .             {
     1,950 (0.0%)          let value = value.skip_binder();
        69 (0.0%)          if !value.has_escaping_bound_vars() {
     1,920 (0.0%)              value
         .                 } else {
         .                     let delegate = FnMutDelegate {
         .                         regions: &mut replace_regions,
         .                         types: &mut |b| bug!("unexpected bound ty in binder: {b:?}"),
         .                         consts: &mut |b, ty| bug!("unexpected bound ct in binder: {b:?} {ty}"),
         .                     };
         .                     let mut replacer = BoundVarReplacer::new(self, delegate);
         .                     value.fold_with(&mut replacer)
-- line 285 ----------------------------------------
-- line 289 ----------------------------------------
         .             /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping
         .             /// bound regions; the `fld_t` closure replaces escaping bound types and the `fld_c`
         .             /// closure replaces escaping bound consts.
         .             pub fn replace_escaping_bound_vars_uncached<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 self,
         .                 value: T,
         .                 delegate: impl BoundVarReplacerDelegate<'tcx>,
         .             ) -> T {
 3,228,099 (0.0%)          if !value.has_escaping_bound_vars() {
11,852,456 (0.1%)              value
         .                 } else {
         .                     let mut replacer = BoundVarReplacer::new(self, delegate);
     3,150 (0.0%)              value.fold_with(&mut replacer)
     1,086 (0.0%)          }
         .             }
         .         
         .             /// Replaces all types or regions bound by the given `Binder`. The `fld_r`
         .             /// closure replaces bound regions, the `fld_t` closure replaces bound
         .             /// types, and `fld_c` replaces bound constants.
         .             pub fn replace_bound_vars_uncached<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 self,
         .                 value: Binder<'tcx, T>,
-- line 310 ----------------------------------------
-- line 318 ----------------------------------------
         .             pub fn liberate_late_bound_regions<T>(
         .                 self,
         .                 all_outlive_scope: DefId,
         .                 value: ty::Binder<'tcx, T>,
         .             ) -> T
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>>,
         .             {
    14,706 (0.0%)          self.instantiate_bound_regions_uncached(value, |br| {
    19,148 (0.0%)              ty::Region::new_late_param(self, all_outlive_scope, br.kind)
    14,361 (0.0%)          })
         .             }
         .         
         .             pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>>,
         .             {
    75,358 (0.0%)          let shift_bv = |bv: ty::BoundVar| ty::BoundVar::from_usize(bv.as_usize() + bound_vars);
         .                 self.replace_escaping_bound_vars_uncached(
         .                     value,
         .                     FnMutDelegate {
   113,037 (0.0%)                  regions: &mut |r: ty::BoundRegion| {
         .                             ty::Region::new_bound(
         .                                 self,
         .                                 ty::INNERMOST,
         .                                 ty::BoundRegion { var: shift_bv(r.var), kind: r.kind },
         .                             )
         .                         },
    75,358 (0.0%)                  types: &mut |t: ty::BoundTy| {
         .                             Ty::new_bound(
         .                                 self,
         .                                 ty::INNERMOST,
         .                                 ty::BoundTy { var: shift_bv(t.var), kind: t.kind },
         .                             )
         .                         },
   113,037 (0.0%)                  consts: &mut |c, ty: Ty<'tcx>| {
         .                             ty::Const::new_bound(self, ty::INNERMOST, shift_bv(c), ty)
         .                         },
         .                     },
         .                 )
         .             }
         .         
         .             /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also
         .             /// method lookup and a few other places where precise region relationships are not required.
         .             pub fn instantiate_bound_regions_with_erased<T>(self, value: Binder<'tcx, T>) -> T
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>>,
         .             {
       618 (0.0%)          self.instantiate_bound_regions(value, |_| self.lifetimes.re_erased).0
         .             }
         .         
         .             /// Anonymize all bound variables in `value`, this is mostly used to improve caching.
 8,523,999 (0.1%)      pub fn anonymize_bound_vars<T>(self, value: Binder<'tcx, T>) -> Binder<'tcx, T>
         .             where
         .                 T: TypeFoldable<TyCtxt<'tcx>>,
         .             {
         .                 struct Anonymize<'a, 'tcx> {
         .                     tcx: TyCtxt<'tcx>,
         .                     map: &'a mut FxIndexMap<ty::BoundVar, ty::BoundVariableKind>,
         .                 }
         .                 impl<'tcx> BoundVarReplacerDelegate<'tcx> for Anonymize<'_, 'tcx> {
     5,733 (0.0%)              fn replace_region(&mut self, br: ty::BoundRegion) -> ty::Region<'tcx> {
     1,911 (0.0%)                  let entry = self.map.entry(br.var);
         .                         let index = entry.index();
         .                         let var = ty::BoundVar::from_usize(index);
     1,911 (0.0%)                  let kind = entry
     2,536 (0.0%)                      .or_insert_with(|| ty::BoundVariableKind::Region(ty::BrAnon))
         .                             .expect_region();
         .                         let br = ty::BoundRegion { var, kind };
       637 (0.0%)                  ty::Region::new_bound(self.tcx, ty::INNERMOST, br)
     5,096 (0.0%)              }
         .                     fn replace_ty(&mut self, bt: ty::BoundTy) -> Ty<'tcx> {
         .                         let entry = self.map.entry(bt.var);
         .                         let index = entry.index();
         .                         let var = ty::BoundVar::from_usize(index);
         .                         let kind = entry
         .                             .or_insert_with(|| ty::BoundVariableKind::Ty(ty::BoundTyKind::Anon))
         .                             .expect_ty();
         .                         Ty::new_bound(self.tcx, ty::INNERMOST, BoundTy { var, kind })
-- line 396 ----------------------------------------
-- line 402 ----------------------------------------
         .                         let () = entry.or_insert_with(|| ty::BoundVariableKind::Const).expect_const();
         .                         ty::Const::new_bound(self.tcx, ty::INNERMOST, var, ty)
         .                     }
         .                 }
         .         
         .                 let mut map = Default::default();
         .                 let delegate = Anonymize { tcx: self, map: &mut map };
         .                 let inner = self.replace_escaping_bound_vars_uncached(value.skip_binder(), delegate);
     4,200 (0.0%)          let bound_vars = self.mk_bound_variable_kinds_from_iter(map.into_values());
         .                 Binder::bind_with_vars(inner, bound_vars)
 6,199,272 (0.1%)      }
         .         }
         .         
         .         ///////////////////////////////////////////////////////////////////////////
         .         // Shifter
         .         //
         .         // Shifts the De Bruijn indices on all escaping bound vars by a
         .         // fixed amount. Useful in instantiation or when otherwise introducing
         .         // a binding level that is not intended to capture the existing bound
-- line 420 ----------------------------------------
-- line 424 ----------------------------------------
         .         struct Shifter<'tcx> {
         .             tcx: TyCtxt<'tcx>,
         .             current_index: ty::DebruijnIndex,
         .             amount: u32,
         .         }
         .         
         .         impl<'tcx> Shifter<'tcx> {
         .             pub fn new(tcx: TyCtxt<'tcx>, amount: u32) -> Self {
       400 (0.0%)          Shifter { tcx, current_index: ty::INNERMOST, amount }
         .             }
         .         }
         .         
         .         impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Shifter<'tcx> {
         .             fn interner(&self) -> TyCtxt<'tcx> {
         .                 self.tcx
         .             }
         .         
-- line 440 ----------------------------------------
-- line 444 ----------------------------------------
         .             ) -> ty::Binder<'tcx, T> {
         .                 self.current_index.shift_in(1);
         .                 let t = t.super_fold_with(self);
         .                 self.current_index.shift_out(1);
         .                 t
         .             }
         .         
         .             fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {
       242 (0.0%)          match *r {
         .                     ty::ReBound(debruijn, br) if debruijn >= self.current_index => {
         .                         let debruijn = debruijn.shifted_in(self.amount);
       121 (0.0%)                  ty::Region::new_bound(self.tcx, debruijn, br)
         .                     }
         .                     _ => r,
         .                 }
         .             }
         .         
     2,565 (0.0%)      fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {
       855 (0.0%)          match *ty.kind() {
         .                     ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {
         .                         let debruijn = debruijn.shifted_in(self.amount);
         .                         Ty::new_bound(self.tcx, debruijn, bound_ty)
         .                     }
         .         
       570 (0.0%)              _ if ty.has_vars_bound_at_or_above(self.current_index) => ty.super_fold_with(self),
         .                     _ => ty,
         .                 }
     2,280 (0.0%)      }
         .         
         .             fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {
         .                 if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.kind()
         .                     && debruijn >= self.current_index
         .                 {
         .                     let debruijn = debruijn.shifted_in(self.amount);
         .                     ty::Const::new_bound(self.tcx, debruijn, bound_ct, ct.ty())
         .                 } else {
-- line 479 ----------------------------------------
-- line 500 ----------------------------------------
         .         }
         .         
         .         pub fn shift_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: T, amount: u32) -> T
         .         where
         .             T: TypeFoldable<TyCtxt<'tcx>>,
         .         {
         .             debug!("shift_vars(value={:?}, amount={})", value, amount);
         .         
    55,294 (0.0%)      if amount == 0 || !value.has_escaping_bound_vars() {
         .                 return value;
         .             }
         .         
         .             value.fold_with(&mut Shifter::new(tcx, amount))
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/generic_args.rs
--------------------------------------------------------------------------------
Ir_______________ 

 7,842,012 (0.1%)  <unknown (line 0)>

-- line 26 ----------------------------------------
         .         /// An entity in the Rust type system, which can be one of
         .         /// several kinds (types, lifetimes, and consts).
         .         /// To reduce memory usage, a `GenericArg` is an interned pointer,
         .         /// with the lowest 2 bits being reserved for a tag to
         .         /// indicate the type (`Ty`, `Region`, or `Const`) it points to.
         .         ///
         .         /// Note: the `PartialEq`, `Eq` and `Hash` derives are only valid because `Ty`,
         .         /// `Region` and `Const` are all interned.
 1,656,607 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash)]
         .         pub struct GenericArg<'tcx> {
         .             ptr: NonNull<()>,
         .             marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, ty::Const<'tcx>)>,
         .         }
         .         
         .         #[cfg(parallel_compiler)]
         .         unsafe impl<'tcx> rustc_data_structures::sync::DynSend for GenericArg<'tcx> where
         .             &'tcx (Ty<'tcx>, ty::Region<'tcx>, ty::Const<'tcx>): rustc_data_structures::sync::DynSend
-- line 42 ----------------------------------------
-- line 62 ----------------------------------------
         .             }
         .         }
         .         
         .         const TAG_MASK: usize = 0b11;
         .         const TYPE_TAG: usize = 0b00;
         .         const REGION_TAG: usize = 0b01;
         .         const CONST_TAG: usize = 0b10;
         .         
 1,380,356 (0.0%)  #[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, HashStable)]
         .         pub enum GenericArgKind<'tcx> {
         .             Lifetime(ty::Region<'tcx>),
         .             Type(Ty<'tcx>),
         .             Const(ty::Const<'tcx>),
         .         }
         .         
         .         impl<'tcx> GenericArgKind<'tcx> {
         .             #[inline]
-- line 78 ----------------------------------------
-- line 128 ----------------------------------------
         .                 }
         .             }
         .         }
         .         
         .         impl<'tcx> GenericArg<'tcx> {
         .             #[inline]
         .             pub fn unpack(self) -> GenericArgKind<'tcx> {
         .                 let ptr =
13,709,007 (0.2%)              unsafe { self.ptr.map_addr(|addr| NonZero::new_unchecked(addr.get() & !TAG_MASK)) };
         .                 // SAFETY: use of `Interned::new_unchecked` here is ok because these
         .                 // pointers were originally created from `Interned` types in `pack()`,
         .                 // and this is just going in the other direction.
         .                 unsafe {
21,436,264 (0.3%)              match self.ptr.addr().get() & TAG_MASK {
         .                         REGION_TAG => GenericArgKind::Lifetime(ty::Region(Interned::new_unchecked(
         .                             ptr.cast::<ty::RegionKind<'tcx>>().as_ref(),
         .                         ))),
         .                         TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(
         .                             ptr.cast::<WithCachedTypeInfo<ty::TyKind<'tcx>>>().as_ref(),
         .                         ))),
         .                         CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(
         .                             ptr.cast::<WithCachedTypeInfo<ty::ConstData<'tcx>>>().as_ref(),
-- line 149 ----------------------------------------
-- line 175 ----------------------------------------
         .                     GenericArgKind::Const(ct) => Some(ct),
         .                     _ => None,
         .                 }
         .             }
         .         
         .             /// Unpack the `GenericArg` as a region when it is known certainly to be a region.
         .             pub fn expect_region(self) -> ty::Region<'tcx> {
         .                 self.as_region().unwrap_or_else(|| bug!("expected a region, but found another kind"))
     1,878 (0.0%)      }
         .         
         .             /// Unpack the `GenericArg` as a type when it is known certainly to be a type.
         .             /// This is true in cases where `GenericArgs` is used in places where the kinds are known
         .             /// to be limited (e.g. in tuples, where the only parameters are type parameters).
         .             pub fn expect_ty(self) -> Ty<'tcx> {
         .                 self.as_type().unwrap_or_else(|| bug!("expected a type, but found another kind"))
     5,860 (0.0%)      }
         .         
         .             /// Unpack the `GenericArg` as a const when it is known certainly to be a const.
         .             pub fn expect_const(self) -> ty::Const<'tcx> {
         .                 self.as_const().unwrap_or_else(|| bug!("expected a const, but found another kind"))
         .             }
         .         
     2,898 (0.0%)      pub fn is_non_region_infer(self) -> bool {
         .                 match self.unpack() {
         .                     GenericArgKind::Lifetime(_) => false,
         .                     GenericArgKind::Type(ty) => ty.is_ty_or_numeric_infer(),
         .                     GenericArgKind::Const(ct) => ct.is_ct_infer(),
         .                 }
     2,898 (0.0%)      }
         .         }
         .         
         .         impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {
         .             type Lifted = GenericArg<'tcx>;
         .         
         .             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {
         .                 match self.unpack() {
         .                     GenericArgKind::Lifetime(lt) => tcx.lift(lt).map(|lt| lt.into()),
         .                     GenericArgKind::Type(ty) => tcx.lift(ty).map(|ty| ty.into()),
         .                     GenericArgKind::Const(ct) => tcx.lift(ct).map(|ct| ct.into()),
         .                 }
         .             }
         .         }
         .         
         .         impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for GenericArg<'tcx> {
   960,234 (0.0%)      fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(
         .                 self,
         .                 folder: &mut F,
         .             ) -> Result<Self, F::Error> {
         .                 match self.unpack() {
        20 (0.0%)              GenericArgKind::Lifetime(lt) => lt.try_fold_with(folder).map(Into::into),
         .                     GenericArgKind::Type(ty) => ty.try_fold_with(folder).map(Into::into),
         .                     GenericArgKind::Const(ct) => ct.try_fold_with(folder).map(Into::into),
         .                 }
   888,461 (0.0%)      }
         .         }
         .         
         .         impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for GenericArg<'tcx> {
         .             fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(&self, visitor: &mut V) -> V::Result {
    54,885 (0.0%)          match self.unpack() {
         .                     GenericArgKind::Lifetime(lt) => lt.visit_with(visitor),
         .                     GenericArgKind::Type(ty) => ty.visit_with(visitor),
         .                     GenericArgKind::Const(ct) => ct.visit_with(visitor),
         .                 }
         .             }
         .         }
         .         
         .         impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for GenericArg<'tcx> {
         .             fn encode(&self, e: &mut E) {
         .                 self.unpack().encode(e)
         .             }
         .         }
         .         
         .         impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for GenericArg<'tcx> {
         .             fn decode(d: &mut D) -> GenericArg<'tcx> {
   121,786 (0.0%)          GenericArgKind::decode(d).pack()
         .             }
         .         }
         .         
         .         /// List of generic arguments that are gonna be used to replace generic parameters.
         .         pub type GenericArgs<'tcx> = List<GenericArg<'tcx>>;
         .         
         .         pub type GenericArgsRef<'tcx> = &'tcx GenericArgs<'tcx>;
         .         
-- line 257 ----------------------------------------
-- line 296 ----------------------------------------
         .             /// Inline const args have a particular structure controlled by the
         .             /// compiler that encodes information like the inferred type;
         .             /// see `ty::InlineConstArgs` struct for more comments.
         .             pub fn as_inline_const(&'tcx self) -> InlineConstArgs<'tcx> {
         .                 InlineConstArgs { args: self }
         .             }
         .         
         .             /// Creates an `GenericArgs` that maps each generic parameter to itself.
    48,858 (0.0%)      pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: impl Into<DefId>) -> GenericArgsRef<'tcx> {
    17,556 (0.0%)          Self::for_item(tcx, def_id.into(), |param, _| tcx.mk_param_from_def(param))
    25,872 (0.0%)      }
         .         
         .             /// Creates an `GenericArgs` for generic parameter definitions,
         .             /// by calling closures to obtain each kind.
         .             /// The closures get to observe the `GenericArgs` as they're
         .             /// being built, which can be used to correctly
         .             /// replace defaults of generic parameters.
         .             pub fn for_item<F>(tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> GenericArgsRef<'tcx>
         .             where
         .                 F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .             {
         .                 let defs = tcx.generics_of(def_id);
         .                 let count = defs.count();
         .                 let mut args = SmallVec::with_capacity(count);
   300,502 (0.0%)          Self::fill_item(&mut args, tcx, defs, &mut mk_kind);
   151,912 (0.0%)          tcx.mk_args(&args)
    75,049 (0.0%)      }
         .         
         .             pub fn extend_to<F>(
         .                 &self,
         .                 tcx: TyCtxt<'tcx>,
         .                 def_id: DefId,
         .                 mut mk_kind: F,
         .             ) -> GenericArgsRef<'tcx>
         .             where
         .                 F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .             {
         .                 Self::for_item(tcx, def_id, |param, args| {
       224 (0.0%)              self.get(param.index as usize).cloned().unwrap_or_else(|| mk_kind(param, args))
         .                 })
         .             }
         .         
   863,126 (0.0%)      pub fn fill_item<F>(
         .                 args: &mut SmallVec<[GenericArg<'tcx>; 8]>,
         .                 tcx: TyCtxt<'tcx>,
         .                 defs: &ty::Generics,
         .                 mk_kind: &mut F,
         .             ) where
         .                 F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .             {
   238,815 (0.0%)          if let Some(def_id) = defs.parent {
         .                     let parent_defs = tcx.generics_of(def_id);
    17,085 (0.0%)              Self::fill_item(args, tcx, parent_defs, mk_kind);
         .                 }
   456,700 (0.0%)          Self::fill_single(args, defs, mk_kind)
   627,728 (0.0%)      }
         .         
         .             pub fn fill_single<F>(
         .                 args: &mut SmallVec<[GenericArg<'tcx>; 8]>,
         .                 defs: &ty::Generics,
         .                 mk_kind: &mut F,
         .             ) where
         .                 F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .             {
         .                 args.reserve(defs.params.len());
    61,155 (0.0%)          for param in &defs.params {
         .                     let kind = mk_kind(param, args);
   405,486 (0.0%)              assert_eq!(param.index as usize, args.len(), "{args:#?}, {defs:#?}");
         .                     args.push(kind);
         .                 }
         .             }
         .         
         .             // Extend an `original_args` list to the full number of args expected by `def_id`,
         .             // filling in the missing parameters with error ty/ct or 'static regions.
         .             pub fn extend_with_error(
         .                 tcx: TyCtxt<'tcx>,
-- line 371 ----------------------------------------
-- line 408 ----------------------------------------
         .                     _ if Some(i) == generics.host_effect_index => None,
         .                     ty::GenericArgKind::Lifetime(_) => None,
         .                     generic => Some(generic),
         .                 })
         .             }
         .         
         .             #[inline]
         .             #[track_caller]
         5 (0.0%)      pub fn type_at(&self, i: usize) -> Ty<'tcx> {
 2,363,925 (0.0%)          self[i].as_type().unwrap_or_else(|| bug!("expected type for param #{} in {:?}", i, self))
         3 (0.0%)      }
         .         
         .             #[inline]
         .             #[track_caller]
         .             pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {
         .                 self[i]
         .                     .as_region()
         .                     .unwrap_or_else(|| bug!("expected region for param #{} in {:?}", i, self))
         .             }
         .         
         .             #[inline]
         .             #[track_caller]
         .             pub fn const_at(&self, i: usize) -> ty::Const<'tcx> {
         6 (0.0%)          self[i].as_const().unwrap_or_else(|| bug!("expected const for param #{} in {:?}", i, self))
         .             }
         .         
         .             #[inline]
         .             #[track_caller]
         .             pub fn type_for_def(&self, def: &ty::GenericParamDef) -> GenericArg<'tcx> {
         .                 self.type_at(def.index as usize).into()
         .             }
         .         
-- line 439 ----------------------------------------
-- line 450 ----------------------------------------
         .             /// impl<U> X<U> for U { fn f<V>() {} }
         .             /// ```
         .             ///
         .             /// * If `self` is `[Self, S, T]`: the identity args of `f` in the trait.
         .             /// * If `source_ancestor` is the def_id of the trait.
         .             /// * If `target_args` is `[U]`, the args for the impl.
         .             /// * Then we will return `[U, T]`, the arg for `f` in the impl that
         .             ///   are needed for it to match the trait.
    17,567 (0.0%)      pub fn rebase_onto(
         .                 &self,
         .                 tcx: TyCtxt<'tcx>,
         .                 source_ancestor: DefId,
         .                 target_args: GenericArgsRef<'tcx>,
         .             ) -> GenericArgsRef<'tcx> {
         .                 let defs = tcx.generics_of(source_ancestor);
         .                 tcx.mk_args_from_iter(target_args.iter().chain(self.iter().skip(defs.count())))
     9,582 (0.0%)      }
         .         
   209,792 (0.0%)      pub fn truncate_to(&self, tcx: TyCtxt<'tcx>, generics: &ty::Generics) -> GenericArgsRef<'tcx> {
   131,120 (0.0%)          tcx.mk_args_from_iter(self.iter().take(generics.count()))
   209,792 (0.0%)      }
         .         
         .             pub fn print_as_list(&self) -> String {
         .                 let v = self.iter().map(|arg| arg.to_string()).collect::<Vec<_>>();
         .                 format!("[{}]", v.join(", "))
         .             }
         .         }
         .         
         .         impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for GenericArgsRef<'tcx> {
16,800,609 (0.2%)      fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(
         .                 self,
         .                 folder: &mut F,
         .             ) -> Result<Self, F::Error> {
         .                 // This code is hot enough that it's worth specializing for the most
         .                 // common length lists, to avoid the overhead of `SmallVec` creation.
         .                 // The match arms are in order of frequency. The 1, 2, and 0 cases are
         .                 // typically hit in 90--99.99% of cases. When folding doesn't change
         .                 // the args, it's faster to reuse the existing args rather than
         .                 // calling `mk_args`.
 6,451,082 (0.1%)          match self.len() {
         .                     1 => {
 1,565,224 (0.0%)                  let param0 = self[0].try_fold_with(folder)?;
 5,137,994 (0.1%)                  if param0 == self[0] { Ok(self) } else { Ok(folder.interner().mk_args(&[param0])) }
         .                     }
         .                     2 => {
   390,390 (0.0%)                  let param0 = self[0].try_fold_with(folder)?;
   902,834 (0.0%)                  let param1 = self[1].try_fold_with(folder)?;
   717,328 (0.0%)                  if param0 == self[0] && param1 == self[1] {
         .                             Ok(self)
         .                         } else {
   843,915 (0.0%)                      Ok(folder.interner().mk_args(&[param0, param1]))
         .                         }
         .                     }
         .                     0 => Ok(self),
    28,854 (0.0%)              _ => ty::util::fold_list(self, folder, |tcx, v| tcx.mk_args(v)),
         .                 }
15,053,176 (0.2%)      }
         .         }
         .         
         .         impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<Ty<'tcx>> {
   156,780 (0.0%)      fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(
         .                 self,
         .                 folder: &mut F,
         .             ) -> Result<Self, F::Error> {
         .                 // This code is fairly hot, though not as hot as `GenericArgsRef`.
         .                 //
         .                 // When compiling stage 2, I get the following results:
         .                 //
         .                 // len |   total   |   %
-- line 518 ----------------------------------------
-- line 521 ----------------------------------------
         .                 //  3  |   7540067 |  24.0
         .                 //  1  |   5300377 |  16.9
         .                 //  4  |   1351897 |   4.3
         .                 //  0  |   1256849 |   4.0
         .                 //
         .                 // I've tried it with some private repositories and got
         .                 // close to the same result, with 4 and 0 swapping places
         .                 // sometimes.
    34,770 (0.0%)          match self.len() {
         .                     2 => {
    11,487 (0.0%)                  let param0 = self[0].try_fold_with(folder)?;
    32,187 (0.0%)                  let param1 = self[1].try_fold_with(folder)?;
    51,974 (0.0%)                  if param0 == self[0] && param1 == self[1] {
         .                             Ok(self)
         .                         } else {
    69,758 (0.0%)                      Ok(folder.interner().mk_type_list(&[param0, param1]))
         .                         }
         .                     }
     4,072 (0.0%)              _ => ty::util::fold_list(self, folder, |tcx, v| tcx.mk_type_list(v)),
         .                 }
   141,102 (0.0%)      }
         .         }
         .         
         .         impl<'tcx, T: TypeVisitable<TyCtxt<'tcx>>> TypeVisitable<TyCtxt<'tcx>> for &'tcx ty::List<T> {
         .             #[inline]
    37,912 (0.0%)      fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(&self, visitor: &mut V) -> V::Result {
26,633,691 (0.3%)          walk_visitable_list!(visitor, self.iter());
         .                 V::Result::output()
    37,912 (0.0%)      }
         .         }
         .         
         .         /// Similar to [`super::Binder`] except that it tracks early bound generics, i.e. `struct Foo<T>(T)`
         .         /// needs `T` instantiated immediately. This type primarily exists to avoid forgetting to call
         .         /// `instantiate`.
         .         ///
         .         /// If you don't have anything to `instantiate`, you may be looking for
         .         /// [`instantiate_identity`](EarlyBinder::instantiate_identity) or [`skip_binder`](EarlyBinder::skip_binder).
         .         #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    23,874 (0.0%)  #[derive(Encodable, Decodable, HashStable)]
         .         pub struct EarlyBinder<T> {
         .             value: T,
         .         }
         .         
         .         /// For early binders, you should first call `instantiate` before using any visitors.
         .         impl<'tcx, T> !TypeFoldable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}
         .         impl<'tcx, T> !TypeVisitable<TyCtxt<'tcx>> for ty::EarlyBinder<T> {}
         .         
         .         impl<T> EarlyBinder<T> {
         .             pub fn bind(value: T) -> EarlyBinder<T> {
     9,136 (0.0%)          EarlyBinder { value }
         .             }
         .         
         .             pub fn as_ref(&self) -> EarlyBinder<&T> {
         .                 EarlyBinder { value: &self.value }
         .             }
         .         
         .             pub fn map_bound_ref<F, U>(&self, f: F) -> EarlyBinder<U>
         .             where
-- line 578 ----------------------------------------
-- line 581 ----------------------------------------
         .                 self.as_ref().map_bound(f)
         .             }
         .         
         .             pub fn map_bound<F, U>(self, f: F) -> EarlyBinder<U>
         .             where
         .                 F: FnOnce(T) -> U,
         .             {
         .                 let value = f(self.value);
     4,290 (0.0%)          EarlyBinder { value }
         .             }
         .         
         .             pub fn try_map_bound<F, U, E>(self, f: F) -> Result<EarlyBinder<U>, E>
         .             where
         .                 F: FnOnce(T) -> Result<U, E>,
         .             {
         .                 let value = f(self.value)?;
         .                 Ok(EarlyBinder { value })
-- line 597 ----------------------------------------
-- line 608 ----------------------------------------
         .             /// [`instantiate_identity`](EarlyBinder::instantiate_identity).
         .             ///
         .             /// To skip the binder on `x: &EarlyBinder<T>` to obtain `&T`, leverage
         .             /// [`EarlyBinder::as_ref`](EarlyBinder::as_ref): `x.as_ref().skip_binder()`.
         .             ///
         .             /// See also [`Binder::skip_binder`](super::Binder::skip_binder), which is
         .             /// the analogous operation on [`super::Binder`].
         .             pub fn skip_binder(self) -> T {
     6,550 (0.0%)          self.value
         .             }
         .         }
         .         
         .         impl<T> EarlyBinder<Option<T>> {
         .             pub fn transpose(self) -> Option<EarlyBinder<T>> {
         .                 self.value.map(|value| EarlyBinder { value })
         .             }
         .         }
-- line 624 ----------------------------------------
-- line 693 ----------------------------------------
         .                 IterInstantiatedCopied { it: self.value.into_iter(), tcx, args }
         .             }
         .         
         .             /// Similar to [`instantiate_identity`](EarlyBinder::instantiate_identity),
         .             /// but on an iterator of values that deref to a `TypeFoldable`.
         .             pub fn instantiate_identity_iter_copied(
         .                 self,
         .             ) -> impl Iterator<Item = <I::Item as Deref>::Target> {
        28 (0.0%)          self.value.into_iter().map(|v| *v)
         .             }
         .         }
         .         
         .         pub struct IterInstantiatedCopied<'a, 'tcx, I: IntoIterator> {
         .             it: I::IntoIter,
         .             tcx: TyCtxt<'tcx>,
         .             args: &'a [GenericArg<'tcx>],
         .         }
-- line 709 ----------------------------------------
-- line 711 ----------------------------------------
         .         impl<'tcx, I: IntoIterator> Iterator for IterInstantiatedCopied<'_, 'tcx, I>
         .         where
         .             I::Item: Deref,
         .             <I::Item as Deref>::Target: Copy + TypeFoldable<TyCtxt<'tcx>>,
         .         {
         .             type Item = <I::Item as Deref>::Target;
         .         
         .             fn next(&mut self) -> Option<Self::Item> {
   327,954 (0.0%)          self.it.next().map(|value| EarlyBinder { value: *value }.instantiate(self.tcx, self.args))
         .             }
         .         
         .             fn size_hint(&self) -> (usize, Option<usize>) {
         .                 self.it.size_hint()
         .             }
         .         }
         .         
         .         impl<'tcx, I: IntoIterator> DoubleEndedIterator for IterInstantiatedCopied<'_, 'tcx, I>
-- line 727 ----------------------------------------
-- line 764 ----------------------------------------
         .         
         .             fn size_hint(&self) -> (usize, Option<usize>) {
         .                 self.t.size_hint()
         .             }
         .         }
         .         
         .         impl<'tcx, T: TypeFoldable<TyCtxt<'tcx>>> ty::EarlyBinder<T> {
         .             pub fn instantiate(self, tcx: TyCtxt<'tcx>, args: &[GenericArg<'tcx>]) -> T {
 2,838,590 (0.0%)          let mut folder = ArgFolder { tcx, args, binders_passed: 0 };
       510 (0.0%)          self.value.fold_with(&mut folder)
         .             }
         .         
         .             /// Makes the identity replacement `T0 => T0, ..., TN => TN`.
         .             /// Conceptually, this converts universally bound variables into placeholders
         .             /// when inside of a given item.
         .             ///
         .             /// For example, consider `for<T> fn foo<T>(){ .. }`:
         .             /// - Outside of `foo`, `T` is bound (represented by the presence of `EarlyBinder`).
         .             /// - Inside of the body of `foo`, we treat `T` as a placeholder by calling
         .             /// `instantiate_identity` to discharge the `EarlyBinder`.
         .             pub fn instantiate_identity(self) -> T {
     5,097 (0.0%)          self.value
         .             }
         .         
         .             /// Returns the inner value, but only if it contains no bound vars.
         .             pub fn no_bound_vars(self) -> Option<T> {
         .                 if !self.value.has_param() { Some(self.value) } else { None }
         .             }
         .         }
         .         
-- line 793 ----------------------------------------
-- line 800 ----------------------------------------
         .         
         .             /// Number of region binders we have passed through while doing the instantiation
         .             binders_passed: u32,
         .         }
         .         
         .         impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for ArgFolder<'a, 'tcx> {
         .             #[inline]
         .             fn interner(&self) -> TyCtxt<'tcx> {
       100 (0.0%)          self.tcx
         .             }
         .         
    16,400 (0.0%)      fn fold_binder<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 &mut self,
         .                 t: ty::Binder<'tcx, T>,
         .             ) -> ty::Binder<'tcx, T> {
   467,181 (0.0%)          self.binders_passed += 1;
         .                 let t = t.super_fold_with(self);
   237,469 (0.0%)          self.binders_passed -= 1;
         .                 t
    13,120 (0.0%)      }
         .         
    96,764 (0.0%)      fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {
         .                 #[cold]
         .                 #[inline(never)]
         .                 fn region_param_out_of_range(data: ty::EarlyParamRegion, args: &[GenericArg<'_>]) -> ! {
         .                     bug!(
         .                         "Region parameter out of range when instantiating in region {} (index={}, args = {:?})",
         .                         data.name,
         .                         data.index,
         .                         args,
-- line 829 ----------------------------------------
-- line 841 ----------------------------------------
         .                     )
         .                 }
         .         
         .                 // Note: This routine only handles regions that are bound on
         .                 // type declarations and other outer declarations, not those
         .                 // bound in *fn types*. Region instantiation of the bound
         .                 // regions that appear in a function signature is done using
         .                 // the specialized routine `ty::replace_late_regions()`.
   120,955 (0.0%)          match *r {
    17,557 (0.0%)              ty::ReEarlyParam(data) => {
    52,671 (0.0%)                  let rk = self.args.get(data.index as usize).map(|k| k.unpack());
         .                         match rk {
    17,557 (0.0%)                      Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),
         .                             Some(other) => region_param_invalid(data, other),
         .                             None => region_param_out_of_range(data, self.args),
         .                         }
         .                     }
         .                     ty::ReBound(..)
         .                     | ty::ReLateParam(_)
         .                     | ty::ReStatic
         .                     | ty::RePlaceholder(_)
         .                     | ty::ReErased
         .                     | ty::ReError(_) => r,
         .                     ty::ReVar(_) => bug!("unexpected region: {r:?}"),
         .                 }
    72,573 (0.0%)      }
         .         
 1,968,424 (0.0%)      fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {
   783,914 (0.0%)          if !t.has_param() {
         .                     return t;
         .                 }
         .         
 1,214,696 (0.0%)          match *t.kind() {
 1,018,480 (0.0%)              ty::Param(p) => self.ty_for_param(p, t),
         .                     _ => t.super_fold_with(self),
         .                 }
 1,195,437 (0.0%)      }
         .         
     8,036 (0.0%)      fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {
     9,870 (0.0%)          if let ty::ConstKind::Param(p) = c.kind() {
     4,349 (0.0%)              self.const_for_param(p, c)
         .                 } else {
         .                     c.super_fold_with(self)
         .                 }
         .             }
         .         }
         .         
         .         impl<'a, 'tcx> ArgFolder<'a, 'tcx> {
    31,176 (0.0%)      fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {
         .                 // Look up the type in the args. It really should be in there.
   987,304 (0.0%)          let opt_ty = self.args.get(p.index as usize).map(|k| k.unpack());
         .                 let ty = match opt_ty {
         .                     Some(GenericArgKind::Type(ty)) => ty,
         .                     Some(kind) => self.type_param_expected(p, source_ty, kind),
         .                     None => self.type_param_out_of_range(p, source_ty),
         .                 };
         .         
         .                 self.shift_vars_through_binders(ty)
    31,176 (0.0%)      }
         .         
         .             #[cold]
         .             #[inline(never)]
         .             fn type_param_expected(&self, p: ty::ParamTy, ty: Ty<'tcx>, kind: GenericArgKind<'tcx>) -> ! {
         .                 bug!(
         .                     "expected type for `{:?}` ({:?}/{}) but found {:?} when instantiating, args={:?}",
         .                     p,
         .                     ty,
-- line 907 ----------------------------------------
-- line 918 ----------------------------------------
         .                     "type parameter `{:?}` ({:?}/{}) out of range when instantiating, args={:?}",
         .                     p,
         .                     ty,
         .                     p.index,
         .                     self.args,
         .                 )
         .             }
         .         
     4,254 (0.0%)      fn const_for_param(&self, p: ParamConst, source_ct: ty::Const<'tcx>) -> ty::Const<'tcx> {
         .                 // Look up the const in the args. It really should be in there.
     4,254 (0.0%)          let opt_ct = self.args.get(p.index as usize).map(|k| k.unpack());
         .                 let ct = match opt_ct {
         .                     Some(GenericArgKind::Const(ct)) => ct,
         .                     Some(kind) => self.const_param_expected(p, source_ct, kind),
         .                     None => self.const_param_out_of_range(p, source_ct),
         .                 };
         .         
         .                 self.shift_vars_through_binders(ct)
     4,254 (0.0%)      }
         .         
         .             #[cold]
         .             #[inline(never)]
         .             fn const_param_expected(
         .                 &self,
         .                 p: ty::ParamConst,
         .                 ct: ty::Const<'tcx>,
         .                 kind: GenericArgKind<'tcx>,
-- line 944 ----------------------------------------
-- line 1010 ----------------------------------------
         .             fn shift_vars_through_binders<T: TypeFoldable<TyCtxt<'tcx>>>(&self, val: T) -> T {
         .                 debug!(
         .                     "shift_vars(val={:?}, binders_passed={:?}, has_escaping_bound_vars={:?})",
         .                     val,
         .                     self.binders_passed,
         .                     val.has_escaping_bound_vars()
         .                 );
         .         
 2,010,376 (0.0%)          if self.binders_passed == 0 || !val.has_escaping_bound_vars() {
         .                     return val;
         .                 }
         .         
         .                 let result = ty::fold::shift_vars(TypeFolder::interner(self), val, self.binders_passed);
         .                 debug!("shift_vars: shifted result = {:?}", result);
         .         
         .                 result
         .             }
         .         
         .             fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {
    46,332 (0.0%)          if self.binders_passed == 0 || !region.has_escaping_bound_vars() {
         .                     return region;
         .                 }
         .                 ty::fold::shift_region(self.tcx, region, self.binders_passed)
         .             }
         .         }
         .         
         .         /// Stores the user-given args to reach some fully qualified path
         .         /// (e.g., `<T>::Item` or `<T as Trait>::Item`).
        10 (0.0%)  #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
     1,496 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable)]
         .         pub struct UserArgs<'tcx> {
         .             /// The args for the item as given by the user.
         .             pub args: GenericArgsRef<'tcx>,
         .         
         .             /// The self type, in the case of a `<T>::Item` path (when applied
         .             /// to an inherent impl). See `UserSelfTy` below.
         .             pub user_self_ty: Option<UserSelfTy<'tcx>>,
         .         }
-- line 1047 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/predicate.rs
--------------------------------------------------------------------------------
Ir______________ 

2,633,859 (0.0%)  <unknown (line 0)>

-- line 26 ----------------------------------------
        .         #[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable)]
        .         #[rustc_pass_by_value]
        .         pub struct Predicate<'tcx>(
        .             pub(super) Interned<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,
        .         );
        .         
        .         impl<'tcx> rustc_type_ir::visit::Flags for Predicate<'tcx> {
        .             fn flags(&self) -> TypeFlags {
   56,317 (0.0%)          self.0.flags
        .             }
        .         
        .             fn outer_exclusive_binder(&self) -> ty::DebruijnIndex {
        .                 self.0.outer_exclusive_binder
        .             }
        .         }
        .         
        .         impl<'tcx> Predicate<'tcx> {
        .             /// Gets the inner `ty::Binder<'tcx, PredicateKind<'tcx>>`.
        .             #[inline]
        .             pub fn kind(self) -> ty::Binder<'tcx, PredicateKind<'tcx>> {
7,376,217 (0.1%)          self.0.internee
        .             }
        .         
        .             // FIXME(compiler-errors): Think about removing this.
        .             #[inline(always)]
        .             pub fn flags(self) -> TypeFlags {
        .                 self.0.flags
        .             }
        .         
        .             // FIXME(compiler-errors): Think about removing this.
        .             #[inline(always)]
        .             pub fn outer_exclusive_binder(self) -> DebruijnIndex {
   38,720 (0.0%)          self.0.outer_exclusive_binder
        .             }
        .         
        .             /// Flips the polarity of a Predicate.
        .             ///
        .             /// Given `T: Trait` predicate it returns `T: !Trait` and given `T: !Trait` returns `T: Trait`.
        .             pub fn flip_polarity(self, tcx: TyCtxt<'tcx>) -> Option<Predicate<'tcx>> {
        .                 let kind = self
        .                     .kind()
-- line 66 ----------------------------------------
-- line 75 ----------------------------------------
        .         
        .                         _ => None,
        .                     })
        .                     .transpose()?;
        .         
        .                 Some(tcx.mk_predicate(kind))
        .             }
        .         
  140,829 (0.0%)      #[instrument(level = "debug", skip(tcx), ret)]
        .             pub fn is_coinductive(self, tcx: TyCtxt<'tcx>) -> bool {
  516,373 (0.0%)          match self.kind().skip_binder() {
        .                     ty::PredicateKind::Clause(ty::ClauseKind::Trait(data)) => {
        .                         tcx.trait_is_coinductive(data.def_id())
   46,943 (0.0%)              }
        .                     ty::PredicateKind::Clause(ty::ClauseKind::WellFormed(_)) => true,
        .                     _ => false,
        .                 }
        .             }
        .         
        .             /// Whether this projection can be soundly normalized.
        .             ///
        .             /// Wf predicates must not be normalized, as normalization
        .             /// can remove required bounds which would cause us to
        .             /// unsoundly accept some programs. See #91068.
        .             #[inline]
        .             pub fn allow_normalization(self) -> bool {
  226,344 (0.0%)          match self.kind().skip_binder() {
        .                     PredicateKind::Clause(ClauseKind::WellFormed(_)) => false,
        .                     // `NormalizesTo` is only used in the new solver, so this shouldn't
        .                     // matter. Normalizing `term` would be 'wrong' however, as it changes whether
        .                     // `normalizes-to(<T as Trait>::Assoc, <T as Trait>::Assoc)` holds.
        .                     PredicateKind::NormalizesTo(..) => false,
        .                     PredicateKind::Clause(ClauseKind::Trait(_))
        .                     | PredicateKind::Clause(ClauseKind::RegionOutlives(_))
        .                     | PredicateKind::Clause(ClauseKind::TypeOutlives(_))
-- line 109 ----------------------------------------
-- line 142 ----------------------------------------
        .         );
        .         
        .         impl<'tcx> Clause<'tcx> {
        .             pub fn as_predicate(self) -> Predicate<'tcx> {
        .                 Predicate(self.0)
        .             }
        .         
        .             pub fn kind(self) -> ty::Binder<'tcx, ClauseKind<'tcx>> {
7,939,117 (0.1%)          self.0.internee.map_bound(|kind| match kind {
        .                     PredicateKind::Clause(clause) => clause,
        .                     _ => unreachable!(),
        .                 })
1,532,570 (0.0%)      }
        .         
        .             pub fn as_trait_clause(self) -> Option<ty::Binder<'tcx, TraitPredicate<'tcx>>> {
        .                 let clause = self.kind();
1,459,234 (0.0%)          if let ty::ClauseKind::Trait(trait_clause) = clause.skip_binder() {
2,868,807 (0.0%)              Some(clause.rebind(trait_clause))
        .                 } else {
  155,846 (0.0%)              None
        .                 }
1,459,210 (0.0%)      }
        .         
        .             pub fn as_projection_clause(self) -> Option<ty::Binder<'tcx, ProjectionPredicate<'tcx>>> {
        .                 let clause = self.kind();
    3,620 (0.0%)          if let ty::ClauseKind::Projection(projection_clause) = clause.skip_binder() {
    1,275 (0.0%)              Some(clause.rebind(projection_clause))
        .                 } else {
    1,543 (0.0%)              None
        .                 }
    3,596 (0.0%)      }
        .         
        .             pub fn as_type_outlives_clause(self) -> Option<ty::Binder<'tcx, TypeOutlivesPredicate<'tcx>>> {
        .                 let clause = self.kind();
  170,200 (0.0%)          if let ty::ClauseKind::TypeOutlives(o) = clause.skip_binder() {
    7,146 (0.0%)              Some(clause.rebind(o))
        .                 } else {
        .                     None
        .                 }
  170,200 (0.0%)      }
        .         
        .             pub fn as_region_outlives_clause(
        .                 self,
        .             ) -> Option<ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>> {
        .                 let clause = self.kind();
        .                 if let ty::ClauseKind::RegionOutlives(o) = clause.skip_binder() {
        .                     Some(clause.rebind(o))
        .                 } else {
        .                     None
        .                 }
        .             }
        .         }
        .         
2,025,152 (0.0%)  #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
1,407,584 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub enum ExistentialPredicate<'tcx> {
        .             /// E.g., `Iterator`.
        .             Trait(ExistentialTraitRef<'tcx>),
        .             /// E.g., `Iterator::Item = T`.
        .             Projection(ExistentialProjection<'tcx>),
        .             /// E.g., `Send`.
        .             AutoTrait(DefId),
        .         }
-- line 204 ----------------------------------------
-- line 210 ----------------------------------------
        .             ) -> std::fmt::Result {
        .                 std::fmt::Debug::fmt(&this.data, f)
        .             }
        .         }
        .         
        .         impl<'tcx> ExistentialPredicate<'tcx> {
        .             /// Compares via an ordering that will not change if modules are reordered or other changes are
        .             /// made to the tree. In particular, this ordering is preserved across incremental compilations.
  338,488 (0.0%)      pub fn stable_cmp(&self, tcx: TyCtxt<'tcx>, other: &Self) -> Ordering {
        .                 use self::ExistentialPredicate::*;
  576,518 (0.0%)          match (*self, *other) {
        .                     (Trait(_), Trait(_)) => Ordering::Equal,
        .                     (Projection(ref a), Projection(ref b)) => {
        .                         tcx.def_path_hash(a.def_id).cmp(&tcx.def_path_hash(b.def_id))
        .                     }
        .                     (AutoTrait(ref a), AutoTrait(ref b)) => {
  165,520 (0.0%)                  tcx.def_path_hash(*a).cmp(&tcx.def_path_hash(*b))
        .                     }
        .                     (Trait(_), _) => Ordering::Less,
        .                     (Projection(_), Trait(_)) => Ordering::Greater,
        .                     (Projection(_), _) => Ordering::Less,
        .                     (AutoTrait(_), _) => Ordering::Greater,
        .                 }
  338,488 (0.0%)      }
        .         }
        .         
        .         pub type PolyExistentialPredicate<'tcx> = ty::Binder<'tcx, ExistentialPredicate<'tcx>>;
        .         
        .         impl<'tcx> PolyExistentialPredicate<'tcx> {
        .             /// Given an existential predicate like `?Self: PartialEq<u32>` (e.g., derived from `dyn PartialEq<u32>`),
        .             /// and a concrete type `self_ty`, returns a full predicate where the existentially quantified variable `?Self`
        .             /// has been replaced with `self_ty` (e.g., `self_ty: PartialEq<u32>`, in our example).
   12,573 (0.0%)      pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Clause<'tcx> {
   18,010 (0.0%)          match self.skip_binder() {
        .                     ExistentialPredicate::Trait(tr) => {
        .                         self.rebind(tr).with_self_ty(tcx, self_ty).to_predicate(tcx)
        .                     }
        .                     ExistentialPredicate::Projection(p) => {
        .                         self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)
        .                     }
        .                     ExistentialPredicate::AutoTrait(did) => {
        .                         let generics = tcx.generics_of(did);
    1,246 (0.0%)                  let trait_ref = if generics.params.len() == 1 {
        .                             ty::TraitRef::new(tcx, did, [self_ty])
        .                         } else {
        .                             // If this is an ill-formed auto trait, then synthesize
        .                             // new error args for the missing generics.
        .                             let err_args = ty::GenericArgs::extend_with_error(tcx, did, &[self_ty.into()]);
        .                             ty::TraitRef::new(tcx, did, err_args)
        .                         };
        .                         self.rebind(trait_ref).to_predicate(tcx)
        .                     }
        .                 }
   11,176 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ty::List<ty::PolyExistentialPredicate<'tcx>> {
        .             /// Returns the "principal `DefId`" of this set of existential predicates.
        .             ///
        .             /// A Rust trait object type consists (in addition to a lifetime bound)
        .             /// of a set of trait bounds, which are separated into any number
        .             /// of auto-trait bounds, and at most one non-auto-trait bound. The
-- line 271 ----------------------------------------
-- line 285 ----------------------------------------
        .             ///
        .             /// It is also possible to have a "trivial" trait object that
        .             /// consists only of auto traits, with no principal - for example,
        .             /// `dyn Send + Sync`. In that case, the set of auto-trait bounds
        .             /// is `{Send, Sync}`, while there is no principal. These trait objects
        .             /// have a "trivial" vtable consisting of just the size, alignment,
        .             /// and destructor.
        .             pub fn principal(&self) -> Option<ty::Binder<'tcx, ExistentialTraitRef<'tcx>>> {
    9,366 (0.0%)          self[0]
   19,522 (0.0%)              .map_bound(|this| match this {
        .                         ExistentialPredicate::Trait(tr) => Some(tr),
        .                         _ => None,
        .                     })
        .                     .transpose()
    1,616 (0.0%)      }
        .         
        .             pub fn principal_def_id(&self) -> Option<DefId> {
        .                 self.principal().map(|trait_ref| trait_ref.skip_binder().def_id)
    2,424 (0.0%)      }
        .         
        .             #[inline]
        .             pub fn projection_bounds<'a>(
        .                 &'a self,
        .             ) -> impl Iterator<Item = ty::Binder<'tcx, ExistentialProjection<'tcx>>> + 'a {
        .                 self.iter().filter_map(|predicate| {
        .                     predicate
    2,048 (0.0%)                  .map_bound(|pred| match pred {
        .                             ExistentialPredicate::Projection(projection) => Some(projection),
        .                             _ => None,
        .                         })
        .                         .transpose()
        .                 })
        .             }
        .         
        .             #[inline]
        .             pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + Captures<'tcx> + 'a {
    2,820 (0.0%)          self.iter().filter_map(|predicate| match predicate.skip_binder() {
        .                     ExistentialPredicate::AutoTrait(did) => Some(did),
        .                     _ => None,
        .                 })
        .             }
        .         }
        .         
        .         /// A complete reference to a trait. These take numerous guises in syntax,
        .         /// but perhaps the most recognizable form is in a where-clause:
-- line 329 ----------------------------------------
-- line 331 ----------------------------------------
        .         /// T: Foo<U>
        .         /// ```
        .         /// This would be represented by a trait-reference where the `DefId` is the
        .         /// `DefId` for the trait `Foo` and the args define `T` as parameter 0,
        .         /// and `U` as parameter 1.
        .         ///
        .         /// Trait references also appear in object types like `Foo<U>`, but in
        .         /// that case the `Self` parameter is absent from the generic parameters.
  756,852 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
4,519,819 (0.1%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct TraitRef<'tcx> {
1,830,406 (0.0%)      pub def_id: DefId,
        .             pub args: GenericArgsRef<'tcx>,
        .             /// This field exists to prevent the creation of `TraitRef` without
        .             /// calling [`TraitRef::new`].
        .             pub(super) _use_trait_ref_new_instead: (),
        .         }
        .         
        .         impl<'tcx> TraitRef<'tcx> {
        .             pub fn new(
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_def_id: DefId,
        .                 args: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,
        .             ) -> Self {
        .                 let args = tcx.check_and_mk_args(trait_def_id, args);
  135,615 (0.0%)          Self { def_id: trait_def_id, args, _use_trait_ref_new_instead: () }
        .             }
        .         
    2,035 (0.0%)      pub fn from_lang_item(
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_lang_item: LangItem,
        .                 span: Span,
        .                 args: impl IntoIterator<Item: Into<ty::GenericArg<'tcx>>>,
        .             ) -> Self {
    4,129 (0.0%)          let trait_def_id = tcx.require_lang_item(trait_lang_item, Some(span));
        .                 Self::new(tcx, trait_def_id, args)
    1,480 (0.0%)      }
        .         
        .             pub fn from_method(
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_id: DefId,
        .                 args: GenericArgsRef<'tcx>,
        .             ) -> ty::TraitRef<'tcx> {
        .                 let defs = tcx.generics_of(trait_id);
        .                 ty::TraitRef::new(tcx, trait_id, tcx.mk_args(&args[..defs.params.len()]))
        .             }
        .         
        .             /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`
        .             /// are the parameters defined on trait.
    6,640 (0.0%)      pub fn identity(tcx: TyCtxt<'tcx>, def_id: DefId) -> TraitRef<'tcx> {
    2,656 (0.0%)          ty::TraitRef::new(tcx, def_id, GenericArgs::identity_for_item(tcx, def_id))
    4,648 (0.0%)      }
        .         
        .             pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {
        .                 ty::TraitRef::new(
        .                     tcx,
        .                     self.def_id,
        .                     [self_ty.into()].into_iter().chain(self.args.iter().skip(1)),
        .                 )
        .             }
        .         
        .             #[inline]
        .             pub fn self_ty(&self) -> Ty<'tcx> {
1,301,280 (0.0%)          self.args.type_at(0)
        .             }
        .         }
        .         
        .         pub type PolyTraitRef<'tcx> = ty::Binder<'tcx, TraitRef<'tcx>>;
        .         
        .         impl<'tcx> PolyTraitRef<'tcx> {
   54,612 (0.0%)      pub fn self_ty(&self) -> ty::Binder<'tcx, Ty<'tcx>> {
        .                 self.map_bound_ref(|tr| tr.self_ty())
   54,612 (0.0%)      }
        .         
        .             pub fn def_id(&self) -> DefId {
   91,187 (0.0%)          self.skip_binder().def_id
        .             }
        .         }
        .         
        .         impl<'tcx> IntoDiagArg for TraitRef<'tcx> {
        .             fn into_diag_arg(self) -> DiagArgValue {
        .                 self.to_string().into_diag_arg()
        .             }
        .         }
-- line 414 ----------------------------------------
-- line 415 ----------------------------------------
        .         
        .         /// An existential reference to a trait, where `Self` is erased.
        .         /// For example, the trait object `Trait<'a, 'b, X, Y>` is:
        .         /// ```ignore (illustrative)
        .         /// exists T. T: Trait<'a, 'b, X, Y>
        .         /// ```
        .         /// The generic parameters don't include the erased `Self`, only trait
        .         /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).
      360 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
  747,169 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct ExistentialTraitRef<'tcx> {
   10,545 (0.0%)      pub def_id: DefId,
        .             pub args: GenericArgsRef<'tcx>,
        .         }
        .         
        .         impl<'tcx> ExistentialTraitRef<'tcx> {
      390 (0.0%)      pub fn erase_self_ty(
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_ref: ty::TraitRef<'tcx>,
        .             ) -> ty::ExistentialTraitRef<'tcx> {
        .                 // Assert there is a Self.
      195 (0.0%)          trait_ref.args.type_at(0);
        .         
      130 (0.0%)          ty::ExistentialTraitRef {
       65 (0.0%)              def_id: trait_ref.def_id,
      195 (0.0%)              args: tcx.mk_args(&trait_ref.args[1..]),
        .                 }
      390 (0.0%)      }
        .         
        .             /// Object types don't have a self type specified. Therefore, when
        .             /// we convert the principal trait-ref into a normal trait-ref,
        .             /// you must give *some* self type. A common choice is `mk_err()`
        .             /// or some placeholder type.
    3,374 (0.0%)      pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::TraitRef<'tcx> {
        .                 // otherwise the escaping vars would be captured by the binder
        .                 // debug_assert!(!self_ty.has_escaping_bound_vars());
        .         
    1,232 (0.0%)          ty::TraitRef::new(tcx, self.def_id, [self_ty.into()].into_iter().chain(self.args.iter()))
    2,892 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> IntoDiagArg for ExistentialTraitRef<'tcx> {
        .             fn into_diag_arg(self) -> DiagArgValue {
        .                 self.to_string().into_diag_arg()
        .             }
        .         }
        .         
-- line 461 ----------------------------------------
-- line 465 ----------------------------------------
        .             pub fn def_id(&self) -> DefId {
        .                 self.skip_binder().def_id
        .             }
        .         
        .             /// Object types don't have a self type specified. Therefore, when
        .             /// we convert the principal trait-ref into a normal trait-ref,
        .             /// you must give *some* self type. A common choice is `mk_err()`
        .             /// or some placeholder type.
    1,024 (0.0%)      pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::PolyTraitRef<'tcx> {
      128 (0.0%)          self.map_bound(|trait_ref| trait_ref.with_self_ty(tcx, self_ty))
      896 (0.0%)      }
        .         }
        .         
        .         /// A `ProjectionPredicate` for an `ExistentialTraitRef`.
      129 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]
   32,572 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct ExistentialProjection<'tcx> {
    3,051 (0.0%)      pub def_id: DefId,
   10,512 (0.0%)      pub args: GenericArgsRef<'tcx>,
        .             pub term: Term<'tcx>,
        .         }
        .         
        .         pub type PolyExistentialProjection<'tcx> = ty::Binder<'tcx, ExistentialProjection<'tcx>>;
        .         
        .         impl<'tcx> ExistentialProjection<'tcx> {
        .             /// Extracts the underlying existential trait reference from this projection.
        .             /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,
        .             /// then this function would return an `exists T. T: Iterator` existential trait
        .             /// reference.
      308 (0.0%)      pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::ExistentialTraitRef<'tcx> {
      140 (0.0%)          let def_id = tcx.parent(self.def_id);
       56 (0.0%)          let args_count = tcx.generics_of(def_id).count() - 1;
       84 (0.0%)          let args = tcx.mk_args(&self.args[..args_count]);
       84 (0.0%)          ty::ExistentialTraitRef { def_id, args }
      252 (0.0%)      }
        .         
      350 (0.0%)      pub fn with_self_ty(
        .                 &self,
        .                 tcx: TyCtxt<'tcx>,
        .                 self_ty: Ty<'tcx>,
        .             ) -> ty::ProjectionPredicate<'tcx> {
        .                 // otherwise the escaping regions would be captured by the binders
        .                 debug_assert!(!self_ty.has_escaping_bound_vars());
        .         
      150 (0.0%)          ty::ProjectionPredicate {
        .                     projection_ty: AliasTy::new(
        .                         tcx,
       50 (0.0%)                  self.def_id,
       50 (0.0%)                  [self_ty.into()].into_iter().chain(self.args),
        .                     ),
       50 (0.0%)              term: self.term,
        .                 }
      300 (0.0%)      }
        .         
       78 (0.0%)      pub fn erase_self_ty(
        .                 tcx: TyCtxt<'tcx>,
        .                 projection_predicate: ty::ProjectionPredicate<'tcx>,
        .             ) -> Self {
        .                 // Assert there is a Self.
       39 (0.0%)          projection_predicate.projection_ty.args.type_at(0);
        .         
       39 (0.0%)          Self {
       13 (0.0%)              def_id: projection_predicate.projection_ty.def_id,
       39 (0.0%)              args: tcx.mk_args(&projection_predicate.projection_ty.args[1..]),
       13 (0.0%)              term: projection_predicate.term,
        .                 }
       78 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> PolyExistentialProjection<'tcx> {
        7 (0.0%)      pub fn with_self_ty(
        .                 &self,
        .                 tcx: TyCtxt<'tcx>,
        .                 self_ty: Ty<'tcx>,
        .             ) -> ty::PolyProjectionPredicate<'tcx> {
        .                 self.map_bound(|p| p.with_self_ty(tcx, self_ty))
        6 (0.0%)      }
        .         
        .             pub fn item_def_id(&self) -> DefId {
        .                 self.skip_binder().def_id
        .             }
        .         }
        .         
        .         impl<'tcx> Clause<'tcx> {
        .             /// Performs a instantiation suitable for going from a
        .             /// poly-trait-ref to supertraits that must hold if that
        .             /// poly-trait-ref holds. This is slightly different from a normal
        .             /// instantiation in terms of what happens with bound regions. See
        .             /// lengthy comment below for details.
  301,432 (0.0%)      pub fn instantiate_supertrait(
        .                 self,
        .                 tcx: TyCtxt<'tcx>,
        .                 trait_ref: &ty::PolyTraitRef<'tcx>,
        .             ) -> Clause<'tcx> {
        .                 // The interaction between HRTB and supertraits is not entirely
        .                 // obvious. Let me walk you (and myself) through an example.
        .                 //
        .                 // Let's start with an easy case. Consider two traits:
-- line 562 ----------------------------------------
-- line 630 ----------------------------------------
        .                 // 3) Finally, to create the final bound vars, we concatenate the bound
        .                 //    vars of the trait ref with those of the predicate:
        .                 //    ['x, 'b]
        .                 let bound_pred = self.kind();
        .                 let pred_bound_vars = bound_pred.bound_vars();
        .                 let trait_bound_vars = trait_ref.bound_vars();
        .                 // 1) Self: Bar1<'a, '^0.0> -> Self: Bar1<'a, '^0.1>
        .                 let shifted_pred =
  150,716 (0.0%)              tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());
        .                 // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>
   37,679 (0.0%)          let new = EarlyBinder::bind(shifted_pred).instantiate(tcx, trait_ref.skip_binder().args);
        .                 // 3) ['x] + ['b] -> ['x, 'b]
        .                 let bound_vars =
    1,071 (0.0%)              tcx.mk_bound_variable_kinds_from_iter(trait_bound_vars.iter().chain(pred_bound_vars));
        .         
        .                 // FIXME: Is it really perf sensitive to use reuse_or_mk_predicate here?
        .                 tcx.reuse_or_mk_predicate(
        .                     self.as_predicate(),
  150,716 (0.0%)              ty::Binder::bind_with_vars(PredicateKind::Clause(new), bound_vars),
        .                 )
        .                 .expect_clause()
  339,111 (0.0%)      }
        .         }
        .         
  359,488 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
  909,622 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct TraitPredicate<'tcx> {
2,682,492 (0.0%)      pub trait_ref: TraitRef<'tcx>,
        .         
        .             /// If polarity is Positive: we are proving that the trait is implemented.
        .             ///
        .             /// If polarity is Negative: we are proving that a negative impl of this trait
        .             /// exists. (Note that coherence also checks whether negative impls of supertraits
        .             /// exist via a series of predicates.)
        .             ///
        .             /// If polarity is Reserved: that's a bug.
-- line 665 ----------------------------------------
-- line 672 ----------------------------------------
        .             pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {
        .                 Self { trait_ref: self.trait_ref.with_self_ty(tcx, self_ty), ..self }
        .             }
        .         
        .             pub fn def_id(self) -> DefId {
        .                 self.trait_ref.def_id
        .             }
        .         
1,164,300 (0.0%)      pub fn self_ty(self) -> Ty<'tcx> {
        .                 self.trait_ref.self_ty()
1,164,300 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> PolyTraitPredicate<'tcx> {
        .             pub fn def_id(self) -> DefId {
        .                 // Ok to skip binder since trait `DefId` does not care about regions.
    1,244 (0.0%)          self.skip_binder().def_id()
        .             }
        .         
  318,081 (0.0%)      pub fn self_ty(self) -> ty::Binder<'tcx, Ty<'tcx>> {
  318,081 (0.0%)          self.map_bound(|trait_ref| trait_ref.self_ty())
  318,081 (0.0%)      }
        .         
        .             #[inline]
        .             pub fn polarity(self) -> PredicatePolarity {
        .                 self.skip_binder().polarity
        .             }
        .         }
        .         
        .         /// `A: B`
    1,856 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]
  156,745 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
      745 (0.0%)  pub struct OutlivesPredicate<A, B>(pub A, pub B);
        .         pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;
        .         pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;
        .         pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;
        .         pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicate<'tcx>>;
        .         
        .         /// Encodes that `a` must be a subtype of `b`. The `a_is_expected` flag indicates
        .         /// whether the `a` type is the type that we should label as "expected" when
        .         /// presenting user diagnostics.
-- line 712 ----------------------------------------
-- line 736 ----------------------------------------
        .         ///
        .         /// In particular, form #1 is "desugared" to the combination of a
        .         /// normal trait predicate (`T: TraitRef<...>`) and one of these
        .         /// predicates. Form #2 is a broader form in that it also permits
        .         /// equality between arbitrary types. Processing an instance of
        .         /// Form #2 eventually yields one of these `ProjectionPredicate`
        .         /// instances to normalize the LHS.
        .         #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
    6,740 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct ProjectionPredicate<'tcx> {
   10,611 (0.0%)      pub projection_ty: AliasTy<'tcx>,
        .             pub term: Term<'tcx>,
        .         }
        .         
        .         impl<'tcx> ProjectionPredicate<'tcx> {
        .             pub fn self_ty(self) -> Ty<'tcx> {
        .                 self.projection_ty.self_ty()
        .             }
        .         
-- line 754 ----------------------------------------
-- line 792 ----------------------------------------
        .             }
        .         
        .             /// The `DefId` of the `TraitItem` for the associated type.
        .             ///
        .             /// Note that this is not the `DefId` of the `TraitRef` containing this
        .             /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.
        .             pub fn projection_def_id(&self) -> DefId {
        .                 // Ok to skip binder since trait `DefId` does not care about regions.
       26 (0.0%)          self.skip_binder().projection_ty.def_id
        .             }
        .         }
        .         
        .         /// Used by the new solver. Unlike a `ProjectionPredicate` this can only be
        .         /// proven by actually normalizing `alias`.
        .         #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
        .         #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
        .         pub struct NormalizesTo<'tcx> {
-- line 808 ----------------------------------------
-- line 829 ----------------------------------------
        .         }
        .         
        .         pub trait ToPolyTraitRef<'tcx> {
        .             fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;
        .         }
        .         
        .         impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {
        .             fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {
  215,046 (0.0%)          self.map_bound_ref(|trait_pred| trait_pred.trait_ref)
        .             }
        .         }
        .         
        .         pub trait ToPredicate<'tcx, P = Predicate<'tcx>> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> P;
        .         }
        .         
        .         impl<'tcx, T> ToPredicate<'tcx, T> for T {
-- line 845 ----------------------------------------
-- line 881 ----------------------------------------
        .             fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
        .                 self.as_predicate()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for ClauseKind<'tcx> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
      763 (0.0%)          tcx.mk_predicate(Binder::dummy(ty::PredicateKind::Clause(self))).expect_clause()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for Binder<'tcx, ClauseKind<'tcx>> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
  101,949 (0.0%)          tcx.mk_predicate(self.map_bound(|clause| ty::PredicateKind::Clause(clause))).expect_clause()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
      740 (0.0%)          ty::Binder::dummy(self).to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, TraitPredicate<'tcx>> for TraitRef<'tcx> {
        .             #[inline(always)]
        .             fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> TraitPredicate<'tcx> {
        .                 TraitPredicate { trait_ref: self, polarity: PredicatePolarity::Positive }
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for TraitRef<'tcx> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let p: Predicate<'tcx> = self.to_predicate(tcx);
    6,479 (0.0%)          p.expect_clause()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
      555 (0.0%)          let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);
  208,054 (0.0%)          pred.to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {
        .             #[inline(always)]
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);
   30,741 (0.0%)          pred.to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {
        .             #[inline(always)]
        .             fn to_predicate(self, _: TyCtxt<'tcx>) -> PolyTraitPredicate<'tcx> {
        .                 self.map_bound(|trait_ref| TraitPredicate {
        .                     trait_ref,
-- line 942 ----------------------------------------
-- line 947 ----------------------------------------
        .         
        .         impl<'tcx> ToPredicate<'tcx> for TraitPredicate<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
        .                 PredicateKind::Clause(ClauseKind::Trait(self)).to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {
  727,101 (0.0%)      fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
  252,614 (0.0%)          self.map_bound(|p| PredicateKind::Clause(ClauseKind::Trait(p))).to_predicate(tcx)
  727,101 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for TraitPredicate<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let p: Predicate<'tcx> = self.to_predicate(tcx);
        .                 p.expect_clause()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for PolyTraitPredicate<'tcx> {
   30,741 (0.0%)      fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let p: Predicate<'tcx> = self.to_predicate(tcx);
        .                 p.expect_clause()
   30,741 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {
       30 (0.0%)      fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
       20 (0.0%)          self.map_bound(|p| PredicateKind::Clause(ClauseKind::RegionOutlives(p))).to_predicate(tcx)
       30 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
        .                 ty::Binder::dummy(PredicateKind::Clause(ClauseKind::TypeOutlives(self))).to_predicate(tcx)
        .             }
        .         }
        .         
-- line 985 ----------------------------------------
-- line 986 ----------------------------------------
        .         impl<'tcx> ToPredicate<'tcx> for ProjectionPredicate<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
        .                 ty::Binder::dummy(PredicateKind::Clause(ClauseKind::Projection(self))).to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
       79 (0.0%)          self.map_bound(|p| PredicateKind::Clause(ClauseKind::Projection(p))).to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for ProjectionPredicate<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let p: Predicate<'tcx> = self.to_predicate(tcx);
        .                 p.expect_clause()
        .             }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx, Clause<'tcx>> for PolyProjectionPredicate<'tcx> {
      237 (0.0%)      fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Clause<'tcx> {
        .                 let p: Predicate<'tcx> = self.to_predicate(tcx);
        .                 p.expect_clause()
      237 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> ToPredicate<'tcx> for NormalizesTo<'tcx> {
        .             fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {
        .                 PredicateKind::NormalizesTo(self).to_predicate(tcx)
        .             }
        .         }
        .         
        .         impl<'tcx> Predicate<'tcx> {
        .             pub fn to_opt_poly_trait_pred(self) -> Option<PolyTraitPredicate<'tcx>> {
        .                 let predicate = self.kind();
    6,512 (0.0%)          match predicate.skip_binder() {
    2,392 (0.0%)              PredicateKind::Clause(ClauseKind::Trait(t)) => Some(predicate.rebind(t)),
        .                     PredicateKind::Clause(ClauseKind::Projection(..))
        .                     | PredicateKind::Clause(ClauseKind::ConstArgHasType(..))
        .                     | PredicateKind::NormalizesTo(..)
        .                     | PredicateKind::AliasRelate(..)
        .                     | PredicateKind::Subtype(..)
        .                     | PredicateKind::Coerce(..)
        .                     | PredicateKind::Clause(ClauseKind::RegionOutlives(..))
        .                     | PredicateKind::Clause(ClauseKind::WellFormed(..))
-- line 1030 ----------------------------------------
-- line 1033 ----------------------------------------
        .                     | PredicateKind::Clause(ClauseKind::ConstEvaluatable(..))
        .                     | PredicateKind::ConstEquate(..)
        .                     | PredicateKind::Ambiguous => None,
        .                 }
        .             }
        .         
        .             pub fn to_opt_poly_projection_pred(self) -> Option<PolyProjectionPredicate<'tcx>> {
        .                 let predicate = self.kind();
    1,804 (0.0%)          match predicate.skip_binder() {
        .                     PredicateKind::Clause(ClauseKind::Projection(t)) => Some(predicate.rebind(t)),
        .                     PredicateKind::Clause(ClauseKind::Trait(..))
        .                     | PredicateKind::Clause(ClauseKind::ConstArgHasType(..))
        .                     | PredicateKind::NormalizesTo(..)
        .                     | PredicateKind::AliasRelate(..)
        .                     | PredicateKind::Subtype(..)
        .                     | PredicateKind::Coerce(..)
        .                     | PredicateKind::Clause(ClauseKind::RegionOutlives(..))
-- line 1049 ----------------------------------------
-- line 1052 ----------------------------------------
        .                     | PredicateKind::Clause(ClauseKind::TypeOutlives(..))
        .                     | PredicateKind::Clause(ClauseKind::ConstEvaluatable(..))
        .                     | PredicateKind::ConstEquate(..)
        .                     | PredicateKind::Ambiguous => None,
        .                 }
        .             }
        .         
        .             /// Matches a `PredicateKind::Clause` and turns it into a `Clause`, otherwise returns `None`.
1,531,954 (0.0%)      pub fn as_clause(self) -> Option<Clause<'tcx>> {
3,063,908 (0.0%)          match self.kind().skip_binder() {
        .                     PredicateKind::Clause(..) => Some(self.expect_clause()),
        .                     _ => None,
        .                 }
1,531,954 (0.0%)      }
        .         
        .             /// Assert that the predicate is a clause.
1,911,376 (0.0%)      pub fn expect_clause(self) -> Clause<'tcx> {
1,747,978 (0.0%)          match self.kind().skip_binder() {
        .                     PredicateKind::Clause(..) => Clause(self.0),
        .                     _ => bug!("{self} is not a clause"),
        .                 }
1,911,376 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/relate.rs
--------------------------------------------------------------------------------
Ir______________ 

3,732,653 (0.0%)  <unknown (line 0)>

-- line 19 ----------------------------------------
        .         
        .         pub trait TypeRelation<'tcx>: Sized {
        .             fn tcx(&self) -> TyCtxt<'tcx>;
        .         
        .             /// Returns a static string we can use for printouts.
        .             fn tag(&self) -> &'static str;
        .         
        .             /// Generic relation routine suitable for most anything.
   82,698 (0.0%)      fn relate<T: Relate<'tcx>>(&mut self, a: T, b: T) -> RelateResult<'tcx, T> {
1,091,468 (0.0%)          Relate::relate(self, a, b)
   55,680 (0.0%)      }
        .         
        .             /// Relate the two args for the given item. The default
        .             /// is to look up the variance for the item and proceed
        .             /// accordingly.
        .             fn relate_item_args(
        .                 &mut self,
        .                 item_def_id: DefId,
        .                 a_arg: GenericArgsRef<'tcx>,
-- line 37 ----------------------------------------
-- line 92 ----------------------------------------
        .                 b: Self,
        .             ) -> RelateResult<'tcx, Self>;
        .         }
        .         
        .         ///////////////////////////////////////////////////////////////////////////
        .         // Relate impls
        .         
        .         #[inline]
2,084,913 (0.0%)  pub fn relate_args_invariantly<'tcx, R: TypeRelation<'tcx>>(
        .             relation: &mut R,
        .             a_arg: GenericArgsRef<'tcx>,
        .             b_arg: GenericArgsRef<'tcx>,
        .         ) -> RelateResult<'tcx, GenericArgsRef<'tcx>> {
  454,932 (0.0%)      relation.tcx().mk_args_from_iter(iter::zip(a_arg, b_arg).map(|(a, b)| {
  267,937 (0.0%)          relation.relate_with_variance(ty::Invariant, ty::VarianceDiagInfo::default(), a, b)
      224 (0.0%)      }))
1,853,256 (0.0%)  }
        .         
        .         pub fn relate_args_with_variances<'tcx, R: TypeRelation<'tcx>>(
        .             relation: &mut R,
        .             ty_def_id: DefId,
        .             variances: &[ty::Variance],
        .             a_arg: GenericArgsRef<'tcx>,
        .             b_arg: GenericArgsRef<'tcx>,
        .             fetch_ty_for_diag: bool,
        .         ) -> RelateResult<'tcx, GenericArgsRef<'tcx>> {
    9,382 (0.0%)      let tcx = relation.tcx();
        .         
    4,691 (0.0%)      let mut cached_ty = None;
        .             let params = iter::zip(a_arg, b_arg).enumerate().map(|(i, (a, b))| {
   20,382 (0.0%)          let variance = variances[i];
    4,729 (0.0%)          let variance_info = if variance == ty::Invariant && fetch_ty_for_diag {
        .                     let ty =
        .                         *cached_ty.get_or_insert_with(|| tcx.type_of(ty_def_id).instantiate(tcx, a_arg));
        .                     ty::VarianceDiagInfo::Invariant { ty, param_index: i.try_into().unwrap() }
        .                 } else {
        .                     ty::VarianceDiagInfo::default()
        .                 };
    5,815 (0.0%)          relation.relate_with_variance(variance, variance_info, a, b)
        .             });
        .         
   14,073 (0.0%)      tcx.mk_args_from_iter(params)
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {
    2,627 (0.0%)      fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::FnSig<'tcx>,
        .                 b: ty::FnSig<'tcx>,
        .             ) -> RelateResult<'tcx, ty::FnSig<'tcx>> {
        .                 let tcx = relation.tcx();
        .         
    2,952 (0.0%)          if a.c_variadic != b.c_variadic {
        .                     return Err(TypeError::VariadicMismatch(expected_found(a.c_variadic, b.c_variadic)));
        .                 }
    2,214 (0.0%)          let unsafety = relation.relate(a.unsafety, b.unsafety)?;
    1,476 (0.0%)          let abi = relation.relate(a.abi, b.abi)?;
        .         
    3,939 (0.0%)          if a.inputs().len() != b.inputs().len() {
        .                     return Err(TypeError::ArgCount);
        .                 }
        .         
    2,586 (0.0%)          let inputs_and_output = iter::zip(a.inputs(), b.inputs())
        .                     .map(|(&a, &b)| ((a, b), false))
    2,539 (0.0%)              .chain(iter::once(((a.output(), b.output()), true)))
      369 (0.0%)              .map(|((a, b), is_output)| {
      369 (0.0%)                  if is_output {
       78 (0.0%)                      relation.relate(a, b)
        .                         } else {
      187 (0.0%)                      relation.relate_with_variance(
        .                                 ty::Contravariant,
        .                                 ty::VarianceDiagInfo::default(),
        .                                 a,
        .                                 b,
        .                             )
        .                         }
        .                     })
        .                     .enumerate()
    6,048 (0.0%)              .map(|(i, r)| match r {
        .                         Err(TypeError::Sorts(exp_found) | TypeError::ArgumentSorts(exp_found, _)) => {
        .                             Err(TypeError::ArgumentSorts(exp_found, i))
        .                         }
        .                         Err(TypeError::Mutability | TypeError::ArgumentMutability(_)) => {
        .                             Err(TypeError::ArgumentMutability(i))
        .                         }
    1,836 (0.0%)                  r => r,
        .                     });
    3,271 (0.0%)          Ok(ty::FnSig {
        .                     inputs_and_output: tcx.mk_type_list_from_iter(inputs_and_output)?,
       41 (0.0%)              c_variadic: a.c_variadic,
        .                     unsafety,
        .                     abi,
        .                 })
    2,624 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::BoundConstness {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 _relation: &mut R,
        .                 a: ty::BoundConstness,
        .                 b: ty::BoundConstness,
        .             ) -> RelateResult<'tcx, ty::BoundConstness> {
-- line 193 ----------------------------------------
-- line 196 ----------------------------------------
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for hir::Unsafety {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 _relation: &mut R,
        .                 a: hir::Unsafety,
        .                 b: hir::Unsafety,
        .             ) -> RelateResult<'tcx, hir::Unsafety> {
      369 (0.0%)          if a != b { Err(TypeError::UnsafetyMismatch(expected_found(a, b))) } else { Ok(a) }
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for abi::Abi {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 _relation: &mut R,
        .                 a: abi::Abi,
        .                 b: abi::Abi,
        .             ) -> RelateResult<'tcx, abi::Abi> {
        .                 if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(a, b))) }
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::AliasTy<'tcx> {
   25,020 (0.0%)      fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::AliasTy<'tcx>,
        .                 b: ty::AliasTy<'tcx>,
        .             ) -> RelateResult<'tcx, ty::AliasTy<'tcx>> {
        .                 if a.def_id != b.def_id {
    1,152 (0.0%)              Err(TypeError::ProjectionMismatched(expected_found(a.def_id, b.def_id)))
        .                 } else {
   22,128 (0.0%)              let args = match relation.tcx().def_kind(a.def_id) {
        .                         DefKind::OpaqueTy => relate_args_with_variances(
        .                             relation,
        .                             a.def_id,
        .                             relation.tcx().variances_of(a.def_id),
        .                             a.args,
        .                             b.args,
        .                             false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle
        .                         )?,
        .                         DefKind::AssocTy | DefKind::AssocConst | DefKind::TyAlias => {
    8,169 (0.0%)                      relate_args_invariantly(relation, a.args, b.args)?
        .                         }
        .                         def => bug!("unknown alias DefKind: {def:?}"),
        .                     };
   18,837 (0.0%)              Ok(ty::AliasTy::new(relation.tcx(), a.def_id, args))
        .                 }
   22,240 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::ExistentialProjection<'tcx>,
        .                 b: ty::ExistentialProjection<'tcx>,
        .             ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {
-- line 251 ----------------------------------------
-- line 253 ----------------------------------------
        .                     Err(TypeError::ProjectionMismatched(expected_found(a.def_id, b.def_id)))
        .                 } else {
        .                     let term = relation.relate_with_variance(
        .                         ty::Invariant,
        .                         ty::VarianceDiagInfo::default(),
        .                         a.term,
        .                         b.term,
        .                     )?;
    2,400 (0.0%)              let args = relation.relate_with_variance(
        .                         ty::Invariant,
        .                         ty::VarianceDiagInfo::default(),
        .                         a.args,
        .                         b.args,
        .                     )?;
    1,800 (0.0%)              Ok(ty::ExistentialProjection { def_id: a.def_id, args, term })
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::TraitRef<'tcx>,
        .                 b: ty::TraitRef<'tcx>,
        .             ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {
        .                 // Different traits cannot be related.
        .                 if a.def_id != b.def_id {
        .                     Err(TypeError::Traits(expected_found(a.def_id, b.def_id)))
        .                 } else {
  230,778 (0.0%)              let args = relate_args_invariantly(relation, a.args, b.args)?;
   64,908 (0.0%)              Ok(ty::TraitRef::new(relation.tcx(), a.def_id, args))
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::ExistentialTraitRef<'tcx>,
        .                 b: ty::ExistentialTraitRef<'tcx>,
        .             ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {
        .                 // Different traits cannot be related.
        .                 if a.def_id != b.def_id {
        .                     Err(TypeError::Traits(expected_found(a.def_id, b.def_id)))
        .                 } else {
        .                     let args = relate_args_invariantly(relation, a.args, b.args)?;
   17,109 (0.0%)              Ok(ty::ExistentialTraitRef { def_id: a.def_id, args })
        .                 }
        .             }
        .         }
        .         
        .         #[derive(PartialEq, Copy, Debug, Clone, TypeFoldable, TypeVisitable)]
        .         struct CoroutineWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);
        .         
        .         impl<'tcx> Relate<'tcx> for CoroutineWitness<'tcx> {
-- line 307 ----------------------------------------
-- line 320 ----------------------------------------
        .         
        .         impl<'tcx> Relate<'tcx> for ImplSubject<'tcx> {
        .             #[inline]
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ImplSubject<'tcx>,
        .                 b: ImplSubject<'tcx>,
        .             ) -> RelateResult<'tcx, ImplSubject<'tcx>> {
      680 (0.0%)          match (a, b) {
        .                     (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {
        .                         let trait_ref = ty::TraitRef::relate(relation, trait_ref_a, trait_ref_b)?;
        .                         Ok(ImplSubject::Trait(trait_ref))
        .                     }
        .                     (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {
        .                         let ty = Ty::relate(relation, ty_a, ty_b)?;
        .                         Ok(ImplSubject::Inherent(ty))
        .                     }
-- line 336 ----------------------------------------
-- line 344 ----------------------------------------
        .         
        .         impl<'tcx> Relate<'tcx> for Ty<'tcx> {
        .             #[inline]
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: Ty<'tcx>,
        .                 b: Ty<'tcx>,
        .             ) -> RelateResult<'tcx, Ty<'tcx>> {
  980,786 (0.0%)          relation.tys(a, b)
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for Pattern<'tcx> {
        .             #[inline]
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: Self,
-- line 360 ----------------------------------------
-- line 381 ----------------------------------------
        .                     }
        .                 }
        .             }
        .         }
        .         
        .         /// Relates `a` and `b` structurally, calling the relation for all nested values.
        .         /// Any semantic equality, e.g. of projections, and inference variables have to be
        .         /// handled by the caller.
7,408,773 (0.1%)  #[instrument(level = "trace", skip(relation), ret)]
        .         pub fn structurally_relate_tys<'tcx, R: TypeRelation<'tcx>>(
        .             relation: &mut R,
        .             a: Ty<'tcx>,
        .             b: Ty<'tcx>,
        .         ) -> RelateResult<'tcx, Ty<'tcx>> {
        .             let tcx = relation.tcx();
6,741,741 (0.1%)      match (a.kind(), b.kind()) {
        .                 (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {
        .                     // The caller should handle these cases!
        .                     bug!("var types encountered in structurally_relate_tys")
        .                 }
        .         
        .                 (ty::Bound(..), _) | (_, ty::Bound(..)) => {
        .                     bug!("bound types encountered in structurally_relate_tys")
        .                 }
-- line 404 ----------------------------------------
-- line 407 ----------------------------------------
        .         
        .                 (&ty::Never, _)
        .                 | (&ty::Char, _)
        .                 | (&ty::Bool, _)
        .                 | (&ty::Int(_), _)
        .                 | (&ty::Uint(_), _)
        .                 | (&ty::Float(_), _)
        .                 | (&ty::Str, _)
   18,160 (0.0%)              if a == b =>
        .                 {
        .                     Ok(a)
        .                 }
        .         
   44,697 (0.0%)          (ty::Param(a_p), ty::Param(b_p)) if a_p.index == b_p.index => {
        .                     debug_assert_eq!(a_p.name, b_p.name, "param types with same index differ in name");
        .                     Ok(a)
        .                 }
        .         
        .                 (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => Ok(a),
        .         
  327,229 (0.0%)          (&ty::Adt(a_def, a_args), &ty::Adt(b_def, b_args)) if a_def == b_def => {
  108,940 (0.0%)              let args = relation.relate_item_args(a_def.did(), a_args, b_args)?;
        .                     Ok(Ty::new_adt(tcx, a_def, args))
        .                 }
        .         
        .                 (&ty::Foreign(a_id), &ty::Foreign(b_id)) if a_id == b_id => Ok(Ty::new_foreign(tcx, a_id)),
        .         
   46,802 (0.0%)          (&ty::Dynamic(a_obj, a_region, a_repr), &ty::Dynamic(b_obj, b_region, b_repr))
    6,686 (0.0%)              if a_repr == b_repr =>
        .                 {
        .                     Ok(Ty::new_dynamic(
        .                         tcx,
   20,058 (0.0%)                  relation.relate(a_obj, b_obj)?,
        .                         relation.relate(a_region, b_region)?,
        .                         a_repr,
        .                     ))
        .                 }
        .         
        .                 (&ty::Coroutine(a_id, a_args), &ty::Coroutine(b_id, b_args)) if a_id == b_id => {
        .                     // All Coroutine types with the same id represent
        .                     // the (anonymous) type of the same coroutine expression. So
-- line 447 ----------------------------------------
-- line 470 ----------------------------------------
        .         
        .                 (&ty::CoroutineClosure(a_id, a_args), &ty::CoroutineClosure(b_id, b_args))
        .                     if a_id == b_id =>
        .                 {
        .                     let args = relate_args_invariantly(relation, a_args, b_args)?;
        .                     Ok(Ty::new_coroutine_closure(tcx, a_id, args))
        .                 }
        .         
    4,899 (0.0%)          (&ty::RawPtr(a_ty, a_mutbl), &ty::RawPtr(b_ty, b_mutbl)) => {
    1,633 (0.0%)              if a_mutbl != b_mutbl {
        .                         return Err(TypeError::Mutability);
        .                     }
        .         
        .                     let (variance, info) = match a_mutbl {
        .                         hir::Mutability::Not => (ty::Covariant, ty::VarianceDiagInfo::None),
        .                         hir::Mutability::Mut => {
        .                             (ty::Invariant, ty::VarianceDiagInfo::Invariant { ty: a, param_index: 0 })
        .                         }
        .                     };
        .         
    4,899 (0.0%)              let ty = relation.relate_with_variance(variance, info, a_ty, b_ty)?;
        .         
        .                     Ok(Ty::new_ptr(tcx, ty, a_mutbl))
        .                 }
        .         
  102,498 (0.0%)          (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {
   12,814 (0.0%)              if a_mutbl != b_mutbl {
        .                         return Err(TypeError::Mutability);
        .                     }
        .         
        .                     let (variance, info) = match a_mutbl {
        .                         hir::Mutability::Not => (ty::Covariant, ty::VarianceDiagInfo::None),
        .                         hir::Mutability::Mut => {
        .                             (ty::Invariant, ty::VarianceDiagInfo::Invariant { ty: a, param_index: 0 })
        .                         }
        .                     };
        .         
        .                     let r = relation.relate(a_r, b_r)?;
   76,872 (0.0%)              let ty = relation.relate_with_variance(variance, info, a_ty, b_ty)?;
        .         
        .                     Ok(Ty::new_ref(tcx, r, ty, a_mutbl))
        .                 }
        .         
    1,158 (0.0%)          (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) => {
        .                     let t = relation.relate(a_t, b_t)?;
      579 (0.0%)              match relation.relate(sz_a, sz_b) {
      386 (0.0%)                  Ok(sz) => Ok(Ty::new_array_with_const_len(tcx, t, sz)),
        .                         Err(err) => {
        .                             // Check whether the lengths are both concrete/known values,
        .                             // but are unequal, for better diagnostics.
        .                             let sz_a = sz_a.try_to_target_usize(tcx);
        .                             let sz_b = sz_b.try_to_target_usize(tcx);
        .         
        .                             match (sz_a, sz_b) {
        .                                 (Some(sz_a_val), Some(sz_b_val)) if sz_a_val != sz_b_val => {
-- line 524 ----------------------------------------
-- line 525 ----------------------------------------
        .                                     Err(TypeError::FixedArraySize(expected_found(sz_a_val, sz_b_val)))
        .                                 }
        .                                 _ => Err(err),
        .                             }
        .                         }
        .                     }
        .                 }
        .         
    7,356 (0.0%)          (&ty::Slice(a_t), &ty::Slice(b_t)) => {
        .                     let t = relation.relate(a_t, b_t)?;
        .                     Ok(Ty::new_slice(tcx, t))
        .                 }
        .         
    6,022 (0.0%)          (&ty::Tuple(as_), &ty::Tuple(bs)) => {
    6,022 (0.0%)              if as_.len() == bs.len() {
        .                         Ok(Ty::new_tup_from_iter(
    3,011 (0.0%)                      tcx,
    3,488 (0.0%)                      iter::zip(as_, bs).map(|(a, b)| relation.relate(a, b)),
        .                         )?)
        .                     } else if !(as_.is_empty() || bs.is_empty()) {
        .                         Err(TypeError::TupleSize(expected_found(as_.len(), bs.len())))
        .                     } else {
        .                         Err(TypeError::Sorts(expected_found(a, b)))
        .                     }
        .                 }
        .         
        .                 (&ty::FnDef(a_def_id, a_args), &ty::FnDef(b_def_id, b_args)) if a_def_id == b_def_id => {
        .                     let args = relation.relate_item_args(a_def_id, a_args, b_args)?;
        .                     Ok(Ty::new_fn_def(tcx, a_def_id, args))
        .                 }
        .         
      115 (0.0%)          (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) => {
        .                     let fty = relation.relate(a_fty, b_fty)?;
        .                     Ok(Ty::new_fn_ptr(tcx, fty))
        .                 }
        .         
        .                 // Alias tend to mostly already be handled downstream due to normalization.
    2,114 (0.0%)          (&ty::Alias(a_kind, a_data), &ty::Alias(b_kind, b_data)) => {
      274 (0.0%)              let alias_ty = relation.relate(a_data, b_data)?;
       14 (0.0%)              assert_eq!(a_kind, b_kind);
        .                     Ok(Ty::new_alias(tcx, a_kind, alias_ty))
        .                 }
        .         
        .                 (&ty::Pat(a_ty, a_pat), &ty::Pat(b_ty, b_pat)) => {
        .                     let ty = relation.relate(a_ty, b_ty)?;
        .                     let pat = relation.relate(a_pat, b_pat)?;
        .                     Ok(Ty::new_pat(tcx, ty, pat))
        .                 }
-- line 572 ----------------------------------------
-- line 576 ----------------------------------------
        .         }
        .         
        .         /// Relates `a` and `b` structurally, calling the relation for all nested values.
        .         /// Any semantic equality, e.g. of unevaluated consts, and inference variables have
        .         /// to be handled by the caller.
        .         ///
        .         /// FIXME: This is not totally structual, which probably should be fixed.
        .         /// See the HACKs below.
    2,702 (0.0%)  pub fn structurally_relate_consts<'tcx, R: TypeRelation<'tcx>>(
        .             relation: &mut R,
        .             mut a: ty::Const<'tcx>,
        .             mut b: ty::Const<'tcx>,
        .         ) -> RelateResult<'tcx, ty::Const<'tcx>> {
        .             debug!("{}.structurally_relate_consts(a = {:?}, b = {:?})", relation.tag(), a, b);
      193 (0.0%)      let tcx = relation.tcx();
        .         
      772 (0.0%)      if tcx.features().generic_const_exprs {
        .                 a = tcx.expand_abstract_consts(a);
        .                 b = tcx.expand_abstract_consts(b);
        .             }
        .         
        .             debug!("{}.structurally_relate_consts(normed_a = {:?}, normed_b = {:?})", relation.tag(), a, b);
        .         
        .             // Currently, the values that can be unified are primitive types,
        .             // and those that derive both `PartialEq` and `Eq`, corresponding
        .             // to structural-match types.
    2,702 (0.0%)      let is_match = match (a.kind(), b.kind()) {
        .                 (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {
        .                     // The caller should handle these cases!
        .                     bug!("var types encountered in structurally_relate_consts: {:?} {:?}", a, b)
        .                 }
        .         
        .                 (ty::ConstKind::Error(_), _) => return Ok(a),
        .                 (_, ty::ConstKind::Error(_)) => return Ok(b),
        .         
        .                 (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) if a_p.index == b_p.index => {
        .                     debug_assert_eq!(a_p.name, b_p.name, "param types with same index differ in name");
        .                     true
        .                 }
        .                 (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,
    1,930 (0.0%)          (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,
        .         
        .                 // While this is slightly incorrect, it shouldn't matter for `min_const_generics`
        .                 // and is the better alternative to waiting until `generic_const_exprs` can
        .                 // be stabilized.
        .                 (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu)) if au.def == bu.def => {
        .                     assert_eq!(a.ty(), b.ty());
        .                     let args = relation.relate_with_variance(
        .                         ty::Variance::Invariant,
-- line 624 ----------------------------------------
-- line 670 ----------------------------------------
        .                             Expr::FunctionCall(func, related_args)
        .                         }
        .                         _ => return Err(TypeError::ConstMismatch(expected_found(a, b))),
        .                     };
        .                     return Ok(ty::Const::new_expr(tcx, expr, a.ty()));
        .                 }
        .                 _ => false,
        .             };
      579 (0.0%)      if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(a, b))) }
    1,544 (0.0%)  }
        .         
        .         impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: Self,
        .                 b: Self,
        .             ) -> RelateResult<'tcx, Self> {
   13,372 (0.0%)          let tcx = relation.tcx();
        .         
        .                 // FIXME: this is wasteful, but want to do a perf run to see how slow it is.
        .                 // We need to perform this deduplication as we sometimes generate duplicate projections
        .                 // in `a`.
        .                 let mut a_v: Vec<_> = a.into_iter().collect();
        .                 let mut b_v: Vec<_> = b.into_iter().collect();
        .                 // `skip_binder` here is okay because `stable_cmp` doesn't look at binders
  114,420 (0.0%)          a_v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));
        .                 a_v.dedup();
        .                 b_v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));
        .                 b_v.dedup();
   13,372 (0.0%)          if a_v.len() != b_v.len() {
    1,710 (0.0%)              return Err(TypeError::ExistentialMismatch(expected_found(a, b)));
        .                 }
        .         
  182,372 (0.0%)          let v = iter::zip(a_v, b_v).map(|(ep_a, ep_b)| {
        .                     use crate::ty::ExistentialPredicate::*;
  229,975 (0.0%)              match (ep_a.skip_binder(), ep_b.skip_binder()) {
   31,786 (0.0%)                  (Trait(a), Trait(b)) => Ok(ep_a
    7,626 (0.0%)                      .rebind(Trait(relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder()))),
    5,426 (0.0%)                  (Projection(a), Projection(b)) => Ok(ep_a.rebind(Projection(
      602 (0.0%)                      relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),
        .                         ))),
   41,992 (0.0%)                  (AutoTrait(a), AutoTrait(b)) if a == b => Ok(ep_a.rebind(AutoTrait(a))),
        .                         _ => Err(TypeError::ExistentialMismatch(expected_found(a, b))),
        .                     }
  137,999 (0.0%)          });
    6,344 (0.0%)          tcx.mk_poly_existential_predicates_from_iter(v)
    1,368 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::ClosureArgs<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::ClosureArgs<'tcx>,
        .                 b: ty::ClosureArgs<'tcx>,
        .             ) -> RelateResult<'tcx, ty::ClosureArgs<'tcx>> {
-- line 724 ----------------------------------------
-- line 749 ----------------------------------------
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::Region<'tcx>,
        .                 b: ty::Region<'tcx>,
        .             ) -> RelateResult<'tcx, ty::Region<'tcx>> {
   49,514 (0.0%)          relation.regions(a, b)
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::Const<'tcx> {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::Const<'tcx>,
        .                 b: ty::Const<'tcx>,
        .             ) -> RelateResult<'tcx, ty::Const<'tcx>> {
    1,613 (0.0%)          relation.consts(a, b)
        .             }
        .         }
        .         
        .         impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<'tcx, T> {
    5,789 (0.0%)      fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: ty::Binder<'tcx, T>,
        .                 b: ty::Binder<'tcx, T>,
        .             ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {
       44 (0.0%)          relation.binders(a, b)
    5,144 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {
1,552,453 (0.0%)      fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: GenericArg<'tcx>,
        .                 b: GenericArg<'tcx>,
        .             ) -> RelateResult<'tcx, GenericArg<'tcx>> {
2,758,978 (0.0%)          match (a.unpack(), b.unpack()) {
        .                     (GenericArgKind::Lifetime(a_lt), GenericArgKind::Lifetime(b_lt)) => {
        .                         Ok(relation.relate(a_lt, b_lt)?.into())
        .                     }
        .                     (GenericArgKind::Type(a_ty), GenericArgKind::Type(b_ty)) => {
        .                         Ok(relation.relate(a_ty, b_ty)?.into())
        .                     }
        .                     (GenericArgKind::Const(a_ct), GenericArgKind::Const(b_ct)) => {
        .                         Ok(relation.relate(a_ct, b_ct)?.into())
-- line 795 ----------------------------------------
-- line 799 ----------------------------------------
        .                     }
        .                     (GenericArgKind::Type(unpacked), x) => {
        .                         bug!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
        .                     }
        .                     (GenericArgKind::Const(unpacked), x) => {
        .                         bug!("impossible case reached: can't relate: {:?} with {:?}", unpacked, x)
        .                     }
        .                 }
1,144,940 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for ty::PredicatePolarity {
        .             fn relate<R: TypeRelation<'tcx>>(
        .                 _relation: &mut R,
        .                 a: ty::PredicatePolarity,
        .                 b: ty::PredicatePolarity,
        .             ) -> RelateResult<'tcx, ty::PredicatePolarity> {
-- line 815 ----------------------------------------
-- line 826 ----------------------------------------
        .                 Ok(ty::TraitPredicate {
        .                     trait_ref: relation.relate(a.trait_ref, b.trait_ref)?,
        .                     polarity: relation.relate(a.polarity, b.polarity)?,
        .                 })
        .             }
        .         }
        .         
        .         impl<'tcx> Relate<'tcx> for Term<'tcx> {
   23,791 (0.0%)      fn relate<R: TypeRelation<'tcx>>(
        .                 relation: &mut R,
        .                 a: Self,
        .                 b: Self,
        .             ) -> RelateResult<'tcx, Self> {
   22,672 (0.0%)          Ok(match (a.unpack(), b.unpack()) {
        .                     (TermKind::Ty(a), TermKind::Ty(b)) => relation.relate(a, b)?.into(),
        .                     (TermKind::Const(a), TermKind::Const(b)) => relation.relate(a, b)?.into(),
        .                     _ => return Err(TypeError::Mismatch),
        .                 })
   13,596 (0.0%)      }
        .         }
        .         
        .         ///////////////////////////////////////////////////////////////////////////
        .         // Error handling
        .         
        .         pub fn expected_found<T>(a: T, b: T) -> ExpectedFound<T> {
        .             ExpectedFound::new(true, a, b)
        .         }
-- line 852 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_middle/src/ty/sty.rs
--------------------------------------------------------------------------------
Ir_______________ 

 1,716,414 (0.0%)  <unknown (line 0)>

-- line 863 ----------------------------------------
         .             }
         .         
         .             /// Returns the type of this inline const.
         .             pub fn ty(self) -> Ty<'tcx> {
         .                 self.split().ty.expect_ty()
         .             }
         .         }
         .         
   364,429 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]
       126 (0.0%)  #[derive(HashStable)]
         .         pub enum BoundVariableKind {
         .             Ty(BoundTyKind),
         .             Region(BoundRegionKind),
         .             Const,
         .         }
         .         
         .         impl BoundVariableKind {
         .             pub fn expect_region(self) -> BoundRegionKind {
     1,274 (0.0%)          match self {
         .                     BoundVariableKind::Region(lt) => lt,
         .                     _ => bug!("expected a region, but found another kind"),
         .                 }
         .             }
         .         
         .             pub fn expect_ty(self) -> BoundTyKind {
         .                 match self {
         .                     BoundVariableKind::Ty(ty) => ty,
-- line 889 ----------------------------------------
-- line 903 ----------------------------------------
         .         /// compiler's representation for things like `for<'a> Fn(&'a isize)`
         .         /// (which would be represented by the type `PolyTraitRef ==
         .         /// Binder<'tcx, TraitRef>`). Note that when we instantiate,
         .         /// erase, or otherwise "discharge" these bound vars, we change the
         .         /// type from `Binder<'tcx, T>` to just `T` (see
         .         /// e.g., `liberate_late_bound_regions`).
         .         ///
         .         /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.
 7,990,153 (0.1%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
   162,022 (0.0%)  #[derive(HashStable, Lift)]
         .         pub struct Binder<'tcx, T> {
 2,066,859 (0.0%)      value: T,
         .             bound_vars: &'tcx List<BoundVariableKind>,
         .         }
         .         
         .         impl<'tcx, T> Binder<'tcx, T>
         .         where
         .             T: TypeVisitable<TyCtxt<'tcx>>,
         .         {
         .             /// Wraps `value` in a binder, asserting that `value` does not
         .             /// contain any bound vars that would be bound by the
         .             /// binder. This is commonly used to 'inject' a value T into a
         .             /// different binding level.
         .             #[track_caller]
   478,320 (0.0%)      pub fn dummy(value: T) -> Binder<'tcx, T> {
         .                 assert!(
    77,407 (0.0%)              !value.has_escaping_bound_vars(),
         .                     "`{value:?}` has escaping bound vars, so it cannot be wrapped in a dummy binder."
         .                 );
 2,820,723 (0.0%)          Binder { value, bound_vars: ty::List::empty() }
   348,379 (0.0%)      }
         .         
         .             pub fn bind_with_vars(value: T, bound_vars: &'tcx List<BoundVariableKind>) -> Binder<'tcx, T> {
         .                 if cfg!(debug_assertions) {
         .                     let mut validator = ValidateBoundVars::new(bound_vars);
         .                     value.visit_with(&mut validator);
         .                 }
10,063,831 (0.1%)          Binder { value, bound_vars }
         .             }
         .         }
         .         
         .         impl<'tcx, T> rustc_type_ir::BoundVars<TyCtxt<'tcx>> for ty::Binder<'tcx, T> {
         .             fn bound_vars(&self) -> &'tcx List<ty::BoundVariableKind> {
         .                 self.bound_vars
         .             }
         .         
-- line 948 ----------------------------------------
-- line 964 ----------------------------------------
         .             /// accounting.
         .             ///
         .             /// Some examples where `skip_binder` is reasonable:
         .             ///
         .             /// - extracting the `DefId` from a PolyTraitRef;
         .             /// - comparing the self type of a PolyTraitRef to see if it is equal to
         .             ///   a type parameter `X`, since the type `X` does not reference any regions
         .             pub fn skip_binder(self) -> T {
   883,292 (0.0%)          self.value
         .             }
         .         
         .             pub fn bound_vars(&self) -> &'tcx List<BoundVariableKind> {
   116,880 (0.0%)          self.bound_vars
         .             }
         .         
         .             pub fn as_ref(&self) -> Binder<'tcx, &T> {
   249,202 (0.0%)          Binder { value: &self.value, bound_vars: self.bound_vars }
         .             }
         .         
         .             pub fn as_deref(&self) -> Binder<'tcx, &T::Target>
         .             where
         .                 T: Deref,
         .             {
         .                 Binder { value: &self.value, bound_vars: self.bound_vars }
         .             }
         .         
         .             pub fn map_bound_ref_unchecked<F, U>(&self, f: F) -> Binder<'tcx, U>
         .             where
         .                 F: FnOnce(&T) -> U,
         .             {
     1,948 (0.0%)          let value = f(&self.value);
         .                 Binder { value, bound_vars: self.bound_vars }
         .             }
         .         
         .             pub fn map_bound_ref<F, U: TypeVisitable<TyCtxt<'tcx>>>(&self, f: F) -> Binder<'tcx, U>
         .             where
         .                 F: FnOnce(&T) -> U,
         .             {
         .                 self.as_ref().map_bound(f)
         .             }
         .         
         .             pub fn map_bound<F, U: TypeVisitable<TyCtxt<'tcx>>>(self, f: F) -> Binder<'tcx, U>
         .             where
         .                 F: FnOnce(T) -> U,
         .             {
       744 (0.0%)          let Binder { value, bound_vars } = self;
       255 (0.0%)          let value = f(value);
         .                 if cfg!(debug_assertions) {
         .                     let mut validator = ValidateBoundVars::new(bound_vars);
         .                     value.visit_with(&mut validator);
         .                 }
 8,336,629 (0.1%)          Binder { value, bound_vars }
         .             }
         .         
         .             pub fn try_map_bound<F, U: TypeVisitable<TyCtxt<'tcx>>, E>(
         .                 self,
         .                 f: F,
         .             ) -> Result<Binder<'tcx, U>, E>
         .             where
         .                 F: FnOnce(T) -> Result<U, E>,
         .             {
   461,812 (0.0%)          let Binder { value, bound_vars } = self;
         4 (0.0%)          let value = f(value)?;
         .                 if cfg!(debug_assertions) {
         .                     let mut validator = ValidateBoundVars::new(bound_vars);
         .                     value.visit_with(&mut validator);
         .                 }
         .                 Ok(Binder { value, bound_vars })
         .             }
         .         
         .             /// Wraps a `value` in a binder, using the same bound variables as the
-- line 1034 ----------------------------------------
-- line 1039 ----------------------------------------
         .             /// This currently doesn't do anything different than `bind`, because we
         .             /// don't actually track bound vars. However, semantically, it is different
         .             /// because bound vars aren't allowed to change here, whereas they are
         .             /// in `bind`. This may be (debug) asserted in the future.
         .             pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U>
         .             where
         .                 U: TypeVisitable<TyCtxt<'tcx>>,
         .             {
   146,167 (0.0%)          Binder::bind_with_vars(value, self.bound_vars)
         .             }
         .         
         .             /// Unwraps and returns the value within, but only if it contains
         .             /// no bound vars at all. (In other words, if this binder --
         .             /// and indeed any enclosing binder -- doesn't bind anything at
         .             /// all.) Otherwise, returns `None`.
         .             ///
         .             /// (One could imagine having a method that just unwraps a single
-- line 1055 ----------------------------------------
-- line 1057 ----------------------------------------
         .             /// binders, but that would require adjusting the debruijn
         .             /// indices, and given the shallow binding structure we often use,
         .             /// would not be that useful.)
         .             pub fn no_bound_vars(self) -> Option<T>
         .             where
         .                 T: TypeVisitable<TyCtxt<'tcx>>,
         .             {
         .                 // `self.value` is equivalent to `self.skip_binder()`
   626,085 (0.0%)          if self.value.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }
         .             }
         .         
         .             /// Splits the contents into two things that share the same binder
         .             /// level as the original, returning two distinct binders.
         .             ///
         .             /// `f` should consider bound regions at depth 1 to be free, and
         .             /// anything it produces with bound regions at depth 1 will be
         .             /// bound in the resulting return values.
-- line 1073 ----------------------------------------
-- line 1104 ----------------------------------------
         .             }
         .         }
         .         
         .         /// Represents the projection of an associated type.
         .         ///
         .         /// * For a projection, this would be `<Ty as Trait<...>>::N<...>`.
         .         /// * For an inherent projection, this would be `Ty::N<...>`.
         .         /// * For an opaque type, there is no explicit syntax.
    61,929 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
   238,191 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
         .         pub struct AliasTy<'tcx> {
         .             /// The parameters of the associated or opaque item.
         .             ///
         .             /// For a projection, these are the generic parameters for the trait and the
         .             /// GAT parameters, if there are any.
         .             ///
         .             /// For an inherent projection, they consist of the self type and the GAT parameters,
         .             /// if there are any.
         .             ///
         .             /// For RPIT the generic parameters are for the generics of the function,
         .             /// while for TAIT it is used for the generic parameters of the alias.
   108,365 (0.0%)      pub args: GenericArgsRef<'tcx>,
         .         
         .             /// The `DefId` of the `TraitItem` or `ImplItem` for the associated type `N` depending on whether
         .             /// this is a projection or an inherent projection or the `DefId` of the `OpaqueType` item if
         .             /// this is an opaque.
         .             ///
         .             /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the
         .             /// underlying type if the type is an opaque.
         .             ///
         .             /// Note that if this is an associated type, this is not the `DefId` of the
         .             /// `TraitRef` containing this associated type, which is in `tcx.associated_item(def_id).container`,
         .             /// aka. `tcx.parent(def_id)`.
        94 (0.0%)      pub def_id: DefId,
         .         
         .             /// This field exists to prevent the creation of `AliasTy` without using
         .             /// [AliasTy::new].
         .             _use_alias_ty_new_instead: (),
         .         }
         .         
         .         impl<'tcx> AliasTy<'tcx> {
         .             pub fn new(
-- line 1145 ----------------------------------------
-- line 1146 ----------------------------------------
         .                 tcx: TyCtxt<'tcx>,
         .                 def_id: DefId,
         .                 args: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,
         .             ) -> ty::AliasTy<'tcx> {
         .                 let args = tcx.check_and_mk_args(def_id, args);
         .                 ty::AliasTy { def_id, args, _use_alias_ty_new_instead: () }
         .             }
         .         
    19,960 (0.0%)      pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {
    17,477 (0.0%)          match tcx.def_kind(self.def_id) {
         .                     DefKind::AssocTy
     9,956 (0.0%)                  if let DefKind::Impl { of_trait: false } =
         .                             tcx.def_kind(tcx.parent(self.def_id)) =>
         .                     {
         .                         ty::Inherent
         .                     }
         .                     DefKind::AssocTy => ty::Projection,
         .                     DefKind::OpaqueTy => ty::Opaque,
         .                     DefKind::TyAlias => ty::Weak,
         .                     kind => bug!("unexpected DefKind in AliasTy: {kind:?}"),
         .                 }
    17,465 (0.0%)      }
         .         
         .             /// Whether this alias type is an opaque.
         .             pub fn is_opaque(self, tcx: TyCtxt<'tcx>) -> bool {
         .                 matches!(self.opt_kind(tcx), Some(ty::Opaque))
         .             }
         .         
         .             /// FIXME: rename `AliasTy` to `AliasTerm` and always handle
         .             /// constants. This function can then be removed.
-- line 1175 ----------------------------------------
-- line 1183 ----------------------------------------
         .                     }
         .                     DefKind::AssocTy => Some(ty::Projection),
         .                     DefKind::OpaqueTy => Some(ty::Opaque),
         .                     DefKind::TyAlias => Some(ty::Weak),
         .                     _ => None,
         .                 }
         .             }
         .         
    17,115 (0.0%)      pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
     2,445 (0.0%)          Ty::new_alias(tcx, self.kind(tcx), self)
    12,225 (0.0%)      }
         .         }
         .         
         .         /// The following methods work only with associated type projections.
         .         impl<'tcx> AliasTy<'tcx> {
   109,731 (0.0%)      pub fn self_ty(self) -> Ty<'tcx> {
   109,731 (0.0%)          self.args.type_at(0)
   109,731 (0.0%)      }
         .         
         .             pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {
         .                 AliasTy::new(tcx, self.def_id, [self_ty.into()].into_iter().chain(self.args.iter().skip(1)))
         .             }
         .         }
         .         
         .         /// The following methods work only with trait associated type projections.
         .         impl<'tcx> AliasTy<'tcx> {
   267,638 (0.0%)      pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {
   267,638 (0.0%)          match tcx.def_kind(self.def_id) {
         .                     DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),
         .                     kind => bug!("expected a projection AliasTy; found {kind:?}"),
         .                 }
   267,638 (0.0%)      }
         .         
         .             /// Extracts the underlying trait reference and own args from this projection.
         .             /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,
         .             /// then this function would return a `T: StreamingIterator` trait reference and `['a]` as the own args
    15,466 (0.0%)      pub fn trait_ref_and_own_args(
         .                 self,
         .                 tcx: TyCtxt<'tcx>,
         .             ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {
         .                 debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));
     5,624 (0.0%)          let trait_def_id = self.trait_def_id(tcx);
         .                 let trait_generics = tcx.generics_of(trait_def_id);
     7,030 (0.0%)          (
     7,030 (0.0%)              ty::TraitRef::new(tcx, trait_def_id, self.args.truncate_to(tcx, trait_generics)),
         .                     &self.args[trait_generics.count()..],
         .                 )
    12,654 (0.0%)      }
         .         
         .             /// Extracts the underlying trait reference from this projection.
         .             /// For example, if this is a projection of `<T as Iterator>::Item`,
         .             /// then this function would return a `T: Iterator` trait reference.
         .             ///
         .             /// WARNING: This will drop the args for generic associated types
         .             /// consider calling [Self::trait_ref_and_own_args] to get those
         .             /// as well.
   272,998 (0.0%)      pub fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {
   124,090 (0.0%)          let def_id = self.trait_def_id(tcx);
   124,090 (0.0%)          ty::TraitRef::new(tcx, def_id, self.args.truncate_to(tcx, tcx.generics_of(def_id)))
   223,362 (0.0%)      }
         .         }
         .         
         .         /// The following methods work only with inherent associated type projections.
         .         impl<'tcx> AliasTy<'tcx> {
         .             /// Transform the generic parameters to have the given `impl` args as the base and the GAT args on top of that.
         .             ///
         .             /// Does the following transformation:
         .             ///
-- line 1250 ----------------------------------------
-- line 1273 ----------------------------------------
         .         }
         .         
         .         /// Signature of a function type, which we have arbitrarily
         .         /// decided to use to refer to the input/output types.
         .         ///
         .         /// - `inputs`: is the list of arguments and their modes.
         .         /// - `output`: is the return type.
         .         /// - `c_variadic`: indicates whether this is a C-variadic function.
    49,323 (0.0%)  #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
    15,153 (0.0%)  #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]
         .         pub struct FnSig<'tcx> {
     1,174 (0.0%)      pub inputs_and_output: &'tcx List<Ty<'tcx>>,
     4,068 (0.0%)      pub c_variadic: bool,
       678 (0.0%)      pub unsafety: hir::Unsafety,
     2,320 (0.0%)      pub abi: abi::Abi,
         .         }
         .         
         .         impl<'tcx> FnSig<'tcx> {
         .             pub fn inputs(&self) -> &'tcx [Ty<'tcx>] {
    91,682 (0.0%)          &self.inputs_and_output[..self.inputs_and_output.len() - 1]
    44,978 (0.0%)      }
         .         
         .             pub fn output(&self) -> Ty<'tcx> {
    97,460 (0.0%)          self.inputs_and_output[self.inputs_and_output.len() - 1]
    24,271 (0.0%)      }
         .         
         .             // Creates a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible
         .             // method.
         .             fn fake() -> FnSig<'tcx> {
         .                 FnSig {
         .                     inputs_and_output: List::empty(),
         .                     c_variadic: false,
         .                     unsafety: hir::Unsafety::Normal,
-- line 1305 ----------------------------------------
-- line 1314 ----------------------------------------
         .             }
         .         }
         .         
         .         pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;
         .         
         .         impl<'tcx> PolyFnSig<'tcx> {
         .             #[inline]
         .             pub fn inputs(&self) -> Binder<'tcx, &'tcx [Ty<'tcx>]> {
    40,677 (0.0%)          self.map_bound_ref_unchecked(|fn_sig| fn_sig.inputs())
         .             }
         .             #[inline]
         .             #[track_caller]
         .             pub fn input(&self, index: usize) -> ty::Binder<'tcx, Ty<'tcx>> {
    76,806 (0.0%)          self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])
         .             }
         .             pub fn inputs_and_output(&self) -> ty::Binder<'tcx, &'tcx List<Ty<'tcx>>> {
         .                 self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)
         .             }
         .             #[inline]
         .             pub fn output(&self) -> ty::Binder<'tcx, Ty<'tcx>> {
    20,447 (0.0%)          self.map_bound_ref(|fn_sig| fn_sig.output())
         .             }
         .             pub fn c_variadic(&self) -> bool {
         .                 self.skip_binder().c_variadic
         .             }
         .             pub fn unsafety(&self) -> hir::Unsafety {
     8,254 (0.0%)          self.skip_binder().unsafety
         .             }
         .             pub fn abi(&self) -> abi::Abi {
         3 (0.0%)          self.skip_binder().abi
         .             }
         .         
         .             pub fn is_fn_trait_compatible(&self) -> bool {
        10 (0.0%)          matches!(
         .                     self.skip_binder(),
         .                     ty::FnSig {
         .                         unsafety: rustc_hir::Unsafety::Normal,
         .                         abi: Abi::Rust,
         .                         c_variadic: false,
         .                         ..
         .                     }
         .                 )
         .             }
         .         }
         .         
         .         pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<'tcx, FnSig<'tcx>>>;
         .         
    10,518 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]
     2,854 (0.0%)  #[derive(HashStable)]
         .         pub struct ParamTy {
         .             pub index: u32,
         .             pub name: Symbol,
         .         }
         .         
         .         impl<'tcx> ParamTy {
         .             pub fn new(index: u32, name: Symbol) -> ParamTy {
         .                 ParamTy { index, name }
         .             }
         .         
         .             pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {
       567 (0.0%)          ParamTy::new(def.index, def.name)
         .             }
         .         
         .             #[inline]
         .             pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
         .                 Ty::new_param(tcx, self.index, self.name)
         .             }
         .         
         .             pub fn span_from_generics(&self, tcx: TyCtxt<'tcx>, item_with_generics: DefId) -> Span {
-- line 1382 ----------------------------------------
-- line 1398 ----------------------------------------
         .                 ParamConst { index, name }
         .             }
         .         
         .             pub fn for_def(def: &ty::GenericParamDef) -> ParamConst {
         .                 ParamConst::new(def.index, def.name)
         .             }
         .         }
         .         
    94,780 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
         2 (0.0%)  #[derive(HashStable)]
         .         pub struct BoundTy {
    23,695 (0.0%)      pub var: BoundVar,
         .             pub kind: BoundTyKind,
         .         }
         .         
   236,950 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]
    38,386 (0.0%)  #[derive(HashStable)]
         .         pub enum BoundTyKind {
         .             Anon,
         .             Param(DefId, Symbol),
         .         }
         .         
         .         impl From<BoundVar> for BoundTy {
         .             fn from(var: BoundVar) -> Self {
         .                 BoundTy { var, kind: BoundTyKind::Anon }
-- line 1422 ----------------------------------------
-- line 1430 ----------------------------------------
         .             #[allow(rustc::usage_of_ty_tykind)]
         .             #[inline]
         .             pub fn new(tcx: TyCtxt<'tcx>, st: TyKind<'tcx>) -> Ty<'tcx> {
         .                 tcx.mk_ty_from_kind(st)
         .             }
         .         
         .             #[inline]
         .             pub fn new_infer(tcx: TyCtxt<'tcx>, infer: ty::InferTy) -> Ty<'tcx> {
       189 (0.0%)          Ty::new(tcx, TyKind::Infer(infer))
         .             }
         .         
         .             #[inline]
         2 (0.0%)      pub fn new_var(tcx: TyCtxt<'tcx>, v: ty::TyVid) -> Ty<'tcx> {
         .                 // Use a pre-interned one when possible.
   100,868 (0.0%)          tcx.types
         .                     .ty_vars
         .                     .get(v.as_usize())
         .                     .copied()
    10,959 (0.0%)              .unwrap_or_else(|| Ty::new(tcx, Infer(TyVar(v))))
         2 (0.0%)      }
         .         
         .             #[inline]
         .             pub fn new_int_var(tcx: TyCtxt<'tcx>, v: ty::IntVid) -> Ty<'tcx> {
         .                 Ty::new_infer(tcx, IntVar(v))
         .             }
         .         
         .             #[inline]
         .             pub fn new_float_var(tcx: TyCtxt<'tcx>, v: ty::FloatVid) -> Ty<'tcx> {
         .                 Ty::new_infer(tcx, FloatVar(v))
         .             }
         .         
         .             #[inline]
         .             pub fn new_fresh(tcx: TyCtxt<'tcx>, n: u32) -> Ty<'tcx> {
         .                 // Use a pre-interned one when possible.
    34,771 (0.0%)          tcx.types
         .                     .fresh_tys
         .                     .get(n as usize)
         .                     .copied()
         .                     .unwrap_or_else(|| Ty::new_infer(tcx, ty::FreshTy(n)))
         .             }
         .         
         .             #[inline]
         .             pub fn new_fresh_int(tcx: TyCtxt<'tcx>, n: u32) -> Ty<'tcx> {
         .                 // Use a pre-interned one when possible.
       189 (0.0%)          tcx.types
         .                     .fresh_int_tys
         .                     .get(n as usize)
         .                     .copied()
         .                     .unwrap_or_else(|| Ty::new_infer(tcx, ty::FreshIntTy(n)))
         .             }
         .         
         .             #[inline]
         .             pub fn new_fresh_float(tcx: TyCtxt<'tcx>, n: u32) -> Ty<'tcx> {
-- line 1482 ----------------------------------------
-- line 1485 ----------------------------------------
         .                     .fresh_float_tys
         .                     .get(n as usize)
         .                     .copied()
         .                     .unwrap_or_else(|| Ty::new_infer(tcx, ty::FreshFloatTy(n)))
         .             }
         .         
         .             #[inline]
         .             pub fn new_param(tcx: TyCtxt<'tcx>, index: u32, name: Symbol) -> Ty<'tcx> {
   192,035 (0.0%)          tcx.mk_ty_from_kind(Param(ParamTy { index, name }))
         .             }
         .         
         .             #[inline]
         .             pub fn new_bound(
         .                 tcx: TyCtxt<'tcx>,
         .                 index: ty::DebruijnIndex,
         .                 bound_ty: ty::BoundTy,
         .             ) -> Ty<'tcx> {
    94,828 (0.0%)          Ty::new(tcx, Bound(index, bound_ty))
         .             }
         .         
         .             #[inline]
         .             pub fn new_placeholder(tcx: TyCtxt<'tcx>, placeholder: ty::PlaceholderType) -> Ty<'tcx> {
         .                 Ty::new(tcx, Placeholder(placeholder))
         .             }
         .         
         .             #[inline]
-- line 1510 ----------------------------------------
-- line 1514 ----------------------------------------
         .                 alias_ty: ty::AliasTy<'tcx>,
         .             ) -> Ty<'tcx> {
         .                 debug_assert_matches!(
         .                     (kind, tcx.def_kind(alias_ty.def_id)),
         .                     (ty::Opaque, DefKind::OpaqueTy)
         .                         | (ty::Projection | ty::Inherent, DefKind::AssocTy)
         .                         | (ty::Weak, DefKind::TyAlias)
         .                 );
    30,581 (0.0%)          Ty::new(tcx, Alias(kind, alias_ty))
         .             }
         .         
         .             #[inline]
         .             pub fn new_pat(tcx: TyCtxt<'tcx>, base: Ty<'tcx>, pat: ty::Pattern<'tcx>) -> Ty<'tcx> {
         .                 Ty::new(tcx, Pat(base, pat))
         .             }
         .         
         .             #[inline]
-- line 1530 ----------------------------------------
-- line 1594 ----------------------------------------
         .         
         .             #[inline]
         .             pub fn new_ref(
         .                 tcx: TyCtxt<'tcx>,
         .                 r: Region<'tcx>,
         .                 ty: Ty<'tcx>,
         .                 mutbl: ty::Mutability,
         .             ) -> Ty<'tcx> {
    87,368 (0.0%)          Ty::new(tcx, Ref(r, ty, mutbl))
         .             }
         .         
         .             #[inline]
         .             pub fn new_mut_ref(tcx: TyCtxt<'tcx>, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {
         .                 Ty::new_ref(tcx, r, ty, hir::Mutability::Mut)
         .             }
         .         
         .             #[inline]
         .             pub fn new_imm_ref(tcx: TyCtxt<'tcx>, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {
         .                 Ty::new_ref(tcx, r, ty, hir::Mutability::Not)
         .             }
         .         
         .             #[inline]
         .             pub fn new_ptr(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, mutbl: ty::Mutability) -> Ty<'tcx> {
     7,006 (0.0%)          Ty::new(tcx, ty::RawPtr(ty, mutbl))
         .             }
         .         
         .             #[inline]
         .             pub fn new_mut_ptr(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {
         .                 Ty::new_ptr(tcx, ty, hir::Mutability::Mut)
         .             }
         .         
         .             #[inline]
         .             pub fn new_imm_ptr(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {
         .                 Ty::new_ptr(tcx, ty, hir::Mutability::Not)
         .             }
         .         
         .             #[inline]
         .             pub fn new_adt(tcx: TyCtxt<'tcx>, def: AdtDef<'tcx>, args: GenericArgsRef<'tcx>) -> Ty<'tcx> {
         .                 tcx.debug_assert_args_compatible(def.did(), args);
   326,685 (0.0%)          Ty::new(tcx, Adt(def, args))
         .             }
         .         
         .             #[inline]
         .             pub fn new_foreign(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {
         .                 Ty::new(tcx, Foreign(def_id))
         .             }
         .         
         .             #[inline]
         .             pub fn new_array(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {
     1,117 (0.0%)          Ty::new(tcx, Array(ty, ty::Const::from_target_usize(tcx, n)))
         .             }
         .         
         .             #[inline]
         .             pub fn new_array_with_const_len(
         .                 tcx: TyCtxt<'tcx>,
         .                 ty: Ty<'tcx>,
         .                 ct: ty::Const<'tcx>,
         .             ) -> Ty<'tcx> {
       778 (0.0%)          Ty::new(tcx, Array(ty, ct))
         .             }
         .         
         .             #[inline]
         .             pub fn new_slice(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {
     7,564 (0.0%)          Ty::new(tcx, Slice(ty))
         .             }
         .         
         .             #[inline]
         .             pub fn new_tup(tcx: TyCtxt<'tcx>, ts: &[Ty<'tcx>]) -> Ty<'tcx> {
    12,341 (0.0%)          if ts.is_empty() { tcx.types.unit } else { Ty::new(tcx, Tuple(tcx.mk_type_list(ts))) }
         .             }
         .         
         .             pub fn new_tup_from_iter<I, T>(tcx: TyCtxt<'tcx>, iter: I) -> T::Output
         .             where
         .                 I: Iterator<Item = T>,
         .                 T: CollectAndApply<Ty<'tcx>, Ty<'tcx>>,
         .             {
     3,011 (0.0%)          T::collect_and_apply(iter, |ts| Ty::new_tup(tcx, ts))
         .             }
         .         
         .             #[inline]
     6,692 (0.0%)      pub fn new_fn_def(
         .                 tcx: TyCtxt<'tcx>,
         .                 def_id: DefId,
         .                 args: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,
         .             ) -> Ty<'tcx> {
         .                 debug_assert_matches!(
         .                     tcx.def_kind(def_id),
         .                     DefKind::AssocFn | DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn)
         .                 );
         .                 let args = tcx.check_and_mk_args(def_id, args);
     4,114 (0.0%)          Ty::new(tcx, FnDef(def_id, args))
     4,780 (0.0%)      }
         .         
         .             #[inline]
         .             pub fn new_fn_ptr(tcx: TyCtxt<'tcx>, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {
     1,194 (0.0%)          Ty::new(tcx, FnPtr(fty))
         .             }
         .         
         .             #[inline]
         .             pub fn new_dynamic(
         .                 tcx: TyCtxt<'tcx>,
         .                 obj: &'tcx List<ty::PolyExistentialPredicate<'tcx>>,
         .                 reg: ty::Region<'tcx>,
         .                 repr: DynKind,
         .             ) -> Ty<'tcx> {
    25,991 (0.0%)          Ty::new(tcx, Dynamic(obj, reg, repr))
         .             }
         .         
         .             #[inline]
         .             pub fn new_projection(
         .                 tcx: TyCtxt<'tcx>,
         .                 item_def_id: DefId,
         .                 args: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,
         .             ) -> Ty<'tcx> {
-- line 1707 ----------------------------------------
-- line 1746 ----------------------------------------
         .             ) -> Ty<'tcx> {
         .                 Ty::new(tcx, CoroutineWitness(id, args))
         .             }
         .         
         .             // misc
         .         
         .             #[inline]
         .             pub fn new_unit(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
       823 (0.0%)          tcx.types.unit
         .             }
         .         
         .             #[inline]
         .             pub fn new_static_str(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
     1,860 (0.0%)          Ty::new_imm_ref(tcx, tcx.lifetimes.re_static, tcx.types.str_)
         .             }
         .         
         .             #[inline]
         .             pub fn new_diverging_default(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
         .                 if tcx.features().never_type_fallback { tcx.types.never } else { tcx.types.unit }
         .             }
         .         
         .             // lang and diagnostic tys
-- line 1767 ----------------------------------------
-- line 1832 ----------------------------------------
         .             // FIXME(compiler-errors): Think about removing this.
         .             #[inline(always)]
         .             pub fn flags(self) -> TypeFlags {
         .                 self.0.0.flags
         .             }
         .         
         .             #[inline]
         .             pub fn is_unit(self) -> bool {
        44 (0.0%)          match self.kind() {
        22 (0.0%)              Tuple(tys) => tys.is_empty(),
         .                     _ => false,
         .                 }
         .             }
         .         
         .             #[inline]
         .             pub fn is_never(self) -> bool {
     7,586 (0.0%)          matches!(self.kind(), Never)
         .             }
         .         
         .             #[inline]
         .             pub fn is_primitive(self) -> bool {
         .                 self.kind().is_primitive()
         .             }
         .         
         .             #[inline]
-- line 1856 ----------------------------------------
-- line 1860 ----------------------------------------
         .         
         .             #[inline]
         .             pub fn is_ref(self) -> bool {
         .                 matches!(self.kind(), Ref(..))
         .             }
         .         
         .             #[inline]
         .             pub fn is_ty_var(self) -> bool {
   275,782 (0.0%)          matches!(self.kind(), Infer(TyVar(_)))
         .             }
         .         
         .             #[inline]
         .             pub fn ty_vid(self) -> Option<ty::TyVid> {
     3,765 (0.0%)          match self.kind() {
     1,168 (0.0%)              &Infer(TyVar(vid)) => Some(vid),
         .                     _ => None,
         .                 }
         .             }
         .         
         .             #[inline]
         .             pub fn is_ty_or_numeric_infer(self) -> bool {
     1,449 (0.0%)          matches!(self.kind(), Infer(_))
         .             }
         .         
         .             #[inline]
         .             pub fn is_phantom_data(self) -> bool {
         .                 if let Adt(def, _) = self.kind() { def.is_phantom_data() } else { false }
         .             }
         .         
         .             #[inline]
         .             pub fn is_bool(self) -> bool {
        14 (0.0%)          *self.kind() == Bool
         .             }
         .         
         .             /// Returns `true` if this type is a `str`.
         .             #[inline]
         .             pub fn is_str(self) -> bool {
         .                 *self.kind() == Str
         .             }
         .         
         .             #[inline]
         .             pub fn is_param(self, index: u32) -> bool {
       348 (0.0%)          match self.kind() {
       322 (0.0%)              ty::Param(ref data) => data.index == index,
         .                     _ => false,
         .                 }
         .             }
         .         
         .             #[inline]
         .             pub fn is_slice(self) -> bool {
         .                 matches!(self.kind(), Slice(_))
         .             }
-- line 1911 ----------------------------------------
-- line 2013 ----------------------------------------
         .                             alloc_adt.did() == global_alloc
         .                         })
         .                     }
         .                     _ => false,
         .                 }
         .             }
         .         
         .             /// Panics if called on any type other than `Box<T>`.
         4 (0.0%)      pub fn boxed_ty(self) -> Ty<'tcx> {
         2 (0.0%)          match self.kind() {
         5 (0.0%)              Adt(def, args) if def.is_box() => args.type_at(0),
         .                     _ => bug!("`boxed_ty` is called on non-box type {:?}", self),
         .                 }
         3 (0.0%)      }
         .         
         .             /// A scalar type is one that denotes an atomic datum, with no sub-components.
         .             /// (A RawPtr is scalar because it represents a non-managed pointer, so its
         .             /// contents are abstract to rustc.)
         .             #[inline]
         .             pub fn is_scalar(self) -> bool {
        36 (0.0%)          matches!(
       126 (0.0%)              self.kind(),
         .                     Bool | Char
         .                         | Int(_)
         .                         | Float(_)
         .                         | Uint(_)
         .                         | FnDef(..)
         .                         | FnPtr(_)
         .                         | RawPtr(_, _)
         .                         | Infer(IntVar(_) | FloatVar(_))
         .                 )
         .             }
         .         
         .             /// Returns `true` if this type is a floating point type.
         .             #[inline]
         .             pub fn is_floating_point(self) -> bool {
       372 (0.0%)          matches!(self.kind(), Float(_) | Infer(FloatVar(_)))
         .             }
         .         
         .             #[inline]
         .             pub fn is_trait(self) -> bool {
         .                 matches!(self.kind(), Dynamic(_, _, ty::Dyn))
         .             }
         .         
         .             #[inline]
         .             pub fn is_dyn_star(self) -> bool {
         .                 matches!(self.kind(), Dynamic(_, _, ty::DynStar))
         .             }
         .         
         .             #[inline]
         .             pub fn is_enum(self) -> bool {
       459 (0.0%)          matches!(self.kind(), Adt(adt_def, _) if adt_def.is_enum())
         .             }
         .         
         .             #[inline]
         .             pub fn is_union(self) -> bool {
         .                 matches!(self.kind(), Adt(adt_def, _) if adt_def.is_union())
         .             }
         .         
         .             #[inline]
         .             pub fn is_closure(self) -> bool {
         4 (0.0%)          matches!(self.kind(), Closure(..))
         .             }
         .         
         .             #[inline]
         .             pub fn is_coroutine(self) -> bool {
         .                 matches!(self.kind(), Coroutine(..))
         .             }
         .         
         .             #[inline]
         .             pub fn is_coroutine_closure(self) -> bool {
         .                 matches!(self.kind(), CoroutineClosure(..))
         .             }
         .         
         .             #[inline]
         .             pub fn is_integral(self) -> bool {
     9,719 (0.0%)          matches!(self.kind(), Infer(IntVar(_)) | Int(_) | Uint(_))
         .             }
         .         
         .             #[inline]
         .             pub fn is_fresh_ty(self) -> bool {
         .                 matches!(self.kind(), Infer(FreshTy(_)))
         .             }
         .         
         .             #[inline]
         .             pub fn is_fresh(self) -> bool {
    62,035 (0.0%)          matches!(self.kind(), Infer(FreshTy(_) | FreshIntTy(_) | FreshFloatTy(_)))
         .             }
         .         
         .             #[inline]
         .             pub fn is_char(self) -> bool {
         .                 matches!(self.kind(), Char)
         .             }
         .         
         .             #[inline]
-- line 2107 ----------------------------------------
-- line 2111 ----------------------------------------
         .         
         .             #[inline]
         .             pub fn is_signed(self) -> bool {
         .                 matches!(self.kind(), Int(_))
         .             }
         .         
         .             #[inline]
         .             pub fn is_ptr_sized_integral(self) -> bool {
     6,608 (0.0%)          matches!(self.kind(), Int(ty::IntTy::Isize) | Uint(ty::UintTy::Usize))
         .             }
         .         
         .             #[inline]
         .             pub fn has_concrete_skeleton(self) -> bool {
         3 (0.0%)          !matches!(self.kind(), Param(_) | Infer(_) | Error(_))
         .             }
         .         
         .             /// Checks whether a type recursively contains another type
         .             ///
         .             /// Example: `Option<()>` contains `()`
         .             pub fn contains(self, other: Ty<'tcx>) -> bool {
         .                 struct ContainsTyVisitor<'tcx>(Ty<'tcx>);
         .         
-- line 2132 ----------------------------------------
-- line 2164 ----------------------------------------
         .                 cf.is_break()
         .             }
         .         
         .             /// Returns the type and mutability of `*ty`.
         .             ///
         .             /// The parameter `explicit` indicates if this is an *explicit* dereference.
         .             /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.
         .             pub fn builtin_deref(self, explicit: bool) -> Option<TypeAndMut<'tcx>> {
     6,047 (0.0%)          match self.kind() {
       182 (0.0%)              Adt(def, _) if def.is_box() => {
         3 (0.0%)                  Some(TypeAndMut { ty: self.boxed_ty(), mutbl: hir::Mutability::Not })
         .                     }
     3,348 (0.0%)              Ref(_, ty, mutbl) => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),
       316 (0.0%)              RawPtr(ty, mutbl) if explicit => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),
         .                     _ => None,
         .                 }
     1,843 (0.0%)      }
         .         
         .             /// Returns the type of `ty[i]`.
         .             pub fn builtin_index(self) -> Option<Ty<'tcx>> {
         .                 match self.kind() {
         .                     Array(ty, _) | Slice(ty) => Some(*ty),
         .                     _ => None,
         .                 }
         .             }
         .         
    13,473 (0.0%)      pub fn fn_sig(self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {
    10,479 (0.0%)          match self.kind() {
     4,473 (0.0%)              FnDef(def_id, args) => tcx.fn_sig(*def_id).instantiate(tcx, args),
        30 (0.0%)              FnPtr(f) => *f,
         .                     Error(_) => {
         .                         // ignore errors (#54954)
         .                         ty::Binder::dummy(FnSig::fake())
         .                     }
         .                     Closure(..) => bug!(
         .                         "to get the signature of a closure, use `args.as_closure().sig()` not `fn_sig()`",
         .                     ),
         .                     _ => bug!("Ty::fn_sig() called on non-fn type: {:?}", self),
         .                 }
    13,473 (0.0%)      }
         .         
         .             #[inline]
         .             pub fn is_fn(self) -> bool {
         .                 matches!(self.kind(), FnDef(..) | FnPtr(_))
         .             }
         .         
         .             #[inline]
         .             pub fn is_fn_ptr(self) -> bool {
-- line 2211 ----------------------------------------
-- line 2214 ----------------------------------------
         .         
         .             #[inline]
         .             pub fn is_impl_trait(self) -> bool {
         .                 matches!(self.kind(), Alias(ty::Opaque, ..))
         .             }
         .         
         .             #[inline]
         .             pub fn ty_adt_def(self) -> Option<AdtDef<'tcx>> {
     1,294 (0.0%)          match self.kind() {
        85 (0.0%)              Adt(adt, _) => Some(*adt),
         .                     _ => None,
         .                 }
         .             }
         .         
         .             /// Iterates over tuple fields.
         .             /// Panics when called on anything but a tuple.
         .             #[inline]
         .             pub fn tuple_fields(self) -> &'tcx List<Ty<'tcx>> {
-- line 2231 ----------------------------------------
-- line 2249 ----------------------------------------
         .                 }
         .             }
         .         
         .             /// If the type contains variants, returns the variant for `variant_index`.
         .             /// Panics if `variant_index` is out of range.
         .             //
         .             // FIXME: This requires the optimized MIR in the case of coroutines.
         .             #[inline]
     1,071 (0.0%)      pub fn discriminant_for_variant(
         .                 self,
         .                 tcx: TyCtxt<'tcx>,
         .                 variant_index: VariantIdx,
         .             ) -> Option<Discr<'tcx>> {
       765 (0.0%)          match self.kind() {
       306 (0.0%)              TyKind::Adt(adt, _) if adt.is_enum() => {
         .                         Some(adt.discriminant_for_variant(tcx, variant_index))
         .                     }
         .                     TyKind::Coroutine(def_id, args) => {
         .                         Some(args.as_coroutine().discriminant_for_variant(*def_id, tcx, variant_index))
         .                     }
         .                     _ => None,
         .                 }
       918 (0.0%)      }
         .         
         .             /// Returns the type of the discriminant of this type.
     4,304 (0.0%)      pub fn discriminant_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
     2,690 (0.0%)          match self.kind() {
     1,846 (0.0%)              ty::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(tcx),
         .                     ty::Coroutine(_, args) => args.as_coroutine().discr_ty(tcx),
         .         
         .                     ty::Param(_) | ty::Alias(..) | ty::Infer(ty::TyVar(_)) => {
         .                         let assoc_items = tcx.associated_item_def_ids(
         .                             tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),
         .                         );
         .                         Ty::new_projection(tcx, assoc_items[0], tcx.mk_args(&[self.into()]))
         .                     }
-- line 2284 ----------------------------------------
-- line 2301 ----------------------------------------
         .                     | ty::FnPtr(..)
         .                     | ty::Dynamic(..)
         .                     | ty::Closure(..)
         .                     | ty::CoroutineClosure(..)
         .                     | ty::CoroutineWitness(..)
         .                     | ty::Never
         .                     | ty::Tuple(_)
         .                     | ty::Error(_)
       153 (0.0%)              | ty::Infer(IntVar(_) | FloatVar(_)) => tcx.types.u8,
         .         
         .                     ty::Bound(..)
         .                     | ty::Placeholder(_)
         .                     | ty::Infer(FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
         .                         bug!("`discriminant_ty` applied to unexpected type: {:?}", self)
         .                     }
         .                 }
     3,766 (0.0%)      }
         .         
         .             /// Returns the type of metadata for (potentially fat) pointers to this type,
         .             /// or the struct tail if the metadata type cannot be determined.
         .             pub fn ptr_metadata_ty_or_tail(
         .                 self,
         .                 tcx: TyCtxt<'tcx>,
         .                 normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,
         .             ) -> Result<Ty<'tcx>, Ty<'tcx>> {
        43 (0.0%)          let tail = tcx.struct_tail_with_normalize(self, normalize, || {});
       255 (0.0%)          match tail.kind() {
         .                     // Sized types
         .                     ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
         .                     | ty::Uint(_)
         .                     | ty::Int(_)
         .                     | ty::Bool
         .                     | ty::Float(_)
         .                     | ty::FnDef(..)
         .                     | ty::FnPtr(_)
-- line 2335 ----------------------------------------
-- line 2349 ----------------------------------------
         .                     | ty::Dynamic(_, _, ty::DynStar)
         .                     // If returned by `struct_tail_with_normalize` this is a unit struct
         .                     // without any fields, or not a struct, and therefore is Sized.
         .                     | ty::Adt(..)
         .                     // If returned by `struct_tail_with_normalize` this is the empty tuple,
         .                     // a.k.a. unit type, which is Sized
         .                     | ty::Tuple(..) => Ok(tcx.types.unit),
         .         
         6 (0.0%)              ty::Str | ty::Slice(_) => Ok(tcx.types.usize),
         .         
         .                     ty::Dynamic(_, _, ty::Dyn) => {
       120 (0.0%)                  let dyn_metadata = tcx.require_lang_item(LangItem::DynMetadata, None);
        20 (0.0%)                  Ok(tcx.type_of(dyn_metadata).instantiate(tcx, &[tail.into()]))
         .                     }
         .         
         .                     // We don't know the metadata of `self`, but it must be equal to the
         .                     // metadata of `tail`.
         .                     ty::Param(_) | ty::Alias(..) => Err(tail),
         .         
         .                     ty::Infer(ty::TyVar(_))
         .                     | ty::Pat(..)
-- line 2369 ----------------------------------------
-- line 2483 ----------------------------------------
         .             /// Returning true means the type is known to be sized. Returning
         .             /// `false` means nothing -- could be sized, might not be.
         .             ///
         .             /// Note that we could never rely on the fact that a type such as `[_]` is
         .             /// trivially `!Sized` because we could be in a type environment with a
         .             /// bound such as `[_]: Copy`. A function with such a bound obviously never
         .             /// can be called, but that doesn't mean it shouldn't typecheck. This is why
         .             /// this method doesn't return `Option<bool>`.
     2,954 (0.0%)      pub fn is_trivially_sized(self, tcx: TyCtxt<'tcx>) -> bool {
     2,620 (0.0%)          match self.kind() {
         .                     ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
         .                     | ty::Uint(_)
         .                     | ty::Int(_)
         .                     | ty::Bool
         .                     | ty::Float(_)
         .                     | ty::FnDef(..)
         .                     | ty::FnPtr(_)
         .                     | ty::RawPtr(..)
-- line 2500 ----------------------------------------
-- line 2507 ----------------------------------------
         .                     | ty::Closure(..)
         .                     | ty::CoroutineClosure(..)
         .                     | ty::Never
         .                     | ty::Error(_)
         .                     | ty::Dynamic(_, _, ty::DynStar) => true,
         .         
         .                     ty::Str | ty::Slice(_) | ty::Dynamic(_, _, ty::Dyn) | ty::Foreign(..) => false,
         .         
        36 (0.0%)              ty::Tuple(tys) => tys.last().map_or(true, |ty| ty.is_trivially_sized(tcx)),
         .         
       272 (0.0%)              ty::Adt(def, args) => def
         .                         .sized_constraint(tcx)
        78 (0.0%)                  .map_or(true, |ty| ty.instantiate(tcx, args).is_trivially_sized(tcx)),
         .         
         .                     ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) | ty::Bound(..) => false,
         .         
         .                     ty::Infer(ty::TyVar(_)) => false,
         .         
         .                     ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
         .                         bug!("`is_trivially_sized` applied to unexpected type: {:?}", self)
         .                     }
         .                 }
     2,954 (0.0%)      }
         .         
         .             /// Fast path helper for primitives which are always `Copy` and which
         .             /// have a side-effect-free `Clone` impl.
         .             ///
         .             /// Returning true means the type is known to be pure and `Copy+Clone`.
         .             /// Returning `false` means nothing -- could be `Copy`, might not be.
         .             ///
         .             /// This is mostly useful for optimizations, as these are the types
-- line 2537 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_parse/src/lexer/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

1,667,776 (0.0%)  <unknown (line 0)>

-- line 43 ----------------------------------------
        .         
        .         pub(crate) fn parse_token_trees<'psess, 'src>(
        .             psess: &'psess ParseSess,
        .             mut src: &'src str,
        .             mut start_pos: BytePos,
        .             override_span: Option<Span>,
        .         ) -> Result<TokenStream, Vec<Diag<'psess>>> {
        .             // Skip `#!`, if present.
    7,060 (0.0%)      if let Some(shebang_len) = rustc_lexer::strip_shebang(src) {
        .                 src = &src[shebang_len..];
        .                 start_pos = start_pos + BytePos::from_usize(shebang_len);
        .             }
        .         
        .             let cursor = Cursor::new(src);
    5,648 (0.0%)      let string_reader = StringReader {
        .                 psess,
        .                 start_pos,
        .                 pos: start_pos,
        .                 src,
        .                 cursor,
        .                 override_span,
        .                 nbsp_is_whitespace: false,
        .                 last_lifetime: None,
        .             };
    7,060 (0.0%)      let (stream, res, unmatched_delims) =
        .                 tokentrees::TokenTreesReader::parse_all_token_trees(string_reader);
    7,060 (0.0%)      match res {
    4,236 (0.0%)          Ok(()) if unmatched_delims.is_empty() => Ok(stream),
        .                 _ => {
        .                     // Return error if there are unmatched delimiters or unclosed delimiters.
        .                     // We emit delimiter mismatch errors first, then emit the unclosing delimiter mismatch
        .                     // because the delimiter mismatch is more likely to be the root cause of error
        .         
        .                     let mut buffer = Vec::with_capacity(1);
        .                     for unmatched in unmatched_delims {
        .                         if let Some(err) = make_unclosed_delims_error(unmatched, psess) {
-- line 78 ----------------------------------------
-- line 117 ----------------------------------------
        .             }
        .         
        .             fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {
        .                 self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))
        .             }
        .         
        .             /// Returns the next token, paired with a bool indicating if the token was
        .             /// preceded by whitespace.
5,163,960 (0.1%)      fn next_token(&mut self) -> (Token, bool) {
        .                 let mut preceded_by_whitespace = false;
        .                 let mut swallow_next_invalid = 0;
        .                 // Skip trivial (whitespace & comments) tokens
        .                 loop {
1,152,240 (0.0%)              let str_before = self.cursor.as_str();
  864,180 (0.0%)              let token = self.cursor.advance_token();
  288,060 (0.0%)              let start = self.pos;
  864,180 (0.0%)              self.pos = self.pos + BytePos(token.len);
        .         
        .                     debug!("next_token: {:?}({:?})", token.kind, self.str_from(start));
        .         
1,152,240 (0.0%)              if let rustc_lexer::TokenKind::Semi
        .                     | rustc_lexer::TokenKind::LineComment { .. }
        .                     | rustc_lexer::TokenKind::BlockComment { .. }
        .                     | rustc_lexer::TokenKind::CloseParen
        .                     | rustc_lexer::TokenKind::CloseBrace
        .                     | rustc_lexer::TokenKind::CloseBracket = token.kind
        .                     {
        .                         // Heuristic: we assume that it is unlikely we're dealing with an unterminated
        .                         // string surrounded by single quotes.
   39,724 (0.0%)                  self.last_lifetime = None;
        .                     }
        .         
        .                     // Now "cook" the token, converting the simple `rustc_lexer::TokenKind` enum into a
        .                     // rich `rustc_ast::TokenKind`. This turns strings into interned symbols and runs
        .                     // additional validation.
  263,510 (0.0%)              let kind = match token.kind {
    3,740 (0.0%)                  rustc_lexer::TokenKind::LineComment { doc_style } => {
        .                             // Skip non-doc comments
   14,371 (0.0%)                      let Some(doc_style) = doc_style else {
    4,329 (0.0%)                          self.lint_unicode_text_flow(start);
        .                                 preceded_by_whitespace = true;
        .                                 continue;
        .                             };
        .         
        .                             // Opening delimiter of the length 3 is not included into the symbol.
        .                             let content_start = start + BytePos(3);
        .                             let content = self.str_from(content_start);
   13,782 (0.0%)                      self.cook_doc_comment(content_start, content, CommentKind::Line, doc_style)
        .                         }
       38 (0.0%)                  rustc_lexer::TokenKind::BlockComment { doc_style, terminated } => {
       19 (0.0%)                      if !terminated {
        .                                 self.report_unterminated_block_comment(start, doc_style);
        .                             }
        .         
        .                             // Skip non-doc comments
       57 (0.0%)                      let Some(doc_style) = doc_style else {
       38 (0.0%)                          self.lint_unicode_text_flow(start);
        .                                 preceded_by_whitespace = true;
        .                                 continue;
        .                             };
        .         
        .                             // Opening delimiter of the length 3 and closing delimiter of the length 2
        .                             // are not included into the symbol.
        .                             let content_start = start + BytePos(3);
        .                             let content_end = self.pos - BytePos(if terminated { 2 } else { 0 });
-- line 181 ----------------------------------------
-- line 235 ----------------------------------------
        .                             let lit_start = start + BytePos(prefix_len);
        .                             self.pos = lit_start;
        .                             self.cursor = Cursor::new(&str_before[prefix_len as usize..]);
        .         
        .                             self.report_unknown_prefix(start);
        .                             let prefix_span = self.mk_sp(start, lit_start);
        .                             return (Token::new(self.ident(start), prefix_span), preceded_by_whitespace);
        .                         }
   46,350 (0.0%)                  rustc_lexer::TokenKind::Literal { kind, suffix_start } => {
        .                             let suffix_start = start + BytePos(suffix_start);
  101,970 (0.0%)                      let (kind, symbol) = self.cook_lexer_literal(start, suffix_start, kind);
        .                             let suffix = if suffix_start < self.pos {
      192 (0.0%)                          let string = self.str_from(suffix_start);
        .                                 if string == "_" {
        .                                     self.psess
        .                                         .dcx
        .                                         .emit_err(errors::UnderscoreLiteralSuffix { span: self.mk_sp(suffix_start, self.pos) });
        .                                     None
        .                                 } else {
      480 (0.0%)                              Some(Symbol::intern(string))
        .                                 }
        .                             } else {
        .                                 None
        .                             };
   46,350 (0.0%)                      token::Literal(token::Lit { kind, symbol, suffix })
        .                         }
      451 (0.0%)                  rustc_lexer::TokenKind::Lifetime { starts_with_number } => {
        .                             // Include the leading `'` in the real identifier, for macro
        .                             // expansion purposes. See #12512 for the gory details of why
        .                             // this is necessary.
        .                             let lifetime_name = self.str_from(start);
      902 (0.0%)                      self.last_lifetime = Some(self.mk_sp(start, start + BytePos(1)));
      451 (0.0%)                      if starts_with_number {
        .                                 let span = self.mk_sp(start, self.pos);
        .                                 self.dcx().struct_err("lifetimes cannot start with a number")
        .                                     .with_span(span)
        .                                     .stash(span, StashKey::LifetimeIsChar);
        .                             }
      902 (0.0%)                      let ident = Symbol::intern(lifetime_name);
    1,353 (0.0%)                      token::Lifetime(ident)
        .                         }
   19,094 (0.0%)                  rustc_lexer::TokenKind::Semi => token::Semi,
   21,846 (0.0%)                  rustc_lexer::TokenKind::Comma => token::Comma,
   18,754 (0.0%)                  rustc_lexer::TokenKind::Dot => token::Dot,
   38,076 (0.0%)                  rustc_lexer::TokenKind::OpenParen => token::OpenDelim(Delimiter::Parenthesis),
   38,076 (0.0%)                  rustc_lexer::TokenKind::CloseParen => token::CloseDelim(Delimiter::Parenthesis),
    8,748 (0.0%)                  rustc_lexer::TokenKind::OpenBrace => token::OpenDelim(Delimiter::Brace),
    8,748 (0.0%)                  rustc_lexer::TokenKind::CloseBrace => token::CloseDelim(Delimiter::Brace),
    6,012 (0.0%)                  rustc_lexer::TokenKind::OpenBracket => token::OpenDelim(Delimiter::Bracket),
    6,012 (0.0%)                  rustc_lexer::TokenKind::CloseBracket => token::CloseDelim(Delimiter::Bracket),
       10 (0.0%)                  rustc_lexer::TokenKind::At => token::At,
    4,294 (0.0%)                  rustc_lexer::TokenKind::Pound => token::Pound,
        .                         rustc_lexer::TokenKind::Tilde => token::Tilde,
      664 (0.0%)                  rustc_lexer::TokenKind::Question => token::Question,
   39,478 (0.0%)                  rustc_lexer::TokenKind::Colon => token::Colon,
      126 (0.0%)                  rustc_lexer::TokenKind::Dollar => token::Dollar,
   12,484 (0.0%)                  rustc_lexer::TokenKind::Eq => token::Eq,
    7,092 (0.0%)                  rustc_lexer::TokenKind::Bang => token::Not,
    6,516 (0.0%)                  rustc_lexer::TokenKind::Lt => token::Lt,
    9,964 (0.0%)                  rustc_lexer::TokenKind::Gt => token::Gt,
    2,404 (0.0%)                  rustc_lexer::TokenKind::Minus => token::BinOp(token::Minus),
    5,686 (0.0%)                  rustc_lexer::TokenKind::And => token::BinOp(token::And),
    2,166 (0.0%)                  rustc_lexer::TokenKind::Or => token::BinOp(token::Or),
    1,274 (0.0%)                  rustc_lexer::TokenKind::Plus => token::BinOp(token::Plus),
      906 (0.0%)                  rustc_lexer::TokenKind::Star => token::BinOp(token::Star),
       18 (0.0%)                  rustc_lexer::TokenKind::Slash => token::BinOp(token::Slash),
       16 (0.0%)                  rustc_lexer::TokenKind::Caret => token::BinOp(token::Caret),
       64 (0.0%)                  rustc_lexer::TokenKind::Percent => token::BinOp(token::Percent),
        .         
        .                         rustc_lexer::TokenKind::Unknown | rustc_lexer::TokenKind::InvalidIdent => {
        .                             // Don't emit diagnostics for sequences of the same invalid token
        .                             if swallow_next_invalid > 0 {
        .                                 swallow_next_invalid -= 1;
        .                                 continue;
        .                             }
        .                             let mut it = self.str_from_to_end(start).chars();
-- line 310 ----------------------------------------
-- line 340 ----------------------------------------
        .         
        .                             if let Some(token) = token {
        .                                 token
        .                             } else {
        .                                 preceded_by_whitespace = true;
        .                                 continue;
        .                             }
        .                         }
    2,824 (0.0%)                  rustc_lexer::TokenKind::Eof => token::Eof,
        .                     };
  115,434 (0.0%)              let span = self.mk_sp(start, self.pos);
1,290,990 (0.0%)              return (Token::new(kind, span), preceded_by_whitespace);
        .                 }
1,721,320 (0.0%)      }
        .         
  797,181 (0.0%)      fn ident(&self, start: BytePos) -> TokenKind {
  217,413 (0.0%)          let sym = nfc_normalize(self.str_from(start));
        .                 let span = self.mk_sp(start, self.pos);
  289,884 (0.0%)          self.psess.symbol_gallery.insert(sym, span);
  144,942 (0.0%)          token::Ident(sym, IdentIsRaw::No)
  579,768 (0.0%)      }
        .         
        .             /// Detect usages of Unicode codepoints changing the direction of the text on screen and loudly
        .             /// complain about it.
   14,620 (0.0%)      fn lint_unicode_text_flow(&self, start: BytePos) {
        .                 // Opening delimiter of the length 2 is not included into the comment text.
        .                 let content_start = start + BytePos(2);
        .                 let content = self.str_from(content_start);
        .                 if contains_text_flow_control_chars(content) {
        .                     let span = self.mk_sp(start, self.pos);
        .                     self.psess.buffer_lint_with_diagnostic(
        .                         TEXT_DIRECTION_CODEPOINT_IN_COMMENT,
        .                         span,
        .                         ast::CRATE_NODE_ID,
        .                         "unicode codepoint changing visible direction of text present in comment",
        .                         BuiltinLintDiag::UnicodeTextFlow(span, content.to_string()),
        .                     );
        .                 }
   11,696 (0.0%)      }
        .         
   27,564 (0.0%)      fn cook_doc_comment(
        .                 &self,
        .                 content_start: BytePos,
        .                 content: &str,
        .                 comment_kind: CommentKind,
        .                 doc_style: DocStyle,
        .             ) -> TokenKind {
    1,481 (0.0%)          if content.contains('\r') {
        .                     for (idx, _) in content.char_indices().filter(|&(_, c)| c == '\r') {
        .                         let span = self.mk_sp(
        .                             content_start + BytePos(idx as u32),
        .                             content_start + BytePos(idx as u32 + 1),
        .                         );
        .                         let block = matches!(comment_kind, CommentKind::Block);
        .                         self.dcx().emit_err(errors::CrDocComment { span, block });
        .                     }
        .                 }
        .         
        .                 let attr_style = match doc_style {
        .                     DocStyle::Outer => AttrStyle::Outer,
        .                     DocStyle::Inner => AttrStyle::Inner,
        .                 };
        .         
   20,673 (0.0%)          token::DocComment(comment_kind, attr_style, Symbol::intern(content))
   18,376 (0.0%)      }
        .         
  139,050 (0.0%)      fn cook_lexer_literal(
        .                 &self,
        .                 start: BytePos,
        .                 end: BytePos,
        .                 kind: rustc_lexer::LiteralKind,
        .             ) -> (token::LitKind, Symbol) {
   46,350 (0.0%)          match kind {
      453 (0.0%)              rustc_lexer::LiteralKind::Char { terminated } => {
      453 (0.0%)                  if !terminated {
        .                             let mut err = self
        .                                 .dcx()
        .                                 .struct_span_fatal(self.mk_sp(start, end), "unterminated character literal")
        .                                 .with_code(E0762);
        .                             if let Some(lt_sp) = self.last_lifetime {
        .                                 err.multipart_suggestion(
        .                                     "if you meant to write a string literal, use double quotes",
        .                                     vec![
-- line 422 ----------------------------------------
-- line 425 ----------------------------------------
        .                                     ],
        .                                     Applicability::MaybeIncorrect,
        .                                 );
        .                             }
        .                             err.emit()
        .                         }
        .                         self.cook_unicode(token::Char, Mode::Char, start, end, 1, 1) // ' '
        .                     }
       65 (0.0%)              rustc_lexer::LiteralKind::Byte { terminated } => {
       65 (0.0%)                  if !terminated {
        .                             self.dcx()
        .                                 .struct_span_fatal(
        .                                     self.mk_sp(start + BytePos(1), end),
        .                                     "unterminated byte constant",
        .                                 )
        .                                 .with_code(E0763)
        .                                 .emit()
        .                         }
        .                         self.cook_unicode(token::Byte, Mode::Byte, start, end, 2, 1) // b' '
        .                     }
    3,496 (0.0%)              rustc_lexer::LiteralKind::Str { terminated } => {
    3,496 (0.0%)                  if !terminated {
        .                             self.dcx()
        .                                 .struct_span_fatal(
        .                                     self.mk_sp(start, end),
        .                                     "unterminated double quote string",
        .                                 )
        .                                 .with_code(E0765)
        .                                 .emit()
        .                         }
        .                         self.cook_unicode(token::Str, Mode::Str, start, end, 1, 1) // " "
        .                     }
      357 (0.0%)              rustc_lexer::LiteralKind::ByteStr { terminated } => {
      357 (0.0%)                  if !terminated {
        .                             self.dcx()
        .                                 .struct_span_fatal(
        .                                     self.mk_sp(start + BytePos(1), end),
        .                                     "unterminated double quote byte string",
        .                                 )
        .                                 .with_code(E0766)
        .                                 .emit()
        .                         }
-- line 466 ----------------------------------------
-- line 474 ----------------------------------------
        .                                     "unterminated C string",
        .                                 )
        .                                 .with_code(E0767)
        .                                 .emit()
        .                         }
        .                         self.cook_mixed(token::CStr, Mode::CStr, start, end, 2, 1) // c" "
        .                     }
        .                     rustc_lexer::LiteralKind::RawStr { n_hashes } => {
        4 (0.0%)                  if let Some(n_hashes) = n_hashes {
        .                             let n = u32::from(n_hashes);
        .                             let kind = token::StrRaw(n_hashes);
        6 (0.0%)                      self.cook_unicode(kind, Mode::RawStr, start, end, 2 + n, 1 + n) // r##" "##
        .                         } else {
        .                             self.report_raw_str_error(start, 1);
        .                         }
        .                     }
        .                     rustc_lexer::LiteralKind::RawByteStr { n_hashes } => {
        .                         if let Some(n_hashes) = n_hashes {
        .                             let n = u32::from(n_hashes);
        .                             let kind = token::ByteStrRaw(n_hashes);
-- line 493 ----------------------------------------
-- line 500 ----------------------------------------
        .                         if let Some(n_hashes) = n_hashes {
        .                             let n = u32::from(n_hashes);
        .                             let kind = token::CStrRaw(n_hashes);
        .                             self.cook_unicode(kind, Mode::RawCStr, start, end, 3 + n, 1 + n) // cr##" "##
        .                         } else {
        .                             self.report_raw_str_error(start, 2);
        .                         }
        .                     }
   14,175 (0.0%)              rustc_lexer::LiteralKind::Int { base, empty_int } => {
        .                         let mut kind = token::Integer;
    4,725 (0.0%)                  if empty_int {
        .                             let span = self.mk_sp(start, end);
        .                             let guar = self.dcx().emit_err(errors::NoDigitsLiteral { span });
        .                             kind = token::Err(guar);
   23,625 (0.0%)                  } else if matches!(base, Base::Binary | Base::Octal) {
        .                             let base = base as u32;
        .                             let s = self.str_from_to(start + BytePos(2), end);
        .                             for (idx, c) in s.char_indices() {
        .                                 let span = self.mk_sp(
        .                                     start + BytePos::from_usize(2 + idx),
       18 (0.0%)                              start + BytePos::from_usize(2 + idx + c.len_utf8()),
        .                                 );
      102 (0.0%)                          if c != '_' && c.to_digit(base).is_none() {
        .                                     let guar =
        .                                         self.dcx().emit_err(errors::InvalidDigitLiteral { span, base });
        .                                     kind = token::Err(guar);
        .                                 }
        .                             }
        .                         }
        .                         (kind, self.symbol_from_to(start, end))
        .                     }
      516 (0.0%)              rustc_lexer::LiteralKind::Float { base, empty_exponent } => {
        .                         let mut kind = token::Float;
      172 (0.0%)                  if empty_exponent {
        .                             let span = self.mk_sp(start, self.pos);
        .                             let guar = self.dcx().emit_err(errors::EmptyExponentFloat { span });
        .                             kind = token::Err(guar);
        .                         }
    1,204 (0.0%)                  let base = match base {
        .                             Base::Hexadecimal => Some("hexadecimal"),
        .                             Base::Octal => Some("octal"),
        .                             Base::Binary => Some("binary"),
        .                             _ => None,
        .                         };
        .                         if let Some(base) = base {
        .                             let span = self.mk_sp(start, end);
        .                             let guar =
        .                                 self.dcx().emit_err(errors::FloatLiteralUnsupportedBase { span, base });
        .                             kind = token::Err(guar)
        .                         }
        .                         (kind, self.symbol_from_to(start, end))
        .                     }
        .                 }
  156,542 (0.0%)      }
        .         
        .             #[inline]
        .             fn src_index(&self, pos: BytePos) -> usize {
   91,236 (0.0%)          (pos - self.start_pos).to_usize()
        .             }
        .         
        .             /// Slice of the source text from `start` up to but excluding `self.pos`,
        .             /// meaning the slice does not include the character `self.ch`.
       96 (0.0%)      fn str_from(&self, start: BytePos) -> &'src str {
   74,029 (0.0%)          self.str_from_to(start, self.pos)
      192 (0.0%)      }
        .         
        .             /// As symbol_from, with an explicit endpoint.
        .             fn symbol_from_to(&self, start: BytePos, end: BytePos) -> Symbol {
        .                 debug!("taking an ident from {:?} to {:?}", start, end);
   29,382 (0.0%)          Symbol::intern(self.str_from_to(start, end))
        .             }
        .         
        .             /// Slice of the source text spanning from `start` up to but excluding `end`.
        .             fn str_from_to(&self, start: BytePos, end: BytePos) -> &'src str {
  172,120 (0.0%)          &self.src[self.src_index(start)..self.src_index(end)]
        .             }
        .         
        .             /// Slice of the source text spanning from `start` until the end
        .             fn str_from_to_end(&self, start: BytePos) -> &'src str {
        .                 &self.src[self.src_index(start)..]
        .             }
        .         
        .             fn report_raw_str_error(&self, start: BytePos, prefix_len: u32) -> ! {
-- line 582 ----------------------------------------
-- line 729 ----------------------------------------
        .                     );
        .                 }
        .             }
        .         
        .             fn report_too_many_hashes(&self, start: BytePos, num: u32) -> ! {
        .                 self.dcx().emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });
        .             }
        .         
   52,476 (0.0%)      fn cook_common(
        .                 &self,
        .                 mut kind: token::LitKind,
        .                 mode: Mode,
        .                 start: BytePos,
        .                 end: BytePos,
        .                 prefix_len: u32,
        .                 postfix_len: u32,
        .                 unescape: fn(&str, Mode, &mut dyn FnMut(Range<usize>, Result<(), EscapeError>)),
        .             ) -> (token::LitKind, Symbol) {
        .                 let content_start = start + BytePos(prefix_len);
        .                 let content_end = end - BytePos(postfix_len);
        .                 let lit_content = self.str_from_to(content_start, content_end);
  458,783 (0.0%)          unescape(lit_content, mode, &mut |range, result| {
        .                     // Here we only check for errors. The actual unescaping is done later.
   83,488 (0.0%)              if let Err(err) = result {
        .                         let span_with_quotes = self.mk_sp(start, end);
        .                         let (start, end) = (range.start as u32, range.end as u32);
        .                         let lo = content_start + BytePos(start);
        .                         let hi = lo + BytePos(end - start);
        .                         let span = self.mk_sp(lo, hi);
        .                         let is_fatal = err.is_fatal();
        .                         if let Some(guar) = emit_unescape_error(
        .                             self.dcx(),
-- line 760 ----------------------------------------
-- line 764 ----------------------------------------
        .                             mode,
        .                             range,
        .                             err,
        .                         ) {
        .                             assert!(is_fatal);
        .                             kind = token::Err(guar);
        .                         }
        .                     }
  333,952 (0.0%)          });
        .         
        .                 // We normally exclude the quotes for the symbol, but for errors we
        .                 // include it because it results in clearer error messages.
    8,746 (0.0%)          let sym = if !matches!(kind, token::Err(_)) {
   13,119 (0.0%)              Symbol::intern(lit_content)
        .                 } else {
        .                     self.symbol_from_to(start, end)
        .                 };
    8,746 (0.0%)          (kind, sym)
   56,849 (0.0%)      }
        .         
        .             fn cook_unicode(
        .                 &self,
        .                 kind: token::LitKind,
        .                 mode: Mode,
        .                 start: BytePos,
        .                 end: BytePos,
        .                 prefix_len: u32,
        .                 postfix_len: u32,
        .             ) -> (token::LitKind, Symbol) {
   45,118 (0.0%)          self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {
        .                     unescape::unescape_unicode(src, mode, &mut |span, result| {
  167,494 (0.0%)                  callback(span, result.map(drop))
        .                     })
        .                 })
        .             }
        .         
        .             fn cook_mixed(
        .                 &self,
        .                 kind: token::LitKind,
        .                 mode: Mode,
-- line 803 ----------------------------------------
-- line 809 ----------------------------------------
        .                 self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {
        .                     unescape::unescape_mixed(src, mode, &mut |span, result| {
        .                         callback(span, result.map(drop))
        .                     })
        .                 })
        .             }
        .         }
        .         
  652,239 (0.0%)  pub fn nfc_normalize(string: &str) -> Symbol {
        .             use unicode_normalization::{is_nfc_quick, IsNormalized, UnicodeNormalization};
  144,942 (0.0%)      match is_nfc_quick(string.chars()) {
  652,239 (0.0%)          IsNormalized::Yes => Symbol::intern(string),
        .                 _ => {
        .                     let normalized_str: String = string.chars().nfc().collect();
        .                     Symbol::intern(&normalized_str)
        .                 }
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_parse/src/lexer/tokentrees.rs
--------------------------------------------------------------------------------
Ir______________ 

  650,578 (0.0%)  <unknown (line 0)>

-- line 15 ----------------------------------------
        .             token: Token,
        .             diag_info: TokenTreeDiagInfo,
        .         }
        .         
        .         impl<'psess, 'src> TokenTreesReader<'psess, 'src> {
        .             pub(super) fn parse_all_token_trees(
        .                 string_reader: StringReader<'psess, 'src>,
        .             ) -> (TokenStream, Result<(), Vec<PErr<'psess>>>, Vec<UnmatchedDelim>) {
   36,712 (0.0%)          let mut tt_reader = TokenTreesReader {
        .                     string_reader,
        .                     token: Token::dummy(),
        .                     diag_info: TokenTreeDiagInfo::default(),
        .                 };
    7,060 (0.0%)          let (_open_spacing, stream, res) =
    2,824 (0.0%)              tt_reader.parse_token_trees(/* is_delimited */ false);
    4,236 (0.0%)          (stream, res, tt_reader.diag_info.unmatched_delims)
    4,810 (0.0%)      }
        .         
        .             // Parse a stream of tokens into a list of `TokenTree`s. The `Spacing` in
        .             // the result is that of the opening delimiter.
  333,960 (0.0%)      fn parse_token_trees(
        .                 &mut self,
        .                 is_delimited: bool,
        .             ) -> (Spacing, TokenStream, Result<(), Vec<PErr<'psess>>>) {
        .                 // Move past the opening delimiter.
  111,320 (0.0%)          let (_, open_spacing) = self.bump(false);
        .         
        .                 let mut buf = Vec::new();
        .                 loop {
1,266,454 (0.0%)              match self.token.kind {
   52,836 (0.0%)                  token::OpenDelim(delim) => {
        .                             buf.push(match self.parse_token_tree_open_delim(delim) {
  264,180 (0.0%)                          Ok(val) => val,
        .                                 Err(errs) => return (open_spacing, TokenStream::new(buf), Err(errs)),
        .                             })
        .                         }
   52,836 (0.0%)                  token::CloseDelim(delim) => {
  132,090 (0.0%)                      return (
        .                                 open_spacing,
   79,254 (0.0%)                          TokenStream::new(buf),
   52,836 (0.0%)                          if is_delimited { Ok(()) } else { Err(vec![self.close_delim_err(delim)]) },
        .                             );
        .                         }
        .                         token::Eof => {
    7,060 (0.0%)                      return (
        .                                 open_spacing,
    4,236 (0.0%)                          TokenStream::new(buf),
    2,824 (0.0%)                          if is_delimited { Err(vec![self.eof_err()]) } else { Ok(()) },
        .                             );
        .                         }
        .                         _ => {
        .                             // Get the next normal token.
1,493,180 (0.0%)                      let (this_tok, this_spacing) = self.bump(true);
  298,636 (0.0%)                      buf.push(TokenTree::Token(this_tok, this_spacing));
        .                         }
        .                     }
        .                 }
  222,640 (0.0%)      }
        .         
        .             fn eof_err(&mut self) -> PErr<'psess> {
        .                 let msg = "this file contains an unclosed delimiter";
        .                 let mut err = self.string_reader.psess.dcx.struct_span_err(self.token.span, msg);
        .                 for &(_, sp) in &self.diag_info.open_braces {
        .                     err.span_label(sp, "unclosed delimiter");
        .                     self.diag_info.unmatched_delims.push(UnmatchedDelim {
        .                         found_delim: None,
-- line 80 ----------------------------------------
-- line 95 ----------------------------------------
        .                 err
        .             }
        .         
        .             fn parse_token_tree_open_delim(
        .                 &mut self,
        .                 open_delim: Delimiter,
        .             ) -> Result<TokenTree, Vec<PErr<'psess>>> {
        .                 // The span for beginning of the delimited section
   52,836 (0.0%)          let pre_span = self.token.span;
        .         
        .                 self.diag_info.open_braces.push((open_delim, self.token.span));
        .         
        .                 // Parse the token trees within the delimiters.
        .                 // We stop at any delimiter so we can try to recover if the user
        .                 // uses an incorrect delimiter.
  343,434 (0.0%)          let (open_spacing, tts, res) = self.parse_token_trees(/* is_delimited */ true);
   79,254 (0.0%)          if let Err(errs) = res {
        .                     return Err(self.unclosed_delim_err(tts, errs));
        .                 }
        .         
        .                 // Expand to cover the entire delimited token tree
   26,418 (0.0%)          let delim_span = DelimSpan::from_pair(pre_span, self.token.span);
        .                 let sm = self.string_reader.psess.source_map();
        .         
   79,254 (0.0%)          let close_spacing = match self.token.kind {
        .                     // Correct delimiter.
   26,418 (0.0%)              token::CloseDelim(close_delim) if close_delim == open_delim => {
        .                         let (open_brace, open_brace_span) = self.diag_info.open_braces.pop().unwrap();
        .                         let close_brace_span = self.token.span;
        .         
   35,166 (0.0%)                  if tts.is_empty() && close_delim == Delimiter::Brace {
      274 (0.0%)                      let empty_block_span = open_brace_span.to(close_brace_span);
      822 (0.0%)                      if !sm.is_multiline(empty_block_span) {
        .                                 // Only track if the block is in the form of `{}`, otherwise it is
        .                                 // likely that it was written on purpose.
        .                                 self.diag_info.empty_block_spans.push(empty_block_span);
        .                             }
        .                         }
        .         
        .                         // only add braces
   79,254 (0.0%)                  if let (Delimiter::Brace, Delimiter::Brace) = (open_brace, open_delim) {
        .                             // Add all the matching spans, we will sort by span later
        .                             self.diag_info.matching_block_spans.push((open_brace_span, close_brace_span));
        .                         }
        .         
        .                         // Move past the closing delimiter.
  132,090 (0.0%)                  self.bump(false).1
        .                     }
        .                     // Incorrect delimiter.
        .                     token::CloseDelim(close_delim) => {
        .                         let mut unclosed_delimiter = None;
        .                         let mut candidate = None;
        .         
        .                         if self.diag_info.last_unclosed_found_span != Some(self.token.span) {
        .                             // do not complain about the same unclosed delimiter multiple times
-- line 149 ----------------------------------------
-- line 194 ----------------------------------------
        .                         // doesn't matter.
        .                         Spacing::Alone
        .                     }
        .                     _ => unreachable!(),
        .                 };
        .         
        .                 let spacing = DelimSpacing::new(open_spacing, close_spacing);
        .         
   26,418 (0.0%)          Ok(TokenTree::Delimited(delim_span, spacing, open_delim, tts))
        .             }
        .         
        .             // Move on to the next token, returning the current token and its spacing.
        .             // Will glue adjacent single-char tokens together if `glue` is set.
2,646,358 (0.0%)      fn bump(&mut self, glue: bool) -> (Token, Spacing) {
        .                 let (this_spacing, next_tok) = loop {
1,517,754 (0.0%)              let (next_tok, is_next_tok_preceded_by_whitespace) = self.string_reader.next_token();
        .         
  215,165 (0.0%)              if is_next_tok_preceded_by_whitespace {
  419,898 (0.0%)                  break (Spacing::Alone, next_tok);
  946,428 (0.0%)              } else if glue && let Some(glued) = self.token.glue(&next_tok) {
   46,396 (0.0%)                  self.token = glued;
        .                     } else {
        .                         let this_spacing = if next_tok.is_punct() {
        .                             Spacing::Joint
  404,435 (0.0%)                  } else if next_tok.kind == token::Eof {
        .                             Spacing::Alone
        .                         } else {
        .                             Spacing::JointHidden
        .                         };
  534,332 (0.0%)                  break (this_spacing, next_tok);
        .                     }
        .                 };
        .                 let this_tok = std::mem::replace(&mut self.token, next_tok);
1,221,396 (0.0%)          (this_tok, this_spacing)
1,628,528 (0.0%)      }
        .         
        .             fn unclosed_delim_err(
        .                 &mut self,
        .                 tts: TokenStream,
        .                 mut errs: Vec<PErr<'psess>>,
        .             ) -> Vec<PErr<'psess>> {
        .                 // If there are unclosed delims, see if there are diff markers and if so, point them
        .                 // out instead of complaining about the unclosed delims.
-- line 236 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_parse/src/parser/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

3,372,867 (0.0%)  <unknown (line 0)>

-- line 40 ----------------------------------------
        .         use std::{mem, slice};
        .         use thin_vec::ThinVec;
        .         use tracing::debug;
        .         
        .         use crate::errors::{
        .             self, IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,
        .         };
        .         
  257,026 (0.0%)  bitflags::bitflags! {
   76,308 (0.0%)      #[derive(Clone, Copy)]
        .             struct Restrictions: u8 {
        .                 const STMT_EXPR         = 1 << 0;
        .                 const NO_STRUCT_LITERAL = 1 << 1;
        .                 const CONST_EXPR        = 1 << 2;
        .                 const ALLOW_LET         = 1 << 3;
        .                 const IN_IF_GUARD       = 1 << 4;
        .                 const IS_PAT            = 1 << 5;
        .             }
-- line 57 ----------------------------------------
-- line 115 ----------------------------------------
        .                 {
        .                     let ty = ty.clone();
        .                     $self.bump();
        .                     return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_token.span, ty);
        .                 }
        .             };
        .         }
        .         
   38,154 (0.0%)  #[derive(Clone, Copy)]
        .         pub enum Recovery {
        .             Allowed,
        .             Forbidden,
        .         }
        .         
1,764,482 (0.0%)  #[derive(Clone)]
        .         pub struct Parser<'a> {
        .             pub psess: &'a ParseSess,
        .             /// The current token.
        .             pub token: Token,
        .             /// The spacing for the current token.
        .             pub token_spacing: Spacing,
        .             /// The previous token.
        .             pub prev_token: Token,
        .             pub capture_cfg: bool,
        .             restrictions: Restrictions,
   59,844 (0.0%)      expected_tokens: Vec<TokenType>,
  114,462 (0.0%)      token_cursor: TokenCursor,
        .             // The number of calls to `bump`, i.e. the position in the token stream.
        .             num_bump_calls: usize,
        .             // During parsing we may sometimes need to 'unglue' a glued token into two
        .             // component tokens (e.g. '>>' into '>' and '>), so the parser can consume
        .             // them one at a time. This process bypasses the normal capturing mechanism
        .             // (e.g. `num_bump_calls` will not be incremented), since the 'unglued'
        .             // tokens due not exist in the original `TokenStream`.
        .             //
-- line 149 ----------------------------------------
-- line 207 ----------------------------------------
        .         /// the first macro inner attribute to invoke a proc-macro).
        .         /// When create a `TokenStream`, the inner attributes get inserted
        .         /// into the proper place in the token stream.
        .         pub type ReplaceRange = (Range<u32>, Vec<(FlatToken, Spacing)>);
        .         
        .         /// Controls how we capture tokens. Capturing can be expensive,
        .         /// so we try to avoid performing capturing in cases where
        .         /// we will never need an `AttrTokenStream`.
   76,308 (0.0%)  #[derive(Copy, Clone)]
        .         pub enum Capturing {
        .             /// We aren't performing any capturing - this is the default mode.
        .             No,
        .             /// We are capturing tokens
        .             Yes,
        .         }
        .         
  415,126 (0.0%)  #[derive(Clone)]
        .         struct CaptureState {
        .             capturing: Capturing,
   38,160 (0.0%)      replace_ranges: Vec<ReplaceRange>,
        .             inner_attr_ranges: FxHashMap<AttrId, ReplaceRange>,
        .         }
        .         
        .         /// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that
        .         /// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)
        .         /// use this type to emit them as a linear sequence. But a linear sequence is
        .         /// what the parser expects, for the most part.
2,204,181 (0.0%)  #[derive(Clone)]
        .         struct TokenCursor {
        .             // Cursor for the current (innermost) token stream. The delimiters for this
        .             // token stream are found in `self.stack.last()`; when that is `None` then
        .             // we are in the outermost token stream which never has delimiters.
        .             tree_cursor: TokenTreeCursor,
        .         
        .             // Token streams surrounding the current one. The delimiters for stack[n]'s
        .             // tokens are in `stack[n-1]`. `stack[0]` (when present) has no delimiters
        .             // because it's the outermost token stream which never has delimiters.
  132,868 (0.0%)      stack: Vec<(TokenTreeCursor, DelimSpan, DelimSpacing, Delimiter)>,
        .         }
        .         
        .         impl TokenCursor {
  482,404 (0.0%)      fn next(&mut self) -> (Token, Spacing) {
        .                 self.inlined_next()
  296,864 (0.0%)      }
        .         
        .             /// This always-inlined version should only be used on hot code paths.
        .             #[inline(always)]
        .             fn inlined_next(&mut self) -> (Token, Spacing) {
        .                 loop {
        .                     // FIXME: we currently don't return `Delimiter::Invisible` open/close delims. To fix
        .                     // #67062 we will need to, whereupon the `delim != Delimiter::Invisible` conditions
        .                     // below can be removed.
        .                     if let Some(tree) = self.tree_cursor.next_ref() {
1,139,382 (0.0%)                  match tree {
  487,660 (0.0%)                      &TokenTree::Token(ref token, spacing) => {
        .                                 debug_assert!(!matches!(
        .                                     token.kind,
        .                                     token::OpenDelim(_) | token::CloseDelim(_)
        .                                 ));
  204,090 (0.0%)                          return (token.clone(), spacing);
        .                             }
  328,124 (0.0%)                      &TokenTree::Delimited(sp, spacing, delim, ref tts) => {
        .                                 let trees = tts.clone().into_trees();
  574,217 (0.0%)                          self.stack.push((
        .                                     mem::replace(&mut self.tree_cursor, trees),
        .                                     sp,
        .                                     spacing,
        .                                     delim,
        .                                 ));
   82,031 (0.0%)                          if delim != Delimiter::Invisible {
  249,043 (0.0%)                              return (Token::new(token::OpenDelim(delim), sp.open), spacing.open);
        .                                 }
        .                                 // No open delimiter to return; continue on to the next iteration.
        .                             }
        .                         };
  161,850 (0.0%)              } else if let Some((tree_cursor, span, spacing, delim)) = self.stack.pop() {
        .                         // We have exhausted this token stream. Move back to its parent token stream.
  242,312 (0.0%)                  self.tree_cursor = tree_cursor;
   80,925 (0.0%)                  if delim != Delimiter::Invisible {
  324,163 (0.0%)                      return (Token::new(token::CloseDelim(delim), span.close), spacing.close);
        .                         }
        .                         // No close delimiter to return; continue on to the next iteration.
        .                     } else {
        .                         // We have exhausted the outermost token stream. The use of
        .                         // `Spacing::Alone` is arbitrary and immaterial, because the
        .                         // `Eof` token's spacing is never used.
   49,680 (0.0%)                  return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);
        .                     }
        .                 }
        .             }
        .         }
        .         
1,248,863 (0.0%)  #[derive(Debug, Clone, PartialEq)]
        .         enum TokenType {
  170,873 (0.0%)      Token(TokenKind),
        .             Keyword(Symbol),
        .             Operator,
        .             Lifetime,
        .             Ident,
        .             Path,
        .             Type,
        .             Const,
        .         }
-- line 309 ----------------------------------------
-- line 340 ----------------------------------------
        .             /// The separator token.
        .             sep: Option<TokenKind>,
        .             /// `true` if a trailing separator is allowed.
        .             trailing_sep_allowed: bool,
        .         }
        .         
        .         impl SeqSep {
        .             fn trailing_allowed(t: TokenKind) -> SeqSep {
   40,224 (0.0%)          SeqSep { sep: Some(t), trailing_sep_allowed: true }
        .             }
        .         
        .             fn none() -> SeqSep {
        .                 SeqSep { sep: None, trailing_sep_allowed: false }
        .             }
        .         }
        .         
        .         pub enum FollowedByType {
-- line 356 ----------------------------------------
-- line 382 ----------------------------------------
        .             ReservedIdentifier,
        .             Keyword,
        .             ReservedKeyword,
        .             DocComment,
        .         }
        .         
        .         impl TokenDescription {
        .             pub fn from_token(token: &Token) -> Option<Self> {
    6,398 (0.0%)          match token.kind {
   12,796 (0.0%)              _ if token.is_special_ident() => Some(TokenDescription::ReservedIdentifier),
   12,796 (0.0%)              _ if token.is_used_keyword() => Some(TokenDescription::Keyword),
   12,796 (0.0%)              _ if token.is_unused_keyword() => Some(TokenDescription::ReservedKeyword),
        .                     token::DocComment(..) => Some(TokenDescription::DocComment),
        .                     _ => None,
        .                 }
        .             }
        .         }
        .         
   35,189 (0.0%)  pub(super) fn token_descr(token: &Token) -> String {
    3,199 (0.0%)      let name = pprust::token_to_string(token).to_string();
        .         
        .             let kind = match (TokenDescription::from_token(token), &token.kind) {
        .                 (Some(TokenDescription::ReservedIdentifier), _) => Some("reserved identifier"),
        .                 (Some(TokenDescription::Keyword), _) => Some("keyword"),
        .                 (Some(TokenDescription::ReservedKeyword), _) => Some("reserved keyword"),
        .                 (Some(TokenDescription::DocComment), _) => Some("doc comment"),
      130 (0.0%)          (None, TokenKind::Interpolated(node)) => Some(node.0.descr()),
        .                 (None, _) => None,
        .             };
        .         
   23,303 (0.0%)      if let Some(kind) = kind { format!("{kind} `{name}`") } else { format!("`{name}`") }
   25,592 (0.0%)  }
        .         
        .         impl<'a> Parser<'a> {
        .             pub fn new(
        .                 psess: &'a ParseSess,
        .                 stream: TokenStream,
        .                 subparser_name: Option<&'static str>,
        .             ) -> Self {
  442,004 (0.0%)          let mut parser = Parser {
        .                     psess,
        .                     token: Token::dummy(),
        .                     token_spacing: Spacing::Alone,
        .                     prev_token: Token::dummy(),
        .                     capture_cfg: false,
        .                     restrictions: Restrictions::empty(),
        .                     expected_tokens: Vec::new(),
        .                     token_cursor: TokenCursor { tree_cursor: stream.into_trees(), stack: Vec::new() },
-- line 429 ----------------------------------------
-- line 439 ----------------------------------------
        .                         replace_ranges: Vec::new(),
        .                         inner_attr_ranges: Default::default(),
        .                     },
        .                     current_closure: None,
        .                     recovery: Recovery::Allowed,
        .                 };
        .         
        .                 // Make parser point to the first token.
   14,663 (0.0%)          parser.bump();
        .         
   41,867 (0.0%)          parser
        .             }
        .         
        .             #[inline]
        .             pub fn recovery(mut self, recovery: Recovery) -> Self {
   16,656 (0.0%)          self.recovery = recovery;
   27,760 (0.0%)          self
        .             }
        .         
        .             /// Whether the parser is allowed to recover from broken code.
        .             ///
        .             /// If this returns false, recovering broken code into valid code (especially if this recovery does lookahead)
        .             /// is not allowed. All recovery done by the parser must be gated behind this check.
        .             ///
        .             /// Technically, this only needs to restrict eager recovery by doing lookahead at more tokens.
        .             /// But making the distinction is very subtle, and simply forbidding all recovery is a lot simpler to uphold.
        .             #[inline]
        .             fn may_recover(&self) -> bool {
  528,523 (0.0%)          matches!(self.recovery, Recovery::Allowed)
        .             }
        .         
        .             /// Version of [`unexpected`](Parser::unexpected) that "returns" any type in the `Ok`
        .             /// (both those functions never return "Ok", and so can lie like that in the type).
        .             pub fn unexpected_any<T>(&mut self) -> PResult<'a, T> {
        .                 match self.expect_one_of(&[], &[]) {
        .                     Err(e) => Err(e),
        .                     // We can get `Ok(true)` from `recover_closing_delimiter`
-- line 475 ----------------------------------------
-- line 478 ----------------------------------------
        .                 }
        .             }
        .         
        .             pub fn unexpected(&mut self) -> PResult<'a, ()> {
        .                 self.unexpected_any()
        .             }
        .         
        .             /// Expects and consumes the token `t`. Signals an error if the next token is not `t`.
    3,549 (0.0%)      pub fn expect(&mut self, t: &TokenKind) -> PResult<'a, Recovered> {
   89,960 (0.0%)          if self.expected_tokens.is_empty() {
    5,852 (0.0%)              if self.token == *t {
    8,651 (0.0%)                  self.bump();
        .                         Ok(Recovered::No)
        .                     } else {
        .                         self.unexpected_try_recover(t)
        .                     }
        .                 } else {
  242,629 (0.0%)              self.expect_one_of(slice::from_ref(t), &[])
        .                 }
    3,549 (0.0%)      }
        .         
        .             /// Expect next token to be edible or inedible token. If edible,
        .             /// then consume it; if inedible, then return without consuming
        .             /// anything. Signal a fatal error if next token is unexpected.
  552,258 (0.0%)      pub fn expect_one_of(
        .                 &mut self,
        .                 edible: &[TokenKind],
        .                 inedible: &[TokenKind],
        .             ) -> PResult<'a, Recovered> {
   78,894 (0.0%)          if edible.contains(&self.token.kind) {
   71,990 (0.0%)              self.bump();
        .                     Ok(Recovered::No)
        .                 } else if inedible.contains(&self.token.kind) {
        .                     // leave it in the input
        .                     Ok(Recovered::No)
        .                 } else if self.token.kind != token::Eof
        .                     && self.last_unexpected_token_span == Some(self.token.span)
        .                 {
        .                     FatalError.raise();
        .                 } else {
        .                     self.expected_one_of_not_found(edible, inedible)
        .                 }
  315,576 (0.0%)      }
        .         
        .             // Public for rustfmt usage.
        .             pub fn parse_ident(&mut self) -> PResult<'a, Ident> {
  242,232 (0.0%)          self.parse_ident_common(true)
        .             }
        .         
  942,711 (0.0%)      fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, Ident> {
        .                 let (ident, is_raw) = self.ident_or_err(recover)?;
        .         
  685,608 (0.0%)          if matches!(is_raw, IdentIsRaw::No) && ident.is_reserved() {
        .                     let err = self.expected_ident_found_err();
        .                     if recover {
        .                         err.emit();
        .                     } else {
        .                         return Err(err);
        .                     }
        .                 }
  171,402 (0.0%)          self.bump();
  257,103 (0.0%)          Ok(ident)
  685,608 (0.0%)      }
        .         
        .             fn ident_or_err(&mut self, recover: bool) -> PResult<'a, (Ident, IdentIsRaw)> {
    4,048 (0.0%)          match self.token.ident() {
  345,804 (0.0%)              Some(ident) => Ok(ident),
        .                     None => self.expected_ident_found(recover),
        .                 }
        .             }
        .         
        .             /// Checks if the next token is `tok`, and returns `true` if so.
        .             ///
        .             /// This method will automatically add `tok` to `expected_tokens` if `tok` is not
        .             /// encountered.
        .             #[inline]
  171,640 (0.0%)      fn check(&mut self, tok: &TokenKind) -> bool {
        .                 let is_present = self.token == *tok;
2,223,726 (0.0%)          if !is_present {
2,676,959 (0.0%)              self.expected_tokens.push(TokenType::Token(tok.clone()));
        .                 }
        .                 is_present
  128,730 (0.0%)      }
        .         
        .             #[inline]
        .             fn check_noexpect(&self, tok: &TokenKind) -> bool {
        .                 self.token == *tok
        .             }
        .         
        .             /// Consumes a token 'tok' if it exists. Returns whether the given token was present.
        .             ///
        .             /// the main purpose of this function is to reduce the cluttering of the suggestions list
        .             /// which using the normal eat method could introduce in some cases.
        .             #[inline]
        .             pub fn eat_noexpect(&mut self, tok: &TokenKind) -> bool {
        .                 let is_present = self.check_noexpect(tok);
    4,698 (0.0%)          if is_present {
        .                     self.bump()
        .                 }
        .                 is_present
        .             }
        .         
        .             /// Consumes a token 'tok' if it exists. Returns whether the given token was present.
        .             #[inline]
        .             pub fn eat(&mut self, tok: &TokenKind) -> bool {
   36,438 (0.0%)          let is_present = self.check(tok);
   24,096 (0.0%)          if is_present {
  180,933 (0.0%)              self.bump()
        .                 }
        .                 is_present
        .             }
        .         
        .             /// If the next token is the given keyword, returns `true` without eating it.
        .             /// An expectation is also added for diagnostics purposes.
        .             #[inline]
        .             fn check_keyword(&mut self, kw: Symbol) -> bool {
  930,165 (0.0%)          self.expected_tokens.push(TokenType::Keyword(kw));
1,361,994 (0.0%)          self.token.is_keyword(kw)
        .             }
        .         
        .             #[inline]
1,250,920 (0.0%)      fn check_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {
  454,880 (0.0%)          if self.check_keyword(kw) {
        .                     return true;
        .                 }
        .         
        .                 if case == Case::Insensitive
   81,425 (0.0%)              && let Some((ident, IdentIsRaw::No)) = self.token.ident()
  132,890 (0.0%)              && ident.as_str().to_lowercase() == kw.as_str().to_lowercase()
        .                 {
        .                     true
        .                 } else {
        .                     false
        .                 }
  796,040 (0.0%)      }
        .         
        .             /// If the next token is the given keyword, eats it and returns `true`.
        .             /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.
        .             // Public for rustfmt usage.
        .             #[inline]
  568,743 (0.0%)      pub fn eat_keyword(&mut self, kw: Symbol) -> bool {
  341,302 (0.0%)          if self.check_keyword(kw) {
   36,372 (0.0%)              self.bump();
        .                     true
        .                 } else {
        .                     false
        .                 }
  406,245 (0.0%)      }
        .         
        .             /// Eats a keyword, optionally ignoring the case.
        .             /// If the case differs (and is ignored) an error is issued.
        .             /// This is useful for recovery.
        .             #[inline]
  256,927 (0.0%)      fn eat_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {
        .                 if self.eat_keyword(kw) {
        .                     return true;
        .                 }
        .         
   41,192 (0.0%)          if case == Case::Insensitive
   10,245 (0.0%)              && let Some((ident, IdentIsRaw::No)) = self.token.ident()
   16,411 (0.0%)              && ident.as_str().to_lowercase() == kw.as_str().to_lowercase()
        .                 {
        .                     self.dcx().emit_err(errors::KwBadCase { span: ident.span, kw: kw.as_str() });
        .                     self.bump();
        .                     return true;
        .                 }
        .         
        .                 false
  163,499 (0.0%)      }
        .         
        .             #[inline]
        .             fn eat_keyword_noexpect(&mut self, kw: Symbol) -> bool {
   39,556 (0.0%)          if self.token.is_keyword(kw) {
        .                     self.bump();
        .                     true
        .                 } else {
        .                     false
        .                 }
        .             }
        .         
        .             /// If the given word is not a keyword, signals an error.
        .             /// If the next token is not the given word, signals an error.
        .             /// Otherwise, eats it.
   17,927 (0.0%)      fn expect_keyword(&mut self, kw: Symbol) -> PResult<'a, ()> {
        .                 if !self.eat_keyword(kw) { self.unexpected() } else { Ok(()) }
   12,805 (0.0%)      }
        .         
        .             /// Is the given keyword `kw` followed by a non-reserved identifier?
  376,875 (0.0%)      fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {
  167,500 (0.0%)          self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())
  376,875 (0.0%)      }
        .         
        .             #[inline]
        .             fn check_or_expected(&mut self, ok: bool, typ: TokenType) -> bool {
  173,396 (0.0%)          if ok {
        .                     true
        .                 } else {
   53,025 (0.0%)              self.expected_tokens.push(typ);
        .                     false
        .                 }
        .             }
        .         
        .             fn check_ident(&mut self) -> bool {
   58,812 (0.0%)          self.check_or_expected(self.token.is_ident(), TokenType::Ident)
        .             }
        .         
  235,434 (0.0%)      fn check_path(&mut self) -> bool {
  144,781 (0.0%)          self.check_or_expected(self.token.is_path_start(), TokenType::Path)
  235,434 (0.0%)      }
        .         
        .             fn check_type(&mut self) -> bool {
    6,626 (0.0%)          self.check_or_expected(self.token.can_begin_type(), TokenType::Type)
        .             }
        .         
        .             fn check_const_arg(&mut self) -> bool {
    5,996 (0.0%)          self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)
        .             }
        .         
  100,528 (0.0%)      fn check_const_closure(&self) -> bool {
        .                 self.is_keyword_ahead(0, &[kw::Const])
      468 (0.0%)              && self.look_ahead(1, |t| match &t.kind {
        .                         // async closures do not work with const closures, so we do not parse that here.
        .                         token::Ident(kw::Move | kw::Static, _) | token::OrOr | token::BinOp(token::Or) => {
        .                             true
        .                         }
        .                         _ => false,
        .                     })
  100,528 (0.0%)      }
        .         
   73,050 (0.0%)      fn check_inline_const(&self, dist: usize) -> bool {
   36,525 (0.0%)          self.is_keyword_ahead(dist, &[kw::Const])
        .                     && self.look_ahead(dist + 1, |t| match &t.kind {
        .                         token::Interpolated(nt) => matches!(&nt.0, token::NtBlock(..)),
        .                         token::OpenDelim(Delimiter::Brace) => true,
        .                         _ => false,
        .                     })
   65,745 (0.0%)      }
        .         
        .             /// Checks to see if the next token is either `+` or `+=`.
        .             /// Otherwise returns `false`.
        .             #[inline]
        .             fn check_plus(&mut self) -> bool {
        .                 self.check_or_expected(
        .                     self.token.is_like_plus(),
        .                     TokenType::Token(token::BinOp(token::Plus)),
        .                 )
        .             }
        .         
        .             /// Eats the expected token if it's present possibly breaking
        .             /// compound tokens like multi-character operators in process.
        .             /// Returns `true` if the token was eaten.
  499,330 (0.0%)      fn break_and_eat(&mut self, expected: TokenKind) -> bool {
  249,665 (0.0%)          if self.token.kind == expected {
   30,117 (0.0%)              self.bump();
        .                     return true;
        .                 }
   39,894 (0.0%)          match self.token.kind.break_two_token_op() {
    3,664 (0.0%)              Some((first, second)) if first == expected => {
    2,412 (0.0%)                  let first_span = self.psess.source_map().start_point(self.token.span);
        .                         let second_span = self.token.span.with_lo(first_span.hi());
    2,412 (0.0%)                  self.token = Token::new(first, first_span);
        .                         // Keep track of this token - if we end token capturing now,
        .                         // we'll want to append this token to the captured stream.
        .                         //
        .                         // If we consume any additional tokens, then this token
        .                         // is not needed (we'll capture the entire 'glued' token),
        .                         // and `bump` will set this field to `None`
      402 (0.0%)                  self.break_last_token = true;
        .                         // Use the spacing of the glued token as the spacing of the
        .                         // unglued second token.
    3,216 (0.0%)                  self.bump_with((Token::new(second, second_span), self.token_spacing));
        .                         true
        .                     }
        .                     _ => {
        .                         self.expected_tokens.push(TokenType::Token(expected));
        .                         false
        .                     }
        .                 }
  449,397 (0.0%)      }
        .         
        .             /// Eats `+` possibly breaking tokens like `+=` in process.
        .             fn eat_plus(&mut self) -> bool {
    5,168 (0.0%)          self.break_and_eat(token::BinOp(token::Plus))
        .             }
        .         
        .             /// Eats `&` possibly breaking tokens like `&&` in process.
        .             /// Signals an error if `&` is not eaten.
        .             fn expect_and(&mut self) -> PResult<'a, ()> {
   23,130 (0.0%)          if self.break_and_eat(token::BinOp(token::And)) { Ok(()) } else { self.unexpected() }
        .             }
        .         
        .             /// Eats `|` possibly breaking tokens like `||` in process.
        .             /// Signals an error if `|` was not eaten.
        .             fn expect_or(&mut self) -> PResult<'a, ()> {
      600 (0.0%)          if self.break_and_eat(token::BinOp(token::Or)) { Ok(()) } else { self.unexpected() }
        .             }
        .         
        .             /// Eats `<` possibly breaking tokens like `<<` in process.
   48,380 (0.0%)      fn eat_lt(&mut self) -> bool {
  157,060 (0.0%)          let ate = self.break_and_eat(token::Lt);
  111,120 (0.0%)          if ate {
        .                     // See doc comment for `unmatched_angle_bracket_count`.
   12,638 (0.0%)              self.unmatched_angle_bracket_count += 1;
        .                     self.max_angle_bracket_count += 1;
        .                     debug!("eat_lt: (increment) count={:?}", self.unmatched_angle_bracket_count);
        .                 }
        .                 ate
   38,704 (0.0%)      }
        .         
        .             /// Eats `<` possibly breaking tokens like `<<` in process.
        .             /// Signals an error if `<` was not eaten.
        .             fn expect_lt(&mut self) -> PResult<'a, ()> {
        .                 if self.eat_lt() { Ok(()) } else { self.unexpected() }
        .             }
        .         
        .             /// Eats `>` possibly breaking tokens like `>>` in process.
        .             /// Signals an error if `>` was not eaten.
        .             fn expect_gt(&mut self) -> PResult<'a, ()> {
   18,012 (0.0%)          if self.break_and_eat(token::Gt) {
        .                     // See doc comment for `unmatched_angle_bracket_count`.
    9,006 (0.0%)              if self.unmatched_angle_bracket_count > 0 {
    6,004 (0.0%)                  self.unmatched_angle_bracket_count -= 1;
        .                         debug!("expect_gt: (decrement) count={:?}", self.unmatched_angle_bracket_count);
        .                     }
        .                     Ok(())
        .                 } else {
        .                     self.unexpected()
        .                 }
        .             }
        .         
        .             /// Checks if the next token is contained within `kets`, and returns `true` if so.
  514,404 (0.0%)      fn expect_any_with_type(&mut self, kets: &[&TokenKind], expect: TokenExpectType) -> bool {
  114,312 (0.0%)          kets.iter().any(|k| match expect {
        .                     TokenExpectType::Expect => self.check(k),
        .                     TokenExpectType::NoExpect => self.check_noexpect(k),
        .                 })
  514,404 (0.0%)      }
        .         
        .             /// Parses a sequence until the specified delimiters. The function
        .             /// `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
      845 (0.0%)      fn parse_seq_to_before_tokens<T>(
        .                 &mut self,
        .                 kets: &[&TokenKind],
        .                 sep: SeqSep,
        .                 expect: TokenExpectType,
        .                 mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing, Recovered)> {
        .                 let mut first = true;
        .                 let mut recovered = Recovered::No;
        .                 let mut trailing = Trailing::No;
        .                 let mut v = ThinVec::new();
        .         
  268,478 (0.0%)          while !self.expect_any_with_type(kets, expect) {
   94,829 (0.0%)              if let token::CloseDelim(..) | token::Eof = self.token.kind {
        .                         break;
        .                     }
   96,008 (0.0%)              if let Some(t) = &sep.sep {
   74,587 (0.0%)                  if first {
        .                             // no separator for the first element
        .                             first = false;
        .                         } else {
        .                             // check for separator
   26,214 (0.0%)                      match self.expect(t) {
        .                                 Ok(Recovered::No) => {
        .                                     self.current_closure.take();
        .                                 }
        .                                 Ok(Recovered::Yes) => {
        .                                     self.current_closure.take();
        .                                     recovered = Recovered::Yes;
        .                                     break;
        .                                 }
-- line 849 ----------------------------------------
-- line 933 ----------------------------------------
        .                                                 break;
        .                                             }
        .                                         }
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                     }
  169,426 (0.0%)              if sep.trailing_sep_allowed && self.expect_any_with_type(kets, expect) {
        .                         trailing = Trailing::Yes;
        .                         break;
        .                     }
        .         
   23,315 (0.0%)              let t = f(self)?;
   13,025 (0.0%)              v.push(t);
        .                 }
        .         
    4,056 (0.0%)          Ok((v, trailing, recovered))
      520 (0.0%)      }
        .         
        .             fn recover_missing_braces_around_closure_body(
        .                 &mut self,
        .                 closure_spans: ClosureSpans,
        .                 mut expect_err: Diag<'_>,
        .             ) -> PResult<'a, ()> {
        .                 let initial_semicolon = self.token.span;
        .         
-- line 959 ----------------------------------------
-- line 1013 ----------------------------------------
        .             /// `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
        .             fn parse_seq_to_before_end<T>(
        .                 &mut self,
        .                 ket: &TokenKind,
        .                 sep: SeqSep,
        .                 f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing, Recovered)> {
   25,118 (0.0%)          self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)
        .             }
        .         
        .             /// Parses a sequence, including only the closing delimiter. The function
        .             /// `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
        .             fn parse_seq_to_end<T>(
        .                 &mut self,
        .                 ket: &TokenKind,
        .                 sep: SeqSep,
        .                 f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing)> {
   19,947 (0.0%)          let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;
   40,035 (0.0%)          if matches!(recovered, Recovered::No) {
        .                     self.eat(ket);
        .                 }
      166 (0.0%)          Ok((val, trailing))
        .             }
        .         
        .             /// Parses a sequence, including both delimiters. The function
        .             /// `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
        .             fn parse_unspanned_seq<T>(
        .                 &mut self,
        .                 bra: &TokenKind,
        .                 ket: &TokenKind,
        .                 sep: SeqSep,
        .                 f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing)> {
        .                 self.expect(bra)?;
   97,445 (0.0%)          self.parse_seq_to_end(ket, sep, f)
        .             }
        .         
        .             /// Parses a comma-separated sequence, including both delimiters.
        .             /// The function `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
        .             fn parse_delim_comma_seq<T>(
        .                 &mut self,
        .                 delim: Delimiter,
        .                 f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing)> {
        .                 self.parse_unspanned_seq(
   19,489 (0.0%)              &token::OpenDelim(delim),
   19,489 (0.0%)              &token::CloseDelim(delim),
        .                     SeqSep::trailing_allowed(token::Comma),
        .                     f,
        .                 )
        .             }
        .         
        .             /// Parses a comma-separated sequence delimited by parentheses (e.g. `(x, y)`).
        .             /// The function `f` must consume tokens until reaching the next separator or
        .             /// closing bracket.
-- line 1072 ----------------------------------------
-- line 1073 ----------------------------------------
        .             fn parse_paren_comma_seq<T>(
        .                 &mut self,
        .                 f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,
        .             ) -> PResult<'a, (ThinVec<T>, Trailing)> {
        .                 self.parse_delim_comma_seq(Delimiter::Parenthesis, f)
        .             }
        .         
        .             /// Advance the parser by one token using provided token as the next one.
    2,814 (0.0%)      fn bump_with(&mut self, next: (Token, Spacing)) {
        .                 self.inlined_bump_with(next)
    2,814 (0.0%)      }
        .         
        .             /// This always-inlined version should only be used on hot code paths.
        .             #[inline(always)]
      402 (0.0%)      fn inlined_bump_with(&mut self, (next_token, next_spacing): (Token, Spacing)) {
        .                 // Update the current and previous tokens.
3,150,425 (0.0%)          self.prev_token = mem::replace(&mut self.token, next_token);
  630,085 (0.0%)          self.token_spacing = next_spacing;
        .         
        .                 // Diagnostics.
        .                 self.expected_tokens.clear();
        .             }
        .         
        .             /// Advance the parser by one token.
5,667,147 (0.1%)      pub fn bump(&mut self) {
        .                 // Note: destructuring here would give nicer code, but it was found in #96210 to be slower
        .                 // than `.0`/`.1` access.
3,148,415 (0.0%)          let mut next = self.token_cursor.inlined_next();
  629,683 (0.0%)          self.num_bump_calls += 1;
        .                 // We've retrieved an token from the underlying
        .                 // cursor, so we no longer need to worry about
        .                 // an unglued token. See `break_and_eat` for more details
1,904,069 (0.0%)          self.break_last_token = false;
        .                 if next.0.span.is_dummy() {
        .                     // Tweak the location for better diagnostics, but keep syntactic context intact.
   15,020 (0.0%)              let fallback_span = self.token.span;
   75,100 (0.0%)              next.0.span = fallback_span.with_ctxt(next.0.span.ctxt());
        .                 }
        .                 debug_assert!(!matches!(
        .                     next.0.kind,
        .                     token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible)
        .                 ));
  629,683 (0.0%)          self.inlined_bump_with(next)
5,037,464 (0.1%)      }
        .         
        .             /// Look-ahead `dist` tokens of `self.token` and get access to that token there.
        .             /// When `dist == 0` then the current token is looked at. `Eof` will be
        .             /// returned if the look-ahead is any distance past the end of the tokens.
    6,938 (0.0%)      pub fn look_ahead<R>(&self, dist: usize, looker: impl FnOnce(&Token) -> R) -> R {
   68,285 (0.0%)          if dist == 0 {
   20,494 (0.0%)              return looker(&self.token);
        .                 }
        .         
  366,973 (0.0%)          if let Some(&(_, span, _, delim)) = self.token_cursor.stack.last()
  120,897 (0.0%)              && delim != Delimiter::Invisible
        .                 {
        .                     // We are not in the outermost token stream, and the token stream
        .                     // we are in has non-skipped delimiters. Look for skipped
        .                     // delimiters in the lookahead range.
        .                     let tree_cursor = &self.token_cursor.tree_cursor;
  126,166 (0.0%)              let all_normal = (0..dist).all(|i| {
  375,453 (0.0%)                  let token = tree_cursor.look_ahead(i);
  507,388 (0.0%)                  !matches!(token, Some(TokenTree::Delimited(.., Delimiter::Invisible, _)))
        .                     });
   10,770 (0.0%)              if all_normal {
        .                         // There were no skipped delimiters. Do lookahead by plain indexing.
  632,770 (0.0%)                  return match tree_cursor.look_ahead(dist - 1) {
        .                             Some(tree) => {
        .                                 // Indexing stayed within the current token stream.
  229,908 (0.0%)                          match tree {
  136,290 (0.0%)                              TokenTree::Token(token, _) => looker(token),
        .                                     TokenTree::Delimited(dspan, _, delim, _) => {
    9,992 (0.0%)                                  looker(&Token::new(token::OpenDelim(*delim), dspan.open))
        .                                     }
        .                                 }
        .                             }
        .                             None => {
        .                                 // Indexing went past the end of the current token
        .                                 // stream. Use the close delimiter, no matter how far
        .                                 // ahead `dist` went.
        .                                 looker(&Token::new(token::CloseDelim(delim), span.close))
        .                             }
        .                         };
        .                     }
        .                 }
        .         
        .                 // We are in a more complex case. Just clone the token cursor and use
        .                 // `next`, skipping delimiters as necessary. Slow but simple.
  164,463 (0.0%)          let mut cursor = self.token_cursor.clone();
        .                 let mut i = 0;
        .                 let mut token = Token::dummy();
      492 (0.0%)          while i < dist {
  240,260 (0.0%)              token = cursor.next().0;
  120,965 (0.0%)              if matches!(
   33,815 (0.0%)                  token.kind,
        .                         token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible)
        .                     ) {
        .                         continue;
        .                     }
    2,859 (0.0%)              i += 1;
        .                 }
       57 (0.0%)          looker(&token)
    6,183 (0.0%)      }
        .         
        .             /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.
  108,295 (0.0%)      pub(crate) fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {
   48,906 (0.0%)          self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))
   88,605 (0.0%)      }
        .         
        .             /// Parses asyncness: `async` or nothing.
   12,881 (0.0%)      fn parse_coroutine_kind(&mut self, case: Case) -> Option<CoroutineKind> {
    5,855 (0.0%)          let span = self.token.uninterpolated_span();
    8,197 (0.0%)          if self.eat_keyword_case(kw::Async, case) {
        .                     // FIXME(gen_blocks): Do we want to unconditionally parse `gen` and then
        .                     // error if edition <= 2024, like we do with async and edition <= 2018?
       46 (0.0%)              if self.token.uninterpolated_span().at_least_rust_2024()
        .                         && self.eat_keyword_case(kw::Gen, case)
        .                     {
        .                         let gen_span = self.prev_token.uninterpolated_span();
        .                         Some(CoroutineKind::AsyncGen {
        .                             span: span.to(gen_span),
        .                             closure_id: DUMMY_NODE_ID,
        .                             return_impl_trait_id: DUMMY_NODE_ID,
        .                         })
        .                     } else {
       46 (0.0%)                  Some(CoroutineKind::Async {
        .                             span,
        .                             closure_id: DUMMY_NODE_ID,
        .                             return_impl_trait_id: DUMMY_NODE_ID,
        .                         })
        .                     }
    1,125 (0.0%)          } else if self.token.uninterpolated_span().at_least_rust_2024()
        .                     && self.eat_keyword_case(kw::Gen, case)
        .                 {
        .                     Some(CoroutineKind::Gen {
        .                         span,
        .                         closure_id: DUMMY_NODE_ID,
        .                         return_impl_trait_id: DUMMY_NODE_ID,
        .                     })
        .                 } else {
    1,125 (0.0%)              None
        .                 }
    9,368 (0.0%)      }
        .         
        .             /// Parses unsafety: `unsafe` or nothing.
        .             fn parse_unsafety(&mut self, case: Case) -> Unsafe {
    7,357 (0.0%)          if self.eat_keyword_case(kw::Unsafe, case) {
       22 (0.0%)              Unsafe::Yes(self.prev_token.uninterpolated_span())
        .                 } else {
        .                     Unsafe::No
        .                 }
        .             }
        .         
        .             /// Parses constness: `const` or nothing.
        .             fn parse_constness(&mut self, case: Case) -> Const {
   34,277 (0.0%)          self.parse_constness_(case, false)
        .             }
        .         
        .             /// Parses constness for closures (case sensitive, feature-gated)
        .             fn parse_closure_constness(&mut self) -> Const {
      480 (0.0%)          let constness = self.parse_constness_(Case::Sensitive, true);
      240 (0.0%)          if let Const::Yes(span) = constness {
        .                     self.psess.gated_spans.gate(sym::const_closures, span);
        .                 }
        .                 constness
        .             }
        .         
  107,424 (0.0%)      fn parse_constness_(&mut self, case: Case, is_closure: bool) -> Const {
        .                 // Avoid const blocks and const closures to be parsed as const items
   44,760 (0.0%)          if (self.check_const_closure() == is_closure)
    8,851 (0.0%)              && !self
   18,496 (0.0%)                  .look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace) || t.is_whole_block())
   60,417 (0.0%)              && self.eat_keyword_case(kw::Const, case)
        .                 {
      402 (0.0%)              Const::Yes(self.prev_token.uninterpolated_span())
        .                 } else {
        .                     Const::No
        .                 }
   71,616 (0.0%)      }
        .         
        .             /// Parses inline const expressions.
        .             fn parse_const_block(&mut self, span: Span, pat: bool) -> PResult<'a, P<Expr>> {
        .                 if pat {
        .                     self.psess.gated_spans.gate(sym::inline_const_pat, span);
        .                 } else {
        .                     self.psess.gated_spans.gate(sym::inline_const, span);
        .                 }
-- line 1259 ----------------------------------------
-- line 1263 ----------------------------------------
        .                     id: DUMMY_NODE_ID,
        .                     value: self.mk_expr(blk.span, ExprKind::Block(blk, None)),
        .                 };
        .                 let blk_span = anon_const.value.span;
        .                 Ok(self.mk_expr_with_attrs(span.to(blk_span), ExprKind::ConstBlock(anon_const), attrs))
        .             }
        .         
        .             /// Parses mutability (`mut` or nothing).
      480 (0.0%)      fn parse_mutability(&mut self) -> Mutability {
        .                 if self.eat_keyword(kw::Mut) { Mutability::Mut } else { Mutability::Not }
      384 (0.0%)      }
        .         
        .             /// Parses reference binding mode (`ref`, `ref mut`, or nothing).
    3,894 (0.0%)      fn parse_byref(&mut self) -> ByRef {
        .                 if self.eat_keyword(kw::Ref) { ByRef::Yes(self.parse_mutability()) } else { ByRef::No }
    3,245 (0.0%)      }
        .         
        .             /// Possibly parses mutability (`const` or `mut`).
       72 (0.0%)      fn parse_const_or_mut(&mut self) -> Option<Mutability> {
        .                 if self.eat_keyword(kw::Mut) {
        .                     Some(Mutability::Mut)
        .                 } else if self.eat_keyword(kw::Const) {
        .                     Some(Mutability::Not)
        .                 } else {
        .                     None
        .                 }
       72 (0.0%)      }
        .         
        .             fn parse_field_name(&mut self) -> PResult<'a, Ident> {
    1,538 (0.0%)          if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) = self.token.kind
        .                 {
        .                     if let Some(suffix) = suffix {
        .                         self.expect_no_tuple_index_suffix(self.token.span, suffix);
        .                     }
        .                     self.bump();
        .                     Ok(Ident::new(symbol, self.prev_token.span))
        .                 } else {
    2,307 (0.0%)              self.parse_ident_common(true)
        .                 }
        .             }
        .         
   97,216 (0.0%)      fn parse_delim_args(&mut self) -> PResult<'a, P<DelimArgs>> {
   85,064 (0.0%)          if let Some(args) = self.parse_delim_args_inner() {
   24,304 (0.0%)              Ok(P(args))
        .                 } else {
        .                     self.unexpected_any()
        .                 }
   60,760 (0.0%)      }
        .         
        .             fn parse_attr_args(&mut self) -> PResult<'a, AttrArgs> {
   21,238 (0.0%)          Ok(if let Some(args) = self.parse_delim_args_inner() {
        .                     AttrArgs::Delimited(args)
        .                 } else {
        .                     if self.eat(&token::Eq) {
       48 (0.0%)                  let eq_span = self.prev_token.span;
        .                         AttrArgs::Eq(eq_span, AttrArgsEq::Ast(self.parse_expr_force_collect()?))
        .                     } else {
        .                         AttrArgs::Empty
        .                     }
        .                 })
        .             }
        .         
  144,060 (0.0%)      fn parse_delim_args_inner(&mut self) -> Option<DelimArgs> {
        .                 let delimited = self.check(&token::OpenDelim(Delimiter::Parenthesis))
        .                     || self.check(&token::OpenDelim(Delimiter::Bracket))
        .                     || self.check(&token::OpenDelim(Delimiter::Brace));
        .         
        .                 delimited.then(|| {
  113,512 (0.0%)              let TokenTree::Delimited(dspan, _, delim, tokens) = self.parse_token_tree() else {
        .                         unreachable!()
        .                     };
        .                     DelimArgs { dspan, delim, tokens }
        .                 })
  115,248 (0.0%)      }
        .         
        .             fn parse_or_use_outer_attributes(
        .                 &mut self,
        .                 already_parsed_attrs: Option<AttrWrapper>,
        .             ) -> PResult<'a, AttrWrapper> {
  245,905 (0.0%)          if let Some(attrs) = already_parsed_attrs {
   54,245 (0.0%)              Ok(attrs)
        .                 } else {
   47,005 (0.0%)              self.parse_outer_attributes()
        .                 }
        .             }
        .         
        .             /// Parses a single token tree from the input.
  327,090 (0.0%)      pub fn parse_token_tree(&mut self) -> TokenTree {
  157,967 (0.0%)          match self.token.kind {
        .                     token::OpenDelim(..) => {
        .                         // Grab the tokens within the delimiters.
        .                         let stream = self.token_cursor.tree_cursor.stream.clone();
  212,988 (0.0%)                  let (_, span, spacing, delim) = *self.token_cursor.stack.last().unwrap();
        .         
        .                         // Advance the token cursor through the entire delimited
        .                         // sequence. After getting the `OpenDelim` we are *within* the
        .                         // delimited sequence, i.e. at depth `d`. After getting the
        .                         // matching `CloseDelim` we are *after* the delimited sequence,
        .                         // i.e. at depth `d - 1`.
        .                         let target_depth = self.token_cursor.stack.len() - 1;
        .                         loop {
        .                             // Advance one token at a time, so `TokenCursor::next()`
        .                             // can capture these tokens if necessary.
  415,390 (0.0%)                      self.bump();
  415,390 (0.0%)                      if self.token_cursor.stack.len() == target_depth {
        .                                 debug_assert!(matches!(self.token.kind, token::CloseDelim(_)));
        .                                 break;
        .                             }
        .                         }
        .         
        .                         // Consume close delimiter
   35,498 (0.0%)                  self.bump();
  177,490 (0.0%)                  TokenTree::Delimited(span, spacing, delim, stream)
        .                     }
        .                     token::CloseDelim(_) | token::Eof => unreachable!(),
        .                     _ => {
   14,960 (0.0%)                  let prev_spacing = self.token_spacing;
   29,920 (0.0%)                  self.bump();
   89,760 (0.0%)                  TokenTree::Token(self.prev_token.clone(), prev_spacing)
        .                     }
        .                 }
  294,381 (0.0%)      }
        .         
      216 (0.0%)      pub fn parse_tokens(&mut self) -> TokenStream {
        .                 let mut result = Vec::new();
        .                 loop {
      300 (0.0%)              match self.token.kind {
        .                         token::Eof | token::CloseDelim(..) => break,
      108 (0.0%)                  _ => result.push(self.parse_token_tree()),
        .                     }
        .                 }
       24 (0.0%)          TokenStream::new(result)
      192 (0.0%)      }
        .         
        .             /// Evaluates the closure with restrictions in place.
        .             ///
        .             /// Afters the closure is evaluated, restrictions are reset.
        .             fn with_res<T>(&mut self, res: Restrictions, f: impl FnOnce(&mut Self) -> T) -> T {
   52,701 (0.0%)          let old = self.restrictions;
  101,295 (0.0%)          self.restrictions = res;
        .                 let res = f(self);
   88,903 (0.0%)          self.restrictions = old;
        .                 res
        .             }
        .         
        .             /// Parses `pub` and `pub(in path)` plus shortcuts `pub(crate)` for `pub(in crate)`, `pub(self)`
        .             /// for `pub(in self)` and `pub(super)` for `pub(in super)`.
        .             /// If the following element can't be a tuple (i.e., it's a function definition), then
        .             /// it's not a tuple struct field), and the contents within the parentheses aren't valid,
        .             /// so emit a proper diagnostic.
        .             // Public for rustfmt usage.
  107,437 (0.0%)      pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {
   28,020 (0.0%)          maybe_whole!(self, NtVis, |vis| vis.into_inner());
        .         
        .                 if !self.eat_keyword(kw::Pub) {
        .                     // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no
        .                     // keyword to grab a span from for inherited visibility; an empty span at the
        .                     // beginning of the current token would seem to be the "Schelling span".
   16,748 (0.0%)              return Ok(Visibility {
   16,748 (0.0%)                  span: self.token.span.shrink_to_lo(),
        .                         kind: VisibilityKind::Inherited,
        .                         tokens: None,
        .                     });
        .                 }
    1,440 (0.0%)          let lo = self.prev_token.span;
        .         
        .                 if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {
        .                     // We don't `self.bump()` the `(` yet because this might be a struct definition where
        .                     // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.
        .                     // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so
        .                     // by the following tokens.
    3,185 (0.0%)              if self.is_keyword_ahead(1, &[kw::In]) {
        .                         // Parse `pub(in path)`.
        .                         self.bump(); // `(`
        .                         self.bump(); // `in`
        .                         let path = self.parse_path(PathStyle::Mod)?; // `path`
        .                         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`
        .                         let vis = VisibilityKind::Restricted {
        .                             path: P(path),
        .                             id: ast::DUMMY_NODE_ID,
        .                             shorthand: false,
        .                         };
        .                         return Ok(Visibility {
        .                             span: lo.to(self.prev_token.span),
        .                             kind: vis,
        .                             tokens: None,
        .                         });
    1,820 (0.0%)              } else if self.look_ahead(2, |t| t == &token::CloseDelim(Delimiter::Parenthesis))
    3,185 (0.0%)                  && self.is_keyword_ahead(1, &[kw::Crate, kw::Super, kw::SelfLower])
        .                     {
        .                         // Parse `pub(crate)`, `pub(self)`, or `pub(super)`.
    1,365 (0.0%)                  self.bump(); // `(`
    1,365 (0.0%)                  let path = self.parse_path(PathStyle::Mod)?; // `crate`/`super`/`self`
    1,820 (0.0%)                  self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`
    1,820 (0.0%)                  let vis = VisibilityKind::Restricted {
        .                             path: P(path),
        .                             id: ast::DUMMY_NODE_ID,
        .                             shorthand: true,
        .                         };
      910 (0.0%)                  return Ok(Visibility {
    1,365 (0.0%)                      span: lo.to(self.prev_token.span),
        .                             kind: vis,
        .                             tokens: None,
        .                         });
        .                     } else if let FollowedByType::No = fbt {
        .                         // Provide this diagnostic if a type cannot follow;
        .                         // in particular, if this is not a tuple struct.
        .                         self.recover_incorrect_vis_restriction()?;
        .                         // Emit diagnostic, but continue with public visibility.
        .                     }
        .                 }
        .         
      530 (0.0%)          Ok(Visibility { span: lo, kind: VisibilityKind::Public, tokens: None })
   87,903 (0.0%)      }
        .         
        .             /// Recovery for e.g. `pub(something) fn ...` or `struct X { pub(something) y: Z }`
        .             fn recover_incorrect_vis_restriction(&mut self) -> PResult<'a, ()> {
        .                 self.bump(); // `(`
        .                 let path = self.parse_path(PathStyle::Mod)?;
        .                 self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`
        .         
        .                 let path_str = pprust::path_to_string(&path);
-- line 1484 ----------------------------------------
-- line 1485 ----------------------------------------
        .                 self.dcx()
        .                     .emit_err(IncorrectVisibilityRestriction { span: path.span, inner_str: path_str });
        .         
        .                 Ok(())
        .             }
        .         
        .             /// Parses `extern string_literal?`.
        .             fn parse_extern(&mut self, case: Case) -> Extern {
    7,357 (0.0%)          if self.eat_keyword_case(kw::Extern, case) {
        .                     let mut extern_span = self.prev_token.span;
        .                     let abi = self.parse_abi();
        .                     if let Some(abi) = abi {
        .                         extern_span = extern_span.to(abi.span);
        .                     }
        .                     Extern::from_abi(abi, extern_span)
        .                 } else {
        .                     Extern::None
-- line 1501 ----------------------------------------
-- line 1518 ----------------------------------------
        .             }
        .         
        .             pub fn collect_tokens_no_attrs<R: HasAttrs + HasTokens>(
        .                 &mut self,
        .                 f: impl FnOnce(&mut Self) -> PResult<'a, R>,
        .             ) -> PResult<'a, R> {
        .                 // The only reason to call `collect_tokens_no_attrs` is if you want tokens, so use
        .                 // `ForceCollect::Yes`
   13,286 (0.0%)          self.collect_tokens_trailing_token(
    1,720 (0.0%)              AttrWrapper::empty(),
        .                     ForceCollect::Yes,
        .                     |this, _attrs| Ok((f(this)?, TrailingToken::None)),
        .                 )
        .             }
        .         
        .             /// `::{` or `::*`
  778,365 (0.0%)      fn is_import_coupler(&mut self) -> bool {
        .                 self.check(&token::ModSep)
        .                     && self.look_ahead(1, |t| {
   63,176 (0.0%)                  *t == token::OpenDelim(Delimiter::Brace) || *t == token::BinOp(token::Star)
        .                     })
  585,252 (0.0%)      }
        .         
        .             pub fn clear_expected_tokens(&mut self) {
        .                 self.expected_tokens.clear();
        .             }
        .         
        .             pub fn approx_token_stream_pos(&self) -> usize {
        .                 self.num_bump_calls
        .             }
-- line 1547 ----------------------------------------
-- line 1568 ----------------------------------------
        .             Some(err)
        .         }
        .         
        .         /// A helper struct used when building an `AttrTokenStream` from
        .         /// a `LazyAttrTokenStream`. Both delimiter and non-delimited tokens
        .         /// are stored as `FlatToken::Token`. A vector of `FlatToken`s
        .         /// is then 'parsed' to build up an `AttrTokenStream` with nested
        .         /// `AttrTokenTree::Delimited` tokens.
    9,493 (0.0%)  #[derive(Debug, Clone)]
        .         pub enum FlatToken {
        .             /// A token - this holds both delimiter (e.g. '{' and '}')
        .             /// and non-delimiter tokens
        .             Token(Token),
        .             /// Holds the `AttributesData` for an AST node. The
        .             /// `AttributesData` is inserted directly into the
        .             /// constructed `AttrTokenStream` as
        .             /// an `AttrTokenTree::Attributes`.
       96 (0.0%)      AttrTarget(AttributesData),
        .             /// A special 'empty' token that is ignored during the conversion
        .             /// to an `AttrTokenStream`. This is used to simplify the
        .             /// handling of replace ranges.
        .             Empty,
        .         }
        .         
        .         // Metavar captures of various kinds.
   36,696 (0.0%)  #[derive(Clone, Debug)]
        .         pub enum ParseNtResult<NtType> {
        .             Tt(TokenTree),
    4,554 (0.0%)      Nt(NtType),
        .         }
        .         
        .         impl<T> ParseNtResult<T> {
        .             pub fn map_nt<F, U>(self, mut f: F) -> ParseNtResult<U>
        .             where
        .                 F: FnMut(T) -> U,
        .             {
   76,158 (0.0%)          match self {
   73,896 (0.0%)              ParseNtResult::Tt(tt) => ParseNtResult::Tt(tt),
   39,210 (0.0%)              ParseNtResult::Nt(nt) => ParseNtResult::Nt(f(nt)),
        .                 }
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_query_impl/src/plumbing.rs
--------------------------------------------------------------------------------
Ir______________ 

   17,519 (0.0%)  <unknown (line 0)>

-- line 38 ----------------------------------------
        .         #[derive(Copy, Clone)]
        .         pub struct QueryCtxt<'tcx> {
        .             pub tcx: TyCtxt<'tcx>,
        .         }
        .         
        .         impl<'tcx> QueryCtxt<'tcx> {
        .             #[inline]
        .             pub fn new(tcx: TyCtxt<'tcx>) -> Self {
  602,690 (0.0%)          QueryCtxt { tcx }
        .             }
        .         }
        .         
        .         impl<'tcx> std::ops::Deref for QueryCtxt<'tcx> {
        .             type Target = TyCtxt<'tcx>;
        .         
        .             #[inline]
        .             fn deref(&self) -> &Self::Target {
-- line 54 ----------------------------------------
-- line 129 ----------------------------------------
        .                 depth_limit: bool,
        .                 diagnostics: Option<&Lock<ThinVec<DiagInner>>>,
        .                 compute: impl FnOnce() -> R,
        .             ) -> R {
        .                 // The `TyCtxt` stored in TLS has the same global interner lifetime
        .                 // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes
        .                 // when accessing the `ImplicitCtxt`.
        .                 tls::with_related_context(self.tcx, move |current_icx| {
    2,480 (0.0%)              if depth_limit && !self.recursion_limit().value_within_limit(current_icx.query_depth) {
        .                         self.depth_limit_error(token);
        .                     }
        .         
        .                     // Update the `ImplicitCtxt` to point to our new query job.
3,594,900 (0.0%)              let new_icx = ImplicitCtxt {
        .                         tcx: self.tcx,
        .                         query: Some(token),
        .                         diagnostics,
  602,690 (0.0%)                  query_depth: current_icx.query_depth + depth_limit as usize,
  602,690 (0.0%)                  task_deps: current_icx.task_deps,
        .                     };
        .         
        .                     // Use the `ImplicitCtxt` while we execute the query.
        .                     tls::enter_context(&new_icx, compute)
        .                 })
        .             }
        .         
        .             fn depth_limit_error(self, job: QueryJobId) {
-- line 155 ----------------------------------------
-- line 185 ----------------------------------------
        .             encoder: &mut CacheEncoder<'_, 'tcx>,
        .             query_result_index: &mut EncodedDepNodeIndex,
        .         ) {
        .             for encode in super::ENCODE_QUERY_RESULTS.iter().copied().flatten() {
        .                 encode(tcx, encoder, query_result_index);
        .             }
        .         }
        .         
        6 (0.0%)  pub fn query_key_hash_verify_all<'tcx>(tcx: TyCtxt<'tcx>) {
        2 (0.0%)      if tcx.sess().opts.unstable_opts.incremental_verify_ich || cfg!(debug_assertions) {
        .                 tcx.sess.time("query_key_hash_verify_all", || {
        .                     for verify in super::QUERY_KEY_HASH_VERIFY.iter() {
      578 (0.0%)                  verify(tcx);
        .                     }
        .                 })
        .             }
        6 (0.0%)  }
        .         
        .         macro_rules! handle_cycle_error {
        .             ([]) => {{
        .                 rustc_query_system::HandleCycleError::Error
        .             }};
        .             ([(fatal_cycle) $($rest:tt)*]) => {{
        .                 rustc_query_system::HandleCycleError::Fatal
        .             }};
-- line 209 ----------------------------------------
-- line 376 ----------------------------------------
        .         
        .                     // Encode the type check tables with the `SerializedDepNodeIndex`
        .                     // as tag.
        .                     encoder.encode_tagged(dep_node, &Q::restore(*value));
        .                 }
        .             });
        .         }
        .         
    1,516 (0.0%)  pub(crate) fn query_key_hash_verify<'tcx>(
        .             query: impl QueryConfig<QueryCtxt<'tcx>>,
        .             qcx: QueryCtxt<'tcx>,
        .         ) {
        .             let _timer =
      867 (0.0%)          qcx.profiler().generic_activity_with_arg("query_key_hash_verify_for", query.name());
        .         
        .             let mut map = UnordMap::default();
        .         
        .             let cache = query.query_cache(qcx);
5,608,692 (0.1%)      cache.iter(&mut |key, _, _| {
2,473,712 (0.0%)          let node = DepNode::construct(qcx.tcx, query.dep_kind(), key);
5,300,328 (0.1%)          if let Some(other_key) = map.insert(node, *key) {
        .                     bug!(
        .                         "query key:\n\
        .                         `{:?}`\n\
        .                         and key:\n\
        .                         `{:?}`\n\
        .                         mapped to the same dep node:\n\
        .                         {:?}",
        .                         key,
        .                         other_key,
        .                         node
        .                     );
        .                 }
4,328,929 (0.1%)      });
    1,591 (0.0%)  }
        .         
        .         fn try_load_from_on_disk_cache<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode)
        .         where
        .             Q: QueryConfig<QueryCtxt<'tcx>>,
        .         {
        .             debug_assert!(tcx.dep_graph.is_green(&dep_node));
        .         
        .             let key = Q::Key::recover(tcx, &dep_node).unwrap_or_else(|| {
-- line 418 ----------------------------------------
-- line 487 ----------------------------------------
        .         
        .         pub(crate) fn query_callback<'tcx, Q>(is_anon: bool, is_eval_always: bool) -> DepKindStruct<'tcx>
        .         where
        .             Q: QueryConfigRestored<'tcx>,
        .         {
        .             let fingerprint_style = <Q::Config as QueryConfig<QueryCtxt<'tcx>>>::Key::fingerprint_style();
        .         
        .             if is_anon || !fingerprint_style.reconstructible() {
       68 (0.0%)          return DepKindStruct {
        .                     is_anon,
        .                     is_eval_always,
        .                     fingerprint_style,
        .                     force_from_dep_node: None,
        .                     try_load_from_on_disk_cache: None,
        .                     name: Q::NAME,
        .                 };
        .             }
-- line 503 ----------------------------------------
-- line 536 ----------------------------------------
        .             ([$other:tt $($modifiers:tt)*], $tokens:expr) => {
        .                 expand_if_cached!([$($modifiers)*], $tokens)
        .             };
        .         }
        .         
        .         /// Don't show the backtrace for query system by default
        .         /// use `RUST_BACKTRACE=full` to show all the backtraces
        .         #[inline(never)]
2,781,783 (0.0%)  pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T
        .         where
        .             F: FnOnce() -> T,
        .         {
        .             let result = f();
        .             std::hint::black_box(());
        .             result
1,951,024 (0.0%)  }
        .         
        .         // NOTE: `$V` isn't used here, but we still need to match on it so it can be passed to other macros
        .         // invoked by `rustc_query_append`.
        .         macro_rules! define_queries {
        .             (
        .              $($(#[$attr:meta])*
        .                 [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {
        .         
-- line 559 ----------------------------------------
-- line 584 ----------------------------------------
        .                             )
        .                         }
        .                     }
        .         
        .                     pub mod get_query_non_incr {
        .                         use super::*;
        .         
        .                         #[inline(never)]
7,423,406 (0.1%)                  pub fn __rust_end_short_backtrace<'tcx>(
        .                             tcx: TyCtxt<'tcx>,
        .                             span: Span,
        .                             key: queries::$name::Key<'tcx>,
        .                             __mode: QueryMode,
        .                         ) -> Option<Erase<queries::$name::Value<'tcx>>> {
1,983,623 (0.0%)                      Some(get_query_non_incr(
        .                                 QueryType::config(tcx),
        .                                 QueryCtxt::new(tcx),
  602,690 (0.0%)                          span,
1,473,885 (0.0%)                          key,
        .                             ))
5,032,141 (0.1%)                  }
        .                     }
        .         
        .                     pub fn dynamic_query<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {
        .                         DynamicQuery {
        .                             name: stringify!($name),
        .                             eval_always: is_eval_always!([$($modifiers)*]),
        .                             dep_kind: dep_graph::dep_kinds::$name,
        .                             handle_cycle_error: handle_cycle_error!([$($modifiers)*]),
        .                             query_state: offset_of!(QueryStates<'tcx> => $name),
        .                             query_cache: offset_of!(QueryCaches<'tcx> => $name),
        .                             cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),
        .                             execute_query: |tcx, key| erase(tcx.$name(key)),
        .                             compute: |tcx, key| {
        .                                 #[cfg(debug_assertions)]
        .                                 let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();
  925,052 (0.0%)                          __rust_begin_short_backtrace(||
        .                                     queries::$name::provided_to_erased(
        .                                         tcx,
        .                                         {
1,504,849 (0.0%)                                      let ret = call_provider!([$($modifiers)*][tcx, $name, key]);
        .                                             tracing::trace!(?ret);
   15,836 (0.0%)                                      ret
   39,225 (0.0%)                                  }
        .                                     )
        .                                 )
        .                             },
        .                             can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),
        .                             try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {
        .                                 |tcx, key, prev_index, index| {
        .                                     if ::rustc_middle::query::cached::$name(tcx, key) {
        .                                         let value = $crate::plumbing::try_load_from_disk::<
-- line 635 ----------------------------------------
-- line 678 ----------------------------------------
        .                             { depth_limit!([$($modifiers)*]) },
        .                             { feedable!([$($modifiers)*]) },
        .                         >;
        .         
        .                         const NAME: &'static &'static str = &stringify!($name);
        .         
        .                         #[inline(always)]
        .                         fn config(tcx: TyCtxt<'tcx>) -> Self::Config {
  602,690 (0.0%)                      DynamicConfig {
  603,095 (0.0%)                          dynamic: &tcx.query_system.dynamic_queries.$name,
        .                             }
        .                         }
        .         
        .                         #[inline(always)]
        .                         fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {
        .                             restore::<queries::$name::Value<'tcx>>(value)
        .                         }
        .                     }
-- line 695 ----------------------------------------
-- line 726 ----------------------------------------
        .                                 query_impl::$name::QueryType::config(tcx),
        .                                 QueryCtxt::new(tcx),
        .                                 encoder,
        .                                 query_result_index,
        .                             )
        .                         }
        .                     }}
        .         
      928 (0.0%)              pub fn query_key_hash_verify<'tcx>(tcx: TyCtxt<'tcx>) {
      456 (0.0%)                  $crate::plumbing::query_key_hash_verify(
        .                             query_impl::$name::QueryType::config(tcx),
        .                             QueryCtxt::new(tcx),
        .                         )
      244 (0.0%)              }
        .                 })*}
        .         
        .                 pub(crate) fn engine(incremental: bool) -> QueryEngine {
        1 (0.0%)              if incremental {
        .                         QueryEngine {
        .                             $($name: query_impl::$name::get_query_incr::__rust_end_short_backtrace,)*
        .                         }
        .                     } else {
        .                         QueryEngine {
        .                             $($name: query_impl::$name::get_query_non_incr::__rust_end_short_backtrace,)*
        .                         }
        .                     }
        .                 }
        .         
        9 (0.0%)          pub fn dynamic_queries<'tcx>() -> DynamicQueries<'tcx> {
        1 (0.0%)              DynamicQueries {
        .                         $(
        .                             $name: query_impl::$name::dynamic_query(),
        .                         )*
        .                     }
        8 (0.0%)          }
        .         
        .                 // These arrays are used for iteration and can't be indexed by `DepKind`.
        .         
        .                 const TRY_COLLECT_ACTIVE_JOBS: &[for<'tcx> fn(TyCtxt<'tcx>, &mut QueryMap)] =
        .                     &[$(query_impl::$name::try_collect_active_jobs),*];
        .         
        .                 const ALLOC_SELF_PROFILE_QUERY_STRINGS: &[
        .                     for<'tcx> fn(TyCtxt<'tcx>, &mut QueryKeyStringCache)
-- line 768 ----------------------------------------
-- line 845 ----------------------------------------
        .                     $(pub(crate) fn $name<'tcx>()-> DepKindStruct<'tcx> {
        .                         $crate::plumbing::query_callback::<query_impl::$name::QueryType<'tcx>>(
        .                             is_anon!([$($modifiers)*]),
        .                             is_eval_always!([$($modifiers)*]),
        .                         )
        .                     })*
        .                 }
        .         
       10 (0.0%)          pub fn query_callbacks<'tcx>(arena: &'tcx Arena<'tcx>) -> &'tcx [DepKindStruct<'tcx>] {
        .                     arena.alloc_from_iter(make_dep_kind_array!(query_callbacks))
        5 (0.0%)          }
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_query_system/src/query/caches.rs
--------------------------------------------------------------------------------
Ir_______________ 

   360,079 (0.0%)  <unknown (line 0)>

-- line 23 ----------------------------------------
         .         }
         .         
         .         pub struct DefaultCache<K, V> {
         .             cache: Sharded<FxHashMap<K, (V, DepNodeIndex)>>,
         .         }
         .         
         .         impl<K, V> Default for DefaultCache<K, V> {
         .             fn default() -> Self {
       665 (0.0%)          DefaultCache { cache: Default::default() }
         .             }
         .         }
         .         
         .         impl<K, V> QueryCache for DefaultCache<K, V>
         .         where
         .             K: Eq + Hash + Copy + Debug,
         .             V: Copy,
         .         {
-- line 39 ----------------------------------------
-- line 41 ----------------------------------------
         .             type Value = V;
         .         
         .             #[inline(always)]
         .             fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {
         .                 let key_hash = sharded::make_hash(key);
         .                 let lock = self.cache.lock_shard_by_hash(key_hash);
         .                 let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);
         .         
12,435,288 (0.2%)          if let Some((_, value)) = result { Some(*value) } else { None }
         .             }
         .         
         .             #[inline]
         .             fn complete(&self, key: K, value: V, index: DepNodeIndex) {
         .                 let mut lock = self.cache.lock_shard_by_value(&key);
         .                 // We may be overwriting another value. This is all right, since the dep-graph
         .                 // will check that the fingerprint matches.
     6,912 (0.0%)          lock.insert(key, (value, index));
         .             }
         .         
       760 (0.0%)      fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {
     1,225 (0.0%)          for shard in self.cache.lock_shards() {
         .                     for (k, v) in shard.iter() {
 2,555,735 (0.0%)                  f(k, &v.0, v.1);
         .                     }
         .                 }
       608 (0.0%)      }
         .         }
         .         
         .         pub struct SingleCache<V> {
         .             cache: OnceLock<(V, DepNodeIndex)>,
         .         }
         .         
         .         impl<V> Default for SingleCache<V> {
         .             fn default() -> Self {
-- line 74 ----------------------------------------
-- line 85 ----------------------------------------
         .         
         .             #[inline(always)]
         .             fn lookup(&self, _key: &()) -> Option<(V, DepNodeIndex)> {
         .                 self.cache.get().copied()
         .             }
         .         
         .             #[inline]
         .             fn complete(&self, _key: (), value: V, index: DepNodeIndex) {
        14 (0.0%)          self.cache.set((value, index)).ok();
         .             }
         .         
         .             fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {
        42 (0.0%)          if let Some(value) = self.cache.get() {
         .                     f(&(), &value.0, value.1)
         .                 }
         .             }
         .         }
         .         
         .         pub struct VecCache<K: Idx, V> {
         .             cache: Lock<IndexVec<K, Option<(V, DepNodeIndex)>>>,
         .         }
-- line 105 ----------------------------------------
-- line 116 ----------------------------------------
         .             V: Copy,
         .         {
         .             type Key = K;
         .             type Value = V;
         .         
         .             #[inline(always)]
         .             fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {
         .                 let lock = self.cache.lock();
 3,985,188 (0.0%)          if let Some(Some(value)) = lock.get(*key) { Some(*value) } else { None }
         .             }
         .         
         .             #[inline]
         .             fn complete(&self, key: K, value: V, index: DepNodeIndex) {
         .                 let mut lock = self.cache.lock();
         .                 lock.insert(key, (value, index));
         .             }
         .         
       720 (0.0%)      fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {
   147,696 (0.0%)          for (k, v) in self.cache.lock().iter_enumerated() {
   435,537 (0.0%)              if let Some(v) = v {
   197,030 (0.0%)                  f(&k, &v.0, v.1);
         .                     }
         .                 }
       576 (0.0%)      }
         .         }
         .         
         .         pub struct DefIdCache<V> {
         .             /// Stores the local DefIds in a dense map. Local queries are much more often dense, so this is
         .             /// a win over hashing query keys at marginal memory cost (~5% at most) compared to FxHashMap.
         .             ///
         .             /// The second element of the tuple is the set of keys actually present in the IndexVec, used
         .             /// for faster iteration in `iter()`.
         .             local: Lock<(IndexVec<DefIndex, Option<(V, DepNodeIndex)>>, Vec<DefIndex>)>,
         .             foreign: DefaultCache<DefId, V>,
         .         }
         .         
         .         impl<V> Default for DefIdCache<V> {
       665 (0.0%)      fn default() -> Self {
     1,389 (0.0%)          DefIdCache { local: Default::default(), foreign: Default::default() }
       475 (0.0%)      }
         .         }
         .         
         .         impl<V> QueryCache for DefIdCache<V>
         .         where
         .             V: Copy,
         .         {
         .             type Key = DefId;
         .             type Value = V;
         .         
         .             #[inline(always)]
         .             fn lookup(&self, key: &DefId) -> Option<(V, DepNodeIndex)> {
 7,476,430 (0.1%)          if key.krate == LOCAL_CRATE {
         .                     let cache = self.local.lock();
 1,557,182 (0.0%)              cache.0.get(key.index).and_then(|v| *v)
         .                 } else {
         .                     self.foreign.lookup(key)
         .                 }
         .             }
         .         
         .             #[inline]
    15,664 (0.0%)      fn complete(&self, key: DefId, value: V, index: DepNodeIndex) {
   542,897 (0.0%)          if key.krate == LOCAL_CRATE {
         .                     let mut cache = self.local.lock();
         .                     let (cache, present) = &mut *cache;
         .                     let slot = cache.ensure_contains_elem(key.index, Default::default);
         .                     if slot.is_none() {
         .                         // FIXME: Only store the present set when running in incremental mode. `iter` is not
         .                         // used outside of saving caches to disk and self-profile.
       412 (0.0%)                  present.push(key.index);
         .                     }
   308,513 (0.0%)              *slot = Some((value, index));
         .                 } else {
         .                     self.foreign.complete(key, value, index)
         .                 }
    11,392 (0.0%)      }
         .         
       990 (0.0%)      fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {
         .                 let guard = self.local.lock();
         .                 let (cache, present) = &*guard;
   144,826 (0.0%)          for &idx in present.iter() {
   175,164 (0.0%)              let value = cache[idx].unwrap();
   506,324 (0.0%)              f(&DefId { krate: LOCAL_CRATE, index: idx }, &value.0, value.1);
         .                 }
         .                 self.foreign.iter(f);
       792 (0.0%)      }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_resolve/src/ident.rs
--------------------------------------------------------------------------------
Ir______________ 

5,929,003 (0.1%)  <unknown (line 0)>

-- line 85 ----------------------------------------
        .                 //    ambiguities with `macro_rules`.
        .                 // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).
        .                 // 4a. User-defined prelude from macro-use
        .                 //    (open, the open part is from macro expansions, not controlled).
        .                 // 4b. "Standard library prelude" part implemented through `macro-use` (closed, controlled).
        .                 // 4c. Standard library prelude (de-facto closed, controlled).
        .                 // 6. Language prelude: builtin attributes (closed, controlled).
        .         
   75,727 (0.0%)          let rust_2015 = ctxt.edition().is_rust_2015();
        .                 let (ns, macro_kind, is_absolute_path) = match scope_set {
        .                     ScopeSet::All(ns) => (ns, None, false),
        .                     ScopeSet::AbsolutePath(ns) => (ns, None, true),
        .                     ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),
        .                     ScopeSet::Late(ns, ..) => (ns, None, false),
        .                 };
        .                 let module = match scope_set {
        .                     // Start with the specified module.
   28,610 (0.0%)              ScopeSet::Late(_, module, _) => module,
        .                     // Jump out of trait or enum modules, they do not act as scopes.
   22,800 (0.0%)              _ => parent_scope.module.nearest_item_scope(),
        .                 };
   31,644 (0.0%)          let mut scope = match ns {
        .                     _ if is_absolute_path => Scope::CrateRoot,
        .                     TypeNS | ValueNS => Scope::Module(module, None),
   58,458 (0.0%)              MacroNS => Scope::DeriveHelpers(parent_scope.expansion),
        .                 };
   74,210 (0.0%)          let mut ctxt = ctxt.normalize_to_macros_2_0();
  913,410 (0.0%)          let mut use_prelude = !module.no_implicit_prelude;
        .         
        .                 loop {
2,066,402 (0.0%)              let visit = match scope {
        .                         // Derive helpers are not in scope when resolving derives in the same container.
        .                         Scope::DeriveHelpers(expn_id) => {
   10,331 (0.0%)                      !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))
        .                         }
        .                         Scope::DeriveHelpersCompat => true,
        .                         Scope::MacroRules(macro_rules_scope) => {
        .                             // Use "path compression" on `macro_rules` scope chains. This is an optimization
        .                             // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.
        .                             // As another consequence of this optimization visitors never observe invocation
        .                             // scopes for macros that were already expanded.
  135,146 (0.0%)                      while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {
        .                                 if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {
        .                                     macro_rules_scope.set(next_scope.get());
        .                                 } else {
        .                                     break;
        .                                 }
        .                             }
        .                             true
        .                         }
        .                         Scope::CrateRoot => true,
        .                         Scope::Module(..) => true,
        .                         Scope::MacroUsePrelude => use_prelude || rust_2015,
        .                         Scope::BuiltinAttrs => true,
        .                         Scope::ExternPrelude => use_prelude || is_absolute_path,
   26,859 (0.0%)                  Scope::ToolPrelude => use_prelude,
   23,998 (0.0%)                  Scope::StdLibPrelude => use_prelude || ns == MacroNS,
        .                         Scope::BuiltinTypes => true,
        .                     };
        .         
   57,220 (0.0%)              if visit {
        .                         let use_prelude = if use_prelude { UsePrelude::Yes } else { UsePrelude::No };
  360,550 (0.0%)                  if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {
        .                             return break_result;
        .                         }
        .                     }
        .         
  926,671 (0.0%)              scope = match scope {
        .                         Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,
        .                         Scope::DeriveHelpers(expn_id) => {
        .                             // Derive helpers are not visible to code generated by bang or derive macros.
   28,461 (0.0%)                      let expn_data = expn_id.expn_data();
   66,409 (0.0%)                      match expn_data.kind {
        .                                 ExpnKind::Root
        .                                 | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {
        .                                     Scope::DeriveHelpersCompat
        .                                 }
      882 (0.0%)                          _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),
        .                             }
        .                         }
        .                         Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),
  239,410 (0.0%)                  Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {
        .                             MacroRulesScope::Binding(binding) => {
  106,044 (0.0%)                          Scope::MacroRules(binding.parent_macro_rules_scope)
        .                             }
        .                             MacroRulesScope::Invocation(invoc_id) => {
    4,050 (0.0%)                          Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)
        .                             }
        .                             MacroRulesScope::Empty => Scope::Module(module, None),
        .                         },
        .                         Scope::CrateRoot => match ns {
        .                             TypeNS => {
        .                                 ctxt.adjust(ExpnId::root());
        .                                 Scope::ExternPrelude
        .                             }
        .                             ValueNS | MacroNS => break,
        .                         },
        .                         Scope::Module(module, prev_lint_id) => {
  293,906 (0.0%)                      use_prelude = !module.no_implicit_prelude;
        .                             let derive_fallback_lint_id = match scope_set {
        .                                 ScopeSet::Late(.., lint_id) => lint_id,
        .                                 _ => None,
        .                             };
  514,596 (0.0%)                      match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {
        .                                 Some((parent_module, lint_id)) => {
        .                                     Scope::Module(parent_module, lint_id.or(prev_lint_id))
        .                                 }
        .                                 None => {
  137,703 (0.0%)                              ctxt.adjust(ExpnId::root());
   69,706 (0.0%)                              match ns {
        .                                         TypeNS => Scope::ExternPrelude,
        .                                         ValueNS => Scope::StdLibPrelude,
        .                                         MacroNS => Scope::MacroUsePrelude,
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                         Scope::MacroUsePrelude => Scope::StdLibPrelude,
        .                         Scope::BuiltinAttrs => break, // nowhere else to search
    5,722 (0.0%)                  Scope::ExternPrelude if is_absolute_path => break,
        .                         Scope::ExternPrelude => Scope::ToolPrelude,
        .                         Scope::ToolPrelude => Scope::StdLibPrelude,
   41,448 (0.0%)                  Scope::StdLibPrelude => match ns {
        .                             TypeNS => Scope::BuiltinTypes,
        .                             ValueNS => break, // nowhere else to search
        .                             MacroNS => Scope::BuiltinAttrs,
        .                         },
        .                         Scope::BuiltinTypes => break, // nowhere else to search
        .                     };
        .                 }
        .         
        .                 None
        .             }
        .         
1,134,084 (0.0%)      fn hygienic_lexical_parent(
        .                 &mut self,
        .                 module: Module<'a>,
        .                 ctxt: &mut SyntaxContext,
        .                 derive_fallback_lint_id: Option<NodeId>,
        .             ) -> Option<(Module<'a>, Option<NodeId>)> {
  661,549 (0.0%)          if !module.expansion.outer_expn_is_descendant_of(*ctxt) {
    2,232 (0.0%)              return Some((self.expn_def_scope(ctxt.remove_mark()), None));
        .                 }
        .         
  188,270 (0.0%)          if let ModuleKind::Block = module.kind {
   62,709 (0.0%)              return Some((module.parent.unwrap().nearest_item_scope(), None));
        .                 }
        .         
        .                 // We need to support the next case under a deprecation warning
        .                 // ```
        .                 // struct MyStruct;
        .                 // ---- begin: this comes from a proc macro derive
        .                 // mod implementation_details {
        .                 //     // Note that `MyStruct` is not in scope here.
        .                 //     impl SomeTrait for MyStruct { ... }
        .                 // }
        .                 // ---- end
        .                 // ```
        .                 // So we have to fall back to the module's parent during lexical resolution in this case.
        .                 if derive_fallback_lint_id.is_some() {
   11,724 (0.0%)              if let Some(parent) = module.parent {
        .                         // Inner module is inside the macro, parent module is outside of the macro.
        .                         if module.expansion != parent.expansion
    8,684 (0.0%)                      && module.expansion.is_descendant_of(parent.expansion)
        .                         {
        .                             // The macro is a proc macro derive
    9,552 (0.0%)                      if let Some(def_id) = module.expansion.expn_data().macro_def_id {
    2,388 (0.0%)                          let ext = &self.get_macro_by_def_id(def_id).ext;
        .                                 if ext.builtin_name.is_none()
        .                                     && ext.macro_kind() == MacroKind::Derive
        .                                     && parent.expansion.outer_expn_is_descendant_of(*ctxt)
        .                                 {
        .                                     return Some((parent, derive_fallback_lint_id));
        .                                 }
        .                             }
        .                         }
        .                     }
        .                 }
        .         
        .                 None
  756,056 (0.0%)      }
        .         
        .             /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.
        .             /// More specifically, we proceed up the hierarchy of scopes and return the binding for
        .             /// `ident` in the first scope that defines it (or None if no scopes define it).
        .             ///
        .             /// A block's items are above its local variables in the scope hierarchy, regardless of where
        .             /// the items are defined in the block. For example,
        .             /// ```rust
-- line 273 ----------------------------------------
-- line 276 ----------------------------------------
        .             ///    let g = || {};
        .             ///    fn g() {}
        .             ///    g(); // This resolves to the local variable `g` since it shadows the item.
        .             /// }
        .             /// ```
        .             ///
        .             /// Invariant: This must only be called during main resolution, not during
        .             /// import resolution.
  491,980 (0.0%)      #[instrument(level = "debug", skip(self, ribs))]
        .             pub(crate) fn resolve_ident_in_lexical_scope(
        .                 &mut self,
        .                 mut ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ribs: &[Rib<'a>],
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> Option<LexicalScopeBinding<'a>> {
   57,880 (0.0%)          assert!(ns == TypeNS || ns == ValueNS);
  115,760 (0.0%)          let orig_ident = ident;
  202,580 (0.0%)          if ident.name == kw::Empty {
        .                     return Some(LexicalScopeBinding::Res(Res::Err));
        .                 }
        .                 let (general_span, normalized_span) = if ident.name == kw::SelfUpper {
        .                     // FIXME(jseyfried) improve `Self` hygiene
    2,050 (0.0%)              let empty_span = ident.span.with_ctxt(SyntaxContext::root());
        .                     (empty_span, empty_span)
   55,830 (0.0%)          } else if ns == TypeNS {
        .                     let normalized_span = ident.span.normalize_to_macros_2_0();
        .                     (normalized_span, normalized_span)
        .                 } else {
        .                     (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())
        .                 };
   28,940 (0.0%)          ident.span = general_span;
        .                 let normalized_ident = Ident { span: normalized_span, ..ident };
        .         
        .                 // Walk backwards up the ribs in scope.
   57,880 (0.0%)          let mut module = self.graph_root;
        .                 for i in (0..ribs.len()).rev() {
        .                     debug!("walk rib\n{:?}", ribs[i].bindings);
        .                     // Use the rib kind to determine whether we are resolving parameters
        .                     // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).
  693,239 (0.0%)              let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };
        .                     if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)
        .                     {
        .                         // The ident resolves to a type parameter or local variable.
   70,302 (0.0%)                  return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(
        .                             i,
   35,151 (0.0%)                      rib_ident,
   58,585 (0.0%)                      *res,
        .                             finalize.map(|finalize| finalize.path_span),
        .                             *original_rib_ident_def,
        .                             ribs,
        .                         )));
        .                     }
        .         
1,411,505 (0.0%)              module = match ribs[i].kind {
   32,733 (0.0%)                  RibKind::Module(module) => module,
    1,565 (0.0%)                  RibKind::MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {
        .                             // If an invocation of this macro created `ident`, give up on `ident`
        .                             // and switch to `ident`'s source from the macro definition.
        .                             ident.span.remove_mark();
        .                             continue;
        .                         }
        .                         _ => continue,
        .                     };
        .         
   98,199 (0.0%)              match module.kind {
        .                         ModuleKind::Block => {} // We can see through blocks
        .                         _ => break,
        .                     }
        .         
        .                     let item = self.resolve_ident_in_module_unadjusted(
        .                         ModuleOrUniformRoot::Module(module),
        .                         ident,
        .                         ns,
-- line 351 ----------------------------------------
-- line 353 ----------------------------------------
        .                         finalize.map(|finalize| Finalize { used: Used::Scope, ..finalize }),
        .                         ignore_binding,
        .                     );
        .                     if let Ok(binding) = item {
        .                         // The ident resolves to an item.
        .                         return Some(LexicalScopeBinding::Item(binding));
        .                     }
        .                 }
  104,965 (0.0%)          self.early_resolve_ident_in_lexical_scope(
        .                     orig_ident,
  104,965 (0.0%)              ScopeSet::Late(ns, module, finalize.map(|finalize| finalize.node_id)),
        .                     parent_scope,
        .                     finalize,
        .                     finalize.is_some(),
        .                     ignore_binding,
        .                 )
        .                 .ok()
        .                 .map(LexicalScopeBinding::Item)
        .             }
        .         
        .             /// Resolve an identifier in lexical scope.
        .             /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during
        .             /// expansion and import resolution (perhaps they can be merged in the future).
        .             /// The function is used for resolving initial segments of macro paths (e.g., `foo` in
        .             /// `foo::bar!();` or `foo!();`) and also for import paths on 2018 edition.
  619,680 (0.0%)      #[instrument(level = "debug", skip(self))]
        .             pub(crate) fn early_resolve_ident_in_lexical_scope(
        .                 &mut self,
        .                 orig_ident: Ident,
        .                 scope_set: ScopeSet<'a>,
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 force: bool,
        .                 ignore_binding: Option<NameBinding<'a>>,
-- line 386 ----------------------------------------
-- line 391 ----------------------------------------
        .                         const MACRO_RULES          = 1 << 0;
        .                         const MODULE               = 1 << 1;
        .                         const MISC_SUGGEST_CRATE   = 1 << 2;
        .                         const MISC_SUGGEST_SELF    = 1 << 3;
        .                         const MISC_FROM_PRELUDE    = 1 << 4;
        .                     }
        .                 }
        .         
   73,454 (0.0%)          assert!(force || finalize.is_none()); // `finalize` implies `force`
        .         
        .                 // Make sure `self`, `super` etc produce an error when passed to here.
  103,280 (0.0%)          if orig_ident.is_path_segment_keyword() {
    1,428 (0.0%)              return Err(Determinacy::Determined);
        .                 }
        .         
  200,848 (0.0%)          let (ns, macro_kind) = match scope_set {
    1,517 (0.0%)              ScopeSet::All(ns) => (ns, None),
        .                     ScopeSet::AbsolutePath(ns) => (ns, None),
   18,568 (0.0%)              ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind)),
   14,305 (0.0%)              ScopeSet::Late(ns, ..) => (ns, None),
        .                 };
        .         
        .                 // This is *the* result, resolution from the scope closest to the resolved identifier.
        .                 // However, sometimes this result is "weak" because it comes from a glob import or
        .                 // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.
        .                 // mod m { ... } // solution in outer scope
        .                 // {
        .                 //     use prefix::*; // imports another `m` - innermost solution
-- line 418 ----------------------------------------
-- line 423 ----------------------------------------
        .                 // to detect potential ambiguities.
        .                 let mut innermost_result: Option<(NameBinding<'_>, Flags)> = None;
        .                 let mut determinacy = Determinacy::Determined;
        .         
        .                 // Go through all the scopes and try to resolve the name.
        .                 let break_result = self.visit_scopes(
        .                     scope_set,
        .                     parent_scope,
  100,424 (0.0%)              orig_ident.span.ctxt(),
        .                     |this, scope, use_prelude, ctxt| {
        .                         let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));
  901,375 (0.0%)                  let result = match scope {
        .                             Scope::DeriveHelpers(expn_id) => {
        .                                 if let Some(binding) = this.helper_attrs.get(&expn_id).and_then(|attrs| {
        .                                     attrs.iter().rfind(|(i, _)| ident == *i).map(|(_, binding)| *binding)
        .                                 }) {
        .                                     Ok((binding, Flags::empty()))
        .                                 } else {
        .                                     Err(Determinacy::Determined)
        .                                 }
-- line 442 ----------------------------------------
-- line 473 ----------------------------------------
        .                                         Ok(_) | Err(Determinacy::Determined) => {}
        .                                         Err(Determinacy::Undetermined) => {
        .                                             result = Err(Determinacy::Undetermined)
        .                                         }
        .                                     }
        .                                 }
        .                                 result
        .                             }
  359,907 (0.0%)                      Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {
        .                                 MacroRulesScope::Binding(macro_rules_binding)
      528 (0.0%)                              if ident == macro_rules_binding.ident =>
        .                                 {
        .                                     Ok((macro_rules_binding.binding, Flags::MACRO_RULES))
        .                                 }
        .                                 MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),
        .                                 _ => Err(Determinacy::Determined),
        .                             },
        .                             Scope::CrateRoot => {
        .                                 let root_ident = Ident::new(kw::PathRoot, ident.span);
-- line 491 ----------------------------------------
-- line 505 ----------------------------------------
        .                                     }
        .                                     Err((Determinacy::Undetermined, Weak::Yes)) => {
        .                                         Err(Determinacy::Undetermined)
        .                                     }
        .                                     Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),
        .                                 }
        .                             }
        .                             Scope::Module(module, derive_fallback_lint_id) => {
  521,937 (0.0%)                          let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };
  579,930 (0.0%)                          let binding = this.resolve_ident_in_module_unadjusted_ext(
        .                                     ModuleOrUniformRoot::Module(module),
  289,965 (0.0%)                              ident,
        .                                     ns,
        .                                     adjusted_parent_scope,
        .                                     !matches!(scope_set, ScopeSet::Late(..)),
        .                                     finalize.map(|finalize| Finalize { used: Used::Scope, ..finalize }),
        .                                     ignore_binding,
        .                                 );
  291,791 (0.0%)                          match binding {
    5,557 (0.0%)                              Ok(binding) => {
   11,114 (0.0%)                                  if let Some(lint_id) = derive_fallback_lint_id {
        .                                             this.lint_buffer.buffer_lint_with_diagnostic(
        .                                                 PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,
        .                                                 lint_id,
        .                                                 orig_ident.span,
        .                                                 format!(
        .                                                     "cannot find {} `{}` in this scope",
        .                                                     ns.descr(),
        .                                                     ident
        .                                                 ),
        .                                                 BuiltinLintDiag::ProcMacroDeriveResolutionFallback(
        .                                                     orig_ident.span,
        .                                                 ),
        .                                             );
        .                                         }
    5,557 (0.0%)                                  let misc_flags = if module == this.graph_root {
        .                                             Flags::MISC_SUGGEST_CRATE
   11,094 (0.0%)                                  } else if module.is_normal() {
        .                                             Flags::MISC_SUGGEST_SELF
        .                                         } else {
        .                                             Flags::empty()
        .                                         };
        .                                         Ok((binding, Flags::MODULE | misc_flags))
        .                                     }
        .                                     Err((Determinacy::Undetermined, Weak::No)) => {
        .                                         return Some(Err(Determinacy::determined(force)));
-- line 550 ----------------------------------------
-- line 563 ----------------------------------------
        .                                     )),
        .                                 }
        .                             }
        .                             Scope::BuiltinAttrs => match this.builtin_attrs_bindings.get(&ident.name) {
        .                                 Some(binding) => Ok((*binding, Flags::empty())),
        .                                 None => Err(Determinacy::Determined),
        .                             },
        .                             Scope::ExternPrelude => {
   43,989 (0.0%)                          match this.extern_prelude_get(ident, finalize.is_some()) {
        .                                     Some(binding) => Ok((binding, Flags::empty())),
        .                                     None => Err(Determinacy::determined(
        .                                         this.graph_root.unexpanded_invocations.borrow().is_empty(),
        .                                     )),
        .                                 }
        .                             }
        .                             Scope::ToolPrelude => match this.registered_tool_bindings.get(&ident) {
        .                                 Some(binding) => Ok((*binding, Flags::empty())),
        .                                 None => Err(Determinacy::Determined),
        .                             },
        .                             Scope::StdLibPrelude => {
        .                                 let mut result = Err(Determinacy::Determined);
   44,496 (0.0%)                          if let Some(prelude) = this.prelude {
        .                                     if let Ok(binding) = this.resolve_ident_in_module_unadjusted(
        .                                         ModuleOrUniformRoot::Module(prelude),
   59,328 (0.0%)                                  ident,
        .                                         ns,
        .                                         parent_scope,
   44,496 (0.0%)                                  None,
        .                                         ignore_binding,
        .                                     ) {
   14,546 (0.0%)                                  if matches!(use_prelude, UsePrelude::Yes)
        .                                             || this.is_builtin_macro(binding.res())
        .                                         {
        .                                             result = Ok((binding, Flags::MISC_FROM_PRELUDE));
        .                                         }
        .                                     }
        .                                 }
        .                                 result
        .                             }
        .                             Scope::BuiltinTypes => match this.builtin_types_bindings.get(&ident.name) {
        .                                 Some(binding) => {
      609 (0.0%)                              if matches!(ident.name, sym::f16)
        .                                         && !this.tcx.features().f16
        .                                         && !ident.span.allows_unstable(sym::f16)
        .                                         && finalize.is_some()
        .                                         && innermost_result.is_none()
        .                                     {
        .                                         feature_err(
        .                                             this.tcx.sess,
        .                                             sym::f16,
        .                                             ident.span,
        .                                             "the type `f16` is unstable",
        .                                         )
        .                                         .emit();
        .                                     }
    1,218 (0.0%)                              if matches!(ident.name, sym::f128)
        .                                         && !this.tcx.features().f128
        .                                         && !ident.span.allows_unstable(sym::f128)
        .                                         && finalize.is_some()
        .                                         && innermost_result.is_none()
        .                                     {
        .                                         feature_err(
        .                                             this.tcx.sess,
        .                                             sym::f128,
-- line 626 ----------------------------------------
-- line 630 ----------------------------------------
        .                                         .emit();
        .                                     }
        .                                     Ok((*binding, Flags::empty()))
        .                                 }
        .                                 None => Err(Determinacy::Determined),
        .                             },
        .                         };
        .         
  229,504 (0.0%)                  match result {
        .                             Ok((binding, flags))
        .                                 if sub_namespace_match(binding.macro_kind(), macro_kind) =>
        .                             {
        .                                 if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {
        .                                     return Some(Ok(binding));
        .                                 }
        .         
   17,322 (0.0%)                          if let Some((innermost_binding, innermost_flags)) = innermost_result {
        .                                     // Found another solution, if the first one was "weak", report an error.
   53,208 (0.0%)                              let (res, innermost_res) = (binding.res(), innermost_binding.res());
    5,912 (0.0%)                              if res != innermost_res {
        .                                         let is_builtin = |res| {
        .                                             matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))
        .                                         };
        .                                         let derive_helper =
        .                                             Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);
        .                                         let derive_helper_compat =
        .                                             Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);
        .         
-- line 657 ----------------------------------------
-- line 719 ----------------------------------------
        .                             Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,
        .                         }
        .         
        .                         None
        .                     },
        .                 );
        .         
        .                 if let Some(break_result) = break_result {
   57,748 (0.0%)              return break_result;
        .                 }
        .         
        .                 // The first found solution was the only one, return it.
   21,338 (0.0%)          if let Some((binding, _)) = innermost_result {
   17,115 (0.0%)              return Ok(binding);
        .                 }
        .         
   39,712 (0.0%)          Err(Determinacy::determined(determinacy == Determinacy::Determined || force))
        .             }
        .         
        .             #[instrument(level = "debug", skip(self))]
        .             pub(crate) fn maybe_resolve_ident_in_module(
        .                 &mut self,
        .                 module: ModuleOrUniformRoot<'a>,
        .                 ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .             ) -> Result<NameBinding<'a>, Determinacy> {
   97,984 (0.0%)          self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, None)
        .                     .map_err(|(determinacy, _)| determinacy)
        .             }
        .         
        .             #[instrument(level = "debug", skip(self))]
        .             pub(crate) fn resolve_ident_in_module(
        .                 &mut self,
        .                 module: ModuleOrUniformRoot<'a>,
        .                 ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> Result<NameBinding<'a>, Determinacy> {
  465,897 (0.0%)          self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize, ignore_binding)
        .                     .map_err(|(determinacy, _)| determinacy)
        .             }
        .         
  921,522 (0.0%)      #[instrument(level = "debug", skip(self))]
        .             fn resolve_ident_in_module_ext(
        .                 &mut self,
        .                 module: ModuleOrUniformRoot<'a>,
        .                 mut ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> Result<NameBinding<'a>, (Determinacy, Weak)> {
        .                 let tmp_parent_scope;
        .                 let mut adjusted_parent_scope = parent_scope;
  131,646 (0.0%)          match module {
        .                     ModuleOrUniformRoot::Module(m) => {
  263,034 (0.0%)                  if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {
    3,738 (0.0%)                      tmp_parent_scope =
    4,806 (0.0%)                          ParentScope { module: self.expn_def_scope(def), ..*parent_scope };
        .                             adjusted_parent_scope = &tmp_parent_scope;
        .                         }
        .                     }
        .                     ModuleOrUniformRoot::ExternPrelude => {
        .                         ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());
        .                     }
        .                     ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {
        .                         // No adjustments
        .                     }
        .                 }
  263,292 (0.0%)          self.resolve_ident_in_module_unadjusted_ext(
        .                     module,
        .                     ident,
        .                     ns,
        .                     adjusted_parent_scope,
        .                     false,
        .                     finalize,
        .                     ignore_binding,
        .                 )
-- line 799 ----------------------------------------
-- line 804 ----------------------------------------
        .                 &mut self,
        .                 module: ModuleOrUniformRoot<'a>,
        .                 ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> Result<NameBinding<'a>, Determinacy> {
  346,344 (0.0%)          self.resolve_ident_in_module_unadjusted_ext(
        .                     module,
        .                     ident,
        .                     ns,
        .                     parent_scope,
        .                     false,
        .                     finalize,
        .                     ignore_binding,
        .                 )
        .                 .map_err(|(determinacy, _)| determinacy)
        .             }
        .         
        .             /// Attempts to resolve `ident` in namespaces `ns` of `module`.
        .             /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.
3,361,125 (0.0%)      #[instrument(level = "debug", skip(self))]
        .             fn resolve_ident_in_module_unadjusted_ext(
        .                 &mut self,
        .                 module: ModuleOrUniformRoot<'a>,
        .                 ident: Ident,
        .                 ns: Namespace,
        .                 parent_scope: &ParentScope<'a>,
        .                 restricted_shadowing: bool,
        .                 finalize: Option<Finalize>,
        .                 // This binding should be ignored during in-module resolution, so that we don't get
        .                 // "self-confirming" import resolutions during import validation and checking.
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> Result<NameBinding<'a>, (Determinacy, Weak)> {
  403,335 (0.0%)          let module = match module {
        .                     ModuleOrUniformRoot::Module(module) => module,
        .                     ModuleOrUniformRoot::CrateRootAndExternPrelude => {
        .                         assert!(!restricted_shadowing);
        .                         let binding = self.early_resolve_ident_in_lexical_scope(
        .                             ident,
        .                             ScopeSet::AbsolutePath(ns),
        .                             parent_scope,
        .                             finalize,
        .                             finalize.is_some(),
        .                             ignore_binding,
        .                         );
        .                         return binding.map_err(|determinacy| (determinacy, Weak::No));
        .                     }
        .                     ModuleOrUniformRoot::ExternPrelude => {
       62 (0.0%)                  assert!(!restricted_shadowing);
       31 (0.0%)                  return if ns != TypeNS {
        .                             Err((Determined, Weak::No))
      108 (0.0%)                  } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {
        .                             Ok(binding)
        .                         } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {
        .                             // Macro-expanded `extern crate` items can add names to extern prelude.
        .                             Err((Undetermined, Weak::No))
        .                         } else {
        .                             Err((Determined, Weak::No))
        .                         };
        .                     }
        .                     ModuleOrUniformRoot::CurrentScope => {
       24 (0.0%)                  assert!(!restricted_shadowing);
       24 (0.0%)                  if ns == TypeNS {
        8 (0.0%)                      if ident.name == kw::Crate || ident.name == kw::DollarCrate {
        .                                 let module = self.resolve_crate_root(ident);
        .                                 return Ok(self.module_self_bindings[&module]);
        .                             } else if ident.name == kw::Super || ident.name == kw::SelfLower {
        .                                 // FIXME: Implement these with renaming requirements so that e.g.
        .                                 // `use super;` doesn't work, but `use super as name;` does.
        .                                 // Fall through here to get an error from `early_resolve_...`.
        .                             }
        .                         }
        .         
       96 (0.0%)                  let binding = self.early_resolve_ident_in_lexical_scope(
        .                             ident,
       24 (0.0%)                      ScopeSet::All(ns),
        .                             parent_scope,
        .                             finalize,
        .                             finalize.is_some(),
        .                             ignore_binding,
        .                         );
        .                         return binding.map_err(|determinacy| (determinacy, Weak::No));
        .                     }
        .                 };
        .         
        .                 let key = BindingKey::new(ident, ns);
        .                 let resolution =
  537,608 (0.0%)              self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.
        .         
        .                 // If the primary binding is unusable, search further and return the shadowed glob
        .                 // binding if it exists. What we really want here is having two separate scopes in
        .                 // a module - one for non-globs and one for globs, but until that's done use this
        .                 // hack to avoid inconsistent resolution ICEs during import validation.
  302,544 (0.0%)          let binding = [resolution.binding, resolution.shadowed_glob]
        .                     .into_iter()
        .                     .find_map(|binding| if binding == ignore_binding { None } else { binding });
        .         
  403,220 (0.0%)          if let Some(Finalize { path_span, report_private, used, root_span, .. }) = finalize {
   73,103 (0.0%)              let Some(binding) = binding else {
        .                         return Err((Determined, Weak::No));
        .                     };
        .         
  214,606 (0.0%)              if !self.is_accessible_from(binding.vis, parent_scope.module) {
       14 (0.0%)                  if report_private {
        .                             self.privacy_errors.push(PrivacyError {
        .                                 ident,
        .                                 binding,
        .                                 dedup_span: path_span,
        .                                 outermost_res: None,
        .                                 parent_scope: *parent_scope,
        .                                 single_nested: path_span != root_span,
        .                             });
        .                         } else {
        .                             return Err((Determined, Weak::No));
        .                         }
        .                     }
        .         
        .                     // Forbid expanded shadowing to avoid time travel.
   99,063 (0.0%)              if let Some(shadowed_glob) = resolution.shadowed_glob
        .                         && restricted_shadowing
        .                         && binding.expansion != LocalExpnId::ROOT
        .                         && binding.res() != shadowed_glob.res()
        .                     {
        .                         self.ambiguity_errors.push(AmbiguityError {
        .                             kind: AmbiguityKind::GlobVsExpanded,
        .                             ident,
        .                             b1: binding,
        .                             b2: shadowed_glob,
        .                             warning: false,
        .                             misc1: AmbiguityErrorMisc::None,
        .                             misc2: AmbiguityErrorMisc::None,
        .                         });
        .                     }
        .         
  131,867 (0.0%)              if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {
   17,693 (0.0%)                  if let NameBindingKind::Import { import, .. } = binding.kind
    6,602 (0.0%)                      && matches!(import.kind, ImportKind::MacroExport)
        .                         {
        .                             self.macro_expanded_macro_export_errors.insert((path_span, binding.span));
        .                         }
        .                     }
        .         
        .                     self.record_use(ident, binding, used);
        .                     return Ok(binding);
        .                 }
        .         
        .                 let check_usable = |this: &mut Self, binding: NameBinding<'a>| {
   69,224 (0.0%)              let usable = this.is_accessible_from(binding.vis, parent_scope.module);
    2,152 (0.0%)              if usable { Ok(binding) } else { Err((Determined, Weak::No)) }
        .                 };
        .         
        .                 // Items and single imports are not shadowable, if we have one, then it's determined.
   61,299 (0.0%)          if let Some(binding) = binding {
      638 (0.0%)              if !binding.is_glob_import() {
        .                         return check_usable(self, binding);
        .                     }
        .                 }
        .         
        .                 // --- From now on we either have a glob resolution or no resolution. ---
        .         
        .                 // Check if one of single imports can still define the name,
        .                 // if it can then our result is not determined and can be invalidated.
      896 (0.0%)          for single_import in &resolution.single_imports {
      896 (0.0%)              let Some(import_vis) = single_import.vis.get() else {
        .                         continue;
        .                     };
    1,712 (0.0%)              if !self.is_accessible_from(import_vis, parent_scope.module) {
        .                         continue;
        .                     }
      439 (0.0%)              if let Some(ignored) = ignore_binding
      405 (0.0%)                  && let NameBindingKind::Import { import, .. } = ignored.kind
      135 (0.0%)                  && import == *single_import
        .                     {
        .                         // Ignore not just the binding itself, but if it has a shadowed_glob,
        .                         // ignore that, too, because this loop is supposed to only process
        .                         // named imports.
        .                         continue;
        .                     }
      608 (0.0%)              let Some(module) = single_import.imported_module.get() else {
        .                         return Err((Undetermined, Weak::No));
        .                     };
      324 (0.0%)              let ImportKind::Single { source: ident, .. } = single_import.kind else {
        .                         unreachable!();
        .                     };
      106 (0.0%)              match self.resolve_ident_in_module(
        .                         module,
        .                         ident,
        .                         ns,
       54 (0.0%)                  &single_import.parent_scope,
       54 (0.0%)                  None,
        .                         ignore_binding,
        .                     ) {
        .                         Err(Determined) => continue,
        .                         Ok(binding)
        8 (0.0%)                      if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>
        .                         {
        .                             continue;
        .                         }
        .                         Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),
        .                     }
        .                 }
        .         
        .                 // So we have a resolution that's from a glob import. This resolution is determined
-- line 1008 ----------------------------------------
-- line 1012 ----------------------------------------
        .                 //
        .                 // Additionally, any macro in any module can plant names in the root module if it creates
        .                 // `macro_export` macros, so the root module effectively has unresolved invocations if any
        .                 // module has unresolved invocations.
        .                 // However, it causes resolution/expansion to stuck too often (#53144), so, to make
        .                 // progress, we have to ignore those potential unresolved invocations from other modules
        .                 // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted
        .                 // shadowing is enabled, see `macro_expanded_macro_export_errors`).
   43,715 (0.0%)          if let Some(binding) = binding {
       48 (0.0%)              if binding.determined() || ns == MacroNS || restricted_shadowing {
        .                         return check_usable(self, binding);
        .                     } else {
        .                         return Err((Undetermined, Weak::No));
        .                     }
        .                 }
        .         
        .                 // --- From now on we have no resolution. ---
        .         
-- line 1029 ----------------------------------------
-- line 1030 ----------------------------------------
        .                 // Now we are in situation when new item/import can appear only from a glob or a macro
        .                 // expansion. With restricted shadowing names from globs and macro expansions cannot
        .                 // shadow names from outer scopes, so we can freely fallback from module search to search
        .                 // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer
        .                 // scopes we return `Undetermined` with `Weak::Yes`.
        .         
        .                 // Check if one of unexpanded macros can still define the name,
        .                 // if it can then our "no resolution" result is not determined and can be invalidated.
   87,398 (0.0%)          if !module.unexpanded_invocations.borrow().is_empty() {
    2,600 (0.0%)              return Err((Undetermined, Weak::Yes));
        .                 }
        .         
        .                 // Check if one of glob imports can still define the name,
        .                 // if it can then our "no resolution" result is not determined and can be invalidated.
   41,099 (0.0%)          for glob_import in module.globs.borrow().iter() {
    4,036 (0.0%)              let Some(import_vis) = glob_import.vis.get() else {
        .                         continue;
        .                     };
    8,074 (0.0%)              if !self.is_accessible_from(import_vis, parent_scope.module) {
        .                         continue;
        .                     }
    8,064 (0.0%)              let module = match glob_import.imported_module.get() {
        .                         Some(ModuleOrUniformRoot::Module(module)) => module,
        .                         Some(_) => continue,
        .                         None => return Err((Undetermined, Weak::Yes)),
        .                     };
        .                     let tmp_parent_scope;
        .                     let (mut adjusted_parent_scope, mut ident) =
        .                         (parent_scope, ident.normalize_to_macros_2_0());
        .                     match ident.span.glob_adjust(module.expansion, glob_import.span) {
-- line 1059 ----------------------------------------
-- line 1081 ----------------------------------------
        .                         {
        .                             continue;
        .                         }
        .                         Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),
        .                     }
        .                 }
        .         
        .                 // No resolution and no one else can define the name - determinate error.
  117,249 (0.0%)          Err((Determined, Weak::No))
        .             }
        .         
        .             /// Validate a local resolution (from ribs).
        .             #[instrument(level = "debug", skip(self, all_ribs))]
        .             fn validate_res_from_ribs(
        .                 &mut self,
        .                 rib_index: usize,
        .                 rib_ident: Ident,
-- line 1097 ----------------------------------------
-- line 1099 ----------------------------------------
        .                 finalize: Option<Span>,
        .                 original_rib_ident_def: Ident,
        .                 all_ribs: &[Rib<'a>],
        .             ) -> Res {
        .                 debug!("validate_res_from_ribs({:?})", res);
        .                 let ribs = &all_ribs[rib_index + 1..];
        .         
        .                 // An invalid forward use of a generic parameter from a previous default.
   23,434 (0.0%)          if let RibKind::ForwardGenericParamBan = all_ribs[rib_index].kind {
        .                     if let Some(span) = finalize {
        .                         let res_error = if rib_ident.name == kw::SelfUpper {
        .                             ResolutionError::SelfInGenericParamDefault
        .                         } else {
        .                             ResolutionError::ForwardDeclaredGenericParam
        .                         };
        .                         self.report_error(span, res_error);
        .                     }
        .                     assert_eq!(res, Res::Err);
        .                     return Res::Err;
        .                 }
        .         
  136,073 (0.0%)          match res {
        .                     Res::Local(_) => {
        .                         use ResolutionError::*;
   20,802 (0.0%)                  let mut res_err = None;
        .         
        .                         for rib in ribs {
   55,896 (0.0%)                      match rib.kind {
        .                                 RibKind::Normal
        .                                 | RibKind::FnOrCoroutine
        .                                 | RibKind::Module(..)
        .                                 | RibKind::MacroDefinition(..)
        .                                 | RibKind::ForwardGenericParamBan => {
        .                                     // Nothing to do. Continue.
        .                                 }
        .                                 RibKind::Item(..) | RibKind::AssocItem => {
        .                                     // This was an attempt to access an upvar inside a
        .                                     // named function item. This is not allowed, so we
        .                                     // report an error.
    5,705 (0.0%)                              if let Some(span) = finalize {
        .                                         // We don't immediately trigger a resolve error, because
        .                                         // we want certain other resolution errors (namely those
        .                                         // emitted for `ConstantItemRibKind` below) to take
        .                                         // precedence.
        .                                         res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));
        .                                     }
        .                                 }
        .                                 RibKind::ConstantItem(_, item) => {
        .                                     // Still doesn't deal with upvars
        2 (0.0%)                              if let Some(span) = finalize {
        .                                         let (span, resolution_error) = match item {
        .                                             None if rib_ident.as_str() == "self" => (span, LowercaseSelf),
        .                                             None => (
        .                                                 rib_ident.span,
        .                                                 AttemptToUseNonConstantValueInConstant(
        .                                                     original_rib_ident_def,
        .                                                     "const",
        .                                                     "let",
-- line 1156 ----------------------------------------
-- line 1184 ----------------------------------------
        .                                 RibKind::InlineAsmSym => {
        .                                     if let Some(span) = finalize {
        .                                         self.report_error(span, InvalidAsmSym);
        .                                     }
        .                                     return Res::Err;
        .                                 }
        .                             }
        .                         }
   11,248 (0.0%)                  if let Some((span, res_err)) = res_err {
        .                             self.report_error(span, res_err);
        .                             return Res::Err;
        .                         }
        4 (0.0%)              }
        .                     Res::Def(DefKind::TyParam, _) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } => {
        .                         for rib in ribs {
   45,112 (0.0%)                      let (has_generic_params, def_kind) = match rib.kind {
        .                                 RibKind::Normal
        .                                 | RibKind::FnOrCoroutine
        .                                 | RibKind::Module(..)
        .                                 | RibKind::MacroDefinition(..)
        .                                 | RibKind::InlineAsmSym
        .                                 | RibKind::AssocItem
        .                                 | RibKind::ForwardGenericParamBan => {
        .                                     // Nothing to do. Continue.
-- line 1207 ----------------------------------------
-- line 1215 ----------------------------------------
        .                                         // we instead remember this and then enforce the self type to be
        .                                         // concrete later on.
        .                                         if let Res::SelfTyAlias {
        .                                             alias_to: def,
        .                                             forbid_generic: _,
        .                                             is_trait_impl,
        .                                         } = res
        .                                         {
    9,004 (0.0%)                                      res = Res::SelfTyAlias {
        .                                                 alias_to: def,
        .                                                 forbid_generic: true,
        .                                                 is_trait_impl,
        .                                             }
        .                                         } else {
        .                                             if let Some(span) = finalize {
        .                                                 let error = match cause {
        .                                                     NoConstantGenericsReason::IsEnumDiscriminant => {
-- line 1231 ----------------------------------------
-- line 1350 ----------------------------------------
        .                                     ),
        .                                 );
        .                             }
        .                             return Res::Err;
        .                         }
        .                     }
        .                     _ => {}
        .                 }
   46,860 (0.0%)          res
        .             }
        .         
        .             #[instrument(level = "debug", skip(self))]
        .             pub(crate) fn maybe_resolve_path(
        .                 &mut self,
        .                 path: &[Segment],
        .                 opt_ns: Option<Namespace>, // `None` indicates a module path in import
        .                 parent_scope: &ParentScope<'a>,
        .             ) -> PathResult<'a> {
   94,239 (0.0%)          self.resolve_path_with_ribs(path, opt_ns, parent_scope, None, None, None)
        .             }
        .         
        .             #[instrument(level = "debug", skip(self))]
        .             pub(crate) fn resolve_path(
        .                 &mut self,
        .                 path: &[Segment],
        .                 opt_ns: Option<Namespace>, // `None` indicates a module path in import
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> PathResult<'a> {
   90,625 (0.0%)          self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, ignore_binding)
        .             }
        .         
  352,544 (0.0%)      pub(crate) fn resolve_path_with_ribs(
        .                 &mut self,
        .                 path: &[Segment],
        .                 opt_ns: Option<Namespace>, // `None` indicates a module path in import
        .                 parent_scope: &ParentScope<'a>,
        .                 finalize: Option<Finalize>,
        .                 ribs: Option<&PerNS<Vec<Rib<'a>>>>,
        .                 ignore_binding: Option<NameBinding<'a>>,
        .             ) -> PathResult<'a> {
        .                 let mut module = None;
        .                 let mut allow_super = true;
        .                 let mut second_binding = None;
        .         
        .                 // We'll provide more context to the privacy errors later, up to `len`.
        .                 let privacy_errors_len = self.privacy_errors.len();
        .         
  301,780 (0.0%)          for (segment_idx, &Segment { ident, id, .. }) in path.iter().enumerate() {
        .                     debug!("resolve_path ident {} {:?} {:?}", segment_idx, ident, id);
        .                     let record_segment_res = |this: &mut Self, res| {
        .                         if finalize.is_some() {
   63,123 (0.0%)                      if let Some(id) = id {
        .                                 if !this.partial_res_map.contains_key(&id) {
   38,369 (0.0%)                              assert!(id != ast::DUMMY_NODE_ID, "Trying to resolve dummy id");
   76,738 (0.0%)                              this.record_partial_res(id, PartialRes::new(res));
        .                                 }
        .                             }
        .                         }
        .                     };
        .         
  150,890 (0.0%)              let is_last = segment_idx + 1 == path.len();
        .                     let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };
  150,890 (0.0%)              let name = ident.name;
        .         
  568,920 (0.0%)              allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);
        .         
        .                     if ns == TypeNS {
   98,850 (0.0%)                  if allow_super && name == kw::Super {
    1,236 (0.0%)                      let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();
      618 (0.0%)                      let self_module = match segment_idx {
    1,236 (0.0%)                          0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),
        .                                 _ => match module {
        .                                     Some(ModuleOrUniformRoot::Module(module)) => Some(module),
        .                                     _ => None,
        .                                 },
        .                             };
        .                             if let Some(self_module) = self_module {
      927 (0.0%)                          if let Some(parent) = self_module.parent {
        .                                     module = Some(ModuleOrUniformRoot::Module(
    3,090 (0.0%)                                  self.resolve_self(&mut ctxt, parent),
        .                                     ));
        .                                     continue;
        .                                 }
        .                             }
        .                             return PathResult::failed(ident, false, finalize.is_some(), module, || {
        .                                 ("there are too many leading `super` keywords".to_string(), None)
        .                             });
        .                         }
  114,336 (0.0%)                  if segment_idx == 0 {
  164,940 (0.0%)                      if name == kw::SelfLower {
      270 (0.0%)                          let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();
        .                                 module = Some(ModuleOrUniformRoot::Module(
      360 (0.0%)                              self.resolve_self(&mut ctxt, parent_scope.module),
        .                                 ));
        .                                 continue;
        .                             }
       66 (0.0%)                      if name == kw::PathRoot && ident.span.at_least_rust_2018() {
        .                                 module = Some(ModuleOrUniformRoot::ExternPrelude);
        .                                 continue;
        .                             }
        .                             if name == kw::PathRoot
        .                                 && ident.span.is_rust_2015()
        .                                 && self.tcx.sess.at_least_rust_2018()
        .                             {
        .                                 // `::a::b` from 2015 macro on 2018 global edition
        .                                 module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);
        .                                 continue;
        .                             }
        .                             if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {
        .                                 // `::a::b`, `crate::a::b` or `$crate::a::b`
  152,915 (0.0%)                          module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));
        .                                 continue;
        .                             }
        .                         }
        .                     }
        .         
        .                     // Report special messages for path segment keywords in wrong positions.
  319,008 (0.0%)              if ident.is_path_segment_keyword() && segment_idx != 0 {
        .                         return PathResult::failed(ident, false, finalize.is_some(), module, || {
        .                             let name_str = if name == kw::PathRoot {
        .                                 "crate root".to_string()
        .                             } else {
        .                                 format!("`{name}`")
        .                             };
        .                             let label = if segment_idx == 1 && path[0].ident.name == kw::PathRoot {
        .                                 format!("global paths cannot start with {name_str}")
        .                             } else {
        .                                 format!("{name_str} in paths can only be used in start position")
        .                             };
        .                             (label, None)
        .                         });
        .                     }
        .         
  159,504 (0.0%)              let binding = if let Some(module) = module {
        .                         self.resolve_ident_in_module(
        .                             module,
  125,516 (0.0%)                      ident,
        .                             ns,
        .                             parent_scope,
        .                             finalize,
        .                             ignore_binding,
        .                         )
   43,578 (0.0%)              } else if let Some(ribs) = ribs
        .                         && let Some(TypeNS | ValueNS) = opt_ns
        .                     {
  282,804 (0.0%)                  match self.resolve_ident_in_lexical_scope(
  101,960 (0.0%)                      ident,
        .                             ns,
        .                             parent_scope,
        .                             finalize,
   20,392 (0.0%)                      &ribs[ns],
        .                             ignore_binding,
        .                         ) {
        .                             // we found a locally-imported or available item/module
   43,468 (0.0%)                      Some(LexicalScopeBinding::Item(binding)) => Ok(binding),
        .                             // we found a local variable or type param
   38,100 (0.0%)                      Some(LexicalScopeBinding::Res(res)) => {
        .                                 record_segment_res(self, res);
   66,675 (0.0%)                          return PathResult::NonModule(PartialRes::with_unresolved_segments(
        .                                     res,
        .                                     path.len() - 1,
        .                                 ));
        .                             }
        .                             _ => Err(Determinacy::determined(finalize.is_some())),
        .                         }
        .                     } else {
   15,367 (0.0%)                  self.early_resolve_ident_in_lexical_scope(
    6,985 (0.0%)                      ident,
    2,794 (0.0%)                      ScopeSet::All(ns),
        .                             parent_scope,
        .                             finalize,
        .                             finalize.is_some(),
        .                             ignore_binding,
        .                         )
        .                     };
        .         
   71,235 (0.0%)              match binding {
   64,806 (0.0%)                  Ok(binding) => {
  259,620 (0.0%)                      if segment_idx == 1 {
        .                                 second_binding = Some(binding);
        .                             }
        .                             let res = binding.res();
        .         
        .                             // Mark every privacy error in this path with the res to the last element. This allows us
        .                             // to detect the item the user cares about and either find an alternative import, or tell
        .                             // the user it is not accessible.
   43,270 (0.0%)                      for error in &mut self.privacy_errors[privacy_errors_len..] {
        .                                 error.outermost_res = Some((res, ident));
        .                             }
        .         
   43,270 (0.0%)                      let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);
        .                             if let Some(next_module) = binding.module() {
        .                                 module = Some(ModuleOrUniformRoot::Module(next_module));
        .                                 record_segment_res(self, res);
  242,280 (0.0%)                      } else if res == Res::ToolMod && !is_last && opt_ns.is_some() {
        .                                 if binding.is_import() {
        .                                     self.dcx().emit_err(errors::ToolModuleImported {
        .                                         span: ident.span,
        .                                         import: binding.span,
        .                                     });
        .                                 }
        .                                 let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);
        .                                 return PathResult::NonModule(PartialRes::new(res));
  134,600 (0.0%)                      } else if res == Res::Err {
        .                                 return PathResult::NonModule(PartialRes::new(Res::Err));
        .                             } else if opt_ns.is_some() && (is_last || maybe_assoc) {
   63,123 (0.0%)                          self.lint_if_path_starts_with_module(finalize, path, second_binding);
        .                                 record_segment_res(self, res);
  188,398 (0.0%)                          return PathResult::NonModule(PartialRes::with_unresolved_segments(
        .                                     res,
        .                                     path.len() - segment_idx - 1,
        .                                 ));
        .                             } else {
        .                                 return PathResult::failed(
       18 (0.0%)                              ident,
        .                                     is_last,
        .                                     finalize.is_some(),
        .                                     module,
        .                                     || {
        .                                         let label = format!(
        .                                             "`{ident}` is {} {}, not a module",
        .                                             res.article(),
        .                                             res.descr()
        .                                         );
        .                                         (label, None)
        .                                     },
        .                                 );
        .                             }
        .                         }
       26 (0.0%)                  Err(Undetermined) => return PathResult::Indeterminate,
        .                         Err(Determined) => {
    1,080 (0.0%)                      if let Some(ModuleOrUniformRoot::Module(module)) = module {
       80 (0.0%)                          if opt_ns.is_some() && !module.is_normal() {
      217 (0.0%)                              return PathResult::NonModule(PartialRes::with_unresolved_segments(
        .                                         module.res().unwrap(),
       31 (0.0%)                                  path.len() - segment_idx,
        .                                     ));
        .                                 }
        .                             }
        .         
      987 (0.0%)                      return PathResult::failed(ident, is_last, finalize.is_some(), module, || {
        .                                 self.report_path_resolution_error(
        .                                     path,
        .                                     opt_ns,
        .                                     parent_scope,
        .                                     ribs,
        .                                     ignore_binding,
        .                                     module,
        .                                     segment_idx,
        .                                     ident,
        .                                 )
        .                             });
        .                         }
        .                     }
        .                 }
        .         
   15,102 (0.0%)          self.lint_if_path_starts_with_module(finalize, path, second_binding);
        .         
   29,000 (0.0%)          PathResult::Module(match module {
        .                     Some(module) => module,
        .                     None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,
        .                     _ => bug!("resolve_path: non-empty path `{:?}` has no module", path),
        .                 })
  352,544 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_serialize/src/opaque.rs
--------------------------------------------------------------------------------
Ir_______________ 

 2,272,212 (0.0%)  <unknown (line 0)>

-- line 264 ----------------------------------------
         .             pub fn new(data: &'a [u8], position: usize) -> MemDecoder<'a> {
         .                 let Range { start, end } = data.as_ptr_range();
         .                 MemDecoder { start, current: data[position..].as_ptr(), end, _marker: PhantomData }
         .             }
         .         
         .             #[inline]
         .             pub fn data(&self) -> &'a [u8] {
         .                 // SAFETY: This recovers the original slice, only using members we never modify.
    31,749 (0.0%)          unsafe { std::slice::from_raw_parts(self.start, self.len()) }
         .             }
         .         
         .             #[inline]
         .             pub fn len(&self) -> usize {
         .                 // SAFETY: This recovers the length of the original slice, only using members we never modify.
   177,444 (0.0%)          unsafe { self.end.sub_ptr(self.start) }
         .             }
         .         
         .             #[inline]
         .             pub fn remaining(&self) -> usize {
         .                 // SAFETY: This type guarantees current <= end.
     1,814 (0.0%)          unsafe { self.end.sub_ptr(self.current) }
         .             }
         .         
         .             #[cold]
         .             #[inline(never)]
         .             fn decoder_exhausted() -> ! {
         .                 panic!("MemDecoder exhausted")
         .             }
         .         
         .             #[inline]
         .             pub fn read_array<const N: usize>(&mut self) -> [u8; N] {
     1,463 (0.0%)          self.read_raw_bytes(N).try_into().unwrap()
         .             }
         .         
         .             /// While we could manually expose manipulation of the decoder position,
         .             /// all current users of that method would need to reset the position later,
         .             /// incurring the bounds check of set_position twice.
         .             #[inline]
         .             pub fn with_position<F, T>(&mut self, pos: usize, func: F) -> T
         .             where
-- line 303 ----------------------------------------
-- line 304 ----------------------------------------
         .                 F: Fn(&mut MemDecoder<'a>) -> T,
         .             {
         .                 struct SetOnDrop<'a, 'guarded> {
         .                     decoder: &'guarded mut MemDecoder<'a>,
         .                     current: *const u8,
         .                 }
         .                 impl Drop for SetOnDrop<'_, '_> {
         .                     fn drop(&mut self) {
   167,074 (0.0%)                  self.decoder.current = self.current;
         .                     }
         .                 }
         .         
   334,148 (0.0%)          if pos >= self.len() {
         .                     Self::decoder_exhausted();
         .                 }
         .                 let previous = self.current;
         .                 // SAFETY: We just checked if this add is in-bounds above.
         .                 unsafe {
   167,074 (0.0%)              self.current = self.start.add(pos);
         .                 }
         .                 let guard = SetOnDrop { current: previous, decoder: self };
         .                 func(guard.decoder)
         .             }
         .         }
         .         
         .         macro_rules! read_leb128 {
         .             ($this_fn:ident, $int_ty:ty, $read_leb_fn:ident) => {
-- line 330 ----------------------------------------
-- line 343 ----------------------------------------
         .         
         .             #[inline]
         .             fn read_u16(&mut self) -> u16 {
         .                 u16::from_le_bytes(self.read_array())
         .             }
         .         
         .             #[inline]
         .             fn read_u8(&mut self) -> u8 {
24,497,026 (0.3%)          if self.current == self.end {
         .                     Self::decoder_exhausted();
         .                 }
         .                 // SAFETY: This type guarantees current <= end, and we just checked current == end.
         .                 unsafe {
10,958,278 (0.1%)              let byte = *self.current;
10,739,214 (0.1%)              self.current = self.current.add(1);
         .                     byte
         .                 }
         .             }
         .         
         .             read_leb128!(read_isize, isize, read_isize_leb128);
         .             read_leb128!(read_i128, i128, read_i128_leb128);
         .             read_leb128!(read_i64, i64, read_i64_leb128);
         .             read_leb128!(read_i32, i32, read_i32_leb128);
-- line 365 ----------------------------------------
-- line 366 ----------------------------------------
         .         
         .             #[inline]
         .             fn read_i16(&mut self) -> i16 {
         .                 i16::from_le_bytes(self.read_array())
         .             }
         .         
         .             #[inline]
         .             fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {
   787,238 (0.0%)          if bytes > self.remaining() {
         .                     Self::decoder_exhausted();
         .                 }
         .                 // SAFETY: We just checked if this range is in-bounds above.
         .                 unsafe {
         .                     let slice = std::slice::from_raw_parts(self.current, bytes);
   513,208 (0.0%)              self.current = self.current.add(bytes);
         .                     slice
         .                 }
         .             }
         .         
         .             #[inline]
         .             fn peek_byte(&self) -> u8 {
 1,655,082 (0.0%)          if self.current == self.end {
         .                     Self::decoder_exhausted();
         .                 }
         .                 // SAFETY: This type guarantees current is inbounds or one-past-the-end, which is end.
         .                 // Since we just checked current == end, the current pointer must be inbounds.
   623,241 (0.0%)          unsafe { *self.current }
         .             }
         .         
         .             #[inline]
         .             fn position(&self) -> usize {
         .                 // SAFETY: This type guarantees start <= current
   408,600 (0.0%)          unsafe { self.current.sub_ptr(self.start) }
         .             }
         .         }
         .         
         .         // Specializations for contiguous byte sequences follow. The default implementations for slices
         .         // encode and decode each element individually. This isn't necessary for `u8` slices when using
         .         // opaque encoders and decoders, because each `u8` is unchanged by encoding and decoding.
         .         // Therefore, we can use more efficient implementations that process the entire sequence at once.
         .         
-- line 406 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_span/src/caching_source_map_view.rs
--------------------------------------------------------------------------------
Ir______________ 

3,111,619 (0.0%)  <unknown (line 0)>

-- line 21 ----------------------------------------
        .             // after a cache miss will produce the last line number, as desired.
        .             line: Range<BytePos>,
        .             file: Lrc<SourceFile>,
        .             file_index: usize,
        .         }
        .         
        .         impl CacheEntry {
        .             #[inline]
1,025,290 (0.0%)      fn update(
        .                 &mut self,
        .                 new_file_and_idx: Option<(Lrc<SourceFile>, usize)>,
        .                 pos: BytePos,
        .                 time_stamp: usize,
        .             ) {
  219,705 (0.0%)          if let Some((file, file_idx)) = new_file_and_idx {
   45,376 (0.0%)              self.file = file;
   90,752 (0.0%)              self.file_index = file_idx;
        .                 }
        .         
        .                 let pos = self.file.relative_position(pos);
        .                 let line_index = self.file.lookup_line(pos).unwrap();
  146,470 (0.0%)          let line_bounds = self.file.line_bounds(line_index);
   73,235 (0.0%)          self.line_number = line_index + 1;
  146,470 (0.0%)          self.line = line_bounds;
        .                 self.touch(time_stamp);
  742,692 (0.0%)      }
        .         
        .             #[inline]
        .             fn touch(&mut self, time_stamp: usize) {
  526,215 (0.0%)          self.time_stamp = time_stamp;
        .             }
        .         }
        .         
        .         #[derive(Clone)]
        .         pub struct CachingSourceMapView<'sm> {
        .             source_map: &'sm SourceMap,
        .             line_cache: [CacheEntry; 3],
        .             time_stamp: usize,
        .         }
        .         
        .         impl<'sm> CachingSourceMapView<'sm> {
   96,936 (0.0%)      pub fn new(source_map: &'sm SourceMap) -> CachingSourceMapView<'sm> {
        .                 let files = source_map.files();
   32,312 (0.0%)          let first_file = files[0].clone();
        .                 let entry = CacheEntry {
        .                     time_stamp: 0,
        .                     line_number: 0,
        .                     line: BytePos(0)..BytePos(0),
        .                     file: first_file,
        .                     file_index: 0,
        .                 };
        .         
  210,028 (0.0%)          CachingSourceMapView {
        .                     source_map,
        .                     line_cache: [entry.clone(), entry.clone(), entry],
        .                     time_stamp: 0,
        .                 }
  113,092 (0.0%)      }
        .         
        .             pub fn byte_pos_to_line_and_col(
        .                 &mut self,
        .                 pos: BytePos,
        .             ) -> Option<(Lrc<SourceFile>, usize, RelativeBytePos)> {
        .                 self.time_stamp += 1;
        .         
        .                 // Check if the position is in one of the cached lines
-- line 86 ----------------------------------------
-- line 105 ----------------------------------------
        .         
        .                 let cache_entry = &mut self.line_cache[oldest];
        .                 cache_entry.update(new_file_and_idx, pos, self.time_stamp);
        .         
        .                 let col = RelativeBytePos(pos.to_u32() - cache_entry.line.start.to_u32());
        .                 Some((cache_entry.file.clone(), cache_entry.line_number, col))
        .             }
        .         
2,496,915 (0.0%)      pub fn span_data_to_lines_and_cols(
        .                 &mut self,
        .                 span_data: &SpanData,
        .             ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {
  277,435 (0.0%)          self.time_stamp += 1;
        .         
        .                 // Check if lo and hi are in the cached lines.
  277,435 (0.0%)          let lo_cache_idx: isize = self.cache_entry_index(span_data.lo);
  277,435 (0.0%)          let hi_cache_idx = self.cache_entry_index(span_data.hi);
        .         
  835,902 (0.0%)          if lo_cache_idx != -1 && hi_cache_idx != -1 {
        .                     // Cache hit for span lo and hi. Check if they belong to the same file.
        .                     let result = {
  427,076 (0.0%)                  let lo = &self.line_cache[lo_cache_idx as usize];
  213,538 (0.0%)                  let hi = &self.line_cache[hi_cache_idx as usize];
        .         
  640,614 (0.0%)                  if lo.file_index != hi.file_index {
        .                             return None;
        .                         }
        .         
        .                         (
  213,538 (0.0%)                      lo.file.clone(),
  213,538 (0.0%)                      lo.line_number,
        .                             span_data.lo - lo.line.start,
  213,538 (0.0%)                      hi.line_number,
        .                             span_data.hi - hi.line.start,
        .                         )
        .                     };
        .         
  213,538 (0.0%)              self.line_cache[lo_cache_idx as usize].touch(self.time_stamp);
        .                     self.line_cache[hi_cache_idx as usize].touch(self.time_stamp);
        .         
1,281,228 (0.0%)              return Some(result);
        .                 }
        .         
        .                 // No cache hit or cache hit for only one of span lo and hi.
   60,663 (0.0%)          let oldest = if lo_cache_idx != -1 || hi_cache_idx != -1 {
        .                     let avoid_idx = if lo_cache_idx != -1 { lo_cache_idx } else { hi_cache_idx };
        .                     self.oldest_cache_entry_index_avoid(avoid_idx as usize)
        .                 } else {
        .                     self.oldest_cache_entry_index()
        .                 };
        .         
        .                 // If the entry doesn't point to the correct file, get the new file and index.
        .                 // Return early if the file containing beginning of span doesn't contain end of span.
   63,897 (0.0%)          let new_file_and_idx = if !file_contains(&self.line_cache[oldest].file, span_data.lo) {
  180,190 (0.0%)              let new_file_and_idx = self.file_for_position(span_data.lo)?;
        .                     if !file_contains(&new_file_and_idx.0, span_data.hi) {
        .                         return None;
        .                     }
        .         
  108,114 (0.0%)              Some(new_file_and_idx)
        .                 } else {
        .                     let file = &self.line_cache[oldest].file;
        .                     if !file_contains(file, span_data.hi) {
        .                         return None;
        .                     }
        .         
   83,577 (0.0%)              None
        .                 };
        .         
        .                 // Update the cache entries.
  191,691 (0.0%)          let (lo_idx, hi_idx) = match (lo_cache_idx, hi_cache_idx) {
        .                     // Oldest cache entry is for span_data.lo line.
        .                     (-1, -1) => {
        .                         let lo = &mut self.line_cache[oldest];
        .                         lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
        .         
  178,089 (0.0%)                  if !lo.line.contains(&span_data.hi) {
   18,676 (0.0%)                      let new_file_and_idx = Some((lo.file.clone(), lo.file_index));
        .                             let next_oldest = self.oldest_cache_entry_index_avoid(oldest);
   18,676 (0.0%)                      let hi = &mut self.line_cache[next_oldest];
   46,690 (0.0%)                      hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
        .                             (oldest, next_oldest)
        .                         } else {
        .                             (oldest, oldest)
        .                         }
        .                     }
        .                     // Oldest cache entry is for span_data.lo line.
        .                     (-1, _) => {
        .                         let lo = &mut self.line_cache[oldest];
        .                         lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
        .                         let hi = &mut self.line_cache[hi_cache_idx as usize];
    1,300 (0.0%)                  hi.touch(self.time_stamp);
        .                         (oldest, hi_cache_idx as usize)
        .                     }
        .                     // Oldest cache entry is for span_data.hi line.
        .                     (_, -1) => {
        .                         let hi = &mut self.line_cache[oldest];
   16,170 (0.0%)                  hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
        .                         let lo = &mut self.line_cache[lo_cache_idx as usize];
    3,234 (0.0%)                  lo.touch(self.time_stamp);
        .                         (lo_cache_idx as usize, oldest)
        .                     }
        .                     _ => {
        .                         panic!(
        .                             "the case of neither value being equal to -1 was handled above and the function returns."
        .                         );
        .                     }
        .                 };
        .         
  127,794 (0.0%)          let lo = &self.line_cache[lo_idx];
        .                 let hi = &self.line_cache[hi_idx];
        .         
        .                 // Span lo and hi may equal line end when last line doesn't
        .                 // end in newline, hence the inclusive upper bounds below.
        .                 assert!(span_data.lo >= lo.line.start);
        .                 assert!(span_data.lo <= lo.line.end);
        .                 assert!(span_data.hi >= hi.line.start);
        .                 assert!(span_data.hi <= hi.line.end);
   63,897 (0.0%)          assert!(lo.file.contains(span_data.lo));
        .                 assert!(lo.file.contains(span_data.hi));
  191,691 (0.0%)          assert_eq!(lo.file_index, hi.file_index);
        .         
  319,485 (0.0%)          Some((
        .                     lo.file.clone(),
   63,897 (0.0%)              lo.line_number,
        .                     span_data.lo - lo.line.start,
   63,897 (0.0%)              hi.line_number,
        .                     span_data.hi - hi.line.start,
        .                 ))
2,496,915 (0.0%)      }
        .         
        .             fn cache_entry_index(&self, pos: BytePos) -> isize {
        .                 for (idx, cache_entry) in self.line_cache.iter().enumerate() {
3,334,410 (0.0%)              if cache_entry.line.contains(&pos) {
        .                         return idx as isize;
        .                     }
        .                 }
        .         
        .                 -1
        .             }
        .         
        .             fn oldest_cache_entry_index(&self) -> usize {
        .                 let mut oldest = 0;
        .         
        .                 for idx in 1..self.line_cache.len() {
  534,267 (0.0%)              if self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp {
        .                         oldest = idx;
        .                     }
        .                 }
        .         
        .                 oldest
        .             }
        .         
        .             fn oldest_cache_entry_index_avoid(&self, avoid_idx: usize) -> usize {
        .                 let mut oldest = if avoid_idx != 0 { 0 } else { 1 };
        .         
        .                 for idx in 0..self.line_cache.len() {
   59,289 (0.0%)              if idx != avoid_idx
   78,430 (0.0%)                  && self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp
        .                     {
        .                         oldest = idx;
        .                     }
        .                 }
        .         
        .                 oldest
        .             }
        .         
  324,342 (0.0%)      fn file_for_position(&self, pos: BytePos) -> Option<(Lrc<SourceFile>, usize)> {
  180,190 (0.0%)          if !self.source_map.files().is_empty() {
        .                     let file_idx = self.source_map.lookup_source_file_idx(pos);
   72,076 (0.0%)              let file = &self.source_map.files()[file_idx];
        .         
        .                     if file_contains(file, pos) {
        .                         return Some((file.clone(), file_idx));
        .                     }
        .                 }
        .         
        .                 None
  324,342 (0.0%)      }
        .         }
        .         
        .         #[inline]
        .         fn file_contains(file: &SourceFile, pos: BytePos) -> bool {
        .             // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position
        .             // one past the end of a file to belong to it. Normally, that's what we want. But for the
        .             // purposes of converting a byte position to a line and column number, we can't come up with a
        .             // line and column number if the file is empty, because an empty file doesn't contain any
        .             // lines. So for our purposes, we don't consider empty files to contain any byte position.
  399,093 (0.0%)      file.contains(pos) && !file.is_empty()
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_span/src/lib.rs
--------------------------------------------------------------------------------
Ir______________ 

3,467,535 (0.0%)  <unknown (line 0)>

-- line 110 ----------------------------------------
        .             /// initialization.
        .             ///
        .             /// This field should only be used in places where the `Session` is truly
        .             /// not available, such as `<Span as Debug>::fmt`.
        .             source_map: Lock<Option<Lrc<SourceMap>>>,
        .         }
        .         
        .         impl SessionGlobals {
       10 (0.0%)      pub fn new(edition: Edition) -> SessionGlobals {
       69 (0.0%)          SessionGlobals {
        .                     symbol_interner: symbol::Interner::fresh(),
        .                     span_interner: Lock::new(span_encoding::SpanInterner::default()),
        .                     metavar_spans: Default::default(),
        .                     hygiene_data: Lock::new(hygiene::HygieneData::new(edition)),
        .                     source_map: Lock::new(None),
        .                 }
        9 (0.0%)      }
        .         }
        .         
        .         pub fn create_session_globals_then<R>(edition: Edition, f: impl FnOnce() -> R) -> R {
        .             assert!(
        1 (0.0%)          !SESSION_GLOBALS.is_set(),
        .                 "SESSION_GLOBALS should never be overwritten! \
        .                  Use another thread if you need another SessionGlobals"
        .             );
        4 (0.0%)      let session_globals = SessionGlobals::new(edition);
        2 (0.0%)      SESSION_GLOBALS.set(&session_globals, f)
        1 (0.0%)  }
        .         
        .         pub fn set_session_globals_then<R>(session_globals: &SessionGlobals, f: impl FnOnce() -> R) -> R {
        .             assert!(
        .                 !SESSION_GLOBALS.is_set(),
        .                 "SESSION_GLOBALS should never be overwritten! \
        .                  Use another thread if you need another SessionGlobals"
        .             );
        .             SESSION_GLOBALS.set(session_globals, f)
-- line 145 ----------------------------------------
-- line 156 ----------------------------------------
        .                 SESSION_GLOBALS.with(f)
        .             }
        .         }
        .         
        .         pub fn with_session_globals<R, F>(f: F) -> R
        .         where
        .             F: FnOnce(&SessionGlobals) -> R,
        .         {
1,268,353 (0.0%)      SESSION_GLOBALS.with(f)
        .         }
        .         
        .         pub fn create_default_session_globals_then<R>(f: impl FnOnce() -> R) -> R {
        .             create_session_globals_then(edition::DEFAULT_EDITION, f)
        .         }
        .         
        .         // If this ever becomes non thread-local, `decode_syntax_context`
        .         // and `decode_expn_id` will need to be updated to handle concurrent
-- line 172 ----------------------------------------
-- line 175 ----------------------------------------
        .         
        .         #[inline]
        .         pub fn with_metavar_spans<R>(f: impl FnOnce(&mut FxHashMap<Span, Span>) -> R) -> R {
        .             with_session_globals(|session_globals| f(&mut session_globals.metavar_spans.lock()))
        .         }
        .         
        .         // FIXME: We should use this enum or something like it to get rid of the
        .         // use of magic `/rust/1.x/...` paths across the board.
  197,080 (0.0%)  #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Decodable)]
        .         pub enum RealFileName {
       85 (0.0%)      LocalPath(PathBuf),
        .             /// For remapped paths (namely paths into libstd that have been mapped
        .             /// to the appropriate spot on the local host's file system, and local file
        .             /// system paths that have been remapped with `FilePathMapping`),
        .             Remapped {
        .                 /// `local_path` is the (host-dependent) local path to the file. This is
        .                 /// None if the file was imported from another crate
        .                 local_path: Option<PathBuf>,
        .                 /// `virtual_name` is the stable path rustc will store internally within
-- line 193 ----------------------------------------
-- line 197 ----------------------------------------
        .         }
        .         
        .         impl Hash for RealFileName {
        .             fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        .                 // To prevent #70924 from happening again we should only hash the
        .                 // remapped (virtualized) path if that exists. This is because
        .                 // virtualized paths to sysroot crates (/rust/$hash or /rust/$version)
        .                 // remain stable even if the corresponding local_path changes
      252 (0.0%)          self.remapped_path_if_available().hash(state)
        .             }
        .         }
        .         
        .         // This is functionally identical to #[derive(Encodable)], with the exception of
        .         // an added assert statement
        .         impl<S: Encoder> Encodable<S> for RealFileName {
        .             fn encode(&self, encoder: &mut S) {
        .                 match *self {
-- line 213 ----------------------------------------
-- line 227 ----------------------------------------
        .                 }
        .             }
        .         }
        .         
        .         impl RealFileName {
        .             /// Returns the path suitable for reading from the file system on the local host,
        .             /// if this information exists.
        .             /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.
      966 (0.0%)      pub fn local_path(&self) -> Option<&Path> {
      644 (0.0%)          match self {
        .                     RealFileName::LocalPath(p) => Some(p),
        .                     RealFileName::Remapped { local_path, virtual_name: _ } => local_path.as_deref(),
        .                 }
      644 (0.0%)      }
        .         
        .             /// Returns the path suitable for reading from the file system on the local host,
        .             /// if this information exists.
        .             /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.
      212 (0.0%)      pub fn into_local_path(self) -> Option<PathBuf> {
      848 (0.0%)          match self {
      848 (0.0%)              RealFileName::LocalPath(p) => Some(p),
        .                     RealFileName::Remapped { local_path: p, virtual_name: _ } => p,
        .                 }
      212 (0.0%)      }
        .         
        .             /// Returns the path suitable for embedding into build artifacts. This would still
        .             /// be a local path if it has not been remapped. A remapped path will not correspond
        .             /// to a valid file system path: see `local_path_if_available()` for something that
        .             /// is more likely to return paths into the local host file system.
        .             pub fn remapped_path_if_available(&self) -> &Path {
      378 (0.0%)          match self {
        .                     RealFileName::LocalPath(p)
        .                     | RealFileName::Remapped { local_path: _, virtual_name: p } => p,
        .                 }
        .             }
        .         
        .             /// Returns the path suitable for reading from the file system on the local host,
        .             /// if this information exists. Otherwise returns the remapped name.
        .             /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.
   13,764 (0.0%)      pub fn local_path_if_available(&self) -> &Path {
   48,494 (0.0%)          match self {
        .                     RealFileName::LocalPath(path)
        .                     | RealFileName::Remapped { local_path: None, virtual_name: path }
        .                     | RealFileName::Remapped { local_path: Some(path), virtual_name: _ } => path,
        .                 }
   13,764 (0.0%)      }
        .         
        .             /// Return the path remmapped or not depending on the [`FileNameDisplayPreference`].
        .             ///
        .             /// For the purpose of this function, local and short preference are equal.
        .             pub fn to_path(&self, display_pref: FileNameDisplayPreference) -> &Path {
        .                 match display_pref {
        .                     FileNameDisplayPreference::Local | FileNameDisplayPreference::Short => {
        .                         self.local_path_if_available()
        .                     }
        .                     FileNameDisplayPreference::Remapped => self.remapped_path_if_available(),
        .                 }
        .             }
        .         
    4,032 (0.0%)      pub fn to_string_lossy(&self, display_pref: FileNameDisplayPreference) -> Cow<'_, str> {
    1,536 (0.0%)          match display_pref {
        .                     FileNameDisplayPreference::Local => self.local_path_if_available().to_string_lossy(),
        .                     FileNameDisplayPreference::Remapped => {
        .                         self.remapped_path_if_available().to_string_lossy()
        .                     }
        .                     FileNameDisplayPreference::Short => self
        .                         .local_path_if_available()
        .                         .file_name()
        .                         .map_or_else(|| "".into(), |f| f.to_string_lossy()),
        .                 }
    3,360 (0.0%)      }
        .         }
        .         
        .         /// Differentiates between real files and common virtual files.
  332,004 (0.0%)  #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, Decodable, Encodable)]
        .         pub enum FileName {
   15,508 (0.0%)      Real(RealFileName),
        .             /// Call to `quote!`.
        .             QuoteExpansion(Hash64),
        .             /// Command line.
        .             Anon(Hash64),
        .             /// Hack in `src/librustc_ast/parse.rs`.
        .             // FIXME(jseyfried)
        .             MacroExpansion(Hash64),
        .             ProcMacroSourceCode(Hash64),
        .             /// Strings provided as crate attributes in the CLI.
        .             CliCrateAttr(Hash64),
        .             /// Custom sources for explicit parser calls from plugins and drivers.
    5,364 (0.0%)      Custom(String),
        .             DocTest(PathBuf, isize),
        .             /// Post-substitution inline assembly from LLVM.
        .             InlineAsm(Hash64),
        .         }
        .         
        .         impl From<PathBuf> for FileName {
        .             fn from(p: PathBuf) -> Self {
      318 (0.0%)          FileName::Real(RealFileName::LocalPath(p))
        .             }
        .         }
        .         
        2 (0.0%)  #[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]
        .         pub enum FileNameDisplayPreference {
        .             /// Display the path after the application of rewrite rules provided via `--remap-path-prefix`.
        .             /// This is appropriate for paths that get embedded into files produced by the compiler.
        .             Remapped,
        .             /// Display the path before the application of rewrite rules provided via `--remap-path-prefix`.
        .             /// This is appropriate for use in user-facing output (such as diagnostics).
        .             Local,
        .             /// Display only the filename, as a way to reduce the verbosity of the output.
-- line 335 ----------------------------------------
-- line 338 ----------------------------------------
        .         }
        .         
        .         pub struct FileNameDisplay<'a> {
        .             inner: &'a FileName,
        .             display_pref: FileNameDisplayPreference,
        .         }
        .         
        .         impl fmt::Display for FileNameDisplay<'_> {
      585 (0.0%)      fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        .                 use FileName::*;
    1,521 (0.0%)          match *self.inner {
        .                     Real(ref name) => {
    1,404 (0.0%)                  write!(fmt, "{}", name.to_string_lossy(self.display_pref))
      117 (0.0%)              }
        .                     QuoteExpansion(_) => write!(fmt, "<quote expansion>"),
        .                     MacroExpansion(_) => write!(fmt, "<macro expansion>"),
        .                     Anon(_) => write!(fmt, "<anon>"),
        .                     ProcMacroSourceCode(_) => write!(fmt, "<proc-macro source code>"),
        .                     CliCrateAttr(_) => write!(fmt, "<crate attribute>"),
        .                     Custom(ref s) => write!(fmt, "<{s}>"),
        .                     DocTest(ref path, _) => write!(fmt, "{}", path.display()),
        .                     InlineAsm(_) => write!(fmt, "<inline asm>"),
        .                 }
      585 (0.0%)      }
        .         }
        .         
        .         impl<'a> FileNameDisplay<'a> {
    2,755 (0.0%)      pub fn to_string_lossy(&self) -> Cow<'a, str> {
    2,204 (0.0%)          match self.inner {
    2,755 (0.0%)              FileName::Real(ref inner) => inner.to_string_lossy(self.display_pref),
        .                     _ => Cow::from(self.to_string()),
        .                 }
    2,755 (0.0%)      }
        .         }
        .         
        .         impl FileName {
        .             pub fn is_real(&self) -> bool {
        .                 use FileName::*;
    4,220 (0.0%)          match *self {
        .                     Real(_) => true,
        .                     Anon(_)
        .                     | MacroExpansion(_)
        .                     | ProcMacroSourceCode(_)
        .                     | CliCrateAttr(_)
        .                     | Custom(_)
        .                     | QuoteExpansion(_)
        .                     | DocTest(_, _)
        .                     | InlineAsm(_) => false,
        .                 }
        .             }
        .         
        .             pub fn prefer_remapped_unconditionaly(&self) -> FileNameDisplay<'_> {
      159 (0.0%)          FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Remapped }
        .             }
        .         
        .             /// This may include transient local filesystem information.
        .             /// Must not be embedded in build outputs.
        .             pub fn prefer_local(&self) -> FileNameDisplay<'_> {
        .                 FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Local }
        .             }
        .         
        .             pub fn display(&self, display_pref: FileNameDisplayPreference) -> FileNameDisplay<'_> {
      128 (0.0%)          FileNameDisplay { inner: self, display_pref }
        .             }
        .         
        .             pub fn macro_expansion_source_code(src: &str) -> FileName {
        .                 let mut hasher = StableHasher::new();
        .                 src.hash(&mut hasher);
        .                 FileName::MacroExpansion(hasher.finish())
        .             }
        .         
-- line 408 ----------------------------------------
-- line 413 ----------------------------------------
        .             }
        .         
        .             pub fn proc_macro_source_code(src: &str) -> FileName {
        .                 let mut hasher = StableHasher::new();
        .                 src.hash(&mut hasher);
        .                 FileName::ProcMacroSourceCode(hasher.finish())
        .             }
        .         
       48 (0.0%)      pub fn cfg_spec_source_code(src: &str) -> FileName {
        .                 let mut hasher = StableHasher::new();
        .                 src.hash(&mut hasher);
      176 (0.0%)          FileName::QuoteExpansion(hasher.finish())
       48 (0.0%)      }
        .         
        .             pub fn cli_crate_attr_source_code(src: &str) -> FileName {
        .                 let mut hasher = StableHasher::new();
        .                 src.hash(&mut hasher);
        .                 FileName::CliCrateAttr(hasher.finish())
        .             }
        .         
        .             pub fn doc_test_source_code(path: PathBuf, line: isize) -> FileName {
-- line 433 ----------------------------------------
-- line 464 ----------------------------------------
        .         /// that the length of the span is equal to `span.hi - span.lo`; there may be space in the
        .         /// [`BytePos`] range between files.
        .         ///
        .         /// `SpanData` is public because `Span` uses a thread-local interner and can't be
        .         /// sent to other threads, but some pieces of performance infra run in a separate thread.
        .         /// Using `Span` is generally preferred.
        .         #[derive(Clone, Copy, Hash, PartialEq, Eq)]
        .         pub struct SpanData {
      468 (0.0%)      pub lo: BytePos,
       98 (0.0%)      pub hi: BytePos,
        .             /// Information about where the macro came from, if this piece of
        .             /// code was created by a macro expansion.
       95 (0.0%)      pub ctxt: SyntaxContext,
        .             pub parent: Option<LocalDefId>,
        .         }
        .         
        .         // Order spans by position in the file.
        .         impl Ord for SpanData {
        .             fn cmp(&self, other: &Self) -> Ordering {
        .                 let SpanData {
        .                     lo: s_lo,
-- line 484 ----------------------------------------
-- line 505 ----------------------------------------
        .             fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        .                 Some(self.cmp(other))
        .             }
        .         }
        .         
        .         impl SpanData {
        .             #[inline]
        .             pub fn span(&self) -> Span {
   10,515 (0.0%)          Span::new(self.lo, self.hi, self.ctxt, self.parent)
        .             }
        .             #[inline]
        .             pub fn with_lo(&self, lo: BytePos) -> Span {
  456,778 (0.0%)          Span::new(lo, self.hi, self.ctxt, self.parent)
        .             }
        .             #[inline]
        .             pub fn with_hi(&self, hi: BytePos) -> Span {
  791,958 (0.0%)          Span::new(self.lo, hi, self.ctxt, self.parent)
        .             }
        .             #[inline]
        .             pub fn with_ctxt(&self, ctxt: SyntaxContext) -> Span {
3,444,527 (0.0%)          Span::new(self.lo, self.hi, ctxt, self.parent)
        .             }
        .             #[inline]
        .             pub fn with_parent(&self, parent: Option<LocalDefId>) -> Span {
   57,445 (0.0%)          Span::new(self.lo, self.hi, self.ctxt, parent)
        .             }
        .             /// Returns `true` if this is a dummy span with any hygienic context.
        .             #[inline]
        .             pub fn is_dummy(self) -> bool {
  862,182 (0.0%)          self.lo.0 == 0 && self.hi.0 == 0
        .             }
        .             /// Returns `true` if `self` fully encloses `other`.
        .             pub fn contains(self, other: Self) -> bool {
        .                 self.lo <= other.lo && other.hi <= self.hi
        .             }
        .         }
        .         
        .         // The interner is pointed to by a thread local value which is only set on the main thread
-- line 542 ----------------------------------------
-- line 543 ----------------------------------------
        .         // with parallelization is disabled. So we don't allow `Span` to transfer between threads
        .         // to avoid panics and other errors, even though it would be memory safe to do so.
        .         #[cfg(not(parallel_compiler))]
        .         impl !Send for Span {}
        .         #[cfg(not(parallel_compiler))]
        .         impl !Sync for Span {}
        .         
        .         impl PartialOrd for Span {
  104,680 (0.0%)      fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
   83,744 (0.0%)          PartialOrd::partial_cmp(&self.data(), &rhs.data())
   83,744 (0.0%)      }
        .         }
        .         impl Ord for Span {
        .             fn cmp(&self, rhs: &Self) -> Ordering {
        .                 Ord::cmp(&self.data(), &rhs.data())
        .             }
        .         }
        .         
        .         impl Span {
        .             #[inline]
        .             pub fn lo(self) -> BytePos {
   98,895 (0.0%)          self.data().lo
        .             }
        .             #[inline]
        .             pub fn with_lo(self, lo: BytePos) -> Span {
        .                 self.data().with_lo(lo)
        .             }
        .             #[inline]
        .             pub fn hi(self) -> BytePos {
   56,415 (0.0%)          self.data().hi
        .             }
        .             #[inline]
        .             pub fn with_hi(self, hi: BytePos) -> Span {
        .                 self.data().with_hi(hi)
        .             }
        .             #[inline]
        .             pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {
  612,420 (0.0%)          self.data_untracked().with_ctxt(ctxt)
        .             }
        .             #[inline]
        .             pub fn parent(self) -> Option<LocalDefId> {
        .                 self.data().parent
        .             }
        .             #[inline]
        .             pub fn with_parent(self, ctxt: Option<LocalDefId>) -> Span {
        .                 self.data().with_parent(ctxt)
-- line 588 ----------------------------------------
-- line 591 ----------------------------------------
        .             #[inline]
        .             pub fn is_visible(self, sm: &SourceMap) -> bool {
        .                 !self.is_dummy() && sm.is_span_accessible(self)
        .             }
        .         
        .             /// Returns `true` if this span comes from any kind of macro, desugaring or inlining.
        .             #[inline]
        .             pub fn from_expansion(self) -> bool {
   65,258 (0.0%)          !self.ctxt().is_root()
        .             }
        .         
        .             /// Returns `true` if `span` originates in a derive-macro's expansion.
      135 (0.0%)      pub fn in_derive_expansion(self) -> bool {
      270 (0.0%)          matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))
      135 (0.0%)      }
        .         
        .             /// Gate suggestions that would not be appropriate in a context the user didn't write.
        .             pub fn can_be_used_for_suggestions(self) -> bool {
        .                 !self.from_expansion()
        .                 // FIXME: If this span comes from a `derive` macro but it points at code the user wrote,
        .                 // the callsite span and the span will be pointing at different places. It also means that
        .                 // we can safely provide suggestions on this span.
        .                     || (self.in_derive_expansion()
        .                         && self.parent_callsite().map(|p| (p.lo(), p.hi())) != Some((self.lo(), self.hi())))
        .             }
        .         
        .             #[inline]
        .             pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {
  719,359 (0.0%)          Span::new(lo, hi, SyntaxContext::root(), None)
        .             }
        .         
        .             /// Returns a new span representing an empty span at the beginning of this span.
        .             #[inline]
        .             pub fn shrink_to_lo(self) -> Span {
   47,216 (0.0%)          let span = self.data_untracked();
   43,685 (0.0%)          span.with_hi(span.lo)
        .             }
        .             /// Returns a new span representing an empty span at the end of this span.
        .             #[inline]
        .             pub fn shrink_to_hi(self) -> Span {
  126,929 (0.0%)          let span = self.data_untracked();
   66,161 (0.0%)          span.with_lo(span.hi)
        .             }
        .         
        .             #[inline]
        .             /// Returns `true` if `hi == lo`.
        .             pub fn is_empty(self) -> bool {
   60,270 (0.0%)          let span = self.data_untracked();
        .                 span.hi == span.lo
        .             }
        .         
        .             /// Returns `self` if `self` is not the dummy span, and `other` otherwise.
        .             pub fn substitute_dummy(self, other: Span) -> Span {
        .                 if self.is_dummy() { other } else { self }
        .             }
        .         
        .             /// Returns `true` if `self` fully encloses `other`.
      987 (0.0%)      pub fn contains(self, other: Span) -> bool {
        .                 let span = self.data();
        .                 let other = other.data();
    4,393 (0.0%)          span.contains(other)
      564 (0.0%)      }
        .         
        .             /// Returns `true` if `self` touches `other`.
        .             pub fn overlaps(self, other: Span) -> bool {
        .                 let span = self.data();
        .                 let other = other.data();
        .                 span.lo < other.hi && other.lo < span.hi
        .             }
        .         
-- line 660 ----------------------------------------
-- line 679 ----------------------------------------
        .             pub fn trim_start(self, other: Span) -> Option<Span> {
        .                 let span = self.data();
        .                 let other = other.data();
        .                 if span.hi > other.hi { Some(span.with_lo(cmp::max(span.lo, other.hi))) } else { None }
        .             }
        .         
        .             /// Returns the source span -- this is either the supplied span, or the span for
        .             /// the macro callsite that expanded to it.
   43,285 (0.0%)      pub fn source_callsite(self) -> Span {
    8,657 (0.0%)          let ctxt = self.ctxt();
   28,054 (0.0%)          if !ctxt.is_root() { ctxt.outer_expn_data().call_site.source_callsite() } else { self }
   43,285 (0.0%)      }
        .         
        .             /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,
        .             /// if any.
        .             pub fn parent_callsite(self) -> Option<Span> {
    2,126 (0.0%)          let ctxt = self.ctxt();
    1,478 (0.0%)          (!ctxt.is_root()).then(|| ctxt.outer_expn_data().call_site)
        .             }
        .         
        .             /// Walk down the expansion ancestors to find a span that's contained within `outer`.
        .             ///
        .             /// The span returned by this method may have a different [`SyntaxContext`] as `outer`.
        .             /// If you need to extend the span, use [`find_ancestor_inside_same_ctxt`] instead,
        .             /// because joining spans with different syntax contexts can create unexpected results.
        .             ///
        .             /// [`find_ancestor_inside_same_ctxt`]: Self::find_ancestor_inside_same_ctxt
   50,580 (0.0%)      pub fn find_ancestor_inside(mut self, outer: Span) -> Option<Span> {
   15,382 (0.0%)          while !outer.contains(self) {
        .                     self = self.parent_callsite()?;
        .                 }
    9,144 (0.0%)          Some(self)
   26,976 (0.0%)      }
        .         
        .             /// Walk down the expansion ancestors to find a span with the same [`SyntaxContext`] as
        .             /// `other`.
        .             ///
        .             /// Like [`find_ancestor_inside_same_ctxt`], but specifically for when spans might not
        .             /// overlap. Take care when using this, and prefer [`find_ancestor_inside`] or
        .             /// [`find_ancestor_inside_same_ctxt`] when you know that the spans are nested (modulo
        .             /// macro expansion).
        .             ///
        .             /// [`find_ancestor_inside`]: Self::find_ancestor_inside
        .             /// [`find_ancestor_inside_same_ctxt`]: Self::find_ancestor_inside_same_ctxt
   40,106 (0.0%)      pub fn find_ancestor_in_same_ctxt(mut self, other: Span) -> Option<Span> {
   18,230 (0.0%)          while !self.eq_ctxt(other) {
        .                     self = self.parent_callsite()?;
        .                 }
   10,938 (0.0%)          Some(self)
   32,814 (0.0%)      }
        .         
        .             /// Walk down the expansion ancestors to find a span that's contained within `outer` and
        .             /// has the same [`SyntaxContext`] as `outer`.
        .             ///
        .             /// This method is the combination of [`find_ancestor_inside`] and
        .             /// [`find_ancestor_in_same_ctxt`] and should be preferred when extending the returned span.
        .             /// If you do not need to modify the span, use [`find_ancestor_inside`] instead.
        .             ///
-- line 736 ----------------------------------------
-- line 778 ----------------------------------------
        .                     && let Some(parent_callsite) = cur.parent_callsite()
        .                 {
        .                     cur = parent_callsite;
        .                 }
        .                 cur
        .             }
        .         
        .             /// Edition of the crate from which this span came.
   91,694 (0.0%)      pub fn edition(self) -> edition::Edition {
  184,204 (0.0%)          self.ctxt().edition()
        .             }
        .         
        .             /// Is this edition 2015?
        .             #[inline]
        .             pub fn is_rust_2015(self) -> bool {
   35,614 (0.0%)          self.edition().is_rust_2015()
        .             }
        .         
        .             /// Are we allowed to use features from the Rust 2018 edition?
        .             #[inline]
        .             pub fn at_least_rust_2018(self) -> bool {
   26,704 (0.0%)          self.edition().at_least_rust_2018()
        .             }
        .         
        .             /// Are we allowed to use features from the Rust 2021 edition?
        .             #[inline]
        .             pub fn at_least_rust_2021(self) -> bool {
      928 (0.0%)          self.edition().at_least_rust_2021()
        .             }
        .         
        .             /// Are we allowed to use features from the Rust 2024 edition?
        .             #[inline]
        .             pub fn at_least_rust_2024(self) -> bool {
    3,018 (0.0%)          self.edition().at_least_rust_2024()
        .             }
        .         
        .             /// Returns the source callee.
        .             ///
        .             /// Returns `None` if the supplied span has no expansion trace,
        .             /// else returns the `ExpnData` for the macro definition
        .             /// corresponding to the source callsite.
        .             pub fn source_callee(self) -> Option<ExpnData> {
-- line 819 ----------------------------------------
-- line 825 ----------------------------------------
        .                     opt_expn_data = Some(expn_data);
        .                 }
        .                 opt_expn_data
        .             }
        .         
        .             /// Checks if a span is "internal" to a macro in which `#[unstable]`
        .             /// items can be used (that is, a macro marked with
        .             /// `#[allow_internal_unstable]`).
      468 (0.0%)      pub fn allows_unstable(self, feature: Symbol) -> bool {
      624 (0.0%)          self.ctxt()
        .                     .outer_expn_data()
        .                     .allow_internal_unstable
        .                     .is_some_and(|features| features.iter().any(|&f| f == feature))
      468 (0.0%)      }
        .         
        .             /// Checks if this span arises from a compiler desugaring of kind `kind`.
   15,561 (0.0%)      pub fn is_desugaring(self, kind: DesugaringKind) -> bool {
   22,230 (0.0%)          match self.ctxt().outer_expn_data().kind {
        .                     ExpnKind::Desugaring(k) => k == kind,
        .                     _ => false,
        .                 }
   13,338 (0.0%)      }
        .         
        .             /// Returns the compiler desugaring that created this span, or `None`
        .             /// if this span is not from a desugaring.
        .             pub fn desugaring_kind(self) -> Option<DesugaringKind> {
        .                 match self.ctxt().outer_expn_data().kind {
        .                     ExpnKind::Desugaring(k) => Some(k),
        .                     _ => None,
        .                 }
        .             }
        .         
        .             /// Checks if a span is "internal" to a macro in which `unsafe`
        .             /// can be used without triggering the `unsafe_code` lint.
        .             /// (that is, a macro marked with `#[allow_internal_unsafe]`).
      264 (0.0%)      pub fn allows_unsafe(self) -> bool {
      330 (0.0%)          self.ctxt().outer_expn_data().allow_internal_unsafe
      264 (0.0%)      }
        .         
        .             pub fn macro_backtrace(mut self) -> impl Iterator<Item = ExpnData> {
        .                 let mut prev_span = DUMMY_SP;
        .                 iter::from_fn(move || {
        .                     loop {
      405 (0.0%)                  let ctxt = self.ctxt();
      162 (0.0%)                  if ctxt.is_root() {
      162 (0.0%)                      return None;
        .                         }
        .         
        .                         let expn_data = ctxt.outer_expn_data();
        .                         let is_recursive = expn_data.call_site.source_equal(prev_span);
        .         
        .                         prev_span = self;
        .                         self = expn_data.call_site;
        .         
-- line 878 ----------------------------------------
-- line 894 ----------------------------------------
        .                     Span::new(self.lo(), split_pos, self.ctxt(), self.parent()),
        .                     Span::new(split_pos, self.hi(), self.ctxt(), self.parent()),
        .                 )
        .             }
        .         
        .             /// Check if you can select metavar spans for the given spans to get matching contexts.
        .             fn try_metavars(a: SpanData, b: SpanData, a_orig: Span, b_orig: Span) -> (SpanData, SpanData) {
        .                 let get = |mspans: &FxHashMap<_, _>, s| mspans.get(&s).copied();
   11,985 (0.0%)          match with_metavar_spans(|mspans| (get(mspans, a_orig), get(mspans, b_orig))) {
        .                     (None, None) => {}
        .                     (Some(meta_a), None) => {
        .                         let meta_a = meta_a.data();
        .                         if meta_a.ctxt == b.ctxt {
        .                             return (meta_a, b);
        .                         }
        .                     }
        .                     (None, Some(meta_b)) => {
-- line 910 ----------------------------------------
-- line 926 ----------------------------------------
        .                         }
        .                     }
        .                 }
        .         
        .                 (a, b)
        .             }
        .         
        .             /// Prepare two spans to a combine operation like `to` or `between`.
3,002,712 (0.0%)      fn prepare_to_combine(
        .                 a_orig: Span,
        .                 b_orig: Span,
        .             ) -> Result<(SpanData, SpanData, Option<LocalDefId>), Span> {
1,251,130 (0.0%)          let (a, b) = (a_orig.data(), b_orig.data());
  250,226 (0.0%)          if a.ctxt == b.ctxt {
2,230,461 (0.0%)              return Ok((a, b, if a.parent == b.parent { a.parent } else { None }));
        .                 }
        .         
        .                 let (a, b) = Span::try_metavars(a, b, a_orig, b_orig);
    2,397 (0.0%)          if a.ctxt == b.ctxt {
        .                     return Ok((a, b, if a.parent == b.parent { a.parent } else { None }));
        .                 }
        .         
        .                 // Context mismatches usually happen when procedural macros combine spans copied from
        .                 // the macro input with spans produced by the macro (`Span::*_site`).
        .                 // In that case we consider the combined span to be produced by the macro and return
        .                 // the original macro-produced span as the result.
        .                 // Otherwise we just fall back to returning the first span.
        .                 // Combining locations typically doesn't make sense in case of context mismatches.
        .                 // `is_root` here is a fast path optimization.
   13,206 (0.0%)          let a_is_callsite = a.ctxt.is_root() || a.ctxt == b.span().source_callsite().ctxt();
    9,294 (0.0%)          Err(if a_is_callsite { b_orig } else { a_orig })
2,001,808 (0.0%)      }
        .         
        .             /// This span, but in a larger context, may switch to the metavariable span if suitable.
    5,383 (0.0%)      pub fn with_neighbor(self, neighbor: Span) -> Span {
    3,845 (0.0%)          match Span::prepare_to_combine(self, neighbor) {
    5,383 (0.0%)              Ok((this, ..)) => Span::new(this.lo, this.hi, this.ctxt, this.parent),
        .                     Err(_) => self,
        .                 }
        .             }
        .         
        .             /// Returns a `Span` that would enclose both `self` and `end`.
        .             ///
        .             /// Note that this can also be used to extend the span "backwards":
        .             /// `start.to(end)` and `end.to(start)` return the same `Span`.
        .             ///
        .             /// ```text
        .             ///     ____             ___
        .             ///     self lorem ipsum end
        .             ///     ^^^^^^^^^^^^^^^^^^^^
        .             /// ```
1,491,048 (0.0%)      pub fn to(self, end: Span) -> Span {
  745,524 (0.0%)          match Span::prepare_to_combine(self, end) {
1,477,200 (0.0%)              Ok((from, to, parent)) => {
  738,600 (0.0%)                  Span::new(cmp::min(from.lo, to.lo), cmp::max(from.hi, to.hi), from.ctxt, parent)
        .                     }
    2,308 (0.0%)              Err(fallback) => fallback,
        .                 }
    6,924 (0.0%)      }
        .         
        .             /// Returns a `Span` between the end of `self` to the beginning of `end`.
        .             ///
        .             /// ```text
        .             ///     ____             ___
        .             ///     self lorem ipsum end
        .             ///         ^^^^^^^^^^^^^
        .             /// ```
    2,382 (0.0%)      pub fn between(self, end: Span) -> Span {
    1,191 (0.0%)          match Span::prepare_to_combine(self, end) {
    2,382 (0.0%)              Ok((from, to, parent)) => {
    1,191 (0.0%)                  Span::new(cmp::min(from.hi, to.hi), cmp::max(from.lo, to.lo), from.ctxt, parent)
        .                     }
        .                     Err(fallback) => fallback,
        .                 }
        .             }
        .         
        .             /// Returns a `Span` from the beginning of `self` until the beginning of `end`.
        .             ///
        .             /// ```text
        .             ///     ____             ___
        .             ///     self lorem ipsum end
        .             ///     ^^^^^^^^^^^^^^^^^
        .             /// ```
    3,312 (0.0%)      pub fn until(self, end: Span) -> Span {
    1,656 (0.0%)          match Span::prepare_to_combine(self, end) {
    1,852 (0.0%)              Ok((from, to, parent)) => {
    1,389 (0.0%)                  Span::new(cmp::min(from.lo, to.lo), cmp::max(from.lo, to.lo), from.ctxt, parent)
        .                     }
       89 (0.0%)              Err(fallback) => fallback,
        .                 }
      267 (0.0%)      }
        .         
    4,788 (0.0%)      pub fn from_inner(self, inner: InnerSpan) -> Span {
        .                 let span = self.data();
    3,724 (0.0%)          Span::new(
      532 (0.0%)              span.lo + BytePos::from_usize(inner.start),
        .                     span.lo + BytePos::from_usize(inner.end),
      532 (0.0%)              span.ctxt,
        .                     span.parent,
        .                 )
        .             }
        .         
        .             /// Equivalent of `Span::def_site` from the proc macro API,
        .             /// except that the location is taken from the `self` span.
   22,518 (0.0%)      pub fn with_def_site_ctxt(self, expn_id: ExpnId) -> Span {
        .                 self.with_ctxt_from_mark(expn_id, Transparency::Opaque)
        .             }
        .         
        .             /// Equivalent of `Span::call_site` from the proc macro API,
        .             /// except that the location is taken from the `self` span.
      732 (0.0%)      pub fn with_call_site_ctxt(self, expn_id: ExpnId) -> Span {
        .                 self.with_ctxt_from_mark(expn_id, Transparency::Transparent)
        .             }
        .         
        .             /// Equivalent of `Span::mixed_site` from the proc macro API,
        .             /// except that the location is taken from the `self` span.
        .             pub fn with_mixed_site_ctxt(self, expn_id: ExpnId) -> Span {
        .                 self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)
        .             }
        .         
        .             /// Produces a span with the same location as `self` and context produced by a macro with the
        .             /// given ID and transparency, assuming that macro was defined directly and not produced by
        .             /// some other macro (which is the case for built-in and procedural macros).
        .             fn with_ctxt_from_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {
   19,375 (0.0%)          self.with_ctxt(SyntaxContext::root().apply_mark(expn_id, transparency))
        .             }
        .         
        .             #[inline]
        .             pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {
        .                 let span = self.data();
   16,205 (0.0%)          span.with_ctxt(span.ctxt.apply_mark(expn_id, transparency))
        .             }
        .         
        .             #[inline]
        .             pub fn remove_mark(&mut self) -> ExpnId {
        .                 let mut span = self.data();
      122 (0.0%)          let mark = span.ctxt.remove_mark();
      488 (0.0%)          *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                 mark
        .             }
        .         
        .             #[inline]
        .             pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {
        .                 let mut span = self.data();
        .                 let mark = span.ctxt.adjust(expn_id);
        .                 *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                 mark
        .             }
        .         
        .             #[inline]
        .             pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {
   91,874 (0.0%)          let mut span = self.data();
  274,990 (0.0%)          let mark = span.ctxt.normalize_to_macros_2_0_and_adjust(expn_id);
  321,558 (0.0%)          *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                 mark
        .             }
        .         
        .             #[inline]
        .             pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {
        .                 let mut span = self.data();
        .                 let mark = span.ctxt.glob_adjust(expn_id, glob_span);
        .                 *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
-- line 1087 ----------------------------------------
-- line 1090 ----------------------------------------
        .         
        .             #[inline]
        .             pub fn reverse_glob_adjust(
        .                 &mut self,
        .                 expn_id: ExpnId,
        .                 glob_span: Span,
        .             ) -> Option<Option<ExpnId>> {
        .                 let mut span = self.data();
    7,730 (0.0%)          let mark = span.ctxt.reverse_glob_adjust(expn_id, glob_span);
    9,231 (0.0%)          *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                 mark
        .             }
        .         
        .             #[inline]
        .             pub fn normalize_to_macros_2_0(self) -> Span {
        .                 let span = self.data();
  246,654 (0.0%)          span.with_ctxt(span.ctxt.normalize_to_macros_2_0())
        .             }
        .         
        .             #[inline]
        .             pub fn normalize_to_macro_rules(self) -> Span {
        .                 let span = self.data();
  118,953 (0.0%)          span.with_ctxt(span.ctxt.normalize_to_macro_rules())
        .             }
        .         }
        .         
        .         impl Default for Span {
        .             fn default() -> Self {
        .                 DUMMY_SP
        .             }
        .         }
        .         
  242,829 (0.0%)  rustc_index::newtype_index! {
        .             #[orderable]
        .             #[debug_format = "AttrId({})"]
        .             pub struct AttrId {}
        .         }
        .         
        .         /// This trait is used to allow encoder specific encodings of certain types.
        .         /// It is similar to rustc_type_ir's TyEncoder.
        .         pub trait SpanEncoder: Encoder {
-- line 1130 ----------------------------------------
-- line 1267 ----------------------------------------
        .         
        .             fn decode_attr_id(&mut self) -> AttrId {
        .                 panic!("cannot decode `AttrId` with `MemDecoder`");
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for Span {
        .             fn decode(s: &mut D) -> Span {
  837,162 (0.0%)          s.decode_span()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for Symbol {
        .             fn decode(s: &mut D) -> Symbol {
1,224,406 (0.0%)          s.decode_symbol()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for ExpnId {
        .             fn decode(s: &mut D) -> ExpnId {
   86,462 (0.0%)          s.decode_expn_id()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for SyntaxContext {
        .             fn decode(s: &mut D) -> SyntaxContext {
  488,744 (0.0%)          s.decode_syntax_context()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for CrateNum {
        .             fn decode(s: &mut D) -> CrateNum {
  495,039 (0.0%)          s.decode_crate_num()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for DefIndex {
        .             fn decode(s: &mut D) -> DefIndex {
        .                 s.decode_def_index()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for DefId {
        .             fn decode(s: &mut D) -> DefId {
  984,677 (0.0%)          s.decode_def_id()
        .             }
        .         }
        .         
        .         impl<D: SpanDecoder> Decodable<D> for AttrId {
        .             fn decode(s: &mut D) -> AttrId {
        .                 s.decode_attr_id()
        .             }
        .         }
        .         
        .         /// Insert `source_map` into the session globals for the duration of the
        .         /// closure's execution.
        .         pub fn set_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) -> T {
        .             with_session_globals(|session_globals| {
        4 (0.0%)          *session_globals.source_map.borrow_mut() = Some(source_map);
        .             });
        .             struct ClearSourceMap;
        .             impl Drop for ClearSourceMap {
        6 (0.0%)          fn drop(&mut self) {
        .                     with_session_globals(|session_globals| {
        .                         session_globals.source_map.borrow_mut().take();
        .                     });
        6 (0.0%)          }
        .             }
        .         
        .             let _guard = ClearSourceMap;
        4 (0.0%)      f()
        .         }
        .         
        .         impl fmt::Debug for Span {
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 // Use the global `SourceMap` to print the span. If that's not
        .                 // available, fall back to printing the raw values.
        .         
        .                 fn fallback(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-- line 1345 ----------------------------------------
-- line 1375 ----------------------------------------
        .         pub struct MultiByteChar {
        .             /// The relative offset of the character in the `SourceFile`.
        .             pub pos: RelativeBytePos,
        .             /// The number of bytes, `>= 2`.
        .             pub bytes: u8,
        .         }
        .         
        .         /// Identifies an offset of a non-narrow character in a `SourceFile`.
    1,780 (0.0%)  #[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug, HashStable_Generic)]
        .         pub enum NonNarrowChar {
        .             /// Represents a zero-width character.
        .             ZeroWidth(RelativeBytePos),
        .             /// Represents a wide (full-width) character.
        .             Wide(RelativeBytePos),
        .             /// Represents a tab character, represented visually with a width of 4 characters.
        .             Tab(RelativeBytePos),
        .         }
        .         
        .         impl NonNarrowChar {
        .             fn new(pos: RelativeBytePos, width: usize) -> Self {
      222 (0.0%)          match width {
        .                     0 => NonNarrowChar::ZeroWidth(pos),
        .                     2 => NonNarrowChar::Wide(pos),
        .                     4 => NonNarrowChar::Tab(pos),
        .                     _ => panic!("width {width} given for non-narrow character"),
        .                 }
        .             }
        .         
        .             /// Returns the relative offset of the character in the `SourceFile`.
-- line 1403 ----------------------------------------
-- line 1469 ----------------------------------------
        .             /// No attempt has been made to load the external source.
        .             AbsentOk,
        .             /// A failed attempt has been made to load the external source.
        .             AbsentErr,
        .         }
        .         
        .         impl ExternalSource {
        .             pub fn get_source(&self) -> Option<&Lrc<String>> {
    7,277 (0.0%)          match self {
        .                     ExternalSource::Foreign { kind: ExternalSourceKind::Present(ref src), .. } => Some(src),
        .                     _ => None,
        .                 }
        .             }
        .         }
        .         
        .         #[derive(Debug)]
        .         pub struct OffsetOverflowError;
        .         
    1,185 (0.0%)  #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]
        .         #[derive(HashStable_Generic)]
        .         pub enum SourceFileHashAlgorithm {
        .             Md5,
        .             Sha1,
        .             Sha256,
        .         }
        .         
        .         impl FromStr for SourceFileHashAlgorithm {
-- line 1495 ----------------------------------------
-- line 1502 ----------------------------------------
        .                     "sha256" => Ok(SourceFileHashAlgorithm::Sha256),
        .                     _ => Err(()),
        .                 }
        .             }
        .         }
        .         
        .         /// The hash of the on-disk source file used for debug info.
        .         #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]
    1,179 (0.0%)  #[derive(HashStable_Generic, Encodable, Decodable)]
        .         pub struct SourceFileHash {
        .             pub kind: SourceFileHashAlgorithm,
        .             value: [u8; 32],
        .         }
        .         
        .         impl SourceFileHash {
   15,565 (0.0%)      pub fn new(kind: SourceFileHashAlgorithm, src: &str) -> SourceFileHash {
        .                 let mut hash = SourceFileHash { kind, value: Default::default() };
        .                 let len = hash.hash_len();
        .                 let value = &mut hash.value[..len];
        .                 let data = src.as_bytes();
        .                 match kind {
        .                     SourceFileHashAlgorithm::Md5 => {
        .                         value.copy_from_slice(&Md5::digest(data));
        .                     }
        .                     SourceFileHashAlgorithm::Sha1 => {
        .                         value.copy_from_slice(&Sha1::digest(data));
        .                     }
        .                     SourceFileHashAlgorithm::Sha256 => {
        .                         value.copy_from_slice(&Sha256::digest(data));
        .                     }
        .                 }
    4,245 (0.0%)          hash
   12,735 (0.0%)      }
        .         
        .             /// Check if the stored hash matches the hash of the string.
        .             pub fn matches(&self, src: &str) -> bool {
       18 (0.0%)          Self::new(self.kind, src) == *self
        .             }
        .         
        .             /// The bytes of the hash.
        .             pub fn hash_bytes(&self) -> &[u8] {
        .                 let len = self.hash_len();
        .                 &self.value[..len]
        .             }
        .         
        .             fn hash_len(&self) -> usize {
    2,830 (0.0%)          match self.kind {
        .                     SourceFileHashAlgorithm::Md5 => 16,
        .                     SourceFileHashAlgorithm::Sha1 => 20,
        .                     SourceFileHashAlgorithm::Sha256 => 32,
        .                 }
        .             }
        .         }
        .         
        .         #[derive(Clone)]
-- line 1556 ----------------------------------------
-- line 1722 ----------------------------------------
        .         
        .         impl<D: SpanDecoder> Decodable<D> for SourceFile {
        .             fn decode(d: &mut D) -> SourceFile {
        .                 let name: FileName = Decodable::decode(d);
        .                 let src_hash: SourceFileHash = Decodable::decode(d);
        .                 let source_len: RelativeBytePos = Decodable::decode(d);
        .                 let lines = {
        .                     let num_lines: u32 = Decodable::decode(d);
    9,432 (0.0%)              if num_lines > 0 {
        .                         // Read the number of bytes used per diff.
        .                         let bytes_per_diff = d.read_u8() as usize;
        .         
        .                         // Read the difference list.
    2,358 (0.0%)                  let num_diffs = num_lines as usize - 1;
    2,358 (0.0%)                  let raw_diffs = d.read_raw_bytes(bytes_per_diff * num_diffs).to_vec();
    8,253 (0.0%)                  SourceFileLines::Diffs(SourceFileDiffs { bytes_per_diff, num_diffs, raw_diffs })
        .                     } else {
        .                         SourceFileLines::Lines(vec![])
        .                     }
        .                 };
        .                 let multibyte_chars: Vec<MultiByteChar> = Decodable::decode(d);
        .                 let non_narrow_chars: Vec<NonNarrowChar> = Decodable::decode(d);
        .                 let stable_id = Decodable::decode(d);
        .                 let normalized_pos: Vec<NormalizedPos> = Decodable::decode(d);
        .                 let cnum: CrateNum = Decodable::decode(d);
  122,616 (0.0%)          SourceFile {
        .                     name,
        .                     start_pos: BytePos::from_u32(0),
        .                     source_len,
        .                     src: None,
        .                     src_hash,
        .                     // Unused - the metadata decoder will construct
        .                     // a new SourceFile, filling in `external_src` properly
        .                     external_src: FreezeLock::frozen(ExternalSource::Unneeded),
-- line 1755 ----------------------------------------
-- line 1803 ----------------------------------------
        .             Default,
        .             PartialOrd,
        .             Ord
        .         )]
        .         pub struct StableSourceFileId(Hash128);
        .         
        .         impl StableSourceFileId {
        .             fn from_filename_in_current_crate(filename: &FileName) -> Self {
    7,060 (0.0%)          Self::from_filename_and_stable_crate_id(filename, None)
        .             }
        .         
        .             pub fn from_filename_for_export(
        .                 filename: &FileName,
        .                 local_crate_stable_crate_id: StableCrateId,
        .             ) -> Self {
        .                 Self::from_filename_and_stable_crate_id(filename, Some(local_crate_stable_crate_id))
        .             }
        .         
   31,064 (0.0%)      fn from_filename_and_stable_crate_id(
        .                 filename: &FileName,
        .                 stable_crate_id: Option<StableCrateId>,
        .             ) -> Self {
        .                 let mut hasher = StableHasher::new();
        .                 filename.hash(&mut hasher);
        .                 stable_crate_id.hash(&mut hasher);
   53,656 (0.0%)          StableSourceFileId(hasher.finish())
   22,592 (0.0%)      }
        .         }
        .         
        .         impl SourceFile {
   15,532 (0.0%)      pub fn new(
        .                 name: FileName,
        .                 mut src: String,
        .                 hash_kind: SourceFileHashAlgorithm,
        .             ) -> Result<Self, OffsetOverflowError> {
        .                 // Compute the file hash before any normalization.
    4,236 (0.0%)          let src_hash = SourceFileHash::new(hash_kind, &src);
    2,824 (0.0%)          let normalized_pos = normalize_src(&mut src);
        .         
        .                 let stable_id = StableSourceFileId::from_filename_in_current_crate(&name);
        .                 let source_len = src.len();
        .                 let source_len = u32::try_from(source_len).map_err(|_| OffsetOverflowError)?;
        .         
        .                 let (lines, multibyte_chars, non_narrow_chars) =
        .                     analyze_source_file::analyze_source_file(&src);
        .         
   69,188 (0.0%)          Ok(SourceFile {
        .                     name,
    4,236 (0.0%)              src: Some(Lrc::new(src)),
        .                     src_hash,
        .                     external_src: FreezeLock::frozen(ExternalSource::Unneeded),
        .                     start_pos: BytePos::from_u32(0),
        .                     source_len: RelativeBytePos::from_u32(source_len),
        .                     lines: FreezeLock::frozen(SourceFileLines::Lines(lines)),
        .                     multibyte_chars,
        .                     non_narrow_chars,
        .                     normalized_pos,
        .                     stable_id,
        .                     cnum: LOCAL_CRATE,
        .                 })
   12,708 (0.0%)      }
        .         
        .             /// This converts the `lines` field to contain `SourceFileLines::Lines` if needed and freezes
        .             /// it.
        .             fn convert_diffs_to_lines_frozen(&self) {
        .                 let mut guard = if let Some(guard) = self.lines.try_write() { guard } else { return };
        .         
      154 (0.0%)          let SourceFileDiffs { bytes_per_diff, num_diffs, raw_diffs } = match &*guard {
        .                     SourceFileLines::Diffs(diffs) => diffs,
        .                     SourceFileLines::Lines(..) => {
        .                         FreezeWriteGuard::freeze(guard);
        .                         return;
        .                     }
        .                 };
        .         
        .                 // Convert from "diffs" form to "lines" form.
        .                 let num_lines = num_diffs + 1;
        .                 let mut lines = Vec::with_capacity(num_lines);
        .                 let mut line_start = RelativeBytePos(0);
        .                 lines.push(line_start);
        .         
      154 (0.0%)          assert_eq!(*num_diffs, raw_diffs.len() / bytes_per_diff);
      154 (0.0%)          match bytes_per_diff {
        .                     1 => {
       77 (0.0%)                  lines.extend(raw_diffs.into_iter().map(|&diff| {
        .                             line_start = line_start + RelativeBytePos(diff as u32);
        .                             line_start
        .                         }));
        .                     }
        .                     2 => {
        .                         lines.extend((0..*num_diffs).map(|i| {
        .                             let pos = bytes_per_diff * i;
        .                             let bytes = [raw_diffs[pos], raw_diffs[pos + 1]];
-- line 1895 ----------------------------------------
-- line 1910 ----------------------------------------
        .                             let diff = u32::from_le_bytes(bytes);
        .                             line_start = line_start + RelativeBytePos(diff);
        .                             line_start
        .                         }));
        .                     }
        .                     _ => unreachable!(),
        .                 }
        .         
      385 (0.0%)          *guard = SourceFileLines::Lines(lines);
        .         
        .                 FreezeWriteGuard::freeze(guard);
        .             }
        .         
        .             pub fn lines(&self) -> &[RelativeBytePos] {
  629,849 (0.0%)          if let Some(SourceFileLines::Lines(lines)) = self.lines.get() {
  493,726 (0.0%)              return &lines[..];
        .                 }
        .         
      557 (0.0%)          outline(|| {
        .                     self.convert_diffs_to_lines_frozen();
      231 (0.0%)              if let Some(SourceFileLines::Lines(lines)) = self.lines.get() {
      154 (0.0%)                  return &lines[..];
        .                     }
        .                     unreachable!()
        .                 })
        .             }
        .         
        .             /// Returns the `BytePos` of the beginning of the current line.
        .             pub fn line_begin_pos(&self, pos: BytePos) -> BytePos {
        .                 let pos = self.relative_position(pos);
-- line 1939 ----------------------------------------
-- line 1945 ----------------------------------------
        .             /// Add externally loaded source.
        .             /// If the hash of the input doesn't match or no input is supplied via None,
        .             /// it is interpreted as an error and the corresponding enum variant is set.
        .             /// The return value signifies whether some kind of source is present.
        .             pub fn add_external_src<F>(&self, get_src: F) -> bool
        .             where
        .                 F: FnOnce() -> Option<String>,
        .             {
    3,368 (0.0%)          if !self.external_src.is_frozen() {
        .                     let src = get_src();
        .                     let src = src.and_then(|mut src| {
        .                         // The src_hash needs to be computed on the pre-normalized src.
        .                         self.src_hash.matches(&src).then(|| {
        6 (0.0%)                      normalize_src(&mut src);
       15 (0.0%)                      src
        .                         })
        .                     });
        .         
        .                     self.external_src.try_write().map(|mut external_src| {
        9 (0.0%)                  if let ExternalSource::Foreign {
        .                             kind: src_kind @ ExternalSourceKind::AbsentOk,
        .                             ..
        .                         } = &mut *external_src
        .                         {
       15 (0.0%)                      *src_kind = if let Some(src) = src {
        .                                 ExternalSourceKind::Present(Lrc::new(src))
        .                             } else {
        .                                 ExternalSourceKind::AbsentErr
        .                             };
        .                         } else {
        .                             panic!("unexpected state {:?}", *external_src)
        .                         }
        .         
-- line 1977 ----------------------------------------
-- line 1980 ----------------------------------------
        .                     });
        .                 }
        .         
        .                 self.src.is_some() || self.external_src.read().get_source().is_some()
        .             }
        .         
        .             /// Gets a line from the list of pre-computed line-beginnings.
        .             /// The line number here is 0-based.
    1,320 (0.0%)      pub fn get_line(&self, line_number: usize) -> Option<Cow<'_, str>> {
      924 (0.0%)          fn get_until_newline(src: &str, begin: usize) -> &str {
        .                     // We can't use `lines.get(line_number+1)` because we might
        .                     // be parsing when we call this function and thus the current
        .                     // line is the last one we have line info for.
        .                     let slice = &src[begin..];
      264 (0.0%)              match slice.find('\n') {
        .                         Some(e) => &slice[..e],
        .                         None => slice,
        .                     }
      924 (0.0%)          }
        .         
        .                 let begin = {
        .                     let line = self.lines().get(line_number).copied()?;
        .                     line.to_usize()
        .                 };
        .         
      396 (0.0%)          if let Some(ref src) = self.src {
      660 (0.0%)              Some(Cow::from(get_until_newline(src, begin)))
        .                 } else {
        .                     self.external_src
        .                         .borrow()
        .                         .get_source()
        .                         .map(|src| Cow::Owned(String::from(get_until_newline(src, begin))))
        .                 }
    1,188 (0.0%)      }
        .         
        .             pub fn is_real_file(&self) -> bool {
        .                 self.name.is_real()
        .             }
        .         
        .             #[inline]
        .             pub fn is_imported(&self) -> bool {
        .                 self.src.is_none()
-- line 2021 ----------------------------------------
-- line 2022 ----------------------------------------
        .             }
        .         
        .             pub fn count_lines(&self) -> usize {
        .                 self.lines().len()
        .             }
        .         
        .             #[inline]
        .             pub fn absolute_position(&self, pos: RelativeBytePos) -> BytePos {
  418,049 (0.0%)          BytePos::from_u32(pos.to_u32() + self.start_pos.to_u32())
        .             }
        .         
        .             #[inline]
        .             pub fn relative_position(&self, pos: BytePos) -> RelativeBytePos {
   94,242 (0.0%)          RelativeBytePos::from_u32(pos.to_u32() - self.start_pos.to_u32())
        .             }
        .         
        .             #[inline]
        .             pub fn end_position(&self) -> BytePos {
  133,453 (0.0%)          self.absolute_position(self.source_len)
        .             }
        .         
        .             /// Finds the line containing the given position. The return value is the
        .             /// index into the `lines` array of this `SourceFile`, not the 1-based line
        .             /// number. If the source_file is empty or the position is located before the
        .             /// first line, `None` is returned.
        .             pub fn lookup_line(&self, pos: RelativeBytePos) -> Option<usize> {
        .                 self.lines().partition_point(|x| x <= &pos).checked_sub(1)
        .             }
        .         
  292,940 (0.0%)      pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {
  146,470 (0.0%)          if self.is_empty() {
        .                     return self.start_pos..self.start_pos;
        .                 }
        .         
        .                 let lines = self.lines();
  146,470 (0.0%)          assert!(line_index < lines.len());
  219,705 (0.0%)          if line_index == (lines.len() - 1) {
        .                     self.absolute_position(lines[line_index])..self.end_position()
        .                 } else {
  219,414 (0.0%)              self.absolute_position(lines[line_index])..self.absolute_position(lines[line_index + 1])
        .                 }
  292,940 (0.0%)      }
        .         
        .             /// Returns whether or not the file contains the given `SourceMap` byte
        .             /// position. The position one past the end of the file is considered to be
        .             /// contained by the file. This implies that files for which `is_empty`
        .             /// returns true still contain one byte position according to this function.
        .             #[inline]
        .             pub fn contains(&self, byte_pos: BytePos) -> bool {
        .                 byte_pos >= self.start_pos && byte_pos <= self.end_position()
-- line 2071 ----------------------------------------
-- line 2079 ----------------------------------------
        .             /// Calculates the original byte position relative to the start of the file
        .             /// based on the given byte position.
        .             pub fn original_relative_byte_pos(&self, pos: BytePos) -> RelativeBytePos {
        .                 let pos = self.relative_position(pos);
        .         
        .                 // Diff before any records is 0. Otherwise use the previously recorded
        .                 // diff as that applies to the following characters until a new diff
        .                 // is recorded.
       94 (0.0%)          let diff = match self.normalized_pos.binary_search_by(|np| np.pos.cmp(&pos)) {
        .                     Ok(i) => self.normalized_pos[i].diff,
        .                     Err(0) => 0,
        .                     Err(i) => self.normalized_pos[i - 1].diff,
        .                 };
        .         
       94 (0.0%)          RelativeBytePos::from_u32(pos.0 + diff)
       94 (0.0%)      }
        .         
        .             /// Calculates a normalized byte position from a byte offset relative to the
        .             /// start of the file.
        .             ///
        .             /// When we get an inline assembler error from LLVM during codegen, we
        .             /// import the expanded assembly code as a new `SourceFile`, which can then
        .             /// be used for error reporting with spans. However the byte offsets given
        .             /// to us by LLVM are relative to the start of the original buffer, not the
-- line 2102 ----------------------------------------
-- line 2117 ----------------------------------------
        .         
        .             /// Converts an relative `RelativeBytePos` to a `CharPos` relative to the `SourceFile`.
        .             fn bytepos_to_file_charpos(&self, bpos: RelativeBytePos) -> CharPos {
        .                 // The number of extra bytes due to multibyte chars in the `SourceFile`.
        .                 let mut total_extra_bytes = 0;
        .         
        .                 for mbc in self.multibyte_chars.iter() {
        .                     debug!("{}-byte char at {:?}", mbc.bytes, mbc.pos);
  100,216 (0.0%)              if mbc.pos < bpos {
        .                         // Every character is at least one byte, so we only
        .                         // count the actual extra bytes.
  277,122 (0.0%)                  total_extra_bytes += mbc.bytes as u32 - 1;
        .                         // We should never see a byte position in the middle of a
        .                         // character.
  277,122 (0.0%)                  assert!(bpos.to_u32() >= mbc.pos.to_u32() + mbc.bytes as u32);
        .                     } else {
        .                         break;
        .                     }
        .                 }
        .         
   31,360 (0.0%)          assert!(total_extra_bytes <= bpos.to_u32());
   62,739 (0.0%)          CharPos(bpos.to_usize() - total_extra_bytes as usize)
        .             }
        .         
        .             /// Looks up the file's (1-based) line number and (0-based `CharPos`) column offset, for a
        .             /// given `RelativeBytePos`.
        .             fn lookup_file_pos(&self, pos: RelativeBytePos) -> (usize, CharPos) {
   20,913 (0.0%)          let chpos = self.bytepos_to_file_charpos(pos);
   20,913 (0.0%)          match self.lookup_line(pos) {
        .                     Some(a) => {
        .                         let line = a + 1; // Line numbers start at 1
   62,739 (0.0%)                  let linebpos = self.lines()[a];
   20,913 (0.0%)                  let linechpos = self.bytepos_to_file_charpos(linebpos);
        .                         let col = chpos - linechpos;
        .                         debug!("byte pos {:?} is on the line at byte pos {:?}", pos, linebpos);
        .                         debug!("char pos {:?} is on the line at char pos {:?}", chpos, linechpos);
        .                         debug!("byte is on line: {}", line);
        .                         assert!(chpos >= linechpos);
        .                         (line, col)
        .                     }
        .                     None => (0, chpos),
        .                 }
        .             }
        .         
        .             /// Looks up the file's (1-based) line number, (0-based `CharPos`) column offset, and (0-based)
        .             /// column offset when displayed, for a given `BytePos`.
  167,304 (0.0%)      pub fn lookup_file_pos_with_col_display(&self, pos: BytePos) -> (usize, CharPos, usize) {
        .                 let pos = self.relative_position(pos);
        .                 let (line, col_or_chpos) = self.lookup_file_pos(pos);
        .                 if line > 0 {
        .                     let col = col_or_chpos;
   41,826 (0.0%)              let linebpos = self.lines()[line - 1];
        .                     let col_display = {
   41,826 (0.0%)                  let start_width_idx = self
        .                             .non_narrow_chars
        .                             .binary_search_by_key(&linebpos, |x| x.pos())
        .                             .unwrap_or_else(|x| x);
        .                         let end_width_idx = self
        .                             .non_narrow_chars
        .                             .binary_search_by_key(&pos, |x| x.pos())
        .                             .unwrap_or_else(|x| x);
   20,913 (0.0%)                  let special_chars = end_width_idx - start_width_idx;
        .                         let non_narrow: usize = self.non_narrow_chars[start_width_idx..end_width_idx]
        .                             .iter()
        .                             .map(|x| x.width())
        .                             .sum();
   41,826 (0.0%)                  col.0 - special_chars + non_narrow
        .                     };
        .                     (line, col, col_display)
        .                 } else {
        .                     let chpos = col_or_chpos;
        .                     let col_display = {
        .                         let end_width_idx = self
        .                             .non_narrow_chars
        .                             .binary_search_by_key(&pos, |x| x.pos())
        .                             .unwrap_or_else(|x| x);
        .                         let non_narrow: usize =
        .                             self.non_narrow_chars[0..end_width_idx].iter().map(|x| x.width()).sum();
        .                         chpos.0 - end_width_idx + non_narrow
        .                     };
        .                     (0, chpos, col_display)
        .                 }
  188,217 (0.0%)      }
        .         }
        .         
        .         /// Normalizes the source code and records the normalizations.
   14,150 (0.0%)  fn normalize_src(src: &mut String) -> Vec<NormalizedPos> {
        .             let mut normalized_pos = vec![];
        .             remove_bom(src, &mut normalized_pos);
        .             normalize_newlines(src, &mut normalized_pos);
    5,660 (0.0%)      normalized_pos
   12,735 (0.0%)  }
        .         
        .         /// Removes UTF-8 BOM, if any.
        .         fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {
    1,415 (0.0%)      if src.starts_with('\u{feff}') {
        .                 src.drain(..3);
        .                 normalized_pos.push(NormalizedPos { pos: RelativeBytePos(0), diff: 3 });
        .             }
        .         }
        .         
        .         /// Replaces `\r\n` with `\n` in-place in `src`.
        .         ///
        .         /// Leaves any occurrences of lone `\r` unchanged.
        .         fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {
    1,407 (0.0%)      if !src.as_bytes().contains(&b'\r') {
        .                 return;
        .             }
        .         
        .             // We replace `\r\n` with `\n` in-place, which doesn't break utf-8 encoding.
        .             // While we *can* call `as_mut_vec` and do surgery on the live string
        .             // directly, let's rather steal the contents of `src`. This makes the code
        .             // safe even if a panic occurs.
        .         
-- line 2230 ----------------------------------------
-- line 2336 ----------------------------------------
        .                         fn sub(self, rhs: $ident) -> $ident {
        .                             $ident(self.0 - rhs.0)
        .                         }
        .                     }
        .                 )*
        .             };
        .         }
        .         
2,766,266 (0.0%)  impl_pos! {
        .             /// A byte offset.
        .             ///
        .             /// Keep this small (currently 32-bits), as AST contains a lot of them.
  937,992 (0.0%)      #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]
        .             pub struct BytePos(pub u32);
        .         
        .             /// A byte offset relative to file beginning.
        .             #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]
        .             pub struct RelativeBytePos(pub u32);
        .         
        .             /// A character offset.
        .             ///
        .             /// Because of multibyte UTF-8 characters, a byte offset
        .             /// is not equivalent to a character offset. The [`SourceMap`] will convert [`BytePos`]
        .             /// values to `CharPos` values as necessary.
       17 (0.0%)      #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
        .             pub struct CharPos(pub usize);
        .         }
        .         
        .         impl<S: Encoder> Encodable<S> for BytePos {
        .             fn encode(&self, s: &mut S) {
        .                 s.emit_u32(self.0);
        .             }
        .         }
-- line 2368 ----------------------------------------
-- line 2391 ----------------------------------------
        .             }
        .         }
        .         
        .         // _____________________________________________________________________________
        .         // Loc, SourceFileAndLine, SourceFileAndBytePos
        .         //
        .         
        .         /// A source code location used for error reporting.
       51 (0.0%)  #[derive(Debug, Clone)]
        .         pub struct Loc {
        .             /// Information about the original source.
        .             pub file: Lrc<SourceFile>,
        .             /// The (1-based) line number.
        .             pub line: usize,
        .             /// The (0-based) column offset.
        .             pub col: CharPos,
        .             /// The (0-based) column offset when displayed.
-- line 2407 ----------------------------------------
-- line 2513 ----------------------------------------
        .             /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)
        .             /// triple, which stays the same even if the containing `SourceFile` has moved
        .             /// within the `SourceMap`.
        .             ///
        .             /// Also note that we are hashing byte offsets for the column, not unicode
        .             /// codepoint offsets. For the purpose of the hash that's sufficient.
        .             /// Also, hashing filenames is expensive so we avoid doing it twice when the
        .             /// span starts and ends in the same file, which is almost always the case.
2,586,546 (0.0%)      fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {
        .                 const TAG_VALID_SPAN: u8 = 0;
        .                 const TAG_INVALID_SPAN: u8 = 1;
        .                 const TAG_RELATIVE_SPAN: u8 = 2;
        .         
  287,394 (0.0%)          if !ctx.hash_spans() {
        .                     return;
        .                 }
        .         
  287,394 (0.0%)          let span = self.data_untracked();
  287,394 (0.0%)          span.ctxt.hash_stable(ctx, hasher);
  862,182 (0.0%)          span.parent.hash_stable(ctx, hasher);
        .         
  574,788 (0.0%)          if span.is_dummy() {
        .                     Hash::hash(&TAG_INVALID_SPAN, hasher);
        .                     return;
        .                 }
        .         
  277,435 (0.0%)          if let Some(parent) = span.parent {
        .                     let def_span = ctx.def_span(parent).data_untracked();
        .                     if def_span.contains(span) {
        .                         // This span is enclosed in a definition: only hash the relative position.
        .                         Hash::hash(&TAG_RELATIVE_SPAN, hasher);
        .                         (span.lo - def_span.lo).to_u32().hash_stable(ctx, hasher);
        .                         (span.hi - def_span.lo).to_u32().hash_stable(ctx, hasher);
        .                         return;
        .                     }
        .                 }
        .         
        .                 // If this is not an empty or invalid span, we want to hash the last
        .                 // position that belongs to it, as opposed to hashing the first
        .                 // position past it.
1,942,045 (0.0%)          let Some((file, line_lo, col_lo, line_hi, col_hi)) = ctx.span_data_to_lines_and_cols(&span)
        .                 else {
        .                     Hash::hash(&TAG_INVALID_SPAN, hasher);
        .                     return;
        .                 };
        .         
        .                 Hash::hash(&TAG_VALID_SPAN, hasher);
        .                 Hash::hash(&file.stable_id, hasher);
        .         
-- line 2561 ----------------------------------------
-- line 2564 ----------------------------------------
        .                 // different end locations will have the same hash. This can cause a problem
        .                 // during incremental compilation wherein a previous result for a query that
        .                 // depends on the end location of a span will be incorrectly reused when the
        .                 // end location of the span it depends on has changed (see issue #74890). A
        .                 // similar analysis applies if some query depends specifically on the length
        .                 // of the span, but we only hash the end location. So hash both.
        .         
        .                 let col_lo_trunc = (col_lo.0 as u64) & 0xFF;
  277,435 (0.0%)          let line_lo_trunc = ((line_lo as u64) & 0xFF_FF_FF) << 8;
        .                 let col_hi_trunc = (col_hi.0 as u64) & 0xFF << 32;
  277,435 (0.0%)          let line_hi_trunc = ((line_hi as u64) & 0xFF_FF_FF) << 40;
  554,870 (0.0%)          let col_line = col_lo_trunc | line_lo_trunc | col_hi_trunc | line_hi_trunc;
        .                 let len = (span.hi - span.lo).0;
        .                 Hash::hash(&col_line, hasher);
        .                 Hash::hash(&len, hasher);
2,299,152 (0.0%)      }
        .         }
        .         
        .         /// Useful type to use with `Result<>` indicate that an error has already
        .         /// been reported to the user, so no need to continue checking.
        .         ///
        .         /// The `()` field is necessary: it is non-`pub`, which means values of this
        .         /// type cannot be constructed outside of this crate.
        .         #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
-- line 2587 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_span/src/span_encoding.rs
--------------------------------------------------------------------------------
Ir_______________ 

10,723,977 (0.1%)  <unknown (line 0)>

-- line 74 ----------------------------------------
         .         ///   for `ctxt_or_parent_or_marker`, but larger crates might need more than 16
         .         ///   bits. The number of bits needed for `parent` hasn't been measured,
         .         ///   because `parent` isn't currently used by default.
         .         ///
         .         /// In order to reliably use parented spans in incremental compilation,
         .         /// the dependency to the parent definition's span. This is performed
         .         /// using the callback `SPAN_TRACK` to access the query engine.
         .         ///
 1,748,982 (0.0%)  #[derive(Clone, Copy, Eq, PartialEq, Hash)]
         .         #[rustc_pass_by_value]
         .         pub struct Span {
       942 (0.0%)      lo_or_index: u32,
       806 (0.0%)      len_with_tag_or_marker: u16,
       403 (0.0%)      ctxt_or_parent_or_marker: u16,
         .         }
         .         
         .         // `MAX_LEN` is chosen so that `PARENT_TAG | MAX_LEN` is distinct from
         .         // `BASE_LEN_INTERNED_MARKER`. (If `MAX_LEN` was 1 higher, this wouldn't be true.)
         .         const MAX_LEN: u32 = 0b0111_1111_1111_1110;
         .         const MAX_CTXT: u32 = 0b0111_1111_1111_1110;
         .         const PARENT_TAG: u16 = 0b1000_0000_0000_0000;
         .         const BASE_LEN_INTERNED_MARKER: u16 = 0b1111_1111_1111_1111;
-- line 95 ----------------------------------------
-- line 96 ----------------------------------------
         .         const CTXT_INTERNED_MARKER: u16 = 0b1111_1111_1111_1111;
         .         
         .         /// The dummy span has zero position, length, and context, and no parent.
         .         pub const DUMMY_SP: Span =
         .             Span { lo_or_index: 0, len_with_tag_or_marker: 0, ctxt_or_parent_or_marker: 0 };
         .         
         .         impl Span {
         .             #[inline]
15,572,774 (0.2%)      pub fn new(
         .                 mut lo: BytePos,
         .                 mut hi: BytePos,
         .                 ctxt: SyntaxContext,
         .                 parent: Option<LocalDefId>,
         .             ) -> Self {
10,709,346 (0.1%)          if lo > hi {
         .                     std::mem::swap(&mut lo, &mut hi);
         .                 }
         .         
10,709,346 (0.1%)          let (lo2, len, ctxt2) = (lo.0, hi.0 - lo.0, ctxt.as_u32());
         .         
 3,569,782 (0.0%)          if len <= MAX_LEN {
 7,121,264 (0.1%)              if ctxt2 <= MAX_CTXT && parent.is_none() {
         .                         // Inline-context format.
         .                         return Span {
         .                             lo_or_index: lo2,
         .                             len_with_tag_or_marker: len as u16,
         .                             ctxt_or_parent_or_marker: ctxt2 as u16,
         .                         };
         .                     } else if ctxt2 == SyntaxContext::root().as_u32()
         .                         && let Some(parent) = parent
-- line 125 ----------------------------------------
-- line 132 ----------------------------------------
         .                             len_with_tag_or_marker: PARENT_TAG | len as u16,
         .                             ctxt_or_parent_or_marker: parent2 as u16,
         .                         };
         .                     }
         .                 }
         .         
         .                 // Partially-interned or fully-interned format.
         .                 let index =
    27,450 (0.0%)              with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));
    13,725 (0.0%)          let ctxt_or_parent_or_marker = if ctxt2 <= MAX_CTXT {
         .                     ctxt2 as u16 // partially-interned
         .                 } else {
         .                     CTXT_INTERNED_MARKER // fully-interned
         .                 };
         .                 Span {
         .                     lo_or_index: index,
         .                     len_with_tag_or_marker: BASE_LEN_INTERNED_MARKER,
         .                     ctxt_or_parent_or_marker,
         .                 }
23,203,583 (0.3%)      }
         .         
         .             #[inline]
    30,228 (0.0%)      pub fn data(self) -> SpanData {
 1,779,216 (0.0%)          let data = self.data_untracked();
 4,274,265 (0.1%)          if let Some(parent) = data.parent {
         .                     (*SPAN_TRACK)(parent);
         .                 }
         .                 data
    20,152 (0.0%)      }
         .         
         .             /// Internal function to translate between an encoded span and the expanded representation.
         .             /// This function must not be used outside the incremental engine.
         .             #[inline]
21,924,480 (0.3%)      pub fn data_untracked(self) -> SpanData {
 3,929,446 (0.0%)          if self.len_with_tag_or_marker != BASE_LEN_INTERNED_MARKER {
 3,870,800 (0.0%)              if self.len_with_tag_or_marker & PARENT_TAG == 0 {
         .                         // Inline-context format.
 1,935,400 (0.0%)                  let len = self.len_with_tag_or_marker as u32;
         .                         debug_assert!(len <= MAX_LEN);
 7,741,600 (0.1%)                  SpanData {
         .                             lo: BytePos(self.lo_or_index),
         .                             hi: BytePos(self.lo_or_index.debug_strict_add(len)),
         .                             ctxt: SyntaxContext::from_u32(self.ctxt_or_parent_or_marker as u32),
         .                             parent: None,
         .                         }
         .                     } else {
         .                         // Inline-parent format.
         .                         let len = (self.len_with_tag_or_marker & !PARENT_TAG) as u32;
-- line 179 ----------------------------------------
-- line 188 ----------------------------------------
         .                             parent: Some(parent),
         .                         }
         .                     }
         .                 } else {
         .                     // Fully-interned or partially-interned format. In either case,
         .                     // the interned value contains all the data, so we don't need to
         .                     // distinguish them.
         .                     let index = self.lo_or_index;
    87,969 (0.0%)              with_span_interner(|interner| interner.spans[index as usize])
         .                 }
15,697,632 (0.2%)      }
         .         
         .             /// Returns `true` if this is a dummy span with any hygienic context.
         .             #[inline]
   215,359 (0.0%)      pub fn is_dummy(self) -> bool {
 1,272,512 (0.0%)          if self.len_with_tag_or_marker != BASE_LEN_INTERNED_MARKER {
         .                     // Inline-context or inline-parent format.
         .                     let lo = self.lo_or_index;
         .                     let len = (self.len_with_tag_or_marker & !PARENT_TAG) as u32;
         .                     debug_assert!(len <= MAX_LEN);
 1,330,145 (0.0%)              lo == 0 && len == 0
         .                 } else {
         .                     // Fully-interned or partially-interned format.
         .                     let index = self.lo_or_index;
         .                     let data = with_span_interner(|interner| interner.spans[index as usize]);
         .                     data.lo == BytePos(0) && data.hi == BytePos(0)
         .                 }
   150,808 (0.0%)      }
         .         
         .             // Returns either syntactic context, if it can be retrieved without taking the interner lock,
         .             // or an index into the interner if it cannot.
         .             fn inline_ctxt(self) -> Result<SyntaxContext, usize> {
 2,128,798 (0.0%)          Ok(if self.len_with_tag_or_marker != BASE_LEN_INTERNED_MARKER {
 3,189,995 (0.0%)              if self.len_with_tag_or_marker & PARENT_TAG == 0 {
         .                         // Inline-context format.
         .                         SyntaxContext::from_u32(self.ctxt_or_parent_or_marker as u32)
         .                     } else {
         .                         // Inline-parent format. We know that the SyntaxContext is root.
         .                         SyntaxContext::root()
         .                     }
       498 (0.0%)          } else if self.ctxt_or_parent_or_marker != CTXT_INTERNED_MARKER {
         .                     // Partially-interned format. This path avoids looking up the
         .                     // interned value, and is the whole point of the
         .                     // partially-interned format.
         .                     SyntaxContext::from_u32(self.ctxt_or_parent_or_marker as u32)
         .                 } else {
         .                     // Fully-interned format.
         .                     return Err(self.lo_or_index as usize);
         .                 })
         .             }
         .         
         .             /// This function is used as a fast path when decoding the full `SpanData` is not necessary.
         .             /// It's a cut-down version of `data_untracked`.
         .             #[cfg_attr(not(test), rustc_diagnostic_item = "SpanCtxt")]
         .             #[inline]
 7,395,013 (0.1%)      pub fn ctxt(self) -> SyntaxContext {
         .                 self.inline_ctxt()
         .                     .unwrap_or_else(|index| with_span_interner(|interner| interner.spans[index].ctxt))
 5,355,211 (0.1%)      }
         .         
         .             #[inline]
 2,275,200 (0.0%)      pub fn eq_ctxt(self, other: Span) -> bool {
   380,662 (0.0%)          match (self.inline_ctxt(), other.inline_ctxt()) {
         .                     (Ok(ctxt1), Ok(ctxt2)) => ctxt1 == ctxt2,
         .                     (Ok(ctxt), Err(index)) | (Err(index), Ok(ctxt)) => {
         .                         with_span_interner(|interner| ctxt == interner.spans[index].ctxt)
         .                     }
         .                     (Err(index1), Err(index2)) => with_span_interner(|interner| {
         .                         interner.spans[index1].ctxt == interner.spans[index2].ctxt
         .                     }),
         .                 }
 1,516,800 (0.0%)      }
         .         }
         .         
         .         #[derive(Default)]
         .         pub struct SpanInterner {
         .             spans: FxIndexSet<SpanData>,
         .         }
         .         
         .         impl SpanInterner {
    41,175 (0.0%)      fn intern(&mut self, span_data: &SpanData) -> u32 {
    45,750 (0.0%)          let (index, _) = self.spans.insert_full(*span_data);
         .                 index as u32
    41,175 (0.0%)      }
         .         }
         .         
         .         // If an interner exists, return it. Otherwise, prepare a fresh one.
         .         #[inline]
         .         fn with_span_interner<T, F: FnOnce(&mut SpanInterner) -> T>(f: F) -> T {
    67,796 (0.0%)      crate::with_session_globals(|session_globals| f(&mut session_globals.span_interner.lock()))
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_span/src/symbol.rs
--------------------------------------------------------------------------------
Ir______________ 

  974,796 (0.0%)  <unknown (line 0)>

-- line 2016 ----------------------------------------
        .                 yeet_expr,
        .                 yes,
        .                 yield_expr,
        .                 ymm_reg,
        .                 zmm_reg,
        .             }
        .         }
        .         
  875,340 (0.0%)  #[derive(Copy, Clone, Eq, HashStable_Generic, Encodable, Decodable)]
        .         pub struct Ident {
        .             pub name: Symbol,
        .             pub span: Span,
        .         }
        .         
        .         impl Ident {
        .             #[inline]
        .             /// Constructs a new identifier from a symbol and a span.
        .             pub const fn new(name: Symbol, span: Span) -> Ident {
  986,753 (0.0%)          Ident { name, span }
        .             }
        .         
        .             /// Constructs a new identifier with a dummy span.
        .             #[inline]
        .             pub const fn with_dummy_span(name: Symbol) -> Ident {
        .                 Ident::new(name, DUMMY_SP)
        .             }
        .         
        .             #[inline]
        .             pub fn empty() -> Ident {
        .                 Ident::with_dummy_span(kw::Empty)
        .             }
        .         
        .             /// Maps a string to an identifier with a dummy span.
    3,020 (0.0%)      pub fn from_str(string: &str) -> Ident {
    1,812 (0.0%)          Ident::with_dummy_span(Symbol::intern(string))
    3,020 (0.0%)      }
        .         
        .             /// Maps a string and a span to an identifier.
      678 (0.0%)      pub fn from_str_and_span(string: &str, span: Span) -> Ident {
      339 (0.0%)          Ident::new(Symbol::intern(string), span)
      565 (0.0%)      }
        .         
        .             /// Replaces `lo` and `hi` with those from `span`, but keep hygiene context.
   72,774 (0.0%)      pub fn with_span_pos(self, span: Span) -> Ident {
   40,430 (0.0%)          Ident::new(self.name, span.with_ctxt(self.span.ctxt()))
   64,688 (0.0%)      }
        .         
    2,502 (0.0%)      pub fn without_first_quote(self) -> Ident {
    1,668 (0.0%)          Ident::new(Symbol::intern(self.as_str().trim_start_matches('\'')), self.span)
    2,085 (0.0%)      }
        .         
        .             /// "Normalize" ident for use in comparisons using "item hygiene".
        .             /// Identifiers with same string value become same if they came from the same macro 2.0 macro
        .             /// (e.g., `macro` item, but not `macro_rules` item) and stay different if they came from
        .             /// different macro 2.0 macros.
        .             /// Technically, this operation strips all non-opaque marks from ident's syntactic context.
1,466,145 (0.0%)      pub fn normalize_to_macros_2_0(self) -> Ident {
  488,715 (0.0%)          Ident::new(self.name, self.span.normalize_to_macros_2_0())
1,466,145 (0.0%)      }
        .         
        .             /// "Normalize" ident for use in comparisons using "local variable hygiene".
        .             /// Identifiers with same string value become same if they came from the same non-transparent
        .             /// macro (e.g., `macro` or `macro_rules!` items) and stay different if they came from different
        .             /// non-transparent macros.
        .             /// Technically, this operation strips all transparent marks from ident's syntactic context.
        .             #[inline]
        .             pub fn normalize_to_macro_rules(self) -> Ident {
-- line 2082 ----------------------------------------
-- line 2083 ----------------------------------------
        .                 Ident::new(self.name, self.span.normalize_to_macro_rules())
        .             }
        .         
        .             /// Access the underlying string. This is a slowish operation because it
        .             /// requires locking the symbol interner.
        .             ///
        .             /// Note that the lifetime of the return value is a lie. See
        .             /// `Symbol::as_str()` for details.
   59,112 (0.0%)      pub fn as_str(&self) -> &str {
   60,780 (0.0%)          self.name.as_str()
        .             }
        .         }
        .         
        .         impl PartialEq for Ident {
        .             #[inline]
    5,848 (0.0%)      fn eq(&self, rhs: &Self) -> bool {
  891,064 (0.0%)          self.name == rhs.name && self.span.eq_ctxt(rhs.span)
    5,848 (0.0%)      }
        .         }
        .         
        .         impl Hash for Ident {
   12,132 (0.0%)      fn hash<H: Hasher>(&self, state: &mut H) {
        .                 self.name.hash(state);
  426,451 (0.0%)          self.span.ctxt().hash(state);
   10,784 (0.0%)      }
        .         }
        .         
        .         impl fmt::Debug for Ident {
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 fmt::Display::fmt(self, f)?;
        .                 fmt::Debug::fmt(&self.span.ctxt(), f)
        .             }
        .         }
        .         
        .         /// This implementation is supposed to be used in error messages, so it's expected to be identical
        .         /// to printing the original identifier token written in source code (`token_to_string`),
        .         /// except that AST identifiers don't keep the rawness flag, so we have to guess it.
        .         impl fmt::Display for Ident {
   27,615 (0.0%)      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   11,835 (0.0%)          fmt::Display::fmt(&IdentPrinter::new(self.name, self.is_raw_guess(), None), f)
   27,615 (0.0%)      }
        .         }
        .         
        .         /// The most general type to print identifiers.
        .         ///
        .         /// AST pretty-printer is used as a fallback for turning AST structures into token streams for
        .         /// proc macros. Additionally, proc macros may stringify their input and expect it survive the
        .         /// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).
        .         /// So we need to somehow pretty-print `$crate` in a way preserving at least some of its
-- line 2131 ----------------------------------------
-- line 2142 ----------------------------------------
        .             /// Span used for retrieving the crate name to which `$crate` refers to,
        .             /// if this field is `None` then the `$crate` conversion doesn't happen.
        .             convert_dollar_crate: Option<Span>,
        .         }
        .         
        .         impl IdentPrinter {
        .             /// The most general `IdentPrinter` constructor. Do not use this.
        .             pub fn new(symbol: Symbol, is_raw: bool, convert_dollar_crate: Option<Span>) -> IdentPrinter {
   43,712 (0.0%)          IdentPrinter { symbol, is_raw, convert_dollar_crate }
        .             }
        .         
        .             /// This implementation is supposed to be used when printing identifiers
        .             /// as a part of pretty-printing for larger AST pieces.
        .             /// Do not use this either.
        .             pub fn for_ast_ident(ident: Ident, is_raw: bool) -> IdentPrinter {
        .                 IdentPrinter::new(ident.name, is_raw, Some(ident.span))
        .             }
        .         }
        .         
        .         impl fmt::Display for IdentPrinter {
   92,920 (0.0%)      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   18,584 (0.0%)          if self.is_raw {
        .                     f.write_str("r#")?;
   18,584 (0.0%)          } else if self.symbol == kw::DollarCrate {
        .                     if let Some(span) = self.convert_dollar_crate {
        .                         let converted = span.ctxt().dollar_crate_name();
        .                         if !converted.is_path_segment_keyword() {
        .                             f.write_str("::")?;
        .                         }
        .                         return fmt::Display::fmt(&converted, f);
        .                     }
        .                 }
    9,292 (0.0%)          fmt::Display::fmt(&self.symbol, f)
        .             }
        .         }
        .         
        .         /// An newtype around `Ident` that calls [Ident::normalize_to_macro_rules] on
        .         /// construction.
        .         // FIXME(matthewj, petrochenkov) Use this more often, add a similar
        .         // `ModernIdent` struct and use that as well.
        .         #[derive(Copy, Clone, Eq, PartialEq, Hash)]
        .         pub struct MacroRulesNormalizedIdent(Ident);
        .         
        .         impl MacroRulesNormalizedIdent {
  565,290 (0.0%)      pub fn new(ident: Ident) -> Self {
  314,050 (0.0%)          Self(ident.normalize_to_macro_rules())
  565,290 (0.0%)      }
        .         }
        .         
        .         impl fmt::Debug for MacroRulesNormalizedIdent {
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 fmt::Debug::fmt(&self.0, f)
        .             }
        .         }
        .         
-- line 2196 ----------------------------------------
-- line 2204 ----------------------------------------
        .         ///
        .         /// Internally, a `Symbol` is implemented as an index, and all operations
        .         /// (including hashing, equality, and ordering) operate on that index. The use
        .         /// of `rustc_index::newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,
        .         /// because `rustc_index::newtype_index!` reserves the last 256 values for tagging purposes.
        .         ///
        .         /// Note that `Symbol` cannot directly be a `rustc_index::newtype_index!` because it
        .         /// implements `fmt::Debug`, `Encodable`, and `Decodable` in special ways.
  154,176 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
        .         pub struct Symbol(SymbolIndex);
        .         
3,431,468 (0.0%)  rustc_index::newtype_index! {
        .             #[orderable]
        .             struct SymbolIndex {}
        .         }
        .         
        .         impl Symbol {
        .             const fn new(n: u32) -> Self {
        .                 Symbol(SymbolIndex::from_u32(n))
        .             }
        .         
        .             /// for use in Decoder only
        .             pub fn new_from_decoded(n: u32) -> Self {
        .                 Self::new(n)
  410,976 (0.0%)      }
        .         
        .             /// Maps a string to its interned representation.
3,660,417 (0.0%)      pub fn intern(string: &str) -> Self {
        .                 with_session_globals(|session_globals| session_globals.symbol_interner.intern(string))
3,660,417 (0.0%)      }
        .         
        .             /// Access the underlying string. This is a slowish operation because it
        .             /// requires locking the symbol interner.
        .             ///
        .             /// Note that the lifetime of the return value is a lie. It's not the same
        .             /// as `&self`, but actually tied to the lifetime of the underlying
        .             /// interner. Interners are long-lived, and there are very few of them, and
        .             /// this function is typically used for short-lived things, so in practice
        .             /// it works out ok.
4,303,440 (0.1%)      pub fn as_str(&self) -> &str {
        .                 with_session_globals(|session_globals| unsafe {
        .                     std::mem::transmute::<&str, &str>(session_globals.symbol_interner.get(*self))
        .                 })
5,020,680 (0.1%)      }
        .         
        .             pub fn as_u32(self) -> u32 {
        .                 self.0.as_u32()
        .             }
        .         
        .             pub fn is_empty(self) -> bool {
        .                 self == kw::Empty
        .             }
-- line 2255 ----------------------------------------
-- line 2265 ----------------------------------------
        .         
        .         impl fmt::Debug for Symbol {
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 fmt::Debug::fmt(self.as_str(), f)
        .             }
        .         }
        .         
        .         impl fmt::Display for Symbol {
  370,045 (0.0%)      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  712,868 (0.0%)          fmt::Display::fmt(self.as_str(), f)
        .             }
        .         }
        .         
        .         // takes advantage of `str::to_string` specialization
        .         impl ToString for Symbol {
    5,418 (0.0%)      fn to_string(&self) -> String {
    2,408 (0.0%)          self.as_str().to_string()
    5,418 (0.0%)      }
        .         }
        .         
        .         impl<CTX> HashStable<CTX> for Symbol {
        .             #[inline]
        .             fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {
  216,998 (0.0%)          self.as_str().hash_stable(hcx, hasher);
        .             }
        .         }
        .         
        .         impl<CTX> ToStableHashKey<CTX> for Symbol {
        .             type KeyType = String;
        .             #[inline]
        .             fn to_stable_hash_key(&self, _: &CTX) -> String {
        .                 self.as_str().to_string()
-- line 2296 ----------------------------------------
-- line 2314 ----------------------------------------
        .         // between `Interner`s.
        .         struct InternerInner {
        .             arena: DroplessArena,
        .             strings: FxIndexSet<&'static str>,
        .         }
        .         
        .         impl Interner {
        .             fn prefill(init: &[&'static str]) -> Self {
       26 (0.0%)          Interner(Lock::new(InternerInner {
        .                     arena: Default::default(),
        .                     strings: init.iter().copied().collect(),
        .                 }))
        .             }
        .         
        .             #[inline]
        .             fn intern(&self, string: &str) -> Symbol {
        .                 let mut inner = self.0.lock();
-- line 2330 ----------------------------------------
-- line 2346 ----------------------------------------
        .         
        .                 Symbol::new(idx as u32)
        .             }
        .         
        .             /// Get the symbol as a string.
        .             ///
        .             /// [`Symbol::as_str()`] should be used in preference to this function.
        .             fn get(&self, symbol: Symbol) -> &str {
2,868,960 (0.0%)          self.0.lock().strings.get_index(symbol.0.as_usize()).unwrap()
        .             }
        .         }
        .         
        .         // This module has a very short name because it's used a lot.
        .         /// This module contains all the defined keyword `Symbol`s.
        .         ///
        .         /// Given that `kw` is imported, use them like `kw::keyword_name`.
        .         /// For example `kw::Loop` or `kw::Break`.
-- line 2362 ----------------------------------------
-- line 2379 ----------------------------------------
        .             pub use super::kw::MacroRules as macro_rules;
        .         
        .             /// Get the symbol for an integer.
        .             ///
        .             /// The first few non-negative integers each have a static symbol and therefore
        .             /// are fast.
        .             pub fn integer<N: TryInto<usize> + Copy + itoa::Integer>(n: N) -> Symbol {
        .                 if let Result::Ok(idx) = n.try_into() {
    1,376 (0.0%)              if idx < 10 {
    1,295 (0.0%)                  return Symbol::new(super::SYMBOL_DIGITS_BASE + idx as u32);
        .                     }
        .                 }
        .                 let mut buffer = itoa::Buffer::new();
        .                 let printed = buffer.format(n);
      555 (0.0%)          Symbol::intern(printed)
        .             }
        .         }
        .         
        .         impl Symbol {
        .             fn is_special(self) -> bool {
        .                 self <= kw::Underscore
        .             }
        .         
-- line 2401 ----------------------------------------
-- line 2407 ----------------------------------------
        .                 (self >= kw::Async && self <= kw::Dyn) && edition() >= Edition::Edition2018
        .             }
        .         
        .             fn is_unused_keyword_always(self) -> bool {
        .                 self >= kw::Abstract && self <= kw::Yield
        .             }
        .         
        .             fn is_unused_keyword_conditional(self, edition: impl Copy + FnOnce() -> Edition) -> bool {
  548,448 (0.0%)          self == kw::Try && edition().at_least_rust_2018()
        .                     || self == kw::Gen && edition().at_least_rust_2024()
        .             }
        .         
        .             pub fn is_reserved(self, edition: impl Copy + FnOnce() -> Edition) -> bool {
        .                 self.is_special()
        .                     || self.is_used_keyword_always()
        .                     || self.is_unused_keyword_always()
      204 (0.0%)              || self.is_used_keyword_conditional(edition)
        .                     || self.is_unused_keyword_conditional(edition)
        .             }
        .         
        .             /// A keyword or reserved identifier that can be used as a path segment.
        .             pub fn is_path_segment_keyword(self) -> bool {
1,462,860 (0.0%)          self == kw::Super
        .                     || self == kw::SelfLower
        .                     || self == kw::SelfUpper
        .                     || self == kw::Crate
        .                     || self == kw::PathRoot
        .                     || self == kw::DollarCrate
        .             }
        .         
        .             /// Returns `true` if the symbol is `true` or `false`.
        .             pub fn is_bool_lit(self) -> bool {
   85,159 (0.0%)          self == kw::True || self == kw::False
        .             }
        .         
        .             /// Returns `true` if this symbol can be a raw identifier.
       10 (0.0%)      pub fn can_be_raw(self) -> bool {
   14,346 (0.0%)          self != kw::Empty && self != kw::Underscore && !self.is_path_segment_keyword()
       10 (0.0%)      }
        .         
        .             /// Is this symbol was interned in compiler's `symbols!` macro
        .             pub fn is_preinterned(self) -> bool {
        .                 self.as_u32() < PREINTERNED_SYMBOLS_COUNT
        .             }
        .         }
        .         
        .         impl Ident {
-- line 2453 ----------------------------------------
-- line 2455 ----------------------------------------
        .             /// unnamed method parameters, crate root module, error recovery etc.
        .             pub fn is_special(self) -> bool {
        .                 self.name.is_special()
        .             }
        .         
        .             /// Returns `true` if the token is a keyword used in the language.
        .             pub fn is_used_keyword(self) -> bool {
        .                 // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
    6,132 (0.0%)          self.name.is_used_keyword_always()
        .                     || self.name.is_used_keyword_conditional(|| self.span.edition())
    3,066 (0.0%)      }
        .         
        .             /// Returns `true` if the token is a keyword reserved for possible future use.
    6,132 (0.0%)      pub fn is_unused_keyword(self) -> bool {
        .                 // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
    6,132 (0.0%)          self.name.is_unused_keyword_always()
    3,066 (0.0%)              || self.name.is_unused_keyword_conditional(|| self.span.edition())
    6,132 (0.0%)      }
        .         
        .             /// Returns `true` if the token is either a special identifier or a keyword.
  844,866 (0.0%)      pub fn is_reserved(self) -> bool {
        .                 // Note: `span.edition()` is relatively expensive, don't call it unless necessary.
  411,927 (0.0%)          self.name.is_reserved(|| self.span.edition())
  985,677 (0.0%)      }
        .         
        .             /// A keyword or reserved identifier that can be used as a path segment.
  487,620 (0.0%)      pub fn is_path_segment_keyword(self) -> bool {
  243,810 (0.0%)          self.name.is_path_segment_keyword()
  487,620 (0.0%)      }
        .         
        .             /// We see this identifier in a normal identifier position, like variable name or a type.
        .             /// How was it written originally? Did it use the raw form? Let's try to guess.
    6,348 (0.0%)      pub fn is_raw_guess(self) -> bool {
    9,444 (0.0%)          self.name.can_be_raw() && self.is_reserved()
      117 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_trait_selection/src/traits/auto_trait.rs
--------------------------------------------------------------------------------
Ir______________ 

1,522,749 (0.0%)  <unknown (line 0)>

-- line 12 ----------------------------------------
        .         use rustc_infer::infer::DefineOpaqueTypes;
        .         use rustc_middle::mir::interpret::ErrorHandled;
        .         use rustc_middle::ty::{Region, RegionVid};
        .         
        .         use std::collections::VecDeque;
        .         use std::iter;
        .         
        .         // FIXME(twk): this is obviously not nice to duplicate like that
   58,572 (0.0%)  #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]
        .         pub enum RegionTarget<'tcx> {
        .             Region(Region<'tcx>),
        .             RegionVid(RegionVid),
        .         }
        .         
   13,968 (0.0%)  #[derive(Default, Debug, Clone)]
        .         pub struct RegionDeps<'tcx> {
        .             pub larger: FxIndexSet<RegionTarget<'tcx>>,
        .             pub smaller: FxIndexSet<RegionTarget<'tcx>>,
        .         }
        .         
        .         pub enum AutoTraitResult<A> {
        .             ExplicitImpl,
        .             PositiveImpl(A),
-- line 34 ----------------------------------------
-- line 42 ----------------------------------------
        .         }
        .         
        .         pub struct AutoTraitFinder<'tcx> {
        .             tcx: TyCtxt<'tcx>,
        .         }
        .         
        .         impl<'tcx> AutoTraitFinder<'tcx> {
        .             pub fn new(tcx: TyCtxt<'tcx>) -> Self {
      406 (0.0%)          AutoTraitFinder { tcx }
        .             }
        .         
        .             /// Makes a best effort to determine whether and under which conditions an auto trait is
        .             /// implemented for a type. For example, if you have
        .             ///
        .             /// ```
        .             /// struct Foo<T> { data: Box<T> }
        .             /// ```
-- line 58 ----------------------------------------
-- line 70 ----------------------------------------
        .             /// in the future.
        .             pub fn find_auto_trait_generics<A>(
        .                 &self,
        .                 ty: Ty<'tcx>,
        .                 orig_env: ty::ParamEnv<'tcx>,
        .                 trait_did: DefId,
        .                 mut auto_trait_callback: impl FnMut(AutoTraitInfo<'tcx>) -> A,
        .             ) -> AutoTraitResult<A> {
    2,340 (0.0%)          let tcx = self.tcx;
        .         
        .                 let trait_ref = ty::TraitRef::new(tcx, trait_did, [ty]);
        .         
    3,510 (0.0%)          let infcx = tcx.infer_ctxt().build();
        .                 let mut selcx = SelectionContext::new(&infcx);
    5,850 (0.0%)          for polarity in [ty::PredicatePolarity::Positive, ty::PredicatePolarity::Negative] {
    9,204 (0.0%)              let result = selcx.select(&Obligation::new(
        .                         tcx,
        .                         ObligationCause::dummy(),
    2,301 (0.0%)                  orig_env,
        .                         ty::TraitPredicate { trait_ref, polarity },
        .                     ));
    7,355 (0.0%)              if let Ok(Some(ImplSource::UserDefined(_))) = result {
        .                         debug!(
        .                             "find_auto_trait_generics({:?}): \
        .                          manual impl found, bailing out",
        .                             trait_ref
        .                         );
        .                         // If an explicit impl exists, it always takes priority over an auto impl
        .                         return AutoTraitResult::ExplicitImpl;
        .                     }
        .                 }
        .         
    3,393 (0.0%)          let infcx = tcx.infer_ctxt().build();
        .                 let mut fresh_preds = FxIndexSet::default();
        .         
        .                 // Due to the way projections are handled by SelectionContext, we need to run
        .                 // evaluate_predicates twice: once on the original param env, and once on the result of
        .                 // the first evaluate_predicates call.
        .                 //
        .                 // The problem is this: most of rustc, including SelectionContext and traits::project,
        .                 // are designed to work with a concrete usage of a type (e.g., Vec<u8>
-- line 110 ----------------------------------------
-- line 130 ----------------------------------------
        .                 // them between calls.
        .                 //
        .                 // We fix the second assumption by reprocessing the result of our first call to
        .                 // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first
        .                 // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,
        .                 // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing
        .                 // SelectionContext to return it back to us.
        .         
    1,131 (0.0%)          let Some((new_env, user_env)) =
   15,834 (0.0%)              self.evaluate_predicates(&infcx, trait_did, ty, orig_env, orig_env, &mut fresh_preds)
        .                 else {
        .                     return AutoTraitResult::NegativeImpl;
        .                 };
        .         
    5,664 (0.0%)          let (full_env, full_user_env) = self
    3,776 (0.0%)              .evaluate_predicates(&infcx, trait_did, ty, new_env, user_env, &mut fresh_preds)
        .                     .unwrap_or_else(|| {
        .                         panic!("Failed to fully process: {ty:?} {trait_did:?} {orig_env:?}")
        .                     });
        .         
        .                 debug!(
        .                     "find_auto_trait_generics({:?}): fulfilling \
        .                      with {:?}",
        .                     trait_ref, full_env
        .                 );
      944 (0.0%)          infcx.clear_caches();
        .         
        .                 // At this point, we already have all of the bounds we need. FulfillmentContext is used
        .                 // to store all of the necessary region/lifetime bounds in the InferContext, as well as
        .                 // an additional sanity check.
      944 (0.0%)          let ocx = ObligationCtxt::new(&infcx);
    6,608 (0.0%)          ocx.register_bound(ObligationCause::dummy(), full_env, ty, trait_did);
    1,888 (0.0%)          let errors = ocx.select_all_or_error();
    1,888 (0.0%)          if !errors.is_empty() {
        .                     panic!("Unable to fulfill trait {trait_did:?} for '{ty:?}': {errors:?}");
        .                 }
        .         
        .                 let outlives_env = OutlivesEnvironment::new(full_env);
      658 (0.0%)          let _ = infcx.process_registered_region_obligations(&outlives_env, |ty, _| Ok(ty));
        .         
        .                 let region_data =
        .                     infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();
        .         
    1,888 (0.0%)          let vid_to_region = self.map_vid_to_region(&region_data);
        .         
   16,992 (0.0%)          let info = AutoTraitInfo { full_user_env, region_data, vid_to_region };
        .         
   21,712 (0.0%)          AutoTraitResult::PositiveImpl(auto_trait_callback(info))
   10,757 (0.0%)      }
        .         }
        .         
        .         impl<'tcx> AutoTraitFinder<'tcx> {
        .             /// The core logic responsible for computing the bounds for our synthesized impl.
        .             ///
        .             /// To calculate the bounds, we call `SelectionContext.select` in a loop. Like
        .             /// `FulfillmentContext`, we recursively select the nested obligations of predicates we
        .             /// encounter. However, whenever we encounter an `UnimplementedError` involving a type
-- line 186 ----------------------------------------
-- line 213 ----------------------------------------
        .             /// have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the
        .             /// `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our
        .             /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate`, or
        .             /// else `SelectionContext` will choke on the missing predicates. However, this should never
        .             /// show up in the final synthesized generics: we don't want our generated docs page to contain
        .             /// something like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a
        .             /// separate `user_env`, which only holds the predicates that will actually be displayed to the
        .             /// user.
   26,975 (0.0%)      fn evaluate_predicates(
        .                 &self,
        .                 infcx: &InferCtxt<'tcx>,
        .                 trait_did: DefId,
        .                 ty: Ty<'tcx>,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 user_env: ty::ParamEnv<'tcx>,
        .                 fresh_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,
        .             ) -> Option<(ty::ParamEnv<'tcx>, ty::ParamEnv<'tcx>)> {
    2,075 (0.0%)          let tcx = infcx.tcx;
        .         
        .                 // Don't try to process any nested obligations involving predicates
        .                 // that are already in the `ParamEnv` (modulo regions): we already
        .                 // know that they must hold.
        .                 for predicate in param_env.caller_bounds() {
    3,478 (0.0%)              fresh_preds.insert(self.clean_pred(infcx, predicate.as_predicate()));
        .                 }
        .         
        .                 let mut select = SelectionContext::new(infcx);
        .         
        .                 let mut already_visited = UnordSet::new();
        .                 let mut predicates = VecDeque::new();
   10,375 (0.0%)          predicates.push_back(ty::Binder::dummy(ty::TraitPredicate {
    4,188 (0.0%)              trait_ref: ty::TraitRef::new(infcx.tcx, trait_did, [ty]),
        .         
        .                     // Auto traits are positive
        .                     polarity: ty::PredicatePolarity::Positive,
        .                 }));
        .         
        .                 let computed_preds = param_env.caller_bounds().iter().map(|c| c.as_predicate());
        .                 let mut user_computed_preds: FxIndexSet<_> =
        .                     user_env.caller_bounds().iter().map(|c| c.as_predicate()).collect();
        .         
        .                 let mut new_env = param_env;
        .                 let dummy_cause = ObligationCause::dummy();
        .         
1,224,391 (0.0%)          while let Some(pred) = predicates.pop_front() {
  174,913 (0.0%)              infcx.clear_caches();
        .         
  874,565 (0.0%)              if !already_visited.insert(pred) {
        .                         continue;
        .                     }
        .         
        .                     // Call `infcx.resolve_vars_if_possible` to see if we can
        .                     // get rid of any inference variables.
        .                     let obligation = infcx.resolve_vars_if_possible(Obligation::new(
        .                         tcx,
        .                         dummy_cause.clone(),
        .                         new_env,
  373,665 (0.0%)                  pred,
        .                     ));
  298,932 (0.0%)              let result = select.poly_select(&obligation);
        .         
  479,281 (0.0%)              match result {
        .                         Ok(Some(ref impl_source)) => {
        .                             // If we see an explicit negative impl (e.g., `impl !Send for MyStruct`),
        .                             // we immediately bail out, since it's impossible for us to continue.
        .         
        .                             if let ImplSource::UserDefined(ImplSourceUserDefinedData {
        .                                 impl_def_id, ..
        .                             }) = impl_source
        .                             {
        .                                 // Blame 'tidy' for the weird bracket placement.
   68,796 (0.0%)                          if infcx.tcx.impl_polarity(*impl_def_id) != ty::ImplPolarity::Positive {
        .                                     debug!(
        .                                         "evaluate_nested_obligations: found explicit negative impl\
        .                                                 {:?}, bailing out",
        .                                         impl_def_id
        .                                     );
        .                                     return None;
        .                                 }
        .                             }
        .         
        .                             let obligations = impl_source.borrow_nested_obligations().iter().cloned();
        .         
        .                             if !self.evaluate_nested_obligations(
  147,452 (0.0%)                          ty,
        .                                 obligations,
        .                                 &mut user_computed_preds,
        .                                 fresh_preds,
        .                                 &mut predicates,
        .                                 &mut select,
        .                             ) {
        .                                 return None;
        .                             }
        .                         }
        .                         Ok(None) => {}
        .                         Err(SelectionError::Unimplemented) => {
    3,021 (0.0%)                      if self.is_param_no_infer(pred.skip_binder().trait_ref.args) {
        .                                 already_visited.remove(&pred);
   13,940 (0.0%)                          self.add_user_pred(&mut user_computed_preds, pred.to_predicate(self.tcx));
        .                                 predicates.push_back(pred);
        .                             } else {
        .                                 debug!(
        .                                     "evaluate_nested_obligations: `Unimplemented` found, bailing: \
        .                                      {:?} {:?} {:?}",
        .                                     ty,
        .                                     pred,
        .                                     pred.skip_binder().trait_ref.args
-- line 319 ----------------------------------------
-- line 320 ----------------------------------------
        .                                 );
        .                                 return None;
        .                             }
        .                         }
        .                         _ => panic!("Unexpected error for '{ty:?}': {result:?}"),
        .                     };
        .         
        .                     let normalized_preds =
  298,184 (0.0%)                  elaborate(tcx, computed_preds.clone().chain(user_computed_preds.iter().cloned()));
        .                     new_env = ty::ParamEnv::new(
  716,682 (0.0%)                  tcx.mk_clauses_from_iter(normalized_preds.filter_map(|p| p.as_clause())),
        .                         param_env.reveal(),
        .                     );
        .                 }
        .         
        .                 let final_user_env = ty::ParamEnv::new(
   12,282 (0.0%)              tcx.mk_clauses_from_iter(user_computed_preds.into_iter().filter_map(|p| p.as_clause())),
        .                     user_env.reveal(),
        .                 );
        .                 debug!(
        .                     "evaluate_nested_obligations(ty={:?}, trait_did={:?}): succeeded with '{:?}' \
        .                      '{:?}'",
        .                     ty, trait_did, new_env, final_user_env
        .                 );
        .         
        .                 Some((new_env, final_user_env))
   29,611 (0.0%)      }
        .         
        .             /// This method is designed to work around the following issue:
        .             /// When we compute auto trait bounds, we repeatedly call `SelectionContext.select`,
        .             /// progressively building a `ParamEnv` based on the results we get.
        .             /// However, our usage of `SelectionContext` differs from its normal use within the compiler,
        .             /// in that we capture and re-reprocess predicates from `Unimplemented` errors.
        .             ///
        .             /// This can lead to a corner case when dealing with region parameters.
-- line 354 ----------------------------------------
-- line 363 ----------------------------------------
        .             /// If we put both of these predicates in our computed `ParamEnv`, we'll
        .             /// confuse `SelectionContext`, since it will (correctly) view both as being applicable.
        .             ///
        .             /// To solve this, we pick the 'more strict' lifetime bound -- i.e., the HRTB
        .             /// Our end goal is to generate a user-visible description of the conditions
        .             /// under which a type implements an auto trait. A trait predicate involving
        .             /// a HRTB means that the type needs to work with any choice of lifetime,
        .             /// not just one specific lifetime (e.g., `'static`).
    8,200 (0.0%)      fn add_user_pred(
        .                 &self,
        .                 user_computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,
        .                 new_pred: ty::Predicate<'tcx>,
        .             ) {
    4,100 (0.0%)          let mut should_add_new = true;
        .                 user_computed_preds.retain(|&old_pred| {
   19,570 (0.0%)              if let (
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Trait(new_trait)),
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Trait(old_trait)),
    3,914 (0.0%)              ) = (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())
        .                     {
        .                         if new_trait.def_id() == old_trait.def_id() {
        .                             let new_args = new_trait.trait_ref.args;
        .                             let old_args = old_trait.trait_ref.args;
        .         
        .                             if !new_args.types().eq(old_args.types()) {
        .                                 // We can't compare lifetimes if the types are different,
        .                                 // so skip checking `old_pred`.
-- line 389 ----------------------------------------
-- line 444 ----------------------------------------
        .                                     _ => {}
        .                                 }
        .                             }
        .                         }
        .                     }
        .                     true
        .                 });
        .         
    1,640 (0.0%)          if should_add_new {
      820 (0.0%)              user_computed_preds.insert(new_pred);
        .                 }
    6,560 (0.0%)      }
        .         
        .             /// This is very similar to `handle_lifetimes`. However, instead of matching `ty::Region`s
        .             /// to each other, we match `ty::RegionVid`s to `ty::Region`s.
    8,496 (0.0%)      fn map_vid_to_region<'cx>(
        .                 &self,
        .                 regions: &RegionConstraintData<'cx>,
        .             ) -> FxIndexMap<ty::RegionVid, ty::Region<'cx>> {
        .                 let mut vid_map = FxIndexMap::<RegionTarget<'cx>, RegionDeps<'cx>>::default();
        .                 let mut finished_map = FxIndexMap::default();
        .         
    1,064 (0.0%)          for (constraint, _) in &regions.constraints {
    3,192 (0.0%)              match constraint {
      108 (0.0%)                  &Constraint::VarSubVar(r1, r2) => {
        .                             {
      432 (0.0%)                          let deps1 = vid_map.entry(RegionTarget::RegionVid(r1)).or_default();
      270 (0.0%)                          deps1.larger.insert(RegionTarget::RegionVid(r2));
        .                             }
        .         
      108 (0.0%)                      let deps2 = vid_map.entry(RegionTarget::RegionVid(r2)).or_default();
        .                             deps2.smaller.insert(RegionTarget::RegionVid(r1));
        .                         }
      936 (0.0%)                  &Constraint::RegSubVar(region, vid) => {
        .                             {
    3,744 (0.0%)                          let deps1 = vid_map.entry(RegionTarget::Region(region)).or_default();
    2,340 (0.0%)                          deps1.larger.insert(RegionTarget::RegionVid(vid));
        .                             }
        .         
    1,404 (0.0%)                      let deps2 = vid_map.entry(RegionTarget::RegionVid(vid)).or_default();
        .                             deps2.smaller.insert(RegionTarget::Region(region));
        .                         }
      738 (0.0%)                  &Constraint::VarSubReg(vid, region) => {
        .                             finished_map.insert(vid, region);
        .                         }
        .                         &Constraint::RegSubReg(r1, r2) => {
        .                             {
        .                                 let deps1 = vid_map.entry(RegionTarget::Region(r1)).or_default();
        .                                 deps1.larger.insert(RegionTarget::Region(r2));
        .                             }
        .         
        .                             let deps2 = vid_map.entry(RegionTarget::Region(r2)).or_default();
        .                             deps2.smaller.insert(RegionTarget::Region(r1));
        .                         }
        .                     }
        .                 }
        .         
    1,524 (0.0%)          while !vid_map.is_empty() {
    2,568 (0.0%)              let target = *vid_map.keys().next().unwrap();
        .                     let deps = vid_map.swap_remove(&target).unwrap();
        .         
      642 (0.0%)              for smaller in deps.smaller.iter() {
        .                         for larger in deps.larger.iter() {
      270 (0.0%)                      match (smaller, larger) {
        .                                 (&RegionTarget::Region(_), &RegionTarget::Region(_)) => {
        .                                     if let IndexEntry::Occupied(v) = vid_map.entry(*smaller) {
        .                                         let smaller_deps = v.into_mut();
        .                                         smaller_deps.larger.insert(*larger);
        .                                         smaller_deps.larger.swap_remove(&target);
        .                                     }
        .         
        .                                     if let IndexEntry::Occupied(v) = vid_map.entry(*larger) {
-- line 515 ----------------------------------------
-- line 520 ----------------------------------------
        .                                 }
        .                                 (&RegionTarget::RegionVid(v1), &RegionTarget::Region(r1)) => {
        .                                     finished_map.insert(v1, r1);
        .                                 }
        .                                 (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {
        .                                     // Do nothing; we don't care about regions that are smaller than vids.
        .                                 }
        .                                 (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {
      513 (0.0%)                              if let IndexEntry::Occupied(v) = vid_map.entry(*smaller) {
       27 (0.0%)                                  let smaller_deps = v.into_mut();
      135 (0.0%)                                  smaller_deps.larger.insert(*larger);
       81 (0.0%)                                  smaller_deps.larger.swap_remove(&target);
        .                                     }
        .         
      243 (0.0%)                              if let IndexEntry::Occupied(v) = vid_map.entry(*larger) {
       54 (0.0%)                                  let larger_deps = v.into_mut();
      243 (0.0%)                                  larger_deps.smaller.insert(*smaller);
        .                                         larger_deps.smaller.swap_remove(&target);
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                     }
    1,284 (0.0%)          }
        .         
   12,272 (0.0%)          finished_map
    7,552 (0.0%)      }
        .         
    8,280 (0.0%)      fn is_param_no_infer(&self, args: GenericArgsRef<'_>) -> bool {
        .                 self.is_of_param(args.type_at(0)) && !args.types().any(|t| t.has_infer_types())
    6,210 (0.0%)      }
        .         
        .             pub fn is_of_param(&self, ty: Ty<'_>) -> bool {
    5,805 (0.0%)          match ty.kind() {
        .                     ty::Param(_) => true,
      424 (0.0%)              ty::Alias(ty::Projection, p) => self.is_of_param(p.self_ty()),
        .                     _ => false,
        .                 }
        .             }
        .         
        .             fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {
        .                 if let Some(ty) = p.term().skip_binder().ty() {
        .                     matches!(ty.kind(), ty::Alias(ty::Projection, proj) if proj == &p.skip_binder().projection_ty)
        .                 } else {
-- line 563 ----------------------------------------
-- line 571 ----------------------------------------
        .                 nested: impl Iterator<Item = PredicateObligation<'tcx>>,
        .                 computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,
        .                 fresh_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,
        .                 predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,
        .                 selcx: &mut SelectionContext<'_, 'tcx>,
        .             ) -> bool {
        .                 let dummy_cause = ObligationCause::dummy();
        .         
  875,945 (0.0%)          for obligation in nested {
        .                     let is_new_pred =
  350,378 (0.0%)                  fresh_preds.insert(self.clean_pred(selcx.infcx, obligation.predicate));
        .         
        .                     // Resolve any inference variables that we can, to help selection succeed
  175,217 (0.0%)              let predicate = selcx.infcx.resolve_vars_if_possible(obligation.predicate);
        .         
        .                     // We only add a predicate as a user-displayable bound if
        .                     // it involves a generic parameter, and doesn't contain
        .                     // any inference variables.
        .                     //
        .                     // Displaying a bound involving a concrete type (instead of a generic
        .                     // parameter) would be pointless, since it's always true
        .                     // (e.g. u8: Copy)
        .                     // Displaying an inference variable is impossible, since they're
        .                     // an internal compiler detail without a defined visual representation
        .                     //
        .                     // We check this by calling is_of_param on the relevant types
        .                     // from the various possible predicates
        .         
        .                     let bound_predicate = predicate.kind();
2,102,268 (0.0%)              match bound_predicate.skip_binder() {
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Trait(p)) => {
        .                             // Add this to `predicates` so that we end up calling `select`
        .                             // with it. If this predicate ends up being unimplemented,
        .                             // then `evaluate_predicates` will handle adding it the `ParamEnv`
        .                             // if possible.
        .                             predicates.push_back(bound_predicate.rebind(p));
        .                         }
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Projection(p)) => {
-- line 608 ----------------------------------------
-- line 612 ----------------------------------------
        .                                 predicate
        .                             );
        .         
        .                             // As described above, we only want to display
        .                             // bounds which include a generic parameter but don't include
        .                             // an inference variable.
        .                             // Additionally, we check if we've seen this predicate before,
        .                             // to avoid rendering duplicate bounds to the user.
      112 (0.0%)                      if self.is_param_no_infer(p.skip_binder().projection_ty.args)
        .                                 && !p.term().skip_binder().has_infer_types()
        .                                 && is_new_pred
        .                             {
        .                                 debug!(
        .                                     "evaluate_nested_obligations: adding projection predicate \
        .                                     to computed_preds: {:?}",
        .                                     predicate
        .                                 );
-- line 628 ----------------------------------------
-- line 684 ----------------------------------------
        .                             // However, through some **interesting** manipulations of the type
        .                             // system, it's actually possible to write a type that never
        .                             // implements an auto trait due to a projection error, not a normal
        .                             // negative impl error. To properly handle this case, we need
        .                             // to ensure that we catch any potential projection errors,
        .                             // and turn them into an explicit negative impl for our type.
        .                             debug!("Projecting and unifying projection predicate {:?}", predicate);
        .         
      196 (0.0%)                      match project::poly_project_and_unify_type(selcx, &obligation.with(self.tcx, p))
        .                             {
        .                                 ProjectAndUnifyResult::MismatchedProjectionTypes(e) => {
        .                                     debug!(
        .                                         "evaluate_nested_obligations: Unable to unify predicate \
        .                                          '{:?}' '{:?}', bailing out",
        .                                         ty, e
        .                                     );
        .                                     return false;
        .                                 }
        .                                 ProjectAndUnifyResult::Recursive => {
        .                                     debug!("evaluate_nested_obligations: recursive projection predicate");
        .                                     return false;
        .                                 }
      112 (0.0%)                          ProjectAndUnifyResult::Holds(v) => {
        .                                     // We only care about sub-obligations
        .                                     // when we started out trying to unify
        .                                     // some inference variables. See the comment above
        .                                     // for more information
        .                                     if p.term().skip_binder().has_infer_types() {
        .                                         if !self.evaluate_nested_obligations(
        .                                             ty,
        .                                             v.into_iter(),
-- line 714 ----------------------------------------
-- line 715 ----------------------------------------
        .                                             computed_preds,
        .                                             fresh_preds,
        .                                             predicates,
        .                                             selcx,
        .                                         ) {
        .                                             return false;
        .                                         }
        .                                     }
       84 (0.0%)                          }
        .                                 ProjectAndUnifyResult::FailedNormalization => {
        .                                     // It's ok not to make progress when have no inference variables -
        .                                     // in that case, we were only performing unification to check if an
        .                                     // error occurred (which would indicate that it's impossible for our
        .                                     // type to implement the auto trait).
        .                                     // However, we should always make progress (either by generating
        .                                     // subobligations or getting an error) when we started off with
        .                                     // inference variables
-- line 731 ----------------------------------------
-- line 813 ----------------------------------------
        .                         | ty::PredicateKind::Clause(ty::ClauseKind::ConstEvaluatable(..))
        .                         | ty::PredicateKind::Coerce(..) => {}
        .                         ty::PredicateKind::Ambiguous => return false,
        .                     };
        .                 }
        .                 true
        .             }
        .         
1,608,003 (0.0%)      pub fn clean_pred(
        .                 &self,
        .                 infcx: &InferCtxt<'tcx>,
        .                 p: ty::Predicate<'tcx>,
        .             ) -> ty::Predicate<'tcx> {
        .                 infcx.freshen(p)
1,608,003 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_trait_selection/src/traits/normalize.rs
--------------------------------------------------------------------------------
Ir_______________ 

 2,231,004 (0.0%)  <unknown (line 0)>

-- line 13 ----------------------------------------
         .         use rustc_middle::ty::{TypeFoldable, TypeSuperFoldable, TypeVisitable, TypeVisitableExt};
         .         
         .         #[extension(pub trait NormalizeExt<'tcx>)]
         .         impl<'tcx> At<'_, 'tcx> {
         .             /// Normalize a value using the `AssocTypeNormalizer`.
         .             ///
         .             /// This normalization should be used when the type contains inference variables or the
         .             /// projection may be fallible.
   190,159 (0.0%)      fn normalize<T: TypeFoldable<TyCtxt<'tcx>>>(&self, value: T) -> InferOk<'tcx, T> {
   109,884 (0.0%)          if self.infcx.next_trait_solver() {
         .                     InferOk { value, obligations: Vec::new() }
         .                 } else {
         .                     let mut selcx = SelectionContext::new(self.infcx);
   301,953 (0.0%)              let Normalized { value, obligations } =
   291,084 (0.0%)                  normalize_with_depth(&mut selcx, self.param_env, self.cause.clone(), 0, value);
   179,759 (0.0%)              InferOk { value, obligations }
   100,680 (0.0%)          }
   166,316 (0.0%)      }
         .         
         .             /// Deeply normalizes `value`, replacing all aliases which can by normalized in
         .             /// the current environment. In the new solver this errors in case normalization
         .             /// fails or is ambiguous.
         .             ///
         .             /// In the old solver this simply uses `normalizes` and adds the nested obligations
         .             /// to the `fulfill_cx`. This is necessary as we otherwise end up recomputing the
         .             /// same goals in both a temporary and the shared context which negatively impacts
-- line 38 ----------------------------------------
-- line 43 ----------------------------------------
         .             /// existing fulfillment context in the old solver. Once we also eagerly prove goals with
         .             /// the old solver or have removed the old solver, remove `traits::fully_normalize` and
         .             /// rename this function to `At::fully_normalize`.
         .             fn deeply_normalize<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 self,
         .                 value: T,
         .                 fulfill_cx: &mut dyn TraitEngine<'tcx>,
         .             ) -> Result<T, Vec<FulfillmentError<'tcx>>> {
     4,136 (0.0%)          if self.infcx.next_trait_solver() {
         .                     crate::solve::deeply_normalize(self, value)
         .                 } else {
    16,544 (0.0%)              let value = self
         .                         .normalize(value)
         .                         .into_value_registering_obligations(self.infcx, &mut *fulfill_cx);
    16,544 (0.0%)              let errors = fulfill_cx.select_where_possible(self.infcx);
         .                     let value = self.infcx.resolve_vars_if_possible(value);
    20,680 (0.0%)              if errors.is_empty() { Ok(value) } else { Err(errors) }
         .                 }
         .             }
         .         }
         .         
         .         /// As `normalize`, but with a custom depth.
        26 (0.0%)  pub(crate) fn normalize_with_depth<'a, 'b, 'tcx, T>(
         .             selcx: &'a mut SelectionContext<'b, 'tcx>,
         .             param_env: ty::ParamEnv<'tcx>,
         .             cause: ObligationCause<'tcx>,
         .             depth: usize,
         .             value: T,
         .         ) -> Normalized<'tcx, T>
         .         where
         .             T: TypeFoldable<TyCtxt<'tcx>>,
         .         {
         .             let mut obligations = Vec::new();
   856,718 (0.0%)      let value = normalize_with_depth_to(selcx, param_env, cause, depth, value, &mut obligations);
 1,645,010 (0.0%)      Normalized { value, obligations }
        16 (0.0%)  }
         .         
10,993,471 (0.1%)  #[instrument(level = "info", skip(selcx, param_env, cause, obligations))]
         .         pub(crate) fn normalize_with_depth_to<'a, 'b, 'tcx, T>(
         .             selcx: &'a mut SelectionContext<'b, 'tcx>,
         .             param_env: ty::ParamEnv<'tcx>,
         .             cause: ObligationCause<'tcx>,
         .             depth: usize,
         .             value: T,
         .             obligations: &mut Vec<PredicateObligation<'tcx>>,
         .         ) -> T
         .         where
         .             T: TypeFoldable<TyCtxt<'tcx>>,
         .         {
         .             debug!(obligations.len = obligations.len());
   592,425 (0.0%)      let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);
 2,820,237 (0.0%)      let result = ensure_sufficient_stack(|| normalizer.fold(value));
         .             debug!(?result, obligations.len = normalizer.obligations.len());
         .             debug!(?normalizer.obligations,);
   562,442 (0.0%)      result
         .         }
         .         
        20 (0.0%)  pub(super) fn needs_normalization<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(
         .             value: &T,
         .             reveal: Reveal,
         .         ) -> bool {
         .             // This mirrors `ty::TypeFlags::HAS_ALIASES` except that we take `Reveal` into account.
         .         
         .             let mut flags = ty::TypeFlags::HAS_TY_PROJECTION
         .                 | ty::TypeFlags::HAS_TY_WEAK
         .                 | ty::TypeFlags::HAS_TY_INHERENT
         .                 | ty::TypeFlags::HAS_CT_PROJECTION;
         .         
 1,727,449 (0.0%)      match reveal {
         .                 Reveal::UserFacing => {}
         .                 Reveal::All => flags |= ty::TypeFlags::HAS_TY_OPAQUE,
         .             }
         .         
   506,923 (0.0%)      value.has_type_flags(flags)
        18 (0.0%)  }
         .         
         .         struct AssocTypeNormalizer<'a, 'b, 'tcx> {
         .             selcx: &'a mut SelectionContext<'b, 'tcx>,
         .             param_env: ty::ParamEnv<'tcx>,
         .             cause: ObligationCause<'tcx>,
         .             obligations: &'a mut Vec<PredicateObligation<'tcx>>,
         .             depth: usize,
         .             universes: Vec<Option<ty::UniverseIndex>>,
-- line 125 ----------------------------------------
-- line 129 ----------------------------------------
         .             fn new(
         .                 selcx: &'a mut SelectionContext<'b, 'tcx>,
         .                 param_env: ty::ParamEnv<'tcx>,
         .                 cause: ObligationCause<'tcx>,
         .                 depth: usize,
         .                 obligations: &'a mut Vec<PredicateObligation<'tcx>>,
         .             ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {
         .                 debug_assert!(!selcx.infcx.next_trait_solver());
 6,182,926 (0.1%)          AssocTypeNormalizer { selcx, param_env, cause, obligations, depth, universes: vec![] }
         .             }
         .         
 3,210,848 (0.0%)      fn fold<T: TypeFoldable<TyCtxt<'tcx>>>(&mut self, value: T) -> T {
   795,800 (0.0%)          let value = self.selcx.infcx.resolve_vars_if_possible(value);
         .                 debug!(?value);
         .         
         .                 assert!(
   402,691 (0.0%)              !value.has_escaping_bound_vars(),
         .                     "Normalizing {value:?} without wrapping in a `Binder`"
         .                 );
         .         
   855,766 (0.0%)          if !needs_normalization(&value, self.param_env.reveal()) {
   370,860 (0.0%)              value
         .                 } else {
     1,867 (0.0%)              value.fold_with(self)
         .                 }
 2,347,636 (0.0%)      }
         .         }
         .         
         .         impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx> {
         .             fn interner(&self) -> TyCtxt<'tcx> {
         .                 self.selcx.tcx()
         .             }
         .         
         .             fn fold_binder<T: TypeFoldable<TyCtxt<'tcx>>>(
         .                 &mut self,
         .                 t: ty::Binder<'tcx, T>,
         .             ) -> ty::Binder<'tcx, T> {
         .                 self.universes.push(None);
         .                 let t = t.super_fold_with(self);
         .                 self.universes.pop();
     6,480 (0.0%)          t
         .             }
         .         
   859,239 (0.0%)      fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {
   190,942 (0.0%)          if !needs_normalization(&ty, self.param_env.reveal()) {
         .                     return ty;
         .                 }
         .         
   103,726 (0.0%)          let (kind, data) = match *ty.kind() {
   161,819 (0.0%)              ty::Alias(kind, data) => (kind, data),
         .                     _ => return ty.super_fold_with(self),
         .                 };
         .         
         .                 // We try to be a little clever here as a performance optimization in
         .                 // cases where there are nested projections under binders.
         .                 // For example:
         .                 // ```
         .                 // for<'a> fn(<T as Foo>::One<'a, Box<dyn Bar<'a, Item=<T as Foo>::Two<'a>>>>)
-- line 186 ----------------------------------------
-- line 197 ----------------------------------------
         .                 //
         .                 // This is possible because the inner `'a` will already be a placeholder
         .                 // when we need to normalize the inner projection
         .                 //
         .                 // On the other hand, this does add a bit of complexity, since we only
         .                 // replace bound vars if the current type is a `Projection` and we need
         .                 // to make sure we don't forget to fold the args regardless.
         .         
   115,585 (0.0%)          match kind {
         .                     ty::Opaque => {
         .                         // Only normalize `impl Trait` outside of type inference, usually in codegen.
         .                         match self.param_env.reveal() {
         .                             Reveal::UserFacing => ty.super_fold_with(self),
         .         
         .                             Reveal::All => {
         .                                 let recursion_limit = self.interner().recursion_limit();
         .                                 if !recursion_limit.value_within_limit(self.depth) {
-- line 213 ----------------------------------------
-- line 232 ----------------------------------------
         .         
         .                     ty::Projection if !data.has_escaping_bound_vars() => {
         .                         // This branch is *mostly* just an optimization: when we don't
         .                         // have escaping bound vars, we don't need to replace them with
         .                         // placeholders (see branch below). *Also*, we know that we can
         .                         // register an obligation to *later* project, since we know
         .                         // there won't be bound vars there.
         .                         let data = data.fold_with(self);
    69,351 (0.0%)                  let normalized_ty = project::normalize_projection_type(
    23,117 (0.0%)                      self.selcx,
    23,117 (0.0%)                      self.param_env,
         .                             data,
         .                             self.cause.clone(),
    69,351 (0.0%)                      self.depth,
    23,117 (0.0%)                      self.obligations,
         .                         );
         .                         debug!(
         .                             ?self.depth,
         .                             ?ty,
         .                             ?normalized_ty,
         .                             obligations.len = ?self.obligations.len(),
         .                             "AssocTypeNormalizer: normalized type"
         .                         );
    23,117 (0.0%)                  normalized_ty.ty().unwrap()
         .                     }
         .         
         .                     ty::Projection => {
         .                         // If there are escaping bound vars, we temporarily replace the
         .                         // bound vars with placeholders. Note though, that in the case
         .                         // that we still can't project for whatever reason (e.g. self
         .                         // type isn't known enough), we *can't* register an obligation
         .                         // and return an inference variable (since then that obligation
-- line 263 ----------------------------------------
-- line 384 ----------------------------------------
         .                             mapped_regions,
         .                             mapped_types,
         .                             mapped_consts,
         .                             &self.universes,
         .                             ty,
         .                         )
         .                     }
         .                 }
   600,525 (0.0%)      }
         .         
    12,046 (0.0%)      #[instrument(skip(self), level = "debug")]
         .             fn fold_const(&mut self, constant: ty::Const<'tcx>) -> ty::Const<'tcx> {
       634 (0.0%)          let tcx = self.selcx.tcx();
     2,536 (0.0%)          if tcx.features().generic_const_exprs
     1,268 (0.0%)              || !needs_normalization(&constant, self.param_env.reveal())
         .                 {
         .                     constant
         .                 } else {
         .                     let constant = constant.super_fold_with(self);
         .                     debug!(?constant, ?self.param_env);
       599 (0.0%)              with_replaced_escaping_bound_vars(
         .                         self.selcx.infcx,
         .                         &mut self.universes,
         .                         constant,
         .                         |constant| constant.normalize(tcx, self.param_env),
         .                     )
         .                 }
         .             }
         .         
         .             #[inline]
         .             fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {
    15,274 (0.0%)          if p.allow_normalization() && needs_normalization(&p, self.param_env.reveal()) {
         .                     p.super_fold_with(self)
         .                 } else {
         .                     p
         .                 }
         .             }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs
--------------------------------------------------------------------------------
Ir______________ 

2,278,833 (0.0%)  <unknown (line 0)>

-- line 21 ----------------------------------------
        .         use crate::traits::query::evaluate_obligation::InferCtxtExt;
        .         use crate::traits::util;
        .         
        .         use super::BuiltinImplConditions;
        .         use super::SelectionCandidate::*;
        .         use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};
        .         
        .         impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {
1,746,309 (0.0%)      #[instrument(skip(self, stack), level = "debug")]
        .             pub(super) fn assemble_candidates<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .             ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {
   91,911 (0.0%)          let TraitObligationStack { obligation, .. } = *stack;
1,654,398 (0.0%)          let obligation = &Obligation {
  183,822 (0.0%)              param_env: obligation.param_env,
        .                     cause: obligation.cause.clone(),
  275,733 (0.0%)              recursion_depth: obligation.recursion_depth,
1,102,932 (0.0%)              predicate: self.infcx.resolve_vars_if_possible(obligation.predicate),
        .                 };
        .         
  735,288 (0.0%)          if obligation.predicate.skip_binder().self_ty().is_ty_var() {
        .                     debug!(ty = ?obligation.predicate.skip_binder().self_ty(), "ambiguous inference var or opaque type");
        .                     // Self is a type variable (e.g., `_: AsRef<str>`).
        .                     //
        .                     // This is somewhat problematic, as the current scheme can't really
        .                     // handle it turning to be a projection. This does end up as truly
        .                     // ambiguous in most cases anyway.
        .                     //
        .                     // Take the fast path out - this also improves
        .                     // performance by preventing assemble_candidates_from_impls from
        .                     // matching every impl for this trait.
    3,365 (0.0%)              return Ok(SelectionCandidateSet { vec: vec![], ambiguous: true });
        .                 }
        .         
  364,952 (0.0%)          let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };
        .         
        .                 // Negative trait predicates have different rules than positive trait predicates.
   91,238 (0.0%)          if obligation.polarity() == ty::PredicatePolarity::Negative {
        .                     self.assemble_candidates_for_trait_alias(obligation, &mut candidates);
    1,131 (0.0%)              self.assemble_candidates_from_impls(obligation, &mut candidates);
    1,131 (0.0%)              self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;
        .                 } else {
        .                     self.assemble_candidates_for_trait_alias(obligation, &mut candidates);
        .         
        .                     // Other bounds. Consider both in-scope bounds from fn decl
        .                     // and applicable impls. There is a certain set of precedence rules here.
  270,321 (0.0%)              let def_id = obligation.predicate.def_id();
   90,107 (0.0%)              let lang_items = self.tcx().lang_items();
        .         
   90,159 (0.0%)              if lang_items.copy_trait() == Some(def_id) {
        .                         debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());
        .         
        .                         // User-defined copy impls are permitted, but only for
        .                         // structs and enums.
       26 (0.0%)                  self.assemble_candidates_from_impls(obligation, &mut candidates);
        .         
        .                         // For other types, we'll use the builtin rules.
       26 (0.0%)                  let copy_conditions = self.copy_clone_conditions(obligation);
        .                         self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);
   90,081 (0.0%)              } else if lang_items.discriminant_kind_trait() == Some(def_id) {
        .                         // `DiscriminantKind` is automatically implemented for every type.
        .                         candidates.vec.push(BuiltinCandidate { has_nested: false });
   90,167 (0.0%)              } else if lang_items.pointee_trait() == Some(def_id) {
        .                         // `Pointee` is automatically implemented for every type.
        .                         candidates.vec.push(BuiltinCandidate { has_nested: false });
   99,688 (0.0%)              } else if lang_items.sized_trait() == Some(def_id) {
        .                         // Sized is never implementable by end-users, it is
        .                         // always automatically computed.
   19,300 (0.0%)                  let sized_conditions = self.sized_conditions(obligation);
    9,650 (0.0%)                  self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);
   85,267 (0.0%)              } else if lang_items.unsize_trait() == Some(def_id) {
       54 (0.0%)                  self.assemble_candidates_for_unsizing(obligation, &mut candidates);
   85,186 (0.0%)              } else if lang_items.destruct_trait() == Some(def_id) {
        .                         self.assemble_const_destruct_candidates(obligation, &mut candidates);
   85,186 (0.0%)              } else if lang_items.transmute_trait() == Some(def_id) {
        .                         // User-defined transmutability impls are permitted.
        .                         self.assemble_candidates_from_impls(obligation, &mut candidates);
        .                         self.assemble_candidates_for_transmutability(obligation, &mut candidates);
   85,194 (0.0%)              } else if lang_items.tuple_trait() == Some(def_id) {
       20 (0.0%)                  self.assemble_candidate_for_tuple(obligation, &mut candidates);
   85,182 (0.0%)              } else if lang_items.pointer_like() == Some(def_id) {
        .                         self.assemble_candidate_for_pointer_like(obligation, &mut candidates);
   85,834 (0.0%)              } else if lang_items.fn_ptr_trait() == Some(def_id) {
    1,630 (0.0%)                  self.assemble_candidates_for_fn_ptr_trait(obligation, &mut candidates);
        .                     } else {
   85,690 (0.0%)                  if lang_items.clone_trait() == Some(def_id) {
        .                             // Same builtin conditions as `Copy`, i.e., every type which has builtin support
        .                             // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`
        .                             // types have builtin support for `Clone`.
      417 (0.0%)                      let clone_conditions = self.copy_clone_conditions(obligation);
      417 (0.0%)                      self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);
        .                         }
        .         
   84,856 (0.0%)                  if lang_items.coroutine_trait() == Some(def_id) {
        .                             self.assemble_coroutine_candidates(obligation, &mut candidates);
   86,046 (0.0%)                  } else if lang_items.future_trait() == Some(def_id) {
    2,975 (0.0%)                      self.assemble_future_candidates(obligation, &mut candidates);
   84,849 (0.0%)                  } else if lang_items.iterator_trait() == Some(def_id) {
    1,470 (0.0%)                      self.assemble_iterator_candidates(obligation, &mut candidates);
   83,967 (0.0%)                  } else if lang_items.fused_iterator_trait() == Some(def_id) {
        .                             self.assemble_fused_iterator_candidates(obligation, &mut candidates);
   84,357 (0.0%)                  } else if lang_items.async_iterator_trait() == Some(def_id) {
      780 (0.0%)                      self.assemble_async_iterator_candidates(obligation, &mut candidates);
   83,772 (0.0%)                  } else if lang_items.async_fn_kind_helper() == Some(def_id) {
        .                             self.assemble_async_fn_kind_helper_candidates(obligation, &mut candidates);
        .                         }
        .         
        .                         // FIXME: Put these into `else if` blocks above, since they're built-in.
   84,856 (0.0%)                  self.assemble_closure_candidates(obligation, &mut candidates);
  339,424 (0.0%)                  self.assemble_async_closure_candidates(obligation, &mut candidates);
  339,424 (0.0%)                  self.assemble_fn_pointer_candidates(obligation, &mut candidates);
        .         
   84,856 (0.0%)                  self.assemble_candidates_from_impls(obligation, &mut candidates);
   84,856 (0.0%)                  self.assemble_candidates_from_object_ty(obligation, &mut candidates);
        .                     }
        .         
        .                     self.assemble_candidates_from_projected_tys(obligation, &mut candidates);
   90,107 (0.0%)              self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;
        .                     self.assemble_candidates_from_auto_impls(obligation, &mut candidates);
        .                 }
        .                 debug!("candidate list size: {}", candidates.vec.len());
  456,190 (0.0%)          Ok(candidates)
        .             }
        .         
        .             #[instrument(level = "debug", skip(self, candidates))]
        .             fn assemble_candidates_from_projected_tys(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // Before we go into the whole placeholder thing, just
        .                 // quickly check if the self-type is a projection at all.
  993,652 (0.0%)          match obligation.predicate.skip_binder().trait_ref.self_ty().kind() {
        .                     // Excluding IATs and type aliases here as they don't have meaningful item bounds.
        .                     ty::Alias(ty::Projection | ty::Opaque, _) => {}
        .                     ty::Infer(ty::TyVar(_)) => {
        .                         span_bug!(
        .                             obligation.cause.span,
        .                             "Self=_ should have been handled by assemble_candidates"
        .                         );
        .                     }
        .                     _ => return,
        .                 }
        .         
    2,475 (0.0%)          self.infcx.probe(|_| {
   11,550 (0.0%)              let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);
        .                     let placeholder_trait_predicate =
    3,300 (0.0%)                  self.infcx.enter_forall_and_leak_universe(poly_trait_predicate);
        .         
        .                     // The bounds returned by `item_bounds` may contain duplicates after
        .                     // normalization, so try to deduplicate when possible to avoid
        .                     // unnecessary ambiguity.
        .                     let mut distinct_normalized_bounds = FxHashSet::default();
        .                     self.for_each_item_bound::<!>(
      825 (0.0%)                  placeholder_trait_predicate.self_ty(),
        .                         |selcx, bound, idx| {
   10,154 (0.0%)                      let Some(bound) = bound.as_trait_clause() else {
        .                                 return ControlFlow::Continue(());
        .                             };
    1,487 (0.0%)                      if bound.polarity() != placeholder_trait_predicate.polarity {
        .                                 return ControlFlow::Continue(());
        .                             }
        .         
    1,487 (0.0%)                      selcx.infcx.probe(|_| {
   14,077 (0.0%)                          match selcx.match_normalize_trait_ref(
        .                                     obligation,
        .                                     placeholder_trait_predicate.trait_ref,
        .                                     bound.to_poly_trait_ref(),
        .                                 ) {
        .                                     Ok(None) => {
        .                                         candidates.vec.push(ProjectionCandidate(idx));
        .                                     }
        .                                     Ok(Some(normalized_trait))
      686 (0.0%)                                  if distinct_normalized_bounds.insert(normalized_trait) =>
        .                                     {
        .                                         candidates.vec.push(ProjectionCandidate(idx));
        .                                     }
        .                                     _ => {}
        .                                 }
        .                             });
        .         
        .                             ControlFlow::Continue(())
        .                         },
        .                         // On ambiguity.
        .                         || candidates.ambiguous = true,
        .                     );
    1,168 (0.0%)          });
        .             }
        .         
        .             /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller
        .             /// supplied to find out whether it is listed among them.
        .             ///
        .             /// Never affects the inference environment.
1,824,760 (0.0%)      #[instrument(level = "debug", skip(self, stack, candidates))]
        .             fn assemble_candidates_from_caller_bounds<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) -> Result<(), SelectionError<'tcx>> {
        .                 debug!(?stack.obligation);
        .         
        .                 // An error type will unify with anything. So, avoid
        .                 // matching an error type with `ParamCandidate`.
        .                 // This helps us avoid spurious errors like issue #121941.
   91,238 (0.0%)          if stack.obligation.predicate.references_error() {
        .                     return Ok(());
        .                 }
        .         
  182,476 (0.0%)          let all_bounds = stack
        .                     .obligation
        .                     .param_env
        .                     .caller_bounds()
        .                     .iter()
        .                     .filter(|p| !p.references_error())
1,448,426 (0.0%)              .filter_map(|p| p.as_trait_clause());
        .         
        .                 // Micro-optimization: filter out predicates relating to different traits.
        .                 let matching_bounds =
        .                     all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());
        .         
        .                 // Keep only those bounds which may apply, and propagate overflow if it occurs.
        .                 for bound in matching_bounds {
  502,485 (0.0%)              if bound.skip_binder().polarity != stack.obligation.predicate.skip_binder().polarity {
        .                         continue;
        .                     }
        .         
        .                     // FIXME(oli-obk): it is suspicious that we are dropping the constness and
        .                     // polarity here.
        .                     let wc = self.where_clause_may_apply(stack, bound.map_bound(|t| t.trait_ref))?;
        .                     if wc.may_apply() {
        .                         candidates.vec.push(ParamCandidate(bound));
-- line 252 ----------------------------------------
-- line 276 ----------------------------------------
        .                     ty::Infer(ty::TyVar(_)) => {
        .                         debug!("assemble_coroutine_candidates: ambiguous self-type");
        .                         candidates.ambiguous = true;
        .                     }
        .                     _ => {}
        .                 }
        .             }
        .         
    3,570 (0.0%)      fn assemble_future_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
    1,190 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
    1,190 (0.0%)          if let ty::Coroutine(did, ..) = self_ty.kind() {
        .                     // async constructs get lowered to a special kind of coroutine that
        .                     // should directly `impl Future`.
        .                     if self.tcx().coroutine_is_async(*did) {
        .                         debug!(?self_ty, ?obligation, "assemble_future_candidates",);
        .         
        .                         candidates.vec.push(FutureCandidate);
        .                     }
        .                 }
    2,380 (0.0%)      }
        .         
    1,764 (0.0%)      fn assemble_iterator_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
      588 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
        .                 // gen constructs get lowered to a special kind of coroutine that
        .                 // should directly `impl Iterator`.
      588 (0.0%)          if let ty::Coroutine(did, ..) = self_ty.kind()
        .                     && self.tcx().coroutine_is_gen(*did)
        .                 {
        .                     debug!(?self_ty, ?obligation, "assemble_iterator_candidates",);
        .         
        .                     candidates.vec.push(IteratorCandidate);
        .                 }
    1,176 (0.0%)      }
        .         
        .             fn assemble_fused_iterator_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 let self_ty = obligation.self_ty().skip_binder();
        .                 // gen constructs get lowered to a special kind of coroutine that
-- line 324 ----------------------------------------
-- line 327 ----------------------------------------
        .                     && self.tcx().coroutine_is_gen(*did)
        .                 {
        .                     debug!(?self_ty, ?obligation, "assemble_fused_iterator_candidates",);
        .         
        .                     candidates.vec.push(BuiltinCandidate { has_nested: false });
        .                 }
        .             }
        .         
    1,560 (0.0%)      fn assemble_async_iterator_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
      390 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
      390 (0.0%)          if let ty::Coroutine(did, args) = *self_ty.kind() {
        .                     // gen constructs get lowered to a special kind of coroutine that
        .                     // should directly `impl AsyncIterator`.
        .                     if self.tcx().coroutine_is_async_gen(did) {
        .                         debug!(?self_ty, ?obligation, "assemble_iterator_candidates",);
        .         
        .                         // Can only confirm this candidate if we have constrained
        .                         // the `Yield` type to at least `Poll<Option<?0>>`..
        .                         let ty::Adt(_poll_def, args) = *args.as_coroutine().yield_ty().kind() else {
-- line 349 ----------------------------------------
-- line 353 ----------------------------------------
        .                         let ty::Adt(_option_def, _) = *args.type_at(0).kind() else {
        .                             candidates.ambiguous = true;
        .                             return;
        .                         };
        .         
        .                         candidates.vec.push(AsyncIteratorCandidate);
        .                     }
        .                 }
    1,170 (0.0%)      }
        .         
        .             /// Checks for the artificial impl that the compiler will create for an obligation like `X :
        .             /// FnMut<..>` where `X` is a closure type.
        .             ///
        .             /// Note: the type parameters on a closure candidate are modeled as *output* type
        .             /// parameters and hence do not affect whether this trait is a match or not. They will be
        .             /// unified during the confirmation step.
  848,560 (0.0%)      fn assemble_closure_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
  424,280 (0.0%)          let Some(kind) = self.tcx().fn_trait_kind_from_def_id(obligation.predicate.def_id()) else {
        .                     return;
        .                 };
        .         
        .                 // Okay to skip binder because the args on closure types never
        .                 // touch bound regions, they just capture the in-scope
        .                 // type/region parameters
    1,386 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
    3,234 (0.0%)          match *self_ty.kind() {
        .                     ty::Closure(def_id, _) => {
        .                         let is_const = self.tcx().is_const_fn_raw(def_id);
        .                         debug!(?kind, ?obligation, "assemble_unboxed_candidates");
        .                         match self.infcx.closure_kind(self_ty) {
        .                             Some(closure_kind) => {
        .                                 debug!(?closure_kind, "assemble_unboxed_candidates");
        .                                 if closure_kind.extends(kind) {
        .                                     candidates.vec.push(ClosureCandidate { is_const });
-- line 390 ----------------------------------------
-- line 434 ----------------------------------------
        .                         }
        .                     }
        .                     ty::Infer(ty::TyVar(_)) => {
        .                         debug!("assemble_unboxed_closure_candidates: ambiguous self-type");
        .                         candidates.ambiguous = true;
        .                     }
        .                     _ => {}
        .                 }
  678,848 (0.0%)      }
        .         
  678,848 (0.0%)      fn assemble_async_closure_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
   84,856 (0.0%)          let Some(goal_kind) =
  339,424 (0.0%)              self.tcx().async_fn_trait_kind_from_def_id(obligation.predicate.def_id())
        .                 else {
        .                     return;
        .                 };
        .         
        .                 match *obligation.self_ty().skip_binder().kind() {
        .                     ty::CoroutineClosure(_, args) => {
        .                         if let Some(closure_kind) =
        .                             args.as_coroutine_closure().kind_ty().to_opt_closure_kind()
-- line 458 ----------------------------------------
-- line 472 ----------------------------------------
        .                         }
        .                         candidates.vec.push(AsyncClosureCandidate);
        .                     }
        .                     ty::FnDef(..) | ty::FnPtr(..) => {
        .                         candidates.vec.push(AsyncClosureCandidate);
        .                     }
        .                     _ => {}
        .                 }
  509,136 (0.0%)      }
        .         
        .             fn assemble_async_fn_kind_helper_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 let self_ty = obligation.self_ty().skip_binder();
        .                 let target_kind_ty = obligation.predicate.skip_binder().trait_ref.args.type_at(1);
-- line 488 ----------------------------------------
-- line 502 ----------------------------------------
        .                 {
        .                     if closure_kind.extends(goal_kind) {
        .                         candidates.vec.push(AsyncFnKindHelperCandidate);
        .                     }
        .                 }
        .             }
        .         
        .             /// Implements one of the `Fn()` family for a fn pointer.
  933,416 (0.0%)      fn assemble_fn_pointer_candidates(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // We provide impl of all fn traits for fn pointers.
  424,280 (0.0%)          if !self.tcx().is_fn_trait(obligation.predicate.def_id()) {
        .                     return;
        .                 }
        .         
        .                 // Keep this function in sync with extract_tupled_inputs_and_output_from_callable
        .                 // until the old solver (and thus this function) is removed.
        .         
        .                 // Okay to skip binder because what we are inspecting doesn't involve bound regions.
      924 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
    3,230 (0.0%)          match *self_ty.kind() {
        .                     ty::Infer(ty::TyVar(_)) => {
        .                         debug!("assemble_fn_pointer_candidates: ambiguous self-type");
        .                         candidates.ambiguous = true; // Could wind up being a fn() type.
        .                     }
        .                     // Provide an impl, but only for suitable `fn` pointers.
        .                     ty::FnPtr(sig) => {
        .                         if sig.is_fn_trait_compatible() {
        .                             candidates
        .                                 .vec
        2 (0.0%)                          .push(FnPointerCandidate { fn_host_effect: self.tcx().consts.true_ });
        .                         }
        .                     }
        .                     // Provide an impl for suitable functions, rejecting `#[target_feature]` functions (RFC 2396).
        .                     ty::FnDef(def_id, args) => {
        .                         let tcx = self.tcx();
        .                         if tcx.fn_sig(def_id).skip_binder().is_fn_trait_compatible()
        .                             && tcx.codegen_fn_attrs(def_id).target_features.is_empty()
        .                         {
-- line 543 ----------------------------------------
-- line 546 ----------------------------------------
        .                                     .generics_of(def_id)
        .                                     .host_effect_index
        .                                     .map_or(tcx.consts.true_, |idx| args.const_at(idx)),
        .                             });
        .                         }
        .                     }
        .                     _ => {}
        .                 }
  678,848 (0.0%)      }
        .         
        .             /// Searches for impls that might apply to `obligation`.
1,634,247 (0.0%)      #[instrument(level = "debug", skip(self, candidates))]
        .             fn assemble_candidates_from_impls(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // Essentially any user-written impl will match with an error type,
        .                 // so creating `ImplCandidates` isn't useful. However, we might
        .                 // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)
-- line 565 ----------------------------------------
-- line 568 ----------------------------------------
        .                 // to try to show the 'nicest' possible errors to the user.
        .                 // We don't check for errors in the `ParamEnv` - in practice,
        .                 // it seems to cause us to be overly aggressive in deciding
        .                 // to give up searching for candidates, leading to spurious errors.
        .                 if obligation.predicate.references_error() {
        .                     return;
        .                 }
        .         
  172,026 (0.0%)          let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };
        .                 let obligation_args = obligation.predicate.skip_binder().trait_ref.args;
        .                 self.tcx().for_each_relevant_impl(
  344,052 (0.0%)              obligation.predicate.def_id(),
        .                     obligation.predicate.skip_binder().trait_ref.self_ty(),
  851,582 (0.0%)              |impl_def_id| {
        .                         // Before we create the generic parameters and everything, first
        .                         // consider a "quick reject". This avoids creating more types
        .                         // and so forth that we need to.
   22,681 (0.0%)                  let impl_trait_header = self.tcx().impl_trait_header(impl_def_id).unwrap();
  136,086 (0.0%)                  if !drcx
   22,681 (0.0%)                      .args_may_unify(obligation_args, impl_trait_header.trait_ref.skip_binder().args)
        .                         {
        .                             return;
        .                         }
        .         
        .                         // For every `default impl`, there's always a non-default `impl`
        .                         // that will *also* apply. There's no reason to register a candidate
        .                         // for this impl, since it is *not* proof that the trait goal holds.
        .                         if self.tcx().defaultness(impl_def_id).is_default() {
        .                             return;
        .                         }
        .         
        .                         if self.reject_fn_ptr_impls(
        .                             impl_def_id,
   55,641 (0.0%)                      obligation,
        .                             impl_trait_header.trait_ref.skip_binder().self_ty(),
        .                         ) {
        .                             return;
        .                         }
        .         
   54,633 (0.0%)                  self.infcx.probe(|_| {
  273,165 (0.0%)                      if let Ok(_args) = self.match_impl(impl_def_id, impl_trait_header, obligation) {
        .                                 candidates.vec.push(ImplCandidate(impl_def_id));
        .                             }
        .                         });
  181,448 (0.0%)              },
        .                 );
        .             }
        .         
        .             /// The various `impl<T: FnPtr> Trait for T` in libcore are more like builtin impls for all function items
        .             /// and function pointers and less like blanket impls. Rejecting them when they can't possibly apply (because
        .             /// the obligation's self-type does not implement `FnPtr`) avoids reporting that the self type does not implement
        .             /// `FnPtr`, when we wanted to report that it doesn't implement `Trait`.
        .             #[instrument(level = "trace", skip(self), ret)]
        .             fn reject_fn_ptr_impls(
        .                 &mut self,
        .                 impl_def_id: DefId,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 impl_self_ty: Ty<'tcx>,
        .             ) -> bool {
        .                 // Let `impl<T: FnPtr> Trait for Vec<T>` go through the normal rejection path.
   37,094 (0.0%)          if !matches!(impl_self_ty.kind(), ty::Param(..)) {
        .                     return false;
        .                 }
   12,705 (0.0%)          let Some(fn_ptr_trait) = self.tcx().lang_items().fn_ptr_trait() else {
        .                     return false;
        .                 };
        .         
   22,726 (0.0%)          for &(predicate, _) in self.tcx().predicates_of(impl_def_id).predicates {
   53,999 (0.0%)              let ty::ClauseKind::Trait(pred) = predicate.kind().skip_binder() else { continue };
        .                     if fn_ptr_trait != pred.trait_ref.def_id {
        .                         continue;
        .                     }
        .                     trace!(?pred);
        .                     // Not the bound we're looking for
    3,024 (0.0%)              if pred.self_ty() != impl_self_ty {
        .                         continue;
        .                     }
        .         
    2,016 (0.0%)              match obligation.self_ty().skip_binder().kind() {
        .                         // Fast path to avoid evaluating an obligation that trivially holds.
        .                         // There may be more bounds, but these are checked by the regular path.
        .                         ty::FnPtr(..) => return false,
        .         
        .                         // These may potentially implement `FnPtr`
        .                         ty::Placeholder(..)
        .                         | ty::Dynamic(_, _, _)
        .                         | ty::Alias(_, _)
-- line 654 ----------------------------------------
-- line 683 ----------------------------------------
        .                         ty::FnDef(_, _) => return true,
        .                     }
        .         
        .                     // Generic params can implement `FnPtr` if the predicate
        .                     // holds within its own environment.
        .                     let obligation = Obligation::new(
        .                         self.tcx(),
        .                         obligation.cause.clone(),
       43 (0.0%)                  obligation.param_env,
      215 (0.0%)                  self.tcx().mk_predicate(obligation.predicate.map_bound(|mut pred| {
        .                             pred.trait_ref =
       43 (0.0%)                          ty::TraitRef::new(self.tcx(), fn_ptr_trait, [pred.trait_ref.self_ty()]);
        .                             ty::PredicateKind::Clause(ty::ClauseKind::Trait(pred))
        .                         })),
        .                     );
      215 (0.0%)              if let Ok(r) = self.evaluate_root_obligation(&obligation) {
        .                         if !r.may_apply() {
        .                             return true;
        .                         }
        .                     }
        .                 }
        .                 false
        .             }
        .         
        .             fn assemble_candidates_from_auto_impls(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // Okay to skip binder here because the tests we do below do not involve bound regions.
  180,214 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
        .                 debug!(?self_ty, "assemble_candidates_from_auto_impls");
        .         
  270,321 (0.0%)          let def_id = obligation.predicate.def_id();
        .         
  450,535 (0.0%)          if self.tcx().trait_is_auto(def_id) {
  366,193 (0.0%)              match *self_ty.kind() {
        .                         ty::Dynamic(..) => {
        .                             // For object types, we don't know what the closed
        .                             // over types are. This means we conservatively
        .                             // say nothing; a candidate may be added by
        .                             // `assemble_candidates_from_object_ty`.
        .                         }
        .                         ty::Foreign(..) => {
        .                             // Since the contents of foreign types is unknown,
-- line 727 ----------------------------------------
-- line 820 ----------------------------------------
        .                             // for `&SomeType: Auto` exists. Due to E0321 the only crate where impls
        .                             // for `&SomeType: Auto` can be defined is the crate where `Auto` has been defined.
        .                             //
        .                             // Generally, we have to guarantee that for all `SimplifiedType`s the only crate
        .                             // which may define impls for that type is either the crate defining the type
        .                             // or the trait. This should be guaranteed by the orphan check.
        .                             let mut has_impl = false;
        .                             self.tcx().for_each_relevant_impl(def_id, self_ty, |_| has_impl = true);
  141,108 (0.0%)                      if !has_impl {
        .                                 candidates.vec.push(AutoImplCandidate)
        .                             }
        .                         }
        .                         ty::Error(_) => {} // do not add an auto trait impl for `ty::Error` for now.
        .                     }
        .                 }
        .             }
        .         
        .             /// Searches for impls that might apply to `obligation`.
  933,416 (0.0%)      fn assemble_candidates_from_object_ty(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 debug!(
        .                     self_ty = ?obligation.self_ty().skip_binder(),
        .                     "assemble_candidates_from_object_ty",
        .                 );
        .         
  339,424 (0.0%)          if !self.tcx().trait_def(obligation.predicate.def_id()).implement_via_object {
        .                     return;
        .                 }
        .         
        .                 self.infcx.probe(|_snapshot| {
  848,560 (0.0%)              let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);
  169,712 (0.0%)              self.infcx.enter_forall(poly_trait_predicate, |placeholder_trait_predicate| {
  254,568 (0.0%)                  let self_ty = placeholder_trait_predicate.self_ty();
  509,136 (0.0%)                  let principal_trait_ref = match self_ty.kind() {
        .                             ty::Dynamic(data, ..) => {
    2,054 (0.0%)                          if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {
        .                                     debug!(
        .                                         "assemble_candidates_from_object_ty: matched builtin bound, \
        .                                      pushing candidate"
        .                                     );
        .                                     candidates.vec.push(BuiltinObjectCandidate);
        .                                     return;
        .                                 }
        .         
      700 (0.0%)                          if let Some(principal) = data.principal() {
      500 (0.0%)                              if !self.infcx.tcx.features().object_safe_for_dispatch {
        .                                         principal.with_self_ty(self.tcx(), self_ty)
        .                                     } else if self.tcx().check_is_object_safe(principal.def_id()) {
        .                                         principal.with_self_ty(self.tcx(), self_ty)
        .                                     } else {
        .                                         return;
        .                                     }
        .                                 } else {
        .                                     // Only auto trait bounds exist.
-- line 876 ----------------------------------------
-- line 887 ----------------------------------------
        .         
        .                         debug!(?principal_trait_ref, "assemble_candidates_from_object_ty");
        .         
        .                         // Count only those upcast versions that match the trait-ref
        .                         // we are looking for. Specifically, do not only check for the
        .                         // correct trait, but also the correct type parameters.
        .                         // For example, we may be trying to upcast `Foo` to `Bar<i32>`,
        .                         // but `Foo` is declared as `trait Foo: Bar<u32>`.
      200 (0.0%)                  let candidate_supertraits = util::supertraits(self.tcx(), principal_trait_ref)
        .                             .enumerate()
        .                             .filter(|&(_, upcast_trait_ref)| {
      804 (0.0%)                          self.infcx.probe(|_| {
    1,206 (0.0%)                              self.match_normalize_trait_ref(
        .                                         obligation,
      402 (0.0%)                                  placeholder_trait_predicate.trait_ref,
    1,608 (0.0%)                                  upcast_trait_ref,
        .                                     )
        .                                     .is_ok()
        .                                 })
        .                             })
        .                             .map(|(idx, _)| ObjectCandidate(idx));
        .         
        .                         candidates.vec.extend(candidate_supertraits);
        .                     })
        .                 })
  678,848 (0.0%)      }
        .         
        .             /// Temporary migration for #89190
        .             fn need_migrate_deref_output_trait_object(
        .                 &mut self,
        .                 ty: Ty<'tcx>,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 cause: &ObligationCause<'tcx>,
        .             ) -> Option<ty::PolyExistentialTraitRef<'tcx>> {
-- line 920 ----------------------------------------
-- line 946 ----------------------------------------
        .                     .ty()
        .                     .unwrap();
        .         
        .                     if let ty::Dynamic(data, ..) = ty.kind() { data.principal() } else { None }
        .                 })
        .             }
        .         
        .             /// Searches for unsizing that might apply to `obligation`.
      297 (0.0%)      fn assemble_candidates_for_unsizing(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // We currently never consider higher-ranked obligations e.g.
        .                 // `for<'a> &'a T: Unsize<Trait+'a>` to be implemented. This is not
        .                 // because they are a priori invalid, and we could potentially add support
        .                 // for them later, it's just that there isn't really a strong need for it.
-- line 962 ----------------------------------------
-- line 965 ----------------------------------------
        .                 //
        .                 // That said, one might try to write a fn with a where clause like
        .                 //     for<'a> Foo<'a, T>: Unsize<Foo<'a, Trait>>
        .                 // where the `'a` is kind of orthogonal to the relevant part of the `Unsize`.
        .                 // Still, you'd be more likely to write that where clause as
        .                 //     T: Trait
        .                 // so it seems ok if we (conservatively) fail to accept that `Unsize`
        .                 // obligation above. Should be possible to extend this in the future.
      135 (0.0%)          let Some(source) = obligation.self_ty().no_bound_vars() else {
        .                     // Don't add any candidates if there are bound regions.
        .                     return;
        .                 };
       81 (0.0%)          let target = obligation.predicate.skip_binder().trait_ref.args.type_at(1);
        .         
        .                 debug!(?source, ?target, "assemble_candidates_for_unsizing");
        .         
      384 (0.0%)          match (source.kind(), target.kind()) {
        .                     // Trait+Kx+'a -> Trait+Ky+'b (upcasts).
        .                     (&ty::Dynamic(a_data, a_region, ty::Dyn), &ty::Dynamic(b_data, b_region, ty::Dyn)) => {
        .                         // Upcast coercions permit several things:
        .                         //
        .                         // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`
        .                         // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`
        .                         // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`
        .                         //
-- line 989 ----------------------------------------
-- line 1065 ----------------------------------------
        .                     }
        .         
        .                     // `[T; n]` -> `[T]`
        .                     (&ty::Array(..), &ty::Slice(_)) => {
        .                         candidates.vec.push(BuiltinUnsizeCandidate);
        .                     }
        .         
        .                     // `Struct<T>` -> `Struct<U>`
        2 (0.0%)              (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {
        .                         if def_id_a == def_id_b {
        .                             candidates.vec.push(BuiltinUnsizeCandidate);
        .                         }
        .                     }
        .         
        .                     // `(.., T)` -> `(.., U)`
        .                     (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {
        .                         if tys_a.len() == tys_b.len() {
        .                             candidates.vec.push(BuiltinUnsizeCandidate);
        .                         }
        .                     }
        .         
        .                     _ => {}
        .                 };
      216 (0.0%)      }
        .         
        .             #[instrument(level = "debug", skip(self, obligation, candidates))]
        .             fn assemble_candidates_for_transmutability(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 if obligation.predicate.has_non_region_param() {
-- line 1096 ----------------------------------------
-- line 1107 ----------------------------------------
        .         
        .             #[instrument(level = "debug", skip(self, obligation, candidates))]
        .             fn assemble_candidates_for_trait_alias(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // Okay to skip binder here because the tests we do below do not involve bound regions.
   91,238 (0.0%)          let self_ty = obligation.self_ty().skip_binder();
        .                 debug!(?self_ty);
        .         
  273,714 (0.0%)          let def_id = obligation.predicate.def_id();
        .         
  273,714 (0.0%)          if self.tcx().is_trait_alias(def_id) {
        .                     candidates.vec.push(TraitAliasCandidate);
        .                 }
        .             }
        .         
        .             /// Assembles the trait which are built-in to the language itself:
        .             /// `Copy`, `Clone` and `Sized`.
   60,660 (0.0%)      #[instrument(level = "debug", skip(self, candidates))]
        .             fn assemble_builtin_bound_candidates(
        .                 &mut self,
        .                 conditions: BuiltinImplConditions<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
   50,276 (0.0%)          match conditions {
    3,836 (0.0%)              BuiltinImplConditions::Where(nested) => {
        .                         candidates
        .                             .vec
        .                             .push(BuiltinCandidate { has_nested: !nested.skip_binder().is_empty() });
        .                     }
        .                     BuiltinImplConditions::None => {}
        .                     BuiltinImplConditions::Ambiguous => {
        .                         candidates.ambiguous = true;
        .                     }
-- line 1142 ----------------------------------------
-- line 1239 ----------------------------------------
        .                     }
        .         
        .                     ty::Infer(_) => {
        .                         candidates.ambiguous = true;
        .                     }
        .                 }
        .             }
        .         
       32 (0.0%)      fn assemble_candidate_for_tuple(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
       12 (0.0%)          let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());
       32 (0.0%)          match self_ty.kind() {
        .                     ty::Tuple(_) => {
        .                         candidates.vec.push(BuiltinCandidate { has_nested: false });
        .                     }
        .                     ty::Infer(ty::TyVar(_)) => {
        .                         candidates.ambiguous = true;
        .                     }
        .                     ty::Bool
        .                     | ty::Char
-- line 1261 ----------------------------------------
-- line 1280 ----------------------------------------
        .                     | ty::Never
        .                     | ty::Alias(..)
        .                     | ty::Param(_)
        .                     | ty::Bound(_, _)
        .                     | ty::Error(_)
        .                     | ty::Infer(_)
        .                     | ty::Placeholder(_) => {}
        .                 }
       24 (0.0%)      }
        .         
        .             fn assemble_candidate_for_pointer_like(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
        .                 // The regions of a type don't affect the size of the type
        .                 let tcx = self.tcx();
-- line 1296 ----------------------------------------
-- line 1307 ----------------------------------------
        .         
        .                 if let Ok(layout) = tcx.layout_of(key)
        .                     && layout.layout.is_pointer_like(&tcx.data_layout)
        .                 {
        .                     candidates.vec.push(BuiltinCandidate { has_nested: false });
        .                 }
        .             }
        .         
    2,608 (0.0%)      fn assemble_candidates_for_fn_ptr_trait(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidates: &mut SelectionCandidateSet<'tcx>,
        .             ) {
      978 (0.0%)          let self_ty = self.infcx.shallow_resolve(obligation.self_ty());
        .         
    1,304 (0.0%)          match self_ty.skip_binder().kind() {
        .                     ty::FnPtr(_) => candidates.vec.push(BuiltinCandidate { has_nested: false }),
        .                     ty::Bool
        .                     | ty::Char
        .                     | ty::Int(_)
        .                     | ty::Uint(_)
        .                     | ty::Float(_)
        .                     | ty::Adt(..)
        .                     | ty::Foreign(..)
-- line 1330 ----------------------------------------
-- line 1352 ----------------------------------------
        .                         | ty::InferTy::FloatVar(_)
        .                         | ty::InferTy::FreshIntTy(_)
        .                         | ty::InferTy::FreshFloatTy(_),
        .                     ) => {}
        .                     ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)) => {
        .                         candidates.ambiguous = true;
        .                     }
        .                 }
    1,956 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_trait_selection/src/traits/select/confirmation.rs
--------------------------------------------------------------------------------
Ir______________ 

  932,209 (0.0%)  <unknown (line 0)>

-- line 34 ----------------------------------------
        .         use super::BuiltinImplConditions;
        .         use super::SelectionCandidate::{self, *};
        .         use super::SelectionContext;
        .         
        .         use std::iter;
        .         use std::ops::ControlFlow;
        .         
        .         impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {
3,225,580 (0.0%)      #[instrument(level = "debug", skip(self))]
        .             pub(super) fn confirm_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 candidate: SelectionCandidate<'tcx>,
        .             ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {
1,451,511 (0.0%)          let mut impl_src = match candidate {
        .                     BuiltinCandidate { has_nested } => {
        .                         let data = self.confirm_builtin_candidate(obligation, has_nested);
   17,376 (0.0%)                  ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
        .         
        .                     TransmutabilityCandidate => {
        .                         let data = self.confirm_transmutability_candidate(obligation)?;
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
        .         
   14,343 (0.0%)              ParamCandidate(param) => {
        .                         let obligations =
        .                             self.confirm_param_candidate(obligation, param.map_bound(|t| t.trait_ref));
  157,773 (0.0%)                  ImplSource::Param(obligations)
        .                     }
        .         
  141,510 (0.0%)              ImplCandidate(impl_def_id) => {
  509,436 (0.0%)                  ImplSource::UserDefined(self.confirm_impl_candidate(obligation, impl_def_id))
        .                     }
        .         
        .                     AutoImplCandidate => {
        .                         let data = self.confirm_auto_impl_candidate(obligation)?;
1,272,072 (0.0%)                  ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
        .         
    1,231 (0.0%)              ProjectionCandidate(idx) => {
        .                         let obligations = self.confirm_projection_candidate(obligation, idx)?;
   18,465 (0.0%)                  ImplSource::Param(obligations)
        .                     }
        .         
    3,374 (0.0%)              ObjectCandidate(idx) => self.confirm_object_candidate(obligation, idx)?,
        .         
        .                     ClosureCandidate { .. } => {
        .                         let vtable_closure = self.confirm_closure_candidate(obligation)?;
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, vtable_closure)
        .                     }
        .         
        .                     AsyncClosureCandidate => {
        .                         let vtable_closure = self.confirm_async_closure_candidate(obligation)?;
-- line 87 ----------------------------------------
-- line 107 ----------------------------------------
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, vtable_iterator)
        .                     }
        .         
        .                     AsyncIteratorCandidate => {
        .                         let vtable_iterator = self.confirm_async_iterator_candidate(obligation)?;
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, vtable_iterator)
        .                     }
        .         
        2 (0.0%)              FnPointerCandidate { fn_host_effect } => {
        .                         let data = self.confirm_fn_pointer_candidate(obligation, fn_host_effect)?;
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
        .         
        .                     TraitAliasCandidate => {
        .                         let data = self.confirm_trait_alias_candidate(obligation);
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
-- line 123 ----------------------------------------
-- line 124 ----------------------------------------
        .         
        .                     BuiltinObjectCandidate => {
        .                         // This indicates something like `Trait + Send: Send`. In this case, we know that
        .                         // this holds because that's what the object type is telling us, and there's really
        .                         // no additional obligations to prove and no types in particular to unify, etc.
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, Vec::new())
        .                     }
        .         
    2,968 (0.0%)              BuiltinUnsizeCandidate => self.confirm_builtin_unsize_candidate(obligation)?,
        .         
        .                     TraitUpcastingUnsizeCandidate(idx) => {
        .                         self.confirm_trait_upcasting_unsize_candidate(obligation, idx)?
        .                     }
        .         
        .                     ConstDestructCandidate(def_id) => {
        .                         let data = self.confirm_const_destruct_candidate(obligation, def_id)?;
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, data)
        .                     }
        .                 };
        .         
        .                 // The obligations returned by confirmation are recursively evaluated
        .                 // so we need to make sure they have the correct depth.
        .                 for subobligation in impl_src.borrow_nested_obligations_mut() {
  255,392 (0.0%)              subobligation.set_depth_from_parent(obligation.recursion_depth);
        .                 }
        .         
2,255,316 (0.0%)          Ok(impl_src)
        .             }
        .         
        .             fn confirm_projection_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 idx: usize,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 let tcx = self.tcx();
        .         
    6,155 (0.0%)          let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);
        .                 let placeholder_trait_predicate =
    9,848 (0.0%)              self.infcx.enter_forall_and_leak_universe(trait_predicate).trait_ref;
        .                 let placeholder_self_ty = placeholder_trait_predicate.self_ty();
    6,155 (0.0%)          let candidate_predicate = self
        .                     .for_each_item_bound(
        .                         placeholder_self_ty,
        .                         |_, clause, clause_idx| {
    1,978 (0.0%)                      if clause_idx == idx {
        .                                 ControlFlow::Break(clause)
        .                             } else {
        .                                 ControlFlow::Continue(())
        .                             }
        .                         },
        .                         || unreachable!(),
        .                     )
        .                     .break_value()
        .                     .expect("expected to index into clause that exists");
    1,231 (0.0%)          let candidate = candidate_predicate
        .                     .as_trait_clause()
        .                     .expect("projection candidate is not a trait predicate")
        .                     .map_bound(|t| t.trait_ref);
        .         
    3,693 (0.0%)          let candidate = self.infcx.instantiate_binder_with_fresh_vars(
    4,924 (0.0%)              obligation.cause.span,
        .                     HigherRankedType,
        .                     candidate,
        .                 );
        .                 let mut obligations = Vec::new();
   13,541 (0.0%)          let candidate = normalize_with_depth_to(
        .                     self,
    1,231 (0.0%)              obligation.param_env,
        .                     obligation.cause.clone(),
    2,462 (0.0%)              obligation.recursion_depth + 1,
        .                     candidate,
        .                     &mut obligations,
        .                 );
        .         
        .                 obligations.extend(
    4,924 (0.0%)              self.infcx
        .                         .at(&obligation.cause, obligation.param_env)
    7,386 (0.0%)                  .eq(DefineOpaqueTypes::No, placeholder_trait_predicate, candidate)
        .                         .map(|InferOk { obligations, .. }| obligations)
        .                         .map_err(|_| Unimplemented)?,
        .                 );
        .         
        .                 // FIXME(compiler-errors): I don't think this is needed.
    4,924 (0.0%)          if let ty::Alias(ty::Projection, alias_ty) = placeholder_self_ty.kind() {
    3,693 (0.0%)              let predicates = tcx.predicates_of(alias_ty.def_id).instantiate_own(tcx, alias_ty.args);
        .                     for (predicate, _) in predicates {
        .                         let normalized = normalize_with_depth_to(
        .                             self,
        .                             obligation.param_env,
        .                             obligation.cause.clone(),
        .                             obligation.recursion_depth + 1,
        .                             predicate,
        .                             &mut obligations,
-- line 216 ----------------------------------------
-- line 220 ----------------------------------------
        .                             obligation.cause.clone(),
        .                             obligation.recursion_depth + 1,
        .                             obligation.param_env,
        .                             normalized,
        .                         ));
        .                     }
        .                 }
        .         
   13,541 (0.0%)          Ok(obligations)
        .             }
        .         
        .             fn confirm_param_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 param: ty::PolyTraitRef<'tcx>,
        .             ) -> Vec<PredicateObligation<'tcx>> {
        .                 debug!(?obligation, ?param, "confirm_param_candidate");
        .         
        .                 // During evaluation, we already checked that this
        .                 // where-clause trait-ref could be unified with the obligation
        .                 // trait-ref. Repeat that unification now without any
        .                 // transactional boundary; it should not fail.
   57,372 (0.0%)          match self.match_where_clause_trait_ref(obligation, param) {
        .                     Ok(obligations) => obligations,
        .                     Err(()) => {
        .                         bug!(
        .                             "Where clause `{:?}` was applicable to `{:?}` but now is not",
        .                             param,
        .                             obligation
        .                         );
        .                     }
-- line 250 ----------------------------------------
-- line 254 ----------------------------------------
        .             fn confirm_builtin_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 has_nested: bool,
        .             ) -> Vec<PredicateObligation<'tcx>> {
        .                 debug!(?obligation, ?has_nested, "confirm_builtin_candidate");
        .         
        .                 let lang_items = self.tcx().lang_items();
   43,440 (0.0%)          let obligations = if has_nested {
    1,244 (0.0%)              let trait_def = obligation.predicate.def_id();
    1,864 (0.0%)              let conditions = if Some(trait_def) == lang_items.sized_trait() {
    3,105 (0.0%)                  self.sized_conditions(obligation)
        3 (0.0%)              } else if Some(trait_def) == lang_items.copy_trait() {
        .                         self.copy_clone_conditions(obligation)
        .                     } else if Some(trait_def) == lang_items.clone_trait() {
        .                         self.copy_clone_conditions(obligation)
        .                     } else if Some(trait_def) == lang_items.fused_iterator_trait() {
        .                         self.fused_iterator_conditions(obligation)
        .                     } else {
        .                         bug!("unexpected builtin trait {:?}", trait_def)
        .                     };
    4,976 (0.0%)              let BuiltinImplConditions::Where(nested) = conditions else {
        .                         bug!("obligation {:?} had matched a builtin impl but now doesn't", obligation);
        .                     };
        .         
        .                     let cause = obligation.derived_cause(BuiltinDerivedObligation);
    3,110 (0.0%)              self.collect_predicates_for_types(
      622 (0.0%)                  obligation.param_env,
        .                         cause,
    1,244 (0.0%)                  obligation.recursion_depth + 1,
        .                         trait_def,
    5,598 (0.0%)                  nested,
        .                     )
        .                 } else {
        .                     vec![]
        .                 };
        .         
        .                 debug!(?obligations);
        .         
    2,488 (0.0%)          obligations
        .             }
        .         
        .             #[instrument(level = "debug", skip(self))]
        .             fn confirm_transmutability_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 use rustc_transmute::{Answer, Condition};
-- line 301 ----------------------------------------
-- line 417 ----------------------------------------
        .             /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds
        .             /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.
        .             fn confirm_auto_impl_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 debug!(?obligation, "confirm_auto_impl_candidate");
        .         
  424,024 (0.0%)          let self_ty = self.infcx.shallow_resolve(obligation.predicate.self_ty());
        .                 let types = self.constituent_types_for_ty(self_ty)?;
1,166,066 (0.0%)          Ok(self.vtable_auto_impl(obligation, obligation.predicate.def_id(), types))
        .             }
        .         
        .             /// See `confirm_auto_impl_candidate`.
        .             fn vtable_auto_impl(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 trait_def_id: DefId,
        .                 nested: ty::Binder<'tcx, Vec<Ty<'tcx>>>,
        .             ) -> Vec<PredicateObligation<'tcx>> {
        .                 debug!(?nested, "vtable_auto_impl");
1,590,090 (0.0%)          ensure_sufficient_stack(|| {
  106,006 (0.0%)              let cause = obligation.derived_cause(BuiltinDerivedObligation);
        .         
        .                     let poly_trait_ref = obligation.predicate.to_poly_trait_ref();
  530,030 (0.0%)              let trait_ref = self.infcx.enter_forall_and_leak_universe(poly_trait_ref);
1,060,060 (0.0%)              let trait_obligations: Vec<PredicateObligation<'_>> = self.impl_or_trait_obligations(
        .                         &cause,
  212,012 (0.0%)                  obligation.recursion_depth + 1,
  106,006 (0.0%)                  obligation.param_env,
  318,018 (0.0%)                  trait_def_id,
  106,006 (0.0%)                  trait_ref.args,
  424,024 (0.0%)                  obligation.predicate,
        .                     );
        .         
  636,036 (0.0%)              let mut obligations = self.collect_predicates_for_types(
  106,006 (0.0%)                  obligation.param_env,
  424,024 (0.0%)                  cause,
  212,012 (0.0%)                  obligation.recursion_depth + 1,
  212,012 (0.0%)                  trait_def_id,
  636,036 (0.0%)                  nested,
        .                     );
        .         
        .                     // Adds the predicates from the trait. Note that this contains a `Self: Trait`
        .                     // predicate as usual. It won't have any effect since auto traits are coinductive.
  318,018 (0.0%)              obligations.extend(trait_obligations);
        .         
        .                     debug!(?obligations, "vtable_auto_impl");
        .         
  530,030 (0.0%)              obligations
  848,048 (0.0%)          })
        .             }
        .         
        .             fn confirm_impl_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 impl_def_id: DefId,
        .             ) -> ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>> {
        .                 debug!(?obligation, ?impl_def_id, "confirm_impl_candidate");
        .         
        .                 // First, create the generic parameters by matching the impl again,
        .                 // this time not in a probe.
  113,208 (0.0%)          let args = self.rematch_impl(impl_def_id, obligation);
        .                 debug!(?args, "impl args");
  113,208 (0.0%)          ensure_sufficient_stack(|| {
  254,718 (0.0%)              self.vtable_impl(
   56,604 (0.0%)                  impl_def_id,
        .                         args,
   28,302 (0.0%)                  &obligation.cause,
   56,604 (0.0%)                  obligation.recursion_depth + 1,
        .                         obligation.param_env,
        .                         obligation.predicate,
        .                     )
        .                 })
        .             }
        .         
  396,228 (0.0%)      fn vtable_impl(
        .                 &mut self,
        .                 impl_def_id: DefId,
        .                 args: Normalized<'tcx, GenericArgsRef<'tcx>>,
        .                 cause: &ObligationCause<'tcx>,
        .                 recursion_depth: usize,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 parent_trait_pred: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,
        .             ) -> ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>> {
        .                 debug!(?impl_def_id, ?args, ?recursion_depth, "vtable_impl");
        .         
  339,624 (0.0%)          let mut impl_obligations = self.impl_or_trait_obligations(
        .                     cause,
        .                     recursion_depth,
        .                     param_env,
        .                     impl_def_id,
   28,302 (0.0%)              args.value,
        .                     parent_trait_pred,
        .                 );
        .         
        .                 debug!(?impl_obligations, "vtable_impl");
        .         
        .                 // Because of RFC447, the impl-trait-ref and obligations
        .                 // are sufficient to determine the impl args, without
        .                 // relying on projections in the impl-trait-ref.
        .                 //
        .                 // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`
   84,906 (0.0%)          impl_obligations.extend(args.obligations);
        .         
  254,718 (0.0%)          ImplSourceUserDefinedData { impl_def_id, args: args.value, nested: impl_obligations }
  226,416 (0.0%)      }
        .         
        .             fn confirm_object_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 index: usize,
        .             ) -> Result<ImplSource<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 let tcx = self.tcx();
        .                 debug!(?obligation, ?index, "confirm_object_candidate");
        .         
    1,928 (0.0%)          let trait_predicate = self.infcx.enter_forall_and_leak_universe(obligation.predicate);
    1,928 (0.0%)          let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());
    2,410 (0.0%)          let ty::Dynamic(data, ..) = *self_ty.kind() else {
        .                     span_bug!(obligation.cause.span, "object candidate with non-object");
        .                 };
        .         
      482 (0.0%)          let object_trait_ref = data.principal().unwrap_or_else(|| {
        .                     span_bug!(obligation.cause.span, "object candidate with no principal")
        .                 });
    1,928 (0.0%)          let object_trait_ref = self.infcx.instantiate_binder_with_fresh_vars(
    2,410 (0.0%)              obligation.cause.span,
        .                     HigherRankedType,
        .                     object_trait_ref,
        .                 );
    1,446 (0.0%)          let object_trait_ref = object_trait_ref.with_self_ty(self.tcx(), self_ty);
        .         
        .                 let mut nested = vec![];
        .         
    1,446 (0.0%)          let mut supertraits = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref));
        .                 let unnormalized_upcast_trait_ref =
      482 (0.0%)              supertraits.nth(index).expect("supertraits iterator no longer has as many elements");
        .         
    5,784 (0.0%)          let upcast_trait_ref = self.infcx.instantiate_binder_with_fresh_vars(
        .                     obligation.cause.span,
        .                     HigherRankedType,
        .                     unnormalized_upcast_trait_ref,
        .                 );
    5,302 (0.0%)          let upcast_trait_ref = normalize_with_depth_to(
        .                     self,
      964 (0.0%)              obligation.param_env,
        .                     obligation.cause.clone(),
    1,446 (0.0%)              obligation.recursion_depth + 1,
        .                     upcast_trait_ref,
        .                     &mut nested,
        .                 );
        .         
        .                 nested.extend(
    6,266 (0.0%)              self.infcx
        .                         .at(&obligation.cause, obligation.param_env)
    1,928 (0.0%)                  .eq(DefineOpaqueTypes::No, trait_predicate.trait_ref, upcast_trait_ref)
        .                         .map(|InferOk { obligations, .. }| obligations)
        .                         .map_err(|_| Unimplemented)?,
        .                 );
        .         
        .                 // Check supertraits hold. This is so that their associated type bounds
        .                 // will be checked in the code below.
    2,410 (0.0%)          for super_trait in tcx
        .                     .super_predicates_of(trait_predicate.def_id())
        .                     .instantiate(tcx, trait_predicate.trait_ref.args)
        .                     .predicates
        .                     .into_iter()
        .                 {
        .                     let normalized_super_trait = normalize_with_depth_to(
        .                         self,
        .                         obligation.param_env,
-- line 587 ----------------------------------------
-- line 588 ----------------------------------------
        .                         obligation.cause.clone(),
        .                         obligation.recursion_depth + 1,
        .                         super_trait,
        .                         &mut nested,
        .                     );
        .                     nested.push(obligation.with(tcx, normalized_super_trait));
        .                 }
        .         
    1,446 (0.0%)          let assoc_types: Vec<_> = tcx
        .                     .associated_items(trait_predicate.def_id())
        .                     .in_definition_order()
        .                     // Associated types that require `Self: Sized` do not show up in the built-in
        .                     // implementation of `Trait for dyn Trait`, and can be dropped here.
        6 (0.0%)              .filter(|item| !tcx.generics_require_sized_self(item.def_id))
        .                     .filter_map(
        .                         |item| if item.kind == ty::AssocKind::Type { Some(item.def_id) } else { None },
        .                     )
        .                     .collect();
        .         
        .                 for assoc_type in assoc_types {
        .                     let defs: &ty::Generics = tcx.generics_of(assoc_type);
        .         
        2 (0.0%)              if !defs.params.is_empty() && !tcx.features().generic_associated_types_extended {
        .                         tcx.dcx().span_delayed_bug(
        .                             obligation.cause.span,
        .                             "GATs in trait object shouldn't have been considered",
        .                         );
        .                         return Err(SelectionError::TraitNotObjectSafe(trait_predicate.trait_ref.def_id));
        .                     }
        .         
        .                     // This maybe belongs in wf, but that can't (doesn't) handle
        .                     // higher-ranked things.
        .                     // Prevent, e.g., `dyn Iterator<Item = str>`.
        3 (0.0%)              for bound in self.tcx().item_bounds(assoc_type).transpose_iter() {
        2 (0.0%)                  let arg_bound = if defs.count() == 0 {
        .                             bound.instantiate(tcx, trait_predicate.trait_ref.args)
        .                         } else {
        .                             let mut args = smallvec::SmallVec::with_capacity(defs.count());
        2 (0.0%)                      args.extend(trait_predicate.trait_ref.args.iter());
        .                             let mut bound_vars: smallvec::SmallVec<[ty::BoundVariableKind; 8]> =
        .                                 smallvec::SmallVec::with_capacity(
        6 (0.0%)                              bound.skip_binder().kind().bound_vars().len() + defs.count(),
        .                                 );
        7 (0.0%)                      bound_vars.extend(bound.skip_binder().kind().bound_vars().into_iter());
        .                             GenericArgs::fill_single(&mut args, defs, &mut |param, _| match param.kind {
        .                                 GenericParamDefKind::Type { .. } => {
        .                                     let kind = ty::BoundTyKind::Param(param.def_id, param.name);
        .                                     let bound_var = ty::BoundVariableKind::Ty(kind);
        .                                     bound_vars.push(bound_var);
        .                                     Ty::new_bound(
        .                                         tcx,
        .                                         ty::INNERMOST,
-- line 639 ----------------------------------------
-- line 667 ----------------------------------------
        .                                         ty::BoundVar::from_usize(bound_vars.len() - 1),
        .                                         tcx.type_of(param.def_id)
        .                                             .no_bound_vars()
        .                                             .expect("const parameter types cannot be generic"),
        .                                     )
        .                                     .into()
        .                                 }
        .                             });
        2 (0.0%)                      let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);
        1 (0.0%)                      let assoc_ty_args = tcx.mk_args(&args);
        .                             let bound =
        3 (0.0%)                          bound.map_bound(|b| b.kind().skip_binder()).instantiate(tcx, assoc_ty_args);
        .                             ty::Binder::bind_with_vars(bound, bound_vars).to_predicate(tcx)
        2 (0.0%)                  };
        5 (0.0%)                  let normalized_bound = normalize_with_depth_to(
        .                             self,
        .                             obligation.param_env,
        .                             obligation.cause.clone(),
        .                             obligation.recursion_depth + 1,
        .                             arg_bound,
        .                             &mut nested,
        .                         );
        .                         nested.push(obligation.with(tcx, normalized_bound));
        .                     }
        .                 }
        .         
        .                 debug!(?nested, "object nested obligations");
        .         
        .                 let vtable_base = vtable_trait_first_method_offset(
        .                     tcx,
    5,784 (0.0%)              (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),
        .                 );
        .         
    3,856 (0.0%)          Ok(ImplSource::Builtin(BuiltinImplSource::Object { vtable_base: vtable_base }, nested))
        .             }
        .         
        .             fn confirm_fn_pointer_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 fn_host_effect: ty::Const<'tcx>,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 debug!(?obligation, "confirm_fn_pointer_candidate");
       10 (0.0%)          let placeholder_predicate = self.infcx.enter_forall_and_leak_universe(obligation.predicate);
        8 (0.0%)          let self_ty = self.infcx.shallow_resolve(placeholder_predicate.self_ty());
        .         
        .                 let tcx = self.tcx();
        8 (0.0%)          let sig = self_ty.fn_sig(tcx);
       14 (0.0%)          let trait_ref = closure_trait_ref_and_return_type(
        .                     tcx,
        4 (0.0%)              obligation.predicate.def_id(),
        .                     self_ty,
       12 (0.0%)              sig,
        .                     util::TupleArgumentsFlag::Yes,
        .                     fn_host_effect,
        .                 )
        .                 .map_bound(|(trait_ref, _)| trait_ref);
        .         
        .                 let mut nested =
        8 (0.0%)              self.equate_trait_refs(obligation.with(tcx, placeholder_predicate), trait_ref)?;
        .                 let cause = obligation.derived_cause(BuiltinDerivedObligation);
        .         
        .                 // Confirm the `type Output: Sized;` bound that is present on `FnOnce`
        8 (0.0%)          let output_ty = self.infcx.enter_forall_and_leak_universe(sig.output());
        6 (0.0%)          let output_ty = normalize_with_depth_to(
        .                     self,
        .                     obligation.param_env,
        .                     cause.clone(),
        .                     obligation.recursion_depth,
        .                     output_ty,
        .                     &mut nested,
        .                 );
        .                 let tr = ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [output_ty]);
       10 (0.0%)          nested.push(Obligation::new(self.infcx.tcx, cause, obligation.param_env, tr));
        .         
        2 (0.0%)          Ok(nested)
        .             }
        .         
        .             fn confirm_trait_alias_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Vec<PredicateObligation<'tcx>> {
        .                 debug!(?obligation, "confirm_trait_alias_candidate");
        .         
-- line 749 ----------------------------------------
-- line 1041 ----------------------------------------
        .             /// Now imagine our obligation is `Closure: Fn(usize)`. So far
        .             /// we have matched the self type `Closure`. At this point we'll
        .             /// compare the `i32` to `usize` and generate an error.
        .             ///
        .             /// Note that this checking occurs *after* the impl has selected,
        .             /// because these output type parameters should not affect the
        .             /// selection of the impl. Therefore, if there is a mismatch, we
        .             /// report an error to the user.
       38 (0.0%)      #[instrument(skip(self), level = "trace")]
        .             fn equate_trait_refs(
        .                 &mut self,
        .                 obligation: TraitObligation<'tcx>,
        .                 found_trait_ref: ty::PolyTraitRef<'tcx>,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        8 (0.0%)          let found_trait_ref = self.infcx.instantiate_binder_with_fresh_vars(
        4 (0.0%)              obligation.cause.span,
        .                     HigherRankedType,
        .                     found_trait_ref,
        .                 );
        .                 // Normalize the obligation and expected trait refs together, because why not
       20 (0.0%)          let Normalized { obligations: nested, value: (obligation_trait_ref, found_trait_ref) } =
        2 (0.0%)              ensure_sufficient_stack(|| {
        6 (0.0%)                  normalize_with_depth(
        .                             self,
        2 (0.0%)                      obligation.param_env,
        .                             obligation.cause.clone(),
        4 (0.0%)                      obligation.recursion_depth + 1,
       14 (0.0%)                      (obligation.predicate.trait_ref, found_trait_ref),
        .                         )
        .                     });
        .         
        .                 // needed to define opaque types for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs
        8 (0.0%)          self.infcx
        2 (0.0%)              .at(&obligation.cause, obligation.param_env)
        .                     .eq(DefineOpaqueTypes::Yes, obligation_trait_ref, found_trait_ref)
        .                     .map(|InferOk { mut obligations, .. }| {
        .                         obligations.extend(nested);
        4 (0.0%)                  obligations
        .                     })
        .                     .map_err(|terr| {
        .                         SignatureMismatch(Box::new(SignatureMismatchData {
        .                             expected_trait_ref: ty::Binder::dummy(obligation_trait_ref),
        .                             found_trait_ref: ty::Binder::dummy(found_trait_ref),
        .                             terr,
        .                         }))
        .                     })
-- line 1086 ----------------------------------------
-- line 1156 ----------------------------------------
        .             fn confirm_builtin_unsize_candidate(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Result<ImplSource<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {
        .                 let tcx = self.tcx();
        .         
        .                 // `assemble_candidates_for_unsizing` should ensure there are no late-bound
        .                 // regions here. See the comment there for more details.
    1,668 (0.0%)          let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());
    2,224 (0.0%)          let target = obligation.predicate.skip_binder().trait_ref.args.type_at(1);
      556 (0.0%)          let target = self.infcx.shallow_resolve(target);
        .                 debug!(?source, ?target, "confirm_builtin_unsize_candidate");
        .         
    8,525 (0.0%)          Ok(match (source.kind(), target.kind()) {
        .                     // Trait+Kx+'a -> Trait+Ky+'b (auto traits and lifetime subtyping).
        .                     (&ty::Dynamic(data_a, r_a, dyn_a), &ty::Dynamic(data_b, r_b, dyn_b))
        .                         if dyn_a == dyn_b =>
        .                     {
        .                         // See `assemble_candidates_for_unsizing` for more info.
        .                         // We already checked the compatibility of auto traits within `assemble_candidates_for_unsizing`.
        .                         let iter = data_a
        .                             .principal()
-- line 1177 ----------------------------------------
-- line 1208 ----------------------------------------
        .                             obligation.param_env,
        .                             obligation.predicate.rebind(outlives),
        .                         ));
        .         
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, obligations)
        .                     }
        .         
        .                     // `T` -> `Trait`
      370 (0.0%)              (_, &ty::Dynamic(data, r, ty::Dyn)) => {
      370 (0.0%)                  let mut object_dids = data.auto_traits().chain(data.principal_def_id());
      740 (0.0%)                  if let Some(did) = object_dids.find(|did| !tcx.check_is_object_safe(*did)) {
        .                             return Err(TraitNotObjectSafe(did));
        .                         }
        .         
      555 (0.0%)                  let predicate_to_obligation = |predicate| {
        .                             Obligation::with_depth(
        .                                 tcx,
      555 (0.0%)                          obligation.cause.clone(),
    1,110 (0.0%)                          obligation.recursion_depth + 1,
      555 (0.0%)                          obligation.param_env,
        .                                 predicate,
        .                             )
        .                         };
        .         
        .                         // Create obligations:
        .                         //  - Casting `T` to `Trait`
        .                         //  - For all the various builtin bounds attached to the object cast. (In other
        .                         //  words, if the object type is `Foo + Send`, this would create an obligation for
        .                         //  the `Send` check.)
        .                         //  - Projection predicates
        .                         let mut nested: Vec<_> = data
        .                             .iter()
      740 (0.0%)                      .map(|predicate| predicate_to_obligation(predicate.with_self_ty(tcx, source)))
        .                             .collect();
        .         
        .                         // We can only make objects from sized types.
      370 (0.0%)                  let tr = ty::TraitRef::from_lang_item(
      185 (0.0%)                      tcx,
        .                             LangItem::Sized,
      185 (0.0%)                      obligation.cause.span,
      370 (0.0%)                      [source],
        .                         );
      370 (0.0%)                  nested.push(predicate_to_obligation(tr.to_predicate(tcx)));
        .         
        .                         // If the type is `Foo + 'a`, ensure that the type
        .                         // being cast to `Foo + 'a` outlives `'a`:
      185 (0.0%)                  let outlives = ty::OutlivesPredicate(source, r);
      185 (0.0%)                  nested.push(predicate_to_obligation(
    1,295 (0.0%)                      ty::Binder::dummy(ty::ClauseKind::TypeOutlives(outlives)).to_predicate(tcx),
        .                         ));
        .         
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, nested)
        .                     }
        .         
        .                     // `[T; n]` -> `[T]`
      558 (0.0%)              (&ty::Array(a, _), &ty::Slice(b)) => {
      558 (0.0%)                  let InferOk { obligations, .. } = self
        .                             .infcx
      372 (0.0%)                      .at(&obligation.cause, obligation.param_env)
        .                             .eq(DefineOpaqueTypes::No, b, a)
        .                             .map_err(|_| Unimplemented)?;
        .         
        .                         ImplSource::Builtin(BuiltinImplSource::Misc, obligations)
        .                     }
        .         
        .                     // `Struct<T>` -> `Struct<U>`
      925 (0.0%)              (&ty::Adt(def, args_a), &ty::Adt(_, args_b)) => {
        .                         let unsizing_params = tcx.unsizing_params_for_adt(def.did());
        .                         if unsizing_params.is_empty() {
        .                             return Err(Unimplemented);
        .                         }
        .         
        .                         let tail_field = def.non_enum_variant().tail();
        .                         let tail_field_ty = tcx.type_of(tail_field.did);
        .         
-- line 1282 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_trait_selection/src/traits/select/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

4,341,707 (0.1%)  <unknown (line 0)>

-- line 69 ----------------------------------------
        .         /// ranked goal. However, we do exit the binder once we're completely finished with a goal,
        .         /// so the leak-check can be used in evaluate by causing nested higher-ranked goals to fail.
        .         #[derive(Debug, Copy, Clone)]
        .         enum LeakCheckHigherRankedGoal {
        .             No,
        .             Yes,
        .         }
        .         
        5 (0.0%)  #[derive(Clone, Debug, Eq, PartialEq, Hash)]
        .         pub enum IntercrateAmbiguityCause<'tcx> {
        .             DownstreamCrate { trait_ref: ty::TraitRef<'tcx>, self_ty: Option<Ty<'tcx>> },
        .             UpstreamCrateUpdate { trait_ref: ty::TraitRef<'tcx>, self_ty: Option<Ty<'tcx>> },
        .             ReservationImpl { message: Symbol },
        .         }
        .         
        .         impl<'tcx> IntercrateAmbiguityCause<'tcx> {
        .             /// Emits notes when the overlap is caused by complex intercrate ambiguities.
-- line 85 ----------------------------------------
-- line 217 ----------------------------------------
        .             /// candidate (a where-clause or user-defined impl).
        .             None,
        .             /// It is unknown whether there is an impl.
        .             Ambiguous,
        .         }
        .         
        .         impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {
        .             pub fn new(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {
1,387,421 (0.0%)          SelectionContext {
        .                     infcx,
        .                     freshener: infcx.freshener(),
        .                     intercrate_ambiguity_causes: None,
        .                     query_mode: TraitQueryMode::Standard,
        .                 }
        .             }
        .         
   52,182 (0.0%)      pub fn with_query_mode(
        .                 infcx: &'cx InferCtxt<'tcx>,
        .                 query_mode: TraitQueryMode,
        .             ) -> SelectionContext<'cx, 'tcx> {
        .                 debug!(?query_mode, "with_query_mode");
  208,728 (0.0%)          SelectionContext { query_mode, ..SelectionContext::new(infcx) }
   34,788 (0.0%)      }
        .         
        .             /// Enables tracking of intercrate ambiguity causes. See
        .             /// the documentation of [`Self::intercrate_ambiguity_causes`] for more.
        .             pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {
        1 (0.0%)          assert!(self.is_intercrate());
        .                 assert!(self.intercrate_ambiguity_causes.is_none());
        7 (0.0%)          self.intercrate_ambiguity_causes = Some(FxIndexSet::default());
        .                 debug!("selcx: enable_tracking_intercrate_ambiguity_causes");
        .             }
        .         
        .             /// Gets the intercrate ambiguity causes collected since tracking
        .             /// was enabled and disables tracking at the same time. If
        .             /// tracking is not enabled, just returns an empty vector.
        .             pub fn take_intercrate_ambiguity_causes(
        .                 &mut self,
        .             ) -> FxIndexSet<IntercrateAmbiguityCause<'tcx>> {
        2 (0.0%)          assert!(self.is_intercrate());
        .                 self.intercrate_ambiguity_causes.take().unwrap_or_default()
        .             }
        .         
        .             pub fn tcx(&self) -> TyCtxt<'tcx> {
4,638,746 (0.1%)          self.infcx.tcx
        .             }
        .         
        .             pub fn is_intercrate(&self) -> bool {
1,431,410 (0.0%)          self.infcx.intercrate
        .             }
        .         
        .             ///////////////////////////////////////////////////////////////////////////
        .             // Selection
        .             //
        .             // The selection phase tries to identify *how* an obligation will
        .             // be resolved. For example, it will identify which impl or
        .             // parameter bound is to be used. The process can be inconclusive
-- line 273 ----------------------------------------
-- line 277 ----------------------------------------
        .             // 1. If no applicable impl or parameter bound can be found.
        .             // 2. If the output type parameters in the obligation do not match
        .             //    those specified by the impl/bound. For example, if the obligation
        .             //    is `Vec<Foo>: Iterable<Bar>`, but the impl specifies
        .             //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.
        .         
        .             /// Attempts to satisfy the obligation. If successful, this will affect the surrounding
        .             /// type environment by performing unification.
3,696,440 (0.0%)      #[instrument(level = "debug", skip(self), ret)]
        .             pub fn poly_select(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> SelectionResult<'tcx, Selection<'tcx>> {
  238,480 (0.0%)          if self.infcx.next_trait_solver() {
        .                     return self.infcx.select_in_new_trait_solver(obligation);
        .                 }
        .         
  607,122 (0.0%)          let candidate = match self.select_from_obligation(obligation) {
        .                     Err(SelectionError::Overflow(OverflowError::Canonical)) => {
        .                         // In standard mode, overflow must have been caught and reported
        .                         // earlier.
        .                         assert!(self.query_mode == TraitQueryMode::Canonical);
        .                         return Err(SelectionError::Overflow(OverflowError::Canonical));
        .                     }
        .                     Err(e) => {
        .                         return Err(e);
        .                     }
        .                     Ok(None) => {
    5,008 (0.0%)                  return Ok(None);
        .                     }
  652,626 (0.0%)              Ok(Some(candidate)) => candidate,
        .                 };
        .         
  544,225 (0.0%)          match self.confirm_candidate(obligation, candidate) {
        .                     Err(SelectionError::Overflow(OverflowError::Canonical)) => {
        .                         assert!(self.query_mode == TraitQueryMode::Canonical);
        .                         Err(SelectionError::Overflow(OverflowError::Canonical))
        .                     }
        .                     Err(e) => Err(e),
  760,102 (0.0%)              Ok(candidate) => Ok(Some(candidate)),
        .                 }
        .             }
        .         
  195,030 (0.0%)      pub fn select(
        .                 &mut self,
        .                 obligation: &TraitObligation<'tcx>,
        .             ) -> SelectionResult<'tcx, Selection<'tcx>> {
  273,042 (0.0%)          self.poly_select(&Obligation {
        .                     cause: obligation.cause.clone(),
   39,006 (0.0%)              param_env: obligation.param_env,
   97,515 (0.0%)              predicate: ty::Binder::dummy(obligation.predicate),
   19,503 (0.0%)              recursion_depth: obligation.recursion_depth,
        .                 })
  175,527 (0.0%)      }
        .         
        .             fn select_from_obligation(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {
        .                 debug_assert!(!obligation.predicate.has_escaping_bound_vars());
        .         
        .                 let pec = &ProvisionalEvaluationCache::default();
        .                 let stack = self.push_stack(TraitObligationStackList::empty(pec), obligation);
        .         
  238,480 (0.0%)          self.candidate_from_obligation(&stack)
        .             }
        .         
4,964,736 (0.1%)      #[instrument(level = "debug", skip(self), ret)]
        .             fn candidate_from_obligation<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .             ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {
        .                 debug_assert!(!self.infcx.next_trait_solver());
        .                 // Watch out for overflow. This intentionally bypasses (and does
        .                 // not update) the cache.
  177,312 (0.0%)          self.check_recursion_limit(stack.obligation, stack.obligation)?;
        .         
        .                 // Check the cache. Note that we freshen the trait-ref
        .                 // separately rather than using `stack.fresh_trait_ref` --
        .                 // this is because we want the unbound variables to be
        .                 // replaced with fresh types starting from index 0.
1,418,496 (0.0%)          let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);
        .                 debug!(?cache_fresh_trait_pred);
        .                 debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());
        .         
1,297,941 (0.0%)          if let Some(c) =
  531,106 (0.0%)              self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)
        .                 {
        .                     debug!("CACHE HIT");
        .                     return c;
        .                 }
        .         
        .                 // If no match, compute result and insert into cache.
        .                 //
        .                 // FIXME(nikomatsakis) -- this cache is not taking into
        .                 // account cycles that may have occurred in forming the
        .                 // candidate. I don't know of any specific problems that
        .                 // result but it seems awfully suspicious.
  736,496 (0.0%)          let (candidate, dep_node) =
  276,186 (0.0%)              self.in_task(|this| this.candidate_from_obligation_no_cache(stack));
        .         
        .                 debug!("CACHE MISS");
        .                 self.insert_candidate_cache(
  368,248 (0.0%)              stack.obligation.param_env,
        .                     cache_fresh_trait_pred,
        .                     dep_node,
   92,062 (0.0%)              candidate.clone(),
        .                 );
  644,434 (0.0%)          candidate
        .             }
        .         
  828,558 (0.0%)      fn candidate_from_obligation_no_cache<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .             ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {
        .                 if let Err(conflict) = self.is_knowable(stack) {
        .                     debug!("coherence stage: not knowable");
        .                     if self.intercrate_ambiguity_causes.is_some() {
        .                         debug!("evaluate_stack: intercrate_ambiguity_causes is some");
        .                         // Heuristics: show the diagnostics when there are no candidates in crate.
        9 (0.0%)                  if let Ok(candidate_set) = self.assemble_candidates(stack) {
        .                             let mut no_candidates_apply = true;
        .         
        3 (0.0%)                      for c in candidate_set.vec.iter() {
        .                                 if self
        .                                     .evaluate_candidate(stack, c, LeakCheckHigherRankedGoal::No)?
        .                                     .may_apply()
        .                                 {
        .                                     no_candidates_apply = false;
        .                                     break;
        .                                 }
        .                             }
        .         
        2 (0.0%)                      if !candidate_set.ambiguous && no_candidates_apply {
        3 (0.0%)                          let trait_ref = self.infcx.resolve_vars_if_possible(
        5 (0.0%)                              stack.obligation.predicate.skip_binder().trait_ref,
        .                                 );
        2 (0.0%)                          if !trait_ref.references_error() {
        .                                     let self_ty = trait_ref.self_ty();
        .                                     let self_ty = self_ty.has_concrete_skeleton().then(|| self_ty);
        .                                     let cause = if let Conflict::Upstream = conflict {
        .                                         IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_ref, self_ty }
        .                                     } else {
        .                                         IntercrateAmbiguityCause::DownstreamCrate { trait_ref, self_ty }
        .                                     };
        .                                     debug!(?cause, "evaluate_stack: pushing cause");
        6 (0.0%)                              self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);
        .                                 }
        .                             }
        .                         }
        .                     }
      152 (0.0%)              return Ok(None);
        .                 }
        .         
  183,820 (0.0%)          let candidate_set = self.assemble_candidates(stack)?;
        .         
  183,820 (0.0%)          if candidate_set.ambiguous {
        .                     debug!("candidate set contains ambig");
      673 (0.0%)              return Ok(None);
        .                 }
        .         
        .                 let candidates = candidate_set.vec;
        .         
        .                 debug!(?stack, ?candidates, "assembled {} candidates", candidates.len());
        .         
        .                 // At this point, we know that each of the entries in the
        .                 // candidate set is *individually* applicable. Now we have to
        .                 // figure out if they contain mutual incompatibilities. This
        .                 // frequently arises if we have an unconstrained input type --
        .                 // for example, we are looking for `$0: Eq` where `$0` is some
        .                 // unconstrained type variable. In that case, we'll get a
        .                 // candidate which assumes $0 == int, one that assumes `$0 ==
        .                 // usize`, etc. This spells an ambiguity.
        .         
   84,234 (0.0%)          let mut candidates = self.filter_impls(candidates, stack.obligation);
        .         
        .                 // If there is more than one candidate, first winnow them down
        .                 // by considering extra conditions (nested obligations and so
        .                 // forth). We don't winnow if there is exactly one
        .                 // candidate. This is a relatively minor distinction but it
        .                 // can lead to better inference and error-reporting. An
        .                 // example would be if there was an impl:
        .                 //
        .                 //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }
        .                 //
        .                 // and we were to see some code `foo.push_clone()` where `boo`
        .                 // is a `Vec<Bar>` and `Bar` does not implement `Clone`. If
        .                 // we were to winnow, we'd wind up with zero candidates.
        .                 // Instead, we select the right impl now but report "`Bar` does
        .                 // not implement `Clone`".
  182,474 (0.0%)          if candidates.len() == 1 {
  166,982 (0.0%)              return self.filter_reservation_impls(candidates.pop().unwrap());
        .                 }
        .         
        .                 // Winnow, but record the exact outcome of evaluation, which
        .                 // is needed for specialization. Propagate overflow if it occurs.
        .                 let mut candidates = candidates
        .                     .into_iter()
    7,634 (0.0%)              .map(|c| match self.evaluate_candidate(stack, &c, LeakCheckHigherRankedGoal::No) {
        .                         Ok(eval) if eval.may_apply() => {
    6,791 (0.0%)                      Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))
        .                         }
        .                         Ok(_) => Ok(None),
        .                         Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),
        .                         Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),
        .                     })
        .                     .flat_map(Result::transpose)
        .                     .collect::<Result<Vec<_>, _>>()?;
        .         
        .                 debug!(?stack, ?candidates, "winnowed to {} candidates", candidates.len());
        .         
   15,492 (0.0%)          let has_non_region_infer = stack.obligation.predicate.has_non_region_infer();
        .         
        .                 // If there are STILL multiple candidates, we can further
        .                 // reduce the list by dropping duplicates -- including
        .                 // resolving specializations.
   15,492 (0.0%)          if candidates.len() > 1 {
        .                     let mut i = 0;
      387 (0.0%)              while i < candidates.len() {
      523 (0.0%)                  let should_drop_i = (0..candidates.len()).filter(|&j| i != j).any(|j| {
        .                             self.candidate_should_be_dropped_in_favor_of(
        .                                 &candidates[i],
        .                                 &candidates[j],
        .                                 has_non_region_infer,
        .                             ) == DropVictim::Yes
        .                         });
      590 (0.0%)                  if should_drop_i {
        .                             debug!(candidate = ?candidates[i], "Dropping candidate #{}/{}", i, candidates.len());
        .                             candidates.swap_remove(i);
        .                         } else {
        .                             debug!(candidate = ?candidates[i], "Retaining candidate #{}/{}", i, candidates.len());
      121 (0.0%)                      i += 1;
        .         
        .                             // If there are *STILL* multiple candidates, give up
        .                             // and report ambiguity.
      484 (0.0%)                      if i > 1 {
        .                                 debug!("multiple matches, ambig");
        .                                 return Ok(None);
        .                             }
        .                         }
        .                     }
        .                 }
        .         
        .                 // If there are *NO* candidates, then there are no impls --
-- line 520 ----------------------------------------
-- line 521 ----------------------------------------
        .                 // that we know of, anyway. Note that in the case where there
        .                 // are unbound type variables within the obligation, it might
        .                 // be the case that you could still satisfy the obligation
        .                 // from another crate by instantiating the type variables with
        .                 // a type from another crate that does have an impl. This case
        .                 // is checked for in `evaluate_stack` (and hence users
        .                 // who might care about this case, like coherence, should use
        .                 // that function).
   15,458 (0.0%)          if candidates.is_empty() {
        .                     // If there's an error type, 'downgrade' our result from
        .                     // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid
        .                     // emitting additional spurious errors, since we're guaranteed
        .                     // to have emitted at least one.
   21,189 (0.0%)              if stack.obligation.predicate.references_error() {
        .                         debug!(?stack.obligation.predicate, "found error type in predicate, treating as ambiguous");
        .                         return Ok(None);
        .                     }
   21,189 (0.0%)              return Err(Unimplemented);
        .                 }
        .         
        .                 // Just one candidate left.
    3,996 (0.0%)          self.filter_reservation_impls(candidates.pop().unwrap().candidate)
  736,496 (0.0%)      }
        .         
        .             ///////////////////////////////////////////////////////////////////////////
        .             // EVALUATION
        .             //
        .             // Tests whether an obligation can be selected or whether an impl
        .             // can be applied to particular types. It skips the "confirmation"
        .             // step and hence completely ignores output type parameters.
        .             //
-- line 551 ----------------------------------------
-- line 552 ----------------------------------------
        .             // The result is "true" if the obligation *may* hold and "false" if
        .             // we can be sure it does not.
        .         
        .             /// Evaluates whether the obligation `obligation` can be satisfied
        .             /// and returns an `EvaluationResult`. This is meant for the
        .             /// *initial* call.
        .             ///
        .             /// Do not use this directly, use `infcx.evaluate_obligation` instead.
   69,576 (0.0%)      pub fn evaluate_root_obligation(
        .                 &mut self,
        .                 obligation: &PredicateObligation<'tcx>,
        .             ) -> Result<EvaluationResult, OverflowError> {
        .                 debug_assert!(!self.infcx.next_trait_solver());
        .                 self.evaluation_probe(|this, _outer_universe| {
        .                     let goal =
   35,414 (0.0%)                  this.infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));
   88,535 (0.0%)              let mut result = this.evaluate_predicate_recursively(
        .                         TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),
        .                         obligation.clone(),
        .                     )?;
        .                     // If the predicate has done any inference, then downgrade the
        .                     // result to ambiguous.
   35,414 (0.0%)              if this.infcx.shallow_resolve(goal) != goal {
        .                         result = result.max(EvaluatedToAmbig);
        .                     }
        .                     Ok(result)
        .                 })
        .             }
        .         
        .             /// Computes the evaluation result of `op`, discarding any constraints.
        .             ///
        .             /// This also runs for leak check to allow higher ranked region errors to impact
        .             /// selection. By default it checks for leaks from all universes created inside of
        .             /// `op`, but this can be overwritten if necessary.
        .             fn evaluation_probe(
        .                 &mut self,
        .                 op: impl FnOnce(&mut Self, &mut ty::UniverseIndex) -> Result<EvaluationResult, OverflowError>,
        .             ) -> Result<EvaluationResult, OverflowError> {
   53,434 (0.0%)          self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {
   17,707 (0.0%)              let mut outer_universe = self.infcx.universe();
        .                     let result = op(self, &mut outer_universe)?;
        .         
1,919,347 (0.0%)              match self.infcx.leak_check(outer_universe, Some(snapshot)) {
        .                         Ok(()) => {}
        .                         Err(_) => return Ok(EvaluatedToErr),
        .                     }
        .         
1,356,005 (0.0%)              if self.infcx.opaque_types_added_in_snapshot(snapshot) {
        .                         return Ok(result.max(EvaluatedToOkModuloOpaqueTypes));
        .                     }
        .         
1,188,515 (0.0%)              if self.infcx.region_constraints_added_in_snapshot(snapshot) {
        .                         Ok(result.max(EvaluatedToOkModuloRegions))
        .                     } else {
        .                         Ok(result)
        .                     }
        .                 })
        .             }
        .         
        .             /// Evaluates the predicates in `predicates` recursively. This may
        .             /// guide inference. If this is not desired, run it inside of a
        .             /// is run within an inference probe.
        .             /// `probe`.
  132,100 (0.0%)      #[instrument(skip(self, stack), level = "debug")]
        .             fn evaluate_predicates_recursively<'o, I>(
        .                 &mut self,
        .                 stack: TraitObligationStackList<'o, 'tcx>,
        .                 predicates: I,
        .             ) -> Result<EvaluationResult, OverflowError>
        .             where
        .                 I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,
        .             {
        .                 let mut result = EvaluatedToOk;
1,737,970 (0.0%)          for mut obligation in predicates {
        .                     obligation.set_depth_from_parent(stack.depth());
  740,676 (0.0%)              let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;
  246,892 (0.0%)              if let EvaluatedToErr = eval {
        .                         // fast-path - EvaluatedToErr is the top of the lattice,
        .                         // so we don't need to look on the other predicates.
        .                         return Ok(EvaluatedToErr);
        .                     } else {
        .                         result = cmp::max(result, eval);
        .                     }
        .                 }
        .                 Ok(result)
        .             }
        .         
2,681,907 (0.0%)      #[instrument(
        .                 level = "debug",
        .                 skip(self, previous_stack),
        .                 fields(previous_stack = ?previous_stack.head())
        .                 ret,
1,411,530 (0.0%)      )]
        .             fn evaluate_predicate_recursively<'o>(
        .                 &mut self,
        .                 previous_stack: TraitObligationStackList<'o, 'tcx>,
        .                 obligation: PredicateObligation<'tcx>,
        .             ) -> Result<EvaluationResult, OverflowError> {
        .                 debug_assert!(!self.infcx.next_trait_solver());
        .                 // `previous_stack` stores a `PolyTraitObligation`, while `obligation` is
        .                 // a `PredicateObligation`. These are distinct types, so we can't
        .                 // use any `Option` combinator method that would force them to be
        .                 // the same.
  282,306 (0.0%)          match previous_stack.head() {
  116,772 (0.0%)              Some(h) => self.check_recursion_limit(&obligation, h.obligation)?,
        .                     None => self.check_recursion_limit(&obligation, &obligation)?,
        .                 }
        .         
1,270,377 (0.0%)          ensure_sufficient_stack(|| {
  282,306 (0.0%)              let bound_predicate = obligation.predicate.kind();
1,834,989 (0.0%)              match bound_predicate.skip_binder() {
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Trait(t)) => {
        .                             let t = bound_predicate.rebind(t);
        .                             debug_assert!(!t.has_escaping_bound_vars());
  134,914 (0.0%)                      let obligation = obligation.with(self.tcx(), t);
  944,398 (0.0%)                      self.evaluate_trait_predicate_recursively(previous_stack, obligation)
        .                         }
        .         
        .                         ty::PredicateKind::Subtype(p) => {
        .                             let p = bound_predicate.rebind(p);
        .                             // Does this code ever run?
        .                             match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {
        .                                 Ok(Ok(InferOk { obligations, .. })) => {
        .                                     self.evaluate_predicates_recursively(previous_stack, obligations)
-- line 675 ----------------------------------------
-- line 775 ----------------------------------------
        .                                 }
        .                                 None => Ok(EvaluatedToAmbig),
        .                             }
        .                         }
        .         
        .                         ty::PredicateKind::Clause(ty::ClauseKind::TypeOutlives(pred)) => {
        .                             // A global type with no free lifetimes or generic parameters
        .                             // outlives anything.
    3,528 (0.0%)                      if pred.0.has_free_regions()
        .                                 || pred.0.has_bound_regions()
        .                                 || pred.0.has_non_region_infer()
        .                                 || pred.0.has_non_region_infer()
        .                             {
        .                                 Ok(EvaluatedToOkModuloRegions)
        .                             } else {
        .                                 Ok(EvaluatedToOk)
        .                             }
-- line 791 ----------------------------------------
-- line 801 ----------------------------------------
        .                                 Ok(EvaluatedToOk)
        .                             } else {
        .                                 Ok(EvaluatedToErr)
        .                             }
        .                         }
        .         
        .                         ty::PredicateKind::Clause(ty::ClauseKind::Projection(data)) => {
        .                             let data = bound_predicate.rebind(data);
    4,798 (0.0%)                      let project_obligation = obligation.with(self.tcx(), data);
   52,778 (0.0%)                      match project::poly_project_and_unify_type(self, &project_obligation) {
   14,730 (0.0%)                          ProjectAndUnifyResult::Holds(mut subobligations) => {
        .                                     'compute_res: {
        .                                         // If we've previously marked this projection as 'complete', then
        .                                         // use the final cached result (either `EvaluatedToOk` or
        .                                         // `EvaluatedToOkModuloRegions`), and skip re-evaluating the
        .                                         // sub-obligations.
    8,838 (0.0%)                                  if let Some(key) =
    5,892 (0.0%)                                      ProjectionCacheKey::from_poly_projection_predicate(self, data)
        .                                         {
   13,944 (0.0%)                                      if let Some(cached_res) = self
        .                                                 .infcx
        .                                                 .inner
        .                                                 .borrow_mut()
        .                                                 .projection_cache()
        .                                                 .is_complete(key)
        .                                             {
        .                                                 break 'compute_res Ok(cached_res);
        .                                             }
-- line 828 ----------------------------------------
-- line 829 ----------------------------------------
        .                                         }
        .         
        .                                         // Need to explicitly set the depth of nested goals here as
        .                                         // projection obligations can cycle by themselves and in
        .                                         // `evaluate_predicates_recursively` we only add the depth
        .                                         // for parent trait goals because only these get added to the
        .                                         // `TraitObligationStackList`.
        .                                         for subobligation in subobligations.iter_mut() {
   10,390 (0.0%)                                      subobligation.set_depth_from_parent(obligation.recursion_depth);
        .                                         }
    8,838 (0.0%)                                  let res = self.evaluate_predicates_recursively(
    8,838 (0.0%)                                      previous_stack,
        .                                             subobligations,
        .                                         );
   11,784 (0.0%)                                  if let Ok(eval_rslt) = res
        .                                             && (eval_rslt == EvaluatedToOk
        .                                                 || eval_rslt == EvaluatedToOkModuloRegions)
      168 (0.0%)                                      && let Some(key) =
      168 (0.0%)                                          ProjectionCacheKey::from_poly_projection_predicate(
        .                                                     self, data,
        .                                                 )
        .                                         {
        .                                             // If the result is something that we can cache, then mark this
        .                                             // entry as 'complete'. This will allow us to skip evaluating the
        .                                             // subobligations at all the next time we evaluate the projection
        .                                             // predicate.
      420 (0.0%)                                      self.infcx
        .                                                 .inner
        .                                                 .borrow_mut()
        .                                                 .projection_cache()
        .                                                 .complete(key, eval_rslt);
        .                                         }
        .                                         res
        .                                     }
        .                                 }
-- line 863 ----------------------------------------
-- line 982 ----------------------------------------
        .                         ty::PredicateKind::NormalizesTo(..) => {
        .                             bug!("NormalizesTo is only used by the new solver")
        .                         }
        .                         ty::PredicateKind::AliasRelate(..) => {
        .                             bug!("AliasRelate is only used by the new solver")
        .                         }
        .                         ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),
        .                         ty::PredicateKind::Clause(ty::ClauseKind::ConstArgHasType(ct, ty)) => {
    2,385 (0.0%)                      match self.infcx.at(&obligation.cause, obligation.param_env).eq(
        .                                 // Only really excercised by generic_const_exprs
        .                                 DefineOpaqueTypes::Yes,
        .                                 ct.ty(),
        .                                 ty,
        .                             ) {
        .                                 Ok(inf_ok) => self.evaluate_predicates_recursively(
        .                                     previous_stack,
        .                                     inf_ok.into_obligations(),
        .                                 ),
        .                                 Err(_) => Ok(EvaluatedToErr),
        .                             }
        .                         }
        .                     }
1,411,530 (0.0%)          })
        .             }
        .         
4,182,334 (0.1%)      #[instrument(skip(self, previous_stack), level = "debug", ret)]
        .             fn evaluate_trait_predicate_recursively<'o>(
        .                 &mut self,
        .                 previous_stack: TraitObligationStackList<'o, 'tcx>,
        .                 mut obligation: PolyTraitObligation<'tcx>,
        .             ) -> Result<EvaluationResult, OverflowError> {
  134,914 (0.0%)          if !self.is_intercrate()
  115,324 (0.0%)              && obligation.is_global()
        .                     && obligation.param_env.caller_bounds().iter().all(|bound| bound.has_param())
        .                 {
        .                     // If a param env has no global bounds, global obligations do not
        .                     // depend on its particular value in order to work, so we can clear
        .                     // out the param env and get better caching.
        .                     debug!("in global");
   16,934 (0.0%)              obligation.param_env = obligation.param_env.without_caller_bounds();
        .                 }
        .         
  404,742 (0.0%)          let stack = self.push_stack(previous_stack, &obligation);
  539,656 (0.0%)          let fresh_trait_pred = stack.fresh_trait_pred;
  269,828 (0.0%)          let param_env = obligation.param_env;
        .         
        .                 debug!(?fresh_trait_pred);
        .         
        .                 // If a trait predicate is in the (local or global) evaluation cache,
        .                 // then we know it holds without cycles.
  760,212 (0.0%)          if let Some(result) = self.check_evaluation_cache(param_env, fresh_trait_pred) {
        .                     debug!("CACHE HIT");
        .                     return Ok(result);
        .                 }
        .         
  469,921 (0.0%)          if let Some(result) = stack.cache().get_provisional(fresh_trait_pred) {
        .                     debug!("PROVISIONAL CACHE HIT");
        .                     stack.update_reached_depth(result.reached_depth);
        .                     return Ok(result.result);
        .                 }
        .         
        .                 // Check if this is a match for something already on the
        .                 // stack. If so, we don't want to insert the result into the
        .                 // main cache (it is cycle dependent) nor the provisional
        .                 // cache (which is meant for things that have completed but
        .                 // for a "backedge" -- this result *is* the backedge).
   93,944 (0.0%)          if let Some(cycle_result) = self.check_evaluation_cycle(&stack) {
        .                     return Ok(cycle_result);
        .                 }
        .         
  580,720 (0.0%)          let (result, dep_node) = self.in_task(|this| {
   58,072 (0.0%)              let mut result = this.evaluate_stack(&stack)?;
        .         
        .                     // fix issue #103563, we don't normalize
        .                     // nested obligations which produced by `TraitDef` candidate
        .                     // (i.e. using bounds on assoc items as assumptions).
        .                     // because we don't have enough information to
        .                     // normalize these obligations before evaluating.
        .                     // so we will try to normalize the obligation and evaluate again.
        .                     // we will replace it with new solver in the future.
  113,074 (0.0%)              if EvaluationResult::EvaluatedToErr == result
   12,534 (0.0%)                  && fresh_trait_pred.has_aliases()
        .                         && fresh_trait_pred.is_global()
        .                     {
        .                         let mut nested_obligations = Vec::new();
        .                         let predicate = normalize_with_depth_to(
        .                             this,
        .                             param_env,
        .                             obligation.cause.clone(),
        .                             obligation.recursion_depth + 1,
-- line 1071 ----------------------------------------
-- line 1087 ----------------------------------------
        .                                     nested_result,
        .                                     this.evaluate_trait_predicate_recursively(previous_stack, obligation)?,
        .                                 );
        .                             }
        .                         }
        .                     }
        .         
        .                     Ok::<_, OverflowError>(result)
  522,648 (0.0%)          });
        .         
        .                 let result = result?;
        .         
        .                 if !result.must_apply_modulo_regions() {
   17,294 (0.0%)              stack.cache().on_failure(stack.dfn);
        .                 }
        .         
        .                 let reached_depth = stack.reached_depth.get();
  116,144 (0.0%)          if reached_depth >= stack.depth {
        .                     debug!("CACHE MISS");
  348,390 (0.0%)              self.insert_evaluation_cache(param_env, fresh_trait_pred, dep_node, result);
   58,065 (0.0%)              stack.cache().on_completion(stack.dfn);
        .                 } else {
        .                     debug!("PROVISIONAL");
        .                     debug!(
        .                         "caching provisionally because {:?} \
        .                          is a cycle participant (at depth {}, reached depth {})",
        .                         fresh_trait_pred, stack.depth, reached_depth,
        .                     );
        .         
       91 (0.0%)              stack.cache().insert_provisional(stack.dfn, reached_depth, fresh_trait_pred, result);
        .                 }
        .         
        .                 Ok(result)
        .             }
        .         
        .             /// If there is any previous entry on the stack that precisely
        .             /// matches this obligation, then we can assume that the
        .             /// obligation is satisfied for now (still all other conditions
-- line 1124 ----------------------------------------
-- line 1141 ----------------------------------------
        .             fn check_evaluation_cycle(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'_, 'tcx>,
        .             ) -> Option<EvaluationResult> {
        .                 if let Some(cycle_depth) = stack
        .                     .iter()
        .                     .skip(1) // Skip top-most frame.
        .                     .find(|prev| {
  854,438 (0.0%)                  stack.obligation.param_env == prev.obligation.param_env
        .                             && stack.fresh_trait_pred == prev.fresh_trait_pred
        .                     })
   71,744 (0.0%)              .map(|stack| stack.depth)
        .                 {
        .                     debug!("evaluate_stack --> recursive at depth {}", cycle_depth);
        .         
        .                     // If we have a stack like `A B C D E A`, where the top of
        .                     // the stack is the final `A`, then this will iterate over
        .                     // `A, E, D, C, B` -- i.e., all the participants apart
        .                     // from the cycle head. We mark them as participating in a
        .                     // cycle. This suppresses caching for those nodes. See
-- line 1160 ----------------------------------------
-- line 1161 ----------------------------------------
        .                     // `in_cycle` field for more details.
        .                     stack.update_reached_depth(cycle_depth);
        .         
        .                     // Subtle: when checking for a coinductive cycle, we do
        .                     // not compare using the "freshened trait refs" (which
        .                     // have erased regions) but rather the fully explicit
        .                     // trait refs. This is important because it's only a cycle
        .                     // if the regions match exactly.
   69,412 (0.0%)              let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);
        .                     let tcx = self.tcx();
  251,153 (0.0%)              let cycle = cycle.map(|stack| stack.obligation.predicate.to_predicate(tcx));
        .                     if self.coinductive_match(cycle) {
        .                         debug!("evaluate_stack --> recursive, coinductive");
        .                         Some(EvaluatedToOk)
        .                     } else {
        .                         debug!("evaluate_stack --> recursive, inductive");
        .                         Some(EvaluatedToAmbigStackDependent)
        .                     }
        .                 } else {
-- line 1179 ----------------------------------------
-- line 1206 ----------------------------------------
        .                 // imagine, this is just where we started. To avoid that, we
        .                 // check for unbound variables and return an ambiguous (hence possible)
        .                 // match if we've seen this trait before.
        .                 //
        .                 // This suffices to allow chains like `FnMut` implemented in
        .                 // terms of `Fn` etc, but we could probably make this more
        .                 // precise still.
        .                 let unbound_input_types =
   58,072 (0.0%)              stack.fresh_trait_pred.skip_binder().trait_ref.args.types().any(|ty| ty.is_fresh());
        .         
        .                 if unbound_input_types
        .                     && stack.iter().skip(1).any(|prev| {
    2,601 (0.0%)                  stack.obligation.param_env == prev.obligation.param_env
    5,202 (0.0%)                      && self.match_fresh_trait_refs(stack.fresh_trait_pred, prev.fresh_trait_pred)
        .                     })
        .                 {
        .                     debug!("evaluate_stack --> unbound argument, recursive --> giving up",);
        .                     return Ok(EvaluatedToAmbigStackDependent);
        .                 }
        .         
  514,175 (0.0%)          match self.candidate_from_obligation(stack) {
  510,260 (0.0%)              Ok(Some(c)) => self.evaluate_candidate(stack, &c, LeakCheckHigherRankedGoal::Yes),
        .                     Ok(None) => Ok(EvaluatedToAmbig),
        .                     Err(Overflow(OverflowError::Canonical)) => Err(OverflowError::Canonical),
        .                     Err(..) => Ok(EvaluatedToErr),
        .                 }
        .             }
        .         
        .             /// For defaulted traits, we use a co-inductive strategy to solve, so
        .             /// that recursion is ok. This routine returns `true` if the top of the
-- line 1235 ----------------------------------------
-- line 1238 ----------------------------------------
        .             /// - is a defaulted trait,
        .             /// - it also appears in the backtrace at some position `X`,
        .             /// - all the predicates at positions `X..` between `X` and the top are
        .             ///   also defaulted traits.
        .             pub(crate) fn coinductive_match<I>(&mut self, mut cycle: I) -> bool
        .             where
        .                 I: Iterator<Item = ty::Predicate<'tcx>>,
        .             {
   82,822 (0.0%)          cycle.all(|predicate| predicate.is_coinductive(self.tcx()))
        .             }
        .         
        .             /// Further evaluates `candidate` to decide whether all type parameters match and whether nested
        .             /// obligations are met. Returns whether `candidate` remains viable after this further
        .             /// scrutiny.
        .             ///
        .             /// Depending on the value of [LeakCheckHigherRankedGoal], we may ignore the binder of the goal
        .             /// when eagerly detecting higher ranked region errors via the `leak_check`. See that enum for
        .             /// more info.
  630,096 (0.0%)      #[instrument(
        .                 level = "debug",
        .                 skip(self, stack),
        .                 fields(depth = stack.obligation.recursion_depth),
        .                 ret
  472,572 (0.0%)      )]
        .             fn evaluate_candidate<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .                 candidate: &SelectionCandidate<'tcx>,
        .                 leak_check_higher_ranked_goal: LeakCheckHigherRankedGoal,
        .             ) -> Result<EvaluationResult, OverflowError> {
  105,016 (0.0%)          let mut result = self.evaluation_probe(|this, outer_universe| {
        .                     // We eagerly instantiate higher ranked goals to prevent universe errors
        .                     // from impacting candidate selection. This matches the behavior of the new
        .                     // solver. This slightly weakens type inference.
        .                     //
        .                     // In case there are no unresolved type or const variables this
        .                     // should still not be necessary to select a unique impl as any overlap
        .                     // relying on a universe error from higher ranked goals should have resulted
        .                     // in an overlap error in coherence.
  630,096 (0.0%)              let p = self.infcx.enter_forall_and_leak_universe(stack.obligation.predicate);
  105,016 (0.0%)              let obligation = stack.obligation.with(this.tcx(), ty::Binder::dummy(p));
  210,032 (0.0%)              match leak_check_higher_ranked_goal {
        .                         LeakCheckHigherRankedGoal::No => *outer_universe = self.infcx.universe(),
        .                         LeakCheckHigherRankedGoal::Yes => {}
        .                     }
        .         
  210,032 (0.0%)              match this.confirm_candidate(&obligation, candidate.clone()) {
  210,032 (0.0%)                  Ok(selection) => {
        .                             debug!(?selection);
        .                             this.evaluate_predicates_recursively(
        .                                 stack.list(),
        .                                 selection.nested_obligations().into_iter(),
        .                             )
        .                         }
        .                         Err(..) => Ok(EvaluatedToErr),
        .                     }
  105,016 (0.0%)          })?;
        .         
        .                 // If we erased any lifetimes, then we want to use
        .                 // `EvaluatedToOkModuloRegions` instead of `EvaluatedToOk`
        .                 // as your final result. The result will be cached using
        .                 // the freshened trait predicate as a key, so we need
        .                 // our result to be correct by *any* choice of original lifetimes,
        .                 // not just the lifetime choice for this particular (non-erased)
        .                 // predicate.
-- line 1302 ----------------------------------------
-- line 1312 ----------------------------------------
        .                 &self,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 trait_pred: ty::PolyTraitPredicate<'tcx>,
        .             ) -> Option<EvaluationResult> {
        .                 // Neither the global nor local cache is aware of intercrate
        .                 // mode, so don't do any caching. In particular, we might
        .                 // re-use the same `InferCtxt` with both an intercrate
        .                 // and non-intercrate `SelectionContext`
  134,914 (0.0%)          if self.is_intercrate() {
        .                     return None;
        .                 }
        .         
        .                 let tcx = self.tcx();
        .                 if self.can_use_global_caches(param_env) {
  741,528 (0.0%)              if let Some(res) = tcx.evaluation_cache.get(&(param_env, trait_pred), tcx) {
        .                         return Some(res);
        .                     }
        .                 }
1,213,058 (0.0%)          self.infcx.evaluation_cache.get(&(param_env, trait_pred), tcx)
        .             }
        .         
        .             fn insert_evaluation_cache(
        .                 &mut self,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 trait_pred: ty::PolyTraitPredicate<'tcx>,
        .                 dep_node: DepNodeIndex,
        .                 result: EvaluationResult,
-- line 1338 ----------------------------------------
-- line 1342 ----------------------------------------
        .                 if result.is_stack_dependent() {
        .                     return;
        .                 }
        .         
        .                 // Neither the global nor local cache is aware of intercrate
        .                 // mode, so don't do any caching. In particular, we might
        .                 // re-use the same `InferCtxt` with both an intercrate
        .                 // and non-intercrate `SelectionContext`
   58,065 (0.0%)          if self.is_intercrate() {
        .                     return;
        .                 }
        .         
        .                 if self.can_use_global_caches(param_env) {
        .                     if !trait_pred.has_infer() {
        .                         debug!(?trait_pred, ?result, "insert_evaluation_cache global");
        .                         // This may overwrite the cache with the same value
        .                         // FIXME: Due to #50507 this overwrites the different values
        .                         // This should be changed to use HashMapExt::insert_same
        .                         // when that is fixed
  314,328 (0.0%)                  self.tcx().evaluation_cache.insert((param_env, trait_pred), dep_node, result);
        .                         return;
        .                     }
        .                 }
        .         
        .                 debug!(?trait_pred, ?result, "insert_evaluation_cache");
  377,988 (0.0%)          self.infcx.evaluation_cache.insert((param_env, trait_pred), dep_node, result);
        .             }
        .         
        .             fn check_recursion_depth<T>(
        .                 &self,
        .                 depth: usize,
        .                 error_obligation: &Obligation<'tcx, T>,
        .             ) -> Result<(), OverflowError>
        .             where
        .                 T: ToPredicate<'tcx> + Clone,
        .             {
1,273,860 (0.0%)          if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {
        .                     match self.query_mode {
        .                         TraitQueryMode::Standard => {
        .                             if let Some(e) = self.infcx.tainted_by_errors() {
        .                                 return Err(OverflowError::Error(e));
        .                             }
        .                             self.infcx.err_ctxt().report_overflow_obligation(error_obligation, true);
        .                         }
        .                         TraitQueryMode::Canonical => {
-- line 1386 ----------------------------------------
-- line 1399 ----------------------------------------
        .             fn check_recursion_limit<T: Display + TypeFoldable<TyCtxt<'tcx>>, V>(
        .                 &self,
        .                 obligation: &Obligation<'tcx, T>,
        .                 error_obligation: &Obligation<'tcx, V>,
        .             ) -> Result<(), OverflowError>
        .             where
        .                 V: ToPredicate<'tcx> + Clone,
        .             {
  318,465 (0.0%)          self.check_recursion_depth(obligation.recursion_depth, error_obligation)
        .             }
        .         
        .             fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)
        .             where
        .                 OP: FnOnce(&mut Self) -> R,
        .             {
  460,310 (0.0%)          let (result, dep_node) =
  638,792 (0.0%)              self.tcx().dep_graph.with_anon_task(self.tcx(), dep_kinds::TraitSelect, || op(self));
  150,134 (0.0%)          self.tcx().dep_graph.read_index(dep_node);
  368,248 (0.0%)          (result, dep_node)
        .             }
        .         
        .             /// filter_impls filters candidates that have a positive impl for a negative
        .             /// goal and a negative impl for a positive goal
        .             #[instrument(level = "debug", skip(self, candidates))]
        .             fn filter_impls(
        .                 &mut self,
        .                 candidates: Vec<SelectionCandidate<'tcx>>,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Vec<SelectionCandidate<'tcx>> {
        .                 trace!("{candidates:#?}");
        .                 let tcx = self.tcx();
        .                 let mut result = Vec::with_capacity(candidates.len());
        .         
  680,264 (0.0%)          for candidate in candidates {
  170,066 (0.0%)              if let ImplCandidate(def_id) = candidate {
   82,055 (0.0%)                  match (tcx.impl_polarity(def_id), obligation.polarity()) {
        .                             (ty::ImplPolarity::Reservation, _)
        .                             | (ty::ImplPolarity::Positive, ty::PredicatePolarity::Positive)
        .                             | (ty::ImplPolarity::Negative, ty::PredicatePolarity::Negative) => {
        .                                 result.push(candidate);
        .                             }
        .                             _ => {}
        .                         }
        .                     } else {
        .                         result.push(candidate);
        .                     }
        .                 }
        .         
        .                 trace!("{result:#?}");
  182,474 (0.0%)          result
        .             }
        .         
        .             /// filter_reservation_impls filter reservation impl for any goal as ambiguous
1,514,826 (0.0%)      #[instrument(level = "debug", skip(self))]
        .             fn filter_reservation_impls(
        .                 &mut self,
        .                 candidate: SelectionCandidate<'tcx>,
        .             ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {
        .                 let tcx = self.tcx();
        .                 // Treat reservation impls as ambiguity.
  199,598 (0.0%)          if let ImplCandidate(def_id) = candidate {
   46,926 (0.0%)              if let ty::ImplPolarity::Reservation = tcx.impl_polarity(def_id) {
        .                         if let Some(intercrate_ambiguity_clauses) = &mut self.intercrate_ambiguity_causes {
        .                             let message = tcx
        .                                 .get_attr(def_id, sym::rustc_reservation_impl)
        .                                 .and_then(|a| a.value_str());
        .                             if let Some(message) = message {
        .                                 debug!(
        .                                     "filter_reservation_impls: \
        .                                          reservation impl ambiguity on {:?}",
-- line 1468 ----------------------------------------
-- line 1470 ----------------------------------------
        .                                 );
        .                                 intercrate_ambiguity_clauses
        .                                     .insert(IntercrateAmbiguityCause::ReservationImpl { message });
        .                             }
        .                         }
        .                         return Ok(None);
        .                     }
        .                 }
  336,628 (0.0%)          Ok(Some(candidate))
        .             }
        .         
        .             fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Result<(), Conflict> {
        .                 debug!("is_knowable(intercrate={:?})", self.is_intercrate());
        .         
   92,062 (0.0%)          if !self.is_intercrate() {
        .                     return Ok(());
        .                 }
        .         
        .                 let obligation = &stack.obligation;
    1,660 (0.0%)          let predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);
        .         
        .                 // Okay to skip binder because of the nature of the
        .                 // trait-ref-is-knowable check, which does not care about
        .                 // bound regions.
      830 (0.0%)          let trait_ref = predicate.skip_binder().trait_ref;
        .         
        .                 coherence::trait_ref_is_knowable::<!>(self.tcx(), trait_ref, |ty| Ok(ty)).unwrap()
        .             }
        .         
        .             /// Returns `true` if the global caches can be used.
        .             fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {
        .                 // If there are any inference variables in the `ParamEnv`, then we
        .                 // always use a cache local to this particular scope. Otherwise, we
        .                 // switch to a global cache.
  460,769 (0.0%)          if param_env.has_infer() {
        .                     return false;
        .                 }
        .         
        .                 // Avoid using the master cache during coherence and just rely
        .                 // on the local cache. This effectively disables caching
        .                 // during coherence. It is really just a simplification to
        .                 // avoid us having to fear that coherence results "pollute"
        .                 // the master cache. Since coherence executes pretty quickly,
-- line 1512 ----------------------------------------
-- line 1524 ----------------------------------------
        .                 &mut self,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,
        .             ) -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>> {
        .                 // Neither the global nor local cache is aware of intercrate
        .                 // mode, so don't do any caching. In particular, we might
        .                 // re-use the same `InferCtxt` with both an intercrate
        .                 // and non-intercrate `SelectionContext`
  177,312 (0.0%)          if self.is_intercrate() {
        .                     return None;
        .                 }
        .                 let tcx = self.tcx();
        .                 let pred = cache_fresh_trait_pred.skip_binder();
        .         
        .                 if self.can_use_global_caches(param_env) {
2,326,176 (0.0%)              if let Some(res) = tcx.selection_cache.get(&(param_env, pred), tcx) {
  426,220 (0.0%)                  return Some(res);
        .                     }
        .                 }
1,191,489 (0.0%)          self.infcx.selection_cache.get(&(param_env, pred), tcx)
        .             }
        .         
        .             /// Determines whether can we safely cache the result
        .             /// of selecting an obligation. This is almost always `true`,
        .             /// except when dealing with certain `ParamCandidate`s.
        .             ///
        .             /// Ordinarily, a `ParamCandidate` will contain no inference variables,
        .             /// since it was usually produced directly from a `DefId`. However,
-- line 1551 ----------------------------------------
-- line 1562 ----------------------------------------
        .             fn can_cache_candidate(
        .                 &self,
        .                 result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>,
        .             ) -> bool {
        .                 // Neither the global nor local cache is aware of intercrate
        .                 // mode, so don't do any caching. In particular, we might
        .                 // re-use the same `InferCtxt` with both an intercrate
        .                 // and non-intercrate `SelectionContext`
   92,062 (0.0%)          if self.is_intercrate() {
        .                     return false;
        .                 }
  695,011 (0.0%)          match result {
        .                     Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.has_infer(),
        .                     _ => true,
        .                 }
        .             }
        .         
        .             #[instrument(skip(self, param_env, cache_fresh_trait_pred, dep_node), level = "debug")]
        .             fn insert_candidate_cache(
        .                 &mut self,
-- line 1581 ----------------------------------------
-- line 1587 ----------------------------------------
        .                 let tcx = self.tcx();
        .                 let pred = cache_fresh_trait_pred.skip_binder();
        .         
        .                 if !self.can_cache_candidate(&candidate) {
        .                     debug!(?pred, ?candidate, "insert_candidate_cache - candidate is not cacheable");
        .                     return;
        .                 }
        .         
   60,142 (0.0%)          if self.can_use_global_caches(param_env) {
  300,710 (0.0%)              if let Err(Overflow(OverflowError::Canonical)) = candidate {
        .                         // Don't cache overflow globally; we only produce this in certain modes.
        .                     } else if !pred.has_infer() {
        4 (0.0%)                  if !candidate.has_infer() {
        .                             debug!(?pred, ?candidate, "insert_candidate_cache global");
        .                             // This may overwrite the cache with the same value.
1,262,982 (0.0%)                      tcx.selection_cache.insert((param_env, pred), dep_node, candidate);
        .                             return;
        .                         }
        .                     }
        .                 }
        .         
        .                 debug!(?pred, ?candidate, "insert_candidate_cache local");
  661,605 (0.0%)          self.infcx.selection_cache.insert((param_env, pred), dep_node, candidate);
        .             }
        .         
        .             /// Looks at the item bounds of the projection or opaque type.
        .             /// If this is a nested rigid projection, such as
        .             /// `<<T as Tr1>::Assoc as Tr2>::Assoc`, consider the item bounds
        .             /// on both `Tr1::Assoc` and `Tr2::Assoc`, since we may encounter
        .             /// relative bounds on both via the `associated_type_bounds` feature.
        .             pub(super) fn for_each_item_bound<T>(
-- line 1617 ----------------------------------------
-- line 1619 ----------------------------------------
        .                 mut self_ty: Ty<'tcx>,
        .                 mut for_each: impl FnMut(&mut Self, ty::Clause<'tcx>, usize) -> ControlFlow<T, ()>,
        .                 on_ambiguity: impl FnOnce(),
        .             ) -> ControlFlow<T, ()> {
        .                 let mut idx = 0;
        .                 let mut in_parent_alias_type = false;
        .         
        .                 loop {
   85,564 (0.0%)              let (kind, alias_ty) = match *self_ty.kind() {
    7,391 (0.0%)                  ty::Alias(kind @ (ty::Projection | ty::Opaque), alias_ty) => (kind, alias_ty),
        .                         ty::Infer(ty::TyVar(_)) => {
        .                             on_ambiguity();
        .                             return ControlFlow::Continue(());
        .                         }
        .                         _ => return ControlFlow::Continue(()),
        .                     };
        .         
        .                     // HACK: On subsequent recursions, we only care about bounds that don't
        .                     // share the same type as `self_ty`. This is because for truly rigid
        .                     // projections, we will never be able to equate, e.g. `<T as Tr>::A`
        .                     // with `<<T as Tr>::A as Tr>::A`.
    8,064 (0.0%)              let relevant_bounds = if in_parent_alias_type {
        .                         self.tcx().item_non_self_assumptions(alias_ty.def_id)
        .                     } else {
        .                         self.tcx().item_super_predicates(alias_ty.def_id)
        .                     };
        .         
    9,347 (0.0%)              for bound in relevant_bounds.instantiate(self.tcx(), alias_ty.args) {
        .                         for_each(self, bound, idx)?;
    2,542 (0.0%)                  idx += 1;
        .                     }
        .         
    3,176 (0.0%)              if kind == ty::Projection {
    4,764 (0.0%)                  self_ty = alias_ty.self_ty();
        .                     } else {
        .                         return ControlFlow::Continue(());
        .                     }
        .         
        .                     in_parent_alias_type = true;
        .                 }
        .             }
        .         
        .             /// Equates the trait in `obligation` with trait bound. If the two traits
        .             /// can be equated and the normalized trait bound doesn't contain inference
        .             /// variables or placeholders, the normalized bound is returned.
   13,504 (0.0%)      fn match_normalize_trait_ref(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 placeholder_trait_ref: ty::TraitRef<'tcx>,
        .                 trait_bound: ty::PolyTraitRef<'tcx>,
        .             ) -> Result<Option<ty::TraitRef<'tcx>>, ()> {
        .                 debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());
      403 (0.0%)          if placeholder_trait_ref.def_id != trait_bound.def_id() {
        .                     // Avoid unnecessary normalization
    1,285 (0.0%)              return Err(());
        .                 }
        .         
    2,015 (0.0%)          let trait_bound = self.infcx.instantiate_binder_with_fresh_vars(
      806 (0.0%)              obligation.cause.span,
        .                     HigherRankedType,
        .                     trait_bound,
        .                 );
    1,612 (0.0%)          let Normalized { value: trait_bound, obligations: _ } = ensure_sufficient_stack(|| {
        .                     normalize_with_depth(
        .                         self,
      403 (0.0%)                  obligation.param_env,
        .                         obligation.cause.clone(),
      806 (0.0%)                  obligation.recursion_depth + 1,
      806 (0.0%)                  trait_bound,
        .                     )
        .                 });
    1,612 (0.0%)          self.infcx
      403 (0.0%)              .at(&obligation.cause, obligation.param_env)
    2,418 (0.0%)              .eq(DefineOpaqueTypes::No, placeholder_trait_ref, trait_bound)
        .                     .map(|InferOk { obligations: _, value: () }| {
        .                         // This method is called within a probe, so we can't have
        .                         // inference variables and placeholders escape.
        .                         if !trait_bound.has_infer() && !trait_bound.has_placeholders() {
        .                             Some(trait_bound)
        .                         } else {
        .                             None
        .                         }
        .                     })
        .                     .map_err(|_| ())
   13,504 (0.0%)      }
        .             fn where_clause_may_apply<'o>(
        .                 &mut self,
        .                 stack: &TraitObligationStack<'o, 'tcx>,
        .                 where_clause_trait_ref: ty::PolyTraitRef<'tcx>,
        .             ) -> Result<EvaluationResult, OverflowError> {
  167,490 (0.0%)          self.evaluation_probe(|this, outer_universe| {
        .                     // Eagerly instantiate higher ranked goals.
        .                     //
        .                     // See the comment in `evaluate_candidate` to see why.
1,674,900 (0.0%)              let p = self.infcx.enter_forall_and_leak_universe(stack.obligation.predicate);
  334,980 (0.0%)              let obligation = stack.obligation.with(this.tcx(), ty::Binder::dummy(p));
        .                     *outer_universe = self.infcx.universe();
1,514,198 (0.0%)              match this.match_where_clause_trait_ref(&obligation, where_clause_trait_ref) {
   33,940 (0.0%)                  Ok(obligations) => this.evaluate_predicates_recursively(stack.list(), obligations),
        .                         Err(()) => Ok(EvaluatedToErr),
        .                     }
        .                 })
        .             }
        .         
        .             /// Return `Yes` if the obligation's predicate type applies to the env_predicate, and
        .             /// `No` if it does not. Return `Ambiguous` in the case that the projection type is a GAT,
        .             /// and applying this env_predicate constrains any of the obligation's GAT parameters.
        .             ///
        .             /// This behavior is a somewhat of a hack to prevent over-constraining inference variables
        .             /// in cases like #91762.
    5,460 (0.0%)      pub(super) fn match_projection_projections(
        .                 &mut self,
        .                 obligation: &ProjectionTyObligation<'tcx>,
        .                 env_predicate: PolyProjectionPredicate<'tcx>,
        .                 potentially_unnormalized_candidates: bool,
        .             ) -> ProjectionMatchesProjection {
        .                 debug_assert_eq!(obligation.predicate.def_id, env_predicate.projection_def_id());
        .         
        .                 let mut nested_obligations = Vec::new();
    1,820 (0.0%)          let infer_predicate = self.infcx.instantiate_binder_with_fresh_vars(
      910 (0.0%)              obligation.cause.span,
        .                     BoundRegionConversionTime::HigherRankedType,
        .                     env_predicate,
        .                 );
      910 (0.0%)          let infer_projection = if potentially_unnormalized_candidates {
        .                     ensure_sufficient_stack(|| {
      385 (0.0%)                  normalize_with_depth_to(
        .                             self,
       55 (0.0%)                      obligation.param_env,
        .                             obligation.cause.clone(),
      110 (0.0%)                      obligation.recursion_depth + 1,
      165 (0.0%)                      infer_predicate.projection_ty,
        .                             &mut nested_obligations,
        .                         )
        .                     })
        .                 } else {
    1,200 (0.0%)              infer_predicate.projection_ty
        .                 };
        .         
    5,005 (0.0%)          let is_match = self
        .                     .infcx
      455 (0.0%)              .at(&obligation.cause, obligation.param_env)
    1,365 (0.0%)              .eq(DefineOpaqueTypes::No, obligation.predicate, infer_projection)
    2,275 (0.0%)              .is_ok_and(|InferOk { obligations, value: () }| {
        .                         self.evaluate_predicates_recursively(
        .                             TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),
        .                             nested_obligations.into_iter().chain(obligations),
        .                         )
        .                         .is_ok_and(|res| res.may_apply())
        .                     });
        .         
      760 (0.0%)          if is_match {
        .                     let generics = self.tcx().generics_of(obligation.predicate.def_id);
        .                     // FIXME(generic-associated-types): Addresses aggressive inference in #92917.
        .                     // If this type is a GAT, and of the GAT args resolve to something new,
        .                     // that means that we must have newly inferred something about the GAT.
        .                     // We should give up in that case.
      760 (0.0%)              if !generics.params.is_empty()
        .                         && obligation.predicate.args[generics.parent_count..]
        .                             .iter()
        .                             .any(|&p| p.has_non_region_infer() && self.infcx.shallow_resolve(p) != p)
        .                     {
        .                         ProjectionMatchesProjection::Ambiguous
        .                     } else {
        .                         ProjectionMatchesProjection::Yes
        .                     }
        .                 } else {
        .                     ProjectionMatchesProjection::No
        .                 }
    4,095 (0.0%)      }
        .         }
        .         
        .         #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        .         enum DropVictim {
        .             Yes,
        .             No,
        .         }
        .         
-- line 1796 ----------------------------------------
-- line 1830 ----------------------------------------
        .                     |cand: &ty::PolyTraitPredicate<'tcx>| cand.is_global() && !cand.has_bound_vars();
        .         
        .                 // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,
        .                 // `DiscriminantKindCandidate`, `ConstDestructCandidate`
        .                 // to anything else.
        .                 //
        .                 // This is a fix for #53123 and prevents winnowing from accidentally extending the
        .                 // lifetime of a variable.
    8,308 (0.0%)          match (&other.candidate, &victim.candidate) {
        .                     // FIXME(@jswrenn): this should probably be more sophisticated
        .                     (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => DropVictim::No,
        .         
        .                     // (*)
        .                     (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => {
        .                         DropVictim::Yes
        .                     }
        .                     (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => {
-- line 1846 ----------------------------------------
-- line 1935 ----------------------------------------
        .                     }
        .                     (ObjectCandidate(_), ProjectionCandidate(_))
        .                     | (ProjectionCandidate(_), ObjectCandidate(_)) => {
        .                         bug!("Have both object and projection candidate")
        .                     }
        .         
        .                     // Arbitrarily give projection and object candidates priority.
        .                     (
      456 (0.0%)                  ObjectCandidate(_) | ProjectionCandidate(_),
        .                         ImplCandidate(..)
        .                         | AutoImplCandidate
        .                         | ClosureCandidate { .. }
        .                         | AsyncClosureCandidate
        .                         | AsyncFnKindHelperCandidate
        .                         | CoroutineCandidate
        .                         | FutureCandidate
        .                         | IteratorCandidate
-- line 1951 ----------------------------------------
-- line 1969 ----------------------------------------
        .                         | IteratorCandidate
        .                         | AsyncIteratorCandidate
        .                         | FnPointerCandidate { .. }
        .                         | BuiltinObjectCandidate
        .                         | BuiltinUnsizeCandidate
        .                         | TraitUpcastingUnsizeCandidate(_)
        .                         | BuiltinCandidate { .. }
        .                         | TraitAliasCandidate,
      912 (0.0%)                  ObjectCandidate(_) | ProjectionCandidate(_),
        .                     ) => DropVictim::No,
        .         
      912 (0.0%)              (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {
        .                         // See if we can toss out `victim` based on specialization.
        .                         // While this requires us to know *for sure* that the `other` impl applies
        .                         // we still use modulo regions here.
        .                         //
        .                         // This is fine as specialization currently assumes that specializing
        .                         // impls have to be always applicable, meaning that the only allowed
        .                         // region constraints may be constraints also present on the default impl.
        .                         let tcx = self.tcx();
      228 (0.0%)                  if other.evaluation.must_apply_modulo_regions() {
    1,752 (0.0%)                      if tcx.specializes((other_def, victim_def)) {
        .                                 return DropVictim::Yes;
        .                             }
        .                         }
        .         
    3,192 (0.0%)                  match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {
        .                             // For #33140 the impl headers must be exactly equal, the trait must not have
        .                             // any associated items and there are no where-clauses.
        .                             //
        .                             // We can just arbitrarily drop one of the impls.
        .                             Some(ty::ImplOverlapKind::Issue33140) => {
        .                                 assert_eq!(other.evaluation, victim.evaluation);
        .                                 DropVictim::Yes
        .                             }
-- line 2003 ----------------------------------------
-- line 2099 ----------------------------------------
        .                         | BuiltinCandidate { has_nested: true }
        .                         | TraitAliasCandidate,
        .                     ) => DropVictim::No,
        .                 }
        .             }
        .         }
        .         
        .         impl<'tcx> SelectionContext<'_, 'tcx> {
   54,460 (0.0%)      fn sized_conditions(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> BuiltinImplConditions<'tcx> {
        .                 use self::BuiltinImplConditions::{Ambiguous, None, Where};
        .         
        .                 // NOTE: binder moved to (*)
   21,784 (0.0%)          let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());
        .         
   27,277 (0.0%)          match self_ty.kind() {
        .                     ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
        .                     | ty::Uint(_)
        .                     | ty::Int(_)
        .                     | ty::Bool
        .                     | ty::Float(_)
        .                     | ty::FnDef(..)
        .                     | ty::FnPtr(_)
        .                     | ty::RawPtr(..)
-- line 2124 ----------------------------------------
-- line 2128 ----------------------------------------
        .                     | ty::CoroutineWitness(..)
        .                     | ty::Array(..)
        .                     | ty::Closure(..)
        .                     | ty::CoroutineClosure(..)
        .                     | ty::Never
        .                     | ty::Dynamic(_, _, ty::DynStar)
        .                     | ty::Error(_) => {
        .                         // safe for everything
    3,798 (0.0%)                  Where(ty::Binder::dummy(Vec::new()))
        .                     }
        .         
        .                     ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,
        .         
    3,318 (0.0%)              ty::Tuple(tys) => Where(
    5,002 (0.0%)                  obligation.predicate.rebind(tys.last().map_or_else(Vec::new, |&last| vec![last])),
        .                     ),
        .         
        .                     ty::Pat(ty, _) => Where(obligation.predicate.rebind(vec![*ty])),
        .         
        .                     ty::Adt(def, args) => {
   10,868 (0.0%)                  if let Some(sized_crit) = def.sized_constraint(self.tcx()) {
        .                             // (*) binder moved here
       63 (0.0%)                      Where(
       42 (0.0%)                          obligation.predicate.rebind(vec![sized_crit.instantiate(self.tcx(), args)]),
        .                             )
        .                         } else {
   24,264 (0.0%)                      Where(ty::Binder::dummy(Vec::new()))
        .                         }
        .                     }
        .         
        .                     ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => None,
        .                     ty::Infer(ty::TyVar(_)) => Ambiguous,
        .         
        .                     // We can make this an ICE if/once we actually instantiate the trait obligation eagerly.
        .                     ty::Bound(..) => None,
        .         
        .                     ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
        .                         bug!("asked to assemble builtin bounds of unexpected type: {:?}", self_ty);
        .                     }
        .                 }
   43,568 (0.0%)      }
        .         
    4,440 (0.0%)      fn copy_clone_conditions(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> BuiltinImplConditions<'tcx> {
        .                 // NOTE: binder moved to (*)
    2,220 (0.0%)          let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());
        .         
        .                 use self::BuiltinImplConditions::{Ambiguous, None, Where};
        .         
    2,220 (0.0%)          match *self_ty.kind() {
        .                     ty::FnDef(..) | ty::FnPtr(_) | ty::Error(_) => Where(ty::Binder::dummy(Vec::new())),
        .         
        .                     ty::Uint(_)
        .                     | ty::Int(_)
        .                     | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
        .                     | ty::Bool
        .                     | ty::Float(_)
        .                     | ty::Char
-- line 2187 ----------------------------------------
-- line 2194 ----------------------------------------
        .                     }
        .         
        .                     ty::Dynamic(..)
        .                     | ty::Str
        .                     | ty::Slice(..)
        .                     | ty::Foreign(..)
        .                     | ty::Ref(_, _, hir::Mutability::Mut) => None,
        .         
        2 (0.0%)              ty::Tuple(tys) => {
        .                         // (*) binder moved here
        8 (0.0%)                  Where(obligation.predicate.rebind(tys.iter().collect()))
        .                     }
        .         
        .                     ty::Pat(ty, _) => {
        .                         // (*) binder moved here
        .                         Where(obligation.predicate.rebind(vec![ty]))
        .                     }
        .         
        .                     ty::Coroutine(coroutine_def_id, args) => {
-- line 2212 ----------------------------------------
-- line 2257 ----------------------------------------
        .                             Where(obligation.predicate.rebind(args.as_closure().upvar_tys().to_vec()))
        .                         }
        .                     }
        .         
        .                     // FIXME(async_closures): These are never clone, for now.
        .                     ty::CoroutineClosure(_, _) => None,
        .                     // `Copy` and `Clone` are automatically implemented for an anonymous adt
        .                     // if all of its fields are `Copy` and `Clone`
      742 (0.0%)              ty::Adt(adt, args) if adt.is_anonymous() => {
        .                         // (*) binder moved here
        .                         Where(obligation.predicate.rebind(
        .                             adt.non_enum_variant().fields.iter().map(|f| f.ty(self.tcx(), args)).collect(),
        .                         ))
        .                     }
        .         
        .                     ty::Adt(..) | ty::Alias(..) | ty::Param(..) | ty::Placeholder(..) => {
        .                         // Fallback to whatever user-defined impls exist in this case.
-- line 2273 ----------------------------------------
-- line 2283 ----------------------------------------
        .         
        .                     // We can make this an ICE if/once we actually instantiate the trait obligation eagerly.
        .                     ty::Bound(..) => None,
        .         
        .                     ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
        .                         bug!("asked to assemble builtin bounds of unexpected type: {:?}", self_ty);
        .                     }
        .                 }
    3,552 (0.0%)      }
        .         
        .             fn fused_iterator_conditions(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> BuiltinImplConditions<'tcx> {
        .                 let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());
        .                 if let ty::Coroutine(did, ..) = *self_ty.kind()
        .                     && self.tcx().coroutine_is_gen(did)
-- line 2299 ----------------------------------------
-- line 2310 ----------------------------------------
        .             /// Here are some (simple) examples:
        .             ///
        .             /// ```ignore (illustrative)
        .             /// (i32, u32) -> [i32, u32]
        .             /// Foo where struct Foo { x: i32, y: u32 } -> [i32, u32]
        .             /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]
        .             /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]
        .             /// ```
  424,024 (0.0%)      #[instrument(level = "debug", skip(self), ret)]
        .             fn constituent_types_for_ty(
        .                 &self,
        .                 t: ty::Binder<'tcx, Ty<'tcx>>,
        .             ) -> Result<ty::Binder<'tcx, Vec<Ty<'tcx>>>, SelectionError<'tcx>> {
1,417,421 (0.0%)          Ok(match *t.skip_binder().kind() {
        .                     ty::Uint(_)
        .                     | ty::Int(_)
        .                     | ty::Bool
        .                     | ty::Float(_)
        .                     | ty::FnDef(..)
        .                     | ty::FnPtr(_)
        .                     | ty::Error(_)
        .                     | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
        .                     | ty::Never
        .                     | ty::Char => ty::Binder::dummy(Vec::new()),
        .         
        .                     // Treat this like `struct str([u8]);`
      128 (0.0%)              ty::Str => ty::Binder::dummy(vec![Ty::new_slice(self.tcx(), self.tcx().types.u8)]),
        .         
        .                     ty::Placeholder(..)
        .                     | ty::Dynamic(..)
        .                     | ty::Param(..)
        .                     | ty::Foreign(..)
        .                     | ty::Alias(ty::Projection | ty::Inherent | ty::Weak, ..)
        .                     | ty::Bound(..)
        .                     | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
        .                         bug!("asked to assemble constituent types of unexpected type: {:?}", t);
        .                     }
        .         
    2,668 (0.0%)              ty::RawPtr(element_ty, _) | ty::Ref(_, element_ty, _) => t.rebind(vec![element_ty]),
        .         
    2,188 (0.0%)              ty::Pat(ty, _) | ty::Array(ty, _) | ty::Slice(ty) => t.rebind(vec![ty]),
        .         
    1,937 (0.0%)              ty::Tuple(tys) => {
        .                         // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet
    4,699 (0.0%)                  t.rebind(tys.iter().collect())
        .                     }
        .         
        .                     ty::Closure(_, args) => {
        .                         let ty = self.infcx.shallow_resolve(args.as_closure().tupled_upvars_ty());
        .                         t.rebind(vec![ty])
        .                     }
        .         
        .                     ty::CoroutineClosure(_, args) => {
-- line 2362 ----------------------------------------
-- line 2370 ----------------------------------------
        .                         t.rebind([ty].into_iter().chain(iter::once(witness)).collect())
        .                     }
        .         
        .                     ty::CoroutineWitness(def_id, args) => {
        .                         bind_coroutine_hidden_types_above(self.infcx, def_id, args, t.bound_vars())
        .                     }
        .         
        .                     // For `PhantomData<T>`, we pass `T`.
  183,484 (0.0%)              ty::Adt(def, args) if def.is_phantom_data() => t.rebind(args.types().collect()),
        .         
        .                     ty::Adt(def, args) => {
  787,295 (0.0%)                  t.rebind(def.all_fields().map(|f| f.ty(self.tcx(), args)).collect())
        .                     }
        .         
        .                     ty::Alias(ty::Opaque, ty::AliasTy { def_id, args, .. }) => {
        .                         // We can resolve the `impl Trait` to its concrete type,
        .                         // which enforces a DAG between the functions requiring
        .                         // the auto trait bounds in question.
        .                         match self.tcx().type_of_opaque(def_id) {
        .                             Ok(ty) => t.rebind(vec![ty.instantiate(self.tcx(), args)]),
-- line 2389 ----------------------------------------
-- line 2390 ----------------------------------------
        .                             Err(_) => {
        .                                 return Err(SelectionError::OpaqueTypeAutoTraitLeakageUnknown(def_id));
        .                             }
        .                         }
        .                     }
        .                 })
        .             }
        .         
1,706,048 (0.0%)      fn collect_predicates_for_types(
        .                 &mut self,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 cause: ObligationCause<'tcx>,
        .                 recursion_depth: usize,
        .                 trait_def_id: DefId,
        .                 types: ty::Binder<'tcx, Vec<Ty<'tcx>>>,
        .             ) -> Vec<PredicateObligation<'tcx>> {
        .                 // Because the types were potentially derived from
-- line 2406 ----------------------------------------
-- line 2412 ----------------------------------------
        .                 //
        .                 // The strategy is to:
        .                 //
        .                 // 1. Instantiate those regions to placeholder regions (e.g.,
        .                 //    `for<'a> &'a i32` becomes `&0 i32`.
        .                 // 2. Produce something like `&'0 i32 : Copy`
        .                 // 3. Re-bind the regions back to `for<'a> &'a i32 : Copy`
        .         
  213,256 (0.0%)          types
        .                     .as_ref()
        .                     .skip_binder() // binder moved -\
        .                     .iter()
        .                     .flat_map(|ty| {
  187,046 (0.0%)                  let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/
        .         
  935,230 (0.0%)                  let placeholder_ty = self.infcx.enter_forall_and_leak_universe(ty);
  935,230 (0.0%)                  let Normalized { value: normalized_ty, mut obligations } =
  748,184 (0.0%)                      ensure_sufficient_stack(|| {
        .                                 normalize_with_depth(
        .                                     self,
  374,092 (0.0%)                              param_env,
        .                                     cause.clone(),
  187,046 (0.0%)                              recursion_depth,
  187,046 (0.0%)                              placeholder_ty,
        .                                 )
        .                             });
        .         
        .                         let tcx = self.tcx();
  935,230 (0.0%)                  let trait_ref = if tcx.generics_of(trait_def_id).params.len() == 1 {
        .                             ty::TraitRef::new(tcx, trait_def_id, [normalized_ty])
        .                         } else {
        .                             // If this is an ill-formed auto/built-in trait, then synthesize
        .                             // new error args for the missing generics.
        .                             let err_args = ty::GenericArgs::extend_with_error(
        .                                 tcx,
        .                                 trait_def_id,
        .                                 &[normalized_ty.into()],
        .                             );
        .                             ty::TraitRef::new(tcx, trait_def_id, err_args)
        .                         };
        .         
  748,184 (0.0%)                  let obligation = Obligation::new(self.tcx(), cause.clone(), param_env, trait_ref);
        .                         obligations.push(obligation);
  187,034 (0.0%)                  obligations
        .                     })
        .                     .collect()
1,050,429 (0.0%)      }
        .         
        .             ///////////////////////////////////////////////////////////////////////////
        .             // Matching
        .             //
        .             // Matching is a common path used for both evaluation and
        .             // confirmation. It basically unifies types that appear in impls
        .             // and traits. This does affect the surrounding environment;
        .             // therefore, when used during evaluation, match routines must be
        .             // run inside of a `probe()` so that their side-effects are
        .             // contained.
        .         
  424,530 (0.0%)      fn rematch_impl(
        .                 &mut self,
        .                 impl_def_id: DefId,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Normalized<'tcx, GenericArgsRef<'tcx>> {
        .                 let impl_trait_header = self.tcx().impl_trait_header(impl_def_id).unwrap();
  226,416 (0.0%)          match self.match_impl(impl_def_id, impl_trait_header, obligation) {
  113,208 (0.0%)              Ok(args) => args,
        .                     Err(()) => {
        .                         let predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);
        .                         bug!("impl {impl_def_id:?} was matchable against {predicate:?} but now is not")
        .                     }
        .                 }
  226,416 (0.0%)      }
        .         
1,581,442 (0.0%)      #[instrument(level = "debug", skip(self), ret)]
        .             fn match_impl(
        .                 &mut self,
        .                 impl_def_id: DefId,
        .                 impl_trait_header: ty::ImplTraitHeader<'tcx>,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .             ) -> Result<Normalized<'tcx, GenericArgsRef<'tcx>>, ()> {
        .                 let placeholder_obligation =
  232,565 (0.0%)              self.infcx.enter_forall_and_leak_universe(obligation.predicate);
  139,539 (0.0%)          let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;
        .         
  418,617 (0.0%)          let impl_args = self.infcx.fresh_args_for_item(obligation.cause.span, impl_def_id);
        .         
        .                 let trait_ref = impl_trait_header.trait_ref.instantiate(self.tcx(), impl_args);
        .                 if trait_ref.references_error() {
        .                     return Err(());
        .                 }
        .         
        .                 debug!(?impl_trait_header);
        .         
  232,565 (0.0%)          let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =
        .                     ensure_sufficient_stack(|| {
        .                         normalize_with_depth(
        .                             self,
   46,513 (0.0%)                      obligation.param_env,
        .                             obligation.cause.clone(),
   93,026 (0.0%)                      obligation.recursion_depth + 1,
   93,026 (0.0%)                      trait_ref,
        .                         )
        .                     });
        .         
        .                 debug!(?impl_trait_ref, ?placeholder_obligation_trait_ref);
        .         
        .                 let cause = ObligationCause::new(
   93,026 (0.0%)              obligation.cause.span,
   46,513 (0.0%)              obligation.cause.body_id,
        .                     ObligationCauseCode::MatchImpl(obligation.cause.clone(), impl_def_id),
        .                 );
        .         
  139,539 (0.0%)          let InferOk { obligations, .. } = self
        .                     .infcx
   46,513 (0.0%)              .at(&cause, obligation.param_env)
        .                     .eq(DefineOpaqueTypes::No, placeholder_obligation_trait_ref, impl_trait_ref)
        .                     .map_err(|e| {
        .                         debug!("match_impl: failed eq_trait_refs due to `{}`", e.to_string(self.tcx()))
        .                     })?;
        .                 nested_obligations.extend(obligations);
        .         
  134,703 (0.0%)          if !self.is_intercrate() && impl_trait_header.polarity == ty::ImplPolarity::Reservation {
        .                     debug!("reservation impls only apply in intercrate mode");
        .                     return Err(());
        .                 }
        .         
  178,852 (0.0%)          Ok(Normalized { value: impl_args, obligations: nested_obligations })
    1,800 (0.0%)      }
        .         
        .             fn match_upcast_principal(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 unnormalized_upcast_principal: ty::PolyTraitRef<'tcx>,
        .                 a_data: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,
        .                 b_data: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,
        .                 a_region: ty::Region<'tcx>,
-- line 2547 ----------------------------------------
-- line 2655 ----------------------------------------
        .             /// Returns `Ok` if `poly_trait_ref` being true implies that the
        .             /// obligation is satisfied.
        .             #[instrument(skip(self), level = "debug")]
        .             fn match_poly_trait_ref(
        .                 &mut self,
        .                 obligation: &PolyTraitObligation<'tcx>,
        .                 poly_trait_ref: ty::PolyTraitRef<'tcx>,
        .             ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {
  894,822 (0.0%)          let predicate = self.infcx.enter_forall_and_leak_universe(obligation.predicate);
  712,989 (0.0%)          let trait_ref = self.infcx.instantiate_binder_with_fresh_vars(
  224,862 (0.0%)              obligation.cause.span,
        .                     HigherRankedType,
        .                     poly_trait_ref,
        .                 );
1,076,655 (0.0%)          self.infcx
  181,833 (0.0%)              .at(&obligation.cause, obligation.param_env)
        .                     .eq(DefineOpaqueTypes::No, predicate.trait_ref, trait_ref)
        .                     .map(|InferOk { obligations, .. }| obligations)
        .                     .map_err(|_| ())
        .             }
        .         
        .             ///////////////////////////////////////////////////////////////////////////
        .             // Miscellany
        .         
-- line 2678 ----------------------------------------
-- line 2685 ----------------------------------------
        .                 matcher.relate(previous, current).is_ok()
        .             }
        .         
        .             fn push_stack<'o>(
        .                 &mut self,
        .                 previous_stack: TraitObligationStackList<'o, 'tcx>,
        .                 obligation: &'o PolyTraitObligation<'tcx>,
        .             ) -> TraitObligationStack<'o, 'tcx> {
1,524,924 (0.0%)          let fresh_trait_pred = obligation.predicate.fold_with(&mut self.freshener);
        .         
        .                 let dfn = previous_stack.cache.next_dfn();
  228,042 (0.0%)          let depth = previous_stack.depth() + 1;
3,018,500 (0.0%)          TraitObligationStack {
        .                     obligation,
        .                     fresh_trait_pred,
        .                     reached_depth: Cell::new(depth),
        .                     previous: previous_stack,
        .                     dfn,
        .                     depth,
        .                 }
        .             }
-- line 2705 ----------------------------------------
-- line 2726 ----------------------------------------
        .                 )
        .                 .map_bound(|(trait_ref, _)| trait_ref)
        .             }
        .         
        .             /// Returns the obligations that are implied by instantiating an
        .             /// impl or trait. The obligations are instantiated and fully
        .             /// normalized. This is used when confirming an impl or default
        .             /// impl.
3,089,084 (0.0%)      #[instrument(level = "debug", skip(self, cause, param_env))]
        .             fn impl_or_trait_obligations(
        .                 &mut self,
        .                 cause: &ObligationCause<'tcx>,
        .                 recursion_depth: usize,
        .                 param_env: ty::ParamEnv<'tcx>,
        .                 def_id: DefId,              // of impl or trait
        .                 args: GenericArgsRef<'tcx>, // for impl or trait
        .                 parent_trait_pred: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,
-- line 2742 ----------------------------------------
-- line 2753 ----------------------------------------
        .                 //    U: Iterator, U: Sized,
        .                 //    V: Iterator, V: Sized,
        .                 //    <U as Iterator>::Item: Copy
        .                 // When we instantiate, say, `V => IntoIter<u32>, U => $0`, the last
        .                 // obligation will normalize to `<$0 as Iterator>::Item = $1` and
        .                 // `$1: Copy`, so we must ensure the obligations are emitted in
        .                 // that order.
        .                 let predicates = tcx.predicates_of(def_id);
  134,308 (0.0%)          assert_eq!(predicates.parent, None);
        .                 let predicates = predicates.instantiate_own(tcx, args);
        .                 let mut obligations = Vec::with_capacity(predicates.len());
        .                 for (index, (predicate, span)) in predicates.into_iter().enumerate() {
        .                     let cause =
  497,071 (0.0%)                  if Some(parent_trait_pred.def_id()) == tcx.lang_items().coerce_unsized_trait() {
        .                             cause.clone()
        .                         } else {
        .                             cause.clone().derived_cause(parent_trait_pred, |derived| {
2,250,598 (0.0%)                          ImplDerivedObligation(Box::new(ImplDerivedObligationCause {
        .                                     derived,
        .                                     impl_or_alias_def_id: def_id,
        .                                     impl_def_predicate_index: Some(index),
        .                                     span,
        .                                 }))
        .                             })
        .                         };
  982,302 (0.0%)              let clause = normalize_with_depth_to(
        .                         self,
        .                         param_env,
        .                         cause.clone(),
        .                         recursion_depth,
        .                         predicate,
        .                         &mut obligations,
        .                     );
  491,151 (0.0%)              obligations.push(Obligation {
  818,585 (0.0%)                  cause,
        .                         recursion_depth,
        .                         param_env,
        .                         predicate: clause.as_predicate(),
        .                     });
        .                 }
        .         
  940,156 (0.0%)          obligations
        .             }
        .         }
        .         
        .         impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {
        .             fn list(&'o self) -> TraitObligationStackList<'o, 'tcx> {
        .                 TraitObligationStackList::with(self)
        .             }
        .         
        .             fn cache(&self) -> &'o ProvisionalEvaluationCache<'tcx> {
  216,183 (0.0%)          self.previous.cache
        .             }
        .         
        .             fn iter(&'o self) -> TraitObligationStackList<'o, 'tcx> {
        .                 self.list()
        .             }
        .         
        .             /// Indicates that attempting to evaluate this stack entry
        .             /// required accessing something from the stack at depth `reached_depth`.
        .             fn update_reached_depth(&self, reached_depth: usize) {
        .                 assert!(
   71,744 (0.0%)              self.depth >= reached_depth,
        .                     "invoked `update_reached_depth` with something under this stack: \
        .                      self.depth={} reached_depth={}",
        .                     self.depth,
        .                     reached_depth,
        .                 );
        .                 debug!(reached_depth, "update_reached_depth");
        .                 let mut p = self;
  143,502 (0.0%)          while reached_depth < p.depth {
        .                     debug!(?p.fresh_trait_pred, "update_reached_depth: marking as cycle participant");
        .                     p.reached_depth.set(p.reached_depth.get().min(reached_depth));
   35,879 (0.0%)              p = p.previous.head.unwrap();
        .                 }
        .             }
        .         }
        .         
        .         /// The "provisional evaluation cache" is used to store intermediate cache results
        .         /// when solving auto traits. Auto traits are unusual in that they can support
        .         /// cycles. So, for example, a "proof tree" like this would be ok:
        .         ///
-- line 2834 ----------------------------------------
-- line 2918 ----------------------------------------
        .         struct ProvisionalEvaluation {
        .             from_dfn: usize,
        .             reached_depth: usize,
        .             result: EvaluationResult,
        .         }
        .         
        .         impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {
        .             fn default() -> Self {
1,510,597 (0.0%)          Self { dfn: Cell::new(0), map: Default::default(), wf_args: Default::default() }
        .             }
        .         }
        .         
        .         impl<'tcx> ProvisionalEvaluationCache<'tcx> {
        .             /// Get the next DFN in sequence (basically a counter).
        .             fn next_dfn(&self) -> usize {
        .                 let result = self.dfn.get();
  134,914 (0.0%)          self.dfn.set(result + 1);
        .                 result
        .             }
        .         
        .             /// Check the provisional cache for any result for
        .             /// `fresh_trait_ref`. If there is a hit, then you must consider
        .             /// it an access to the stack slots at depth
        .             /// `reached_depth` (from the returned value).
        .             fn get_provisional(
-- line 2942 ----------------------------------------
-- line 2992 ----------------------------------------
        .             /// Invoked when the node with dfn `dfn` does not get a successful
        .             /// result. This will clear out any provisional cache entries
        .             /// that were added since `dfn` was created. This is because the
        .             /// provisional entries are things which must assume that the
        .             /// things on the stack at the time of their creation succeeded --
        .             /// since the failing node is presently at the top of the stack,
        .             /// these provisional entries must either depend on it or some
        .             /// ancestor of it.
   34,588 (0.0%)      fn on_failure(&self, dfn: usize) {
        .                 debug!(?dfn, "on_failure");
        .                 self.map.borrow_mut().retain(|key, eval| {
        .                     if !eval.from_dfn >= dfn {
        .                         debug!("on_failure: removing {:?}", key);
        .                         false
        .                     } else {
        .                         true
        .                     }
        .                 });
   34,588 (0.0%)      }
        .         
        .             /// Invoked when the node at depth `depth` completed without
        .             /// depending on anything higher in the stack (if that completion
        .             /// was a failure, then `on_failure` should have been invoked
        .             /// already).
        .             ///
        .             /// Note that we may still have provisional cache items remaining
        .             /// in the cache when this is done. For example, if there is a
-- line 3018 ----------------------------------------
-- line 3043 ----------------------------------------
        .             ///
        .             /// We used to try to perform this caching,
        .             /// but it lead to multiple incremental compilation ICEs
        .             /// (see #92987 and #96319), and was very hard to understand.
        .             /// Fortunately, removing the caching didn't seem to
        .             /// have a performance impact in practice.
        .             fn on_completion(&self, dfn: usize) {
        .                 debug!(?dfn, "on_completion");
        7 (0.0%)          self.map.borrow_mut().retain(|fresh_trait_pred, eval| {
       40 (0.0%)              if eval.from_dfn >= dfn {
        .                         debug!(?fresh_trait_pred, ?eval, "on_completion");
        .                         return false;
        .                     }
        .                     true
        .                 });
        .             }
        .         }
        .         
-- line 3060 ----------------------------------------
-- line 3073 ----------------------------------------
        .                 TraitObligationStackList { cache: r.cache(), head: Some(r) }
        .             }
        .         
        .             fn head(&self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {
        .                 self.head
        .             }
        .         
        .             fn depth(&self) -> usize {
  514,307 (0.0%)          if let Some(head) = self.head { head.depth } else { 0 }
        .             }
        .         }
        .         
        .         impl<'o, 'tcx> Iterator for TraitObligationStackList<'o, 'tcx> {
        .             type Item = &'o TraitObligationStack<'o, 'tcx>;
        .         
        .             fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {
        .                 let o = self.head?;
  560,424 (0.0%)          *self = o.previous;
        .                 Some(o)
        .             }
        .         }
        .         
        .         impl<'o, 'tcx> fmt::Debug for TraitObligationStack<'o, 'tcx> {
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 write!(f, "TraitObligationStack({:?})", self.obligation)
        .             }
-- line 3098 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_type_ir/src/interner.rs
--------------------------------------------------------------------------------
Ir_______________ 

   959,898 (0.0%)  <unknown (line 0)>

-- line 148 ----------------------------------------
         .                 F: FnOnce(&[T]) -> R;
         .         }
         .         
         .         /// The blanket impl that always collects all elements and applies `f`.
         .         impl<T, R> CollectAndApply<T, R> for T {
         .             type Output = R;
         .         
         .             /// Equivalent to `f(&iter.collect::<Vec<_>>())`.
11,633,987 (0.1%)      fn collect_and_apply<I, F>(mut iter: I, f: F) -> R
         .             where
         .                 I: Iterator<Item = T>,
         .                 F: FnOnce(&[T]) -> R,
         .             {
         .                 // This code is hot enough that it's worth specializing for the most
         .                 // common length lists, to avoid the overhead of `SmallVec` creation.
         .                 // Lengths 0, 1, and 2 typically account for ~95% of cases. If
         .                 // `size_hint` is incorrect a panic will occur via an `unwrap` or an
         .                 // `assert`.
 5,122,375 (0.1%)          match iter.size_hint() {
         .                     (0, Some(0)) => {
    46,222 (0.0%)                  assert!(iter.next().is_none());
     6,530 (0.0%)                  f(&[])
         .                     }
         .                     (1, Some(1)) => {
    20,263 (0.0%)                  let t0 = iter.next().unwrap();
    13,249 (0.0%)                  assert!(iter.next().is_none());
   797,966 (0.0%)                  f(&[t0])
         .                     }
         .                     (2, Some(2)) => {
     8,080 (0.0%)                  let t0 = iter.next().unwrap();
     8,080 (0.0%)                  let t1 = iter.next().unwrap();
     5,213 (0.0%)                  assert!(iter.next().is_none());
   264,178 (0.0%)                  f(&[t0, t1])
         .                     }
   142,248 (0.0%)              _ => f(&iter.collect::<SmallVec<[_; 8]>>()),
         .                 }
10,139,391 (0.1%)      }
         .         }
         .         
         .         /// A fallible impl that will fail, without calling `f`, if there are any
         .         /// errors during collection.
         .         impl<T, R, E> CollectAndApply<T, R> for Result<T, E> {
         .             type Output = Result<R, E>;
         .         
         .             /// Equivalent to `Ok(f(&iter.collect::<Result<Vec<_>>>()?))`.
 1,204,441 (0.0%)      fn collect_and_apply<I, F>(mut iter: I, f: F) -> Result<R, E>
         .             where
         .                 I: Iterator<Item = Result<T, E>>,
         .                 F: FnOnce(&[T]) -> R,
         .             {
         .                 // This code is hot enough that it's worth specializing for the most
         .                 // common length lists, to avoid the overhead of `SmallVec` creation.
         .                 // Lengths 0, 1, and 2 typically account for ~95% of cases. If
         .                 // `size_hint` is incorrect a panic will occur via an `unwrap` or an
         .                 // `assert`, unless a failure happens first, in which case the result
         .                 // will be an error anyway.
 2,271,253 (0.0%)          Ok(match iter.size_hint() {
         .                     (0, Some(0)) => {
         .                         assert!(iter.next().is_none());
    48,398 (0.0%)                  f(&[])
         .                     }
         .                     (1, Some(1)) => {
     3,432 (0.0%)                  let t0 = iter.next().unwrap()?;
        12 (0.0%)                  assert!(iter.next().is_none());
   274,768 (0.0%)                  f(&[t0])
         .                     }
         .                     (2, Some(2)) => {
       147 (0.0%)                  let t0 = iter.next().unwrap()?;
     1,499 (0.0%)                  let t1 = iter.next().unwrap()?;
       147 (0.0%)                  assert!(iter.next().is_none());
   129,379 (0.0%)                  f(&[t0, t1])
         .                     }
   162,268 (0.0%)              _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),
         .                 })
   961,144 (0.0%)      }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_type_ir/src/predicate_kind.rs
--------------------------------------------------------------------------------
Ir_______________ 

15,461,314 (0.2%)  <unknown (line 0)>

-- line 3 ----------------------------------------
         .         use std::fmt;
         .         
         .         use crate::fold::{FallibleTypeFolder, TypeFoldable};
         .         use crate::visit::{TypeVisitable, TypeVisitor};
         .         use crate::Interner;
         .         
         .         /// A clause is something that can appear in where bounds or be inferred
         .         /// by implied bounds.
 2,304,762 (0.0%)  #[derive(derivative::Derivative)]
         .         #[derivative(Clone(bound = ""), Copy(bound = ""), Hash(bound = ""))]
   337,408 (0.0%)  #[cfg_attr(feature = "nightly", derive(TyEncodable, TyDecodable, HashStable_NoContext))]
         .         pub enum ClauseKind<I: Interner> {
         .             /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be
         .             /// the `Self` type of the trait reference and `A`, `B`, and `C`
         .             /// would be the type parameters.
         .             Trait(I::TraitPredicate),
         .         
         .             /// `where 'a: 'b`
         .             RegionOutlives(I::RegionOutlivesPredicate),
-- line 21 ----------------------------------------
-- line 35 ----------------------------------------
         .             WellFormed(I::GenericArg),
         .         
         .             /// Constant initializer must evaluate successfully.
         .             ConstEvaluatable(I::Const),
         .         }
         .         
         .         impl<I: Interner> PartialEq for ClauseKind<I> {
         .             fn eq(&self, other: &Self) -> bool {
10,835,672 (0.1%)          match (self, other) {
         .                     (Self::Trait(l0), Self::Trait(r0)) => l0 == r0,
         .                     (Self::RegionOutlives(l0), Self::RegionOutlives(r0)) => l0 == r0,
         .                     (Self::TypeOutlives(l0), Self::TypeOutlives(r0)) => l0 == r0,
         .                     (Self::Projection(l0), Self::Projection(r0)) => l0 == r0,
     3,258 (0.0%)              (Self::ConstArgHasType(l0, l1), Self::ConstArgHasType(r0, r1)) => l0 == r0 && l1 == r1,
         .                     (Self::WellFormed(l0), Self::WellFormed(r0)) => l0 == r0,
         .                     (Self::ConstEvaluatable(l0), Self::ConstEvaluatable(r0)) => l0 == r0,
         .                     _ => false,
         .                 }
         .             }
         .         }
         .         
         .         impl<I: Interner> Eq for ClauseKind<I> {}
-- line 56 ----------------------------------------
-- line 60 ----------------------------------------
         .             I::Ty: TypeFoldable<I>,
         .             I::Const: TypeFoldable<I>,
         .             I::GenericArg: TypeFoldable<I>,
         .             I::TraitPredicate: TypeFoldable<I>,
         .             I::ProjectionPredicate: TypeFoldable<I>,
         .             I::TypeOutlivesPredicate: TypeFoldable<I>,
         .             I::RegionOutlivesPredicate: TypeFoldable<I>,
         .         {
 2,559,378 (0.0%)      fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {
 3,737,414 (0.0%)          Ok(match self {
   751,737 (0.0%)              ClauseKind::Trait(p) => ClauseKind::Trait(p.try_fold_with(folder)?),
     3,412 (0.0%)              ClauseKind::RegionOutlives(p) => ClauseKind::RegionOutlives(p.try_fold_with(folder)?),
    10,022 (0.0%)              ClauseKind::TypeOutlives(p) => ClauseKind::TypeOutlives(p.try_fold_with(folder)?),
    24,837 (0.0%)              ClauseKind::Projection(p) => ClauseKind::Projection(p.try_fold_with(folder)?),
     1,002 (0.0%)              ClauseKind::ConstArgHasType(c, t) => {
       185 (0.0%)                  ClauseKind::ConstArgHasType(c.try_fold_with(folder)?, t.try_fold_with(folder)?)
         .                     }
         .                     ClauseKind::WellFormed(p) => ClauseKind::WellFormed(p.try_fold_with(folder)?),
         .                     ClauseKind::ConstEvaluatable(p) => {
         .                         ClauseKind::ConstEvaluatable(p.try_fold_with(folder)?)
         .                     }
         .                 })
 2,122,448 (0.0%)      }
         .         }
         .         
         .         impl<I: Interner> TypeVisitable<I> for ClauseKind<I>
         .         where
         .             I::Ty: TypeVisitable<I>,
         .             I::Const: TypeVisitable<I>,
         .             I::GenericArg: TypeVisitable<I>,
         .             I::TraitPredicate: TypeVisitable<I>,
         .             I::ProjectionPredicate: TypeVisitable<I>,
         .             I::TypeOutlivesPredicate: TypeVisitable<I>,
         .             I::RegionOutlivesPredicate: TypeVisitable<I>,
         .         {
 8,501,248 (0.1%)      fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> V::Result {
 4,925,335 (0.1%)          match self {
   813,892 (0.0%)              ClauseKind::Trait(p) => p.visit_with(visitor),
     8,672 (0.0%)              ClauseKind::RegionOutlives(p) => p.visit_with(visitor),
   543,101 (0.0%)              ClauseKind::TypeOutlives(p) => p.visit_with(visitor),
    16,748 (0.0%)              ClauseKind::Projection(p) => p.visit_with(visitor),
         .                     ClauseKind::ConstArgHasType(c, t) => {
     6,252 (0.0%)                  try_visit!(c.visit_with(visitor));
     2,064 (0.0%)                  t.visit_with(visitor)
         .                     }
    27,141 (0.0%)              ClauseKind::WellFormed(p) => p.visit_with(visitor),
         .                     ClauseKind::ConstEvaluatable(p) => p.visit_with(visitor),
         .                 }
 8,501,248 (0.1%)      }
         .         }
         .         
24,213,199 (0.3%)  #[derive(derivative::Derivative)]
         .         #[derivative(
         .             Clone(bound = ""),
         .             Copy(bound = ""),
         .             Hash(bound = ""),
         .             PartialEq(bound = ""),
         .             Eq(bound = "")
         .         )]
   880,750 (0.0%)  #[cfg_attr(feature = "nightly", derive(TyEncodable, TyDecodable, HashStable_NoContext))]
         .         pub enum PredicateKind<I: Interner> {
         .             /// Prove a clause
         .             Clause(ClauseKind<I>),
         .         
         .             /// Trait must be object-safe.
         .             ObjectSafe(I::DefId),
         .         
         .             /// `T1 <: T2`
-- line 127 ----------------------------------------
-- line 171 ----------------------------------------
         .             I::Const: TypeFoldable<I>,
         .             I::GenericArgs: TypeFoldable<I>,
         .             I::Term: TypeFoldable<I>,
         .             I::CoercePredicate: TypeFoldable<I>,
         .             I::SubtypePredicate: TypeFoldable<I>,
         .             I::NormalizesTo: TypeFoldable<I>,
         .             ClauseKind<I>: TypeFoldable<I>,
         .         {
   111,879 (0.0%)      fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {
 5,921,507 (0.1%)          Ok(match self {
   791,779 (0.0%)              PredicateKind::Clause(c) => PredicateKind::Clause(c.try_fold_with(folder)?),
         .                     PredicateKind::ObjectSafe(d) => PredicateKind::ObjectSafe(d.try_fold_with(folder)?),
         .                     PredicateKind::Subtype(s) => PredicateKind::Subtype(s.try_fold_with(folder)?),
         .                     PredicateKind::Coerce(s) => PredicateKind::Coerce(s.try_fold_with(folder)?),
         .                     PredicateKind::ConstEquate(a, b) => {
         .                         PredicateKind::ConstEquate(a.try_fold_with(folder)?, b.try_fold_with(folder)?)
         .                     }
         .                     PredicateKind::Ambiguous => PredicateKind::Ambiguous,
         .                     PredicateKind::NormalizesTo(p) => PredicateKind::NormalizesTo(p.try_fold_with(folder)?),
         .                     PredicateKind::AliasRelate(a, b, d) => PredicateKind::AliasRelate(
         .                         a.try_fold_with(folder)?,
         .                         b.try_fold_with(folder)?,
         .                         d.try_fold_with(folder)?,
         .                     ),
         .                 })
    99,448 (0.0%)      }
         .         }
         .         
         .         impl<I: Interner> TypeVisitable<I> for PredicateKind<I>
         .         where
         .             I::DefId: TypeVisitable<I>,
         .             I::Const: TypeVisitable<I>,
         .             I::GenericArgs: TypeVisitable<I>,
         .             I::Term: TypeVisitable<I>,
         .             I::CoercePredicate: TypeVisitable<I>,
         .             I::SubtypePredicate: TypeVisitable<I>,
         .             I::NormalizesTo: TypeVisitable<I>,
         .             ClauseKind<I>: TypeVisitable<I>,
         .         {
         .             fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> V::Result {
 8,701,184 (0.1%)          match self {
 7,632,450 (0.1%)              PredicateKind::Clause(p) => p.visit_with(visitor),
         .                     PredicateKind::ObjectSafe(d) => d.visit_with(visitor),
         .                     PredicateKind::Subtype(s) => s.visit_with(visitor),
         .                     PredicateKind::Coerce(s) => s.visit_with(visitor),
         .                     PredicateKind::ConstEquate(a, b) => {
         .                         try_visit!(a.visit_with(visitor));
         .                         b.visit_with(visitor)
         .                     }
         .                     PredicateKind::Ambiguous => V::Result::output(),
-- line 220 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/compiler/rustc_type_ir/src/ty_kind.rs
--------------------------------------------------------------------------------
Ir_______________ 

 7,018,474 (0.1%)  <unknown (line 0)>

-- line 10 ----------------------------------------
         .         use crate::Interner;
         .         use crate::{DebruijnIndex, DebugWithInfcx, InferCtxtLike, WithInfcx};
         .         
         .         use self::TyKind::*;
         .         
         .         use rustc_ast_ir::Mutability;
         .         
         .         /// Specifies how a trait object is represented.
    13,372 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
       168 (0.0%)  #[cfg_attr(feature = "nightly", derive(Encodable, Decodable, HashStable_NoContext))]
         .         pub enum DynKind {
         .             /// An unsized `dyn Trait` object
         .             Dyn,
         .             /// A sized `dyn* Trait` object
         .             ///
         .             /// These objects are represented as a `(data, vtable)` pair where `data` is a value of some
         .             /// ptr-sized and ptr-aligned dynamically determined type `T` and `vtable` is a pointer to the
         .             /// vtable of `impl T for Trait`. This allows a `dyn*` object to be treated agnostically with
         .             /// respect to whether it points to a `Box<T>`, `Rc<T>`, etc.
         .             DynStar,
         .         }
         .         
   118,571 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
     3,413 (0.0%)  #[cfg_attr(feature = "nightly", derive(Encodable, Decodable, HashStable_NoContext))]
         .         pub enum AliasKind {
         .             /// A projection `<Type as Trait>::AssocType`.
         .             /// Can get normalized away if monomorphic enough.
         .             Projection,
         .             /// An associated type in an inherent `impl`
         .             Inherent,
         .             /// An opaque type (usually from `impl Trait` in type aliases or function return types)
         .             /// Can only be normalized away in RevealAll mode
-- line 41 ----------------------------------------
-- line 57 ----------------------------------------
         .             }
         .         }
         .         
         .         /// Defines the kinds of types used by the type system.
         .         ///
         .         /// Types written by the user start out as `hir::TyKind` and get
         .         /// converted to this representation using `<dyn HirTyLowerer>::lower_ty`.
         .         #[cfg_attr(feature = "nightly", rustc_diagnostic_item = "IrTyKind")]
12,569,024 (0.2%)  #[derive(derivative::Derivative)]
         .         #[derivative(Clone(bound = ""), Copy(bound = ""), Hash(bound = ""))]
 1,366,188 (0.0%)  #[cfg_attr(feature = "nightly", derive(TyEncodable, TyDecodable, HashStable_NoContext))]
    16,986 (0.0%)  pub enum TyKind<I: Interner> {
         .             /// The primitive boolean type. Written as `bool`.
         .             Bool,
         .         
         .             /// The primitive character type; holds a Unicode scalar value
         .             /// (a non-surrogate code point). Written as `char`.
         .             Char,
         .         
         .             /// A primitive signed integer type. For example, `i32`.
-- line 76 ----------------------------------------
-- line 288 ----------------------------------------
         .                 Infer(_) => 26,
         .                 Error(_) => 27,
         .             }
         .         }
         .         
         .         // This is manually implemented because a derive would require `I: PartialEq`
         .         impl<I: Interner> PartialEq for TyKind<I> {
         .             #[inline]
 1,531,740 (0.0%)      fn eq(&self, other: &TyKind<I>) -> bool {
         .                 // You might expect this `match` to be preceded with this:
         .                 //
         .                 //   tykind_discriminant(self) == tykind_discriminant(other) &&
         .                 //
         .                 // but the data patterns in practice are such that a comparison
         .                 // succeeds 99%+ of the time, and it's faster to omit it.
 9,041,438 (0.1%)          match (self, other) {
         .                     (Int(a_i), Int(b_i)) => a_i == b_i,
         .                     (Uint(a_u), Uint(b_u)) => a_u == b_u,
         .                     (Float(a_f), Float(b_f)) => a_f == b_f,
         .                     (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,
         .                     (Foreign(a_d), Foreign(b_d)) => a_d == b_d,
         .                     (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,
         .                     (Pat(a_t, a_c), Pat(b_t, b_c)) => a_t == b_t && a_c == b_c,
         .                     (Slice(a_t), Slice(b_t)) => a_t == b_t,
    42,728 (0.0%)              (RawPtr(a_t, a_m), RawPtr(b_t, b_m)) => a_t == b_t && a_m == b_m,
         .                     (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,
         .                     (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,
     2,414 (0.0%)              (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,
         .                     (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {
         .                         a_p == b_p && a_r == b_r && a_repr == b_repr
         .                     }
         .                     (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,
         .                     (CoroutineClosure(a_d, a_s), CoroutineClosure(b_d, b_s)) => a_d == b_d && a_s == b_s,
         .                     (Coroutine(a_d, a_s), Coroutine(b_d, b_s)) => a_d == b_d && a_s == b_s,
         .                     (CoroutineWitness(a_d, a_s), CoroutineWitness(b_d, b_s)) => a_d == b_d && a_s == b_s,
         .                     (Tuple(a_t), Tuple(b_t)) => a_t == b_t,
    44,443 (0.0%)              (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i == b_i && a_p == b_p,
         .                     (Param(a_p), Param(b_p)) => a_p == b_p,
    71,085 (0.0%)              (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,
         .                     (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,
         .                     (Infer(a_t), Infer(b_t)) => a_t == b_t,
         .                     (Error(a_e), Error(b_e)) => a_e == b_e,
         .                     (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => true,
         .                     _ => {
         .                         debug_assert!(
         .                             tykind_discriminant(self) != tykind_discriminant(other),
         .                             "This branch must be unreachable, maybe the match is missing an arm? self = {self:?}, other = {other:?}"
         .                         );
         .                         false
         .                     }
         .                 }
 1,849,461 (0.0%)      }
         .         }
         .         
         .         // This is manually implemented because a derive would require `I: Eq`
         .         impl<I: Interner> Eq for TyKind<I> {}
         .         
         .         impl<I: Interner> DebugWithInfcx<I> for TyKind<I> {
         .             fn fmt<Infcx: InferCtxtLike<Interner = I>>(
         .                 this: WithInfcx<'_, Infcx, &Self>,
-- line 347 ----------------------------------------
-- line 421 ----------------------------------------
         .         // This is manually implemented because a derive would require `I: Debug`
         .         impl<I: Interner> fmt::Debug for TyKind<I> {
         .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         .                 WithInfcx::with_no_infcx(self).fmt(f)
         .             }
         .         }
         .         
         .         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    12,748 (0.0%)  #[cfg_attr(feature = "nightly", derive(Encodable, Decodable, HashStable_NoContext))]
         .         pub enum IntTy {
         .             Isize,
         .             I8,
         .             I16,
         .             I32,
         .             I64,
         .             I128,
         .         }
         .         
         .         impl IntTy {
         .             pub fn name_str(&self) -> &'static str {
        36 (0.0%)          match *self {
         6 (0.0%)              IntTy::Isize => "isize",
         .                     IntTy::I8 => "i8",
         6 (0.0%)              IntTy::I16 => "i16",
         6 (0.0%)              IntTy::I32 => "i32",
         6 (0.0%)              IntTy::I64 => "i64",
         .                     IntTy::I128 => "i128",
         .                 }
         .             }
         .         
         .             pub fn bit_width(&self) -> Option<u64> {
         .                 Some(match *self {
         .                     IntTy::Isize => return None,
         .                     IntTy::I8 => 8,
-- line 454 ----------------------------------------
-- line 479 ----------------------------------------
         .                     IntTy::I32 => UintTy::U32,
         .                     IntTy::I64 => UintTy::U64,
         .                     IntTy::I128 => UintTy::U128,
         .                 }
         .             }
         .         }
         .         
         .         #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]
    21,803 (0.0%)  #[cfg_attr(feature = "nightly", derive(Encodable, Decodable, HashStable_NoContext))]
         .         pub enum UintTy {
         .             Usize,
         .             U8,
         .             U16,
         .             U32,
         .             U64,
         .             U128,
         .         }
         .         
         .         impl UintTy {
         .             pub fn name_str(&self) -> &'static str {
       321 (0.0%)          match *self {
         3 (0.0%)              UintTy::Usize => "usize",
        89 (0.0%)              UintTy::U8 => "u8",
        18 (0.0%)              UintTy::U16 => "u16",
         3 (0.0%)              UintTy::U32 => "u32",
         6 (0.0%)              UintTy::U64 => "u64",
         .                     UintTy::U128 => "u128",
         .                 }
         .             }
         .         
         .             pub fn bit_width(&self) -> Option<u64> {
         .                 Some(match *self {
         .                     UintTy::Usize => return None,
         .                     UintTy::U8 => 8,
-- line 512 ----------------------------------------
-- line 537 ----------------------------------------
         .                     UintTy::U32 => IntTy::I32,
         .                     UintTy::U64 => IntTy::I64,
         .                     UintTy::U128 => IntTy::I128,
         .                 }
         .             }
         .         }
         .         
         .         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
     1,895 (0.0%)  #[cfg_attr(feature = "nightly", derive(Encodable, Decodable, HashStable_NoContext))]
         .         pub enum FloatTy {
         .             F16,
         .             F32,
         .             F64,
         .             F128,
         .         }
         .         
         .         impl FloatTy {
-- line 553 ----------------------------------------
-- line 565 ----------------------------------------
         .                     FloatTy::F16 => 16,
         .                     FloatTy::F32 => 32,
         .                     FloatTy::F64 => 64,
         .                     FloatTy::F128 => 128,
         .                 }
         .             }
         .         }
         .         
        72 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq)]
         .         pub enum IntVarValue {
         .             IntType(IntTy),
         .             UintType(UintTy),
         .         }
         .         
         .         #[derive(Clone, Copy, PartialEq, Eq)]
         .         pub struct FloatVarValue(pub FloatTy);
         .         
 1,369,195 (0.0%)  rustc_index::newtype_index! {
         .             /// A **ty**pe **v**ariable **ID**.
         .             #[encodable]
         .             #[orderable]
         .             #[debug_format = "?{}t"]
         .             #[gate_rustc_only]
         .             pub struct TyVid {}
         .         }
         .         
     8,936 (0.0%)  rustc_index::newtype_index! {
         .             /// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.
         .             #[encodable]
         .             #[orderable]
         .             #[debug_format = "?{}i"]
         .             #[gate_rustc_only]
         .             pub struct IntVid {}
         .         }
         .         
     5,188 (0.0%)  rustc_index::newtype_index! {
         .             /// A **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.
         .             #[encodable]
         .             #[orderable]
         .             #[debug_format = "?{}f"]
         .             #[gate_rustc_only]
         .             pub struct FloatVid {}
         .         }
         .         
         .         /// A placeholder for a type that hasn't been inferred yet.
         .         ///
         .         /// E.g., if we have an empty array (`[]`), then we create a fresh
         .         /// type variable for the element type since we won't know until it's
         .         /// used what the element type is supposed to be.
    14,349 (0.0%)  #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
         .         #[cfg_attr(feature = "nightly", derive(Encodable, Decodable))]
         .         pub enum InferTy {
         .             /// A type variable.
         .             TyVar(TyVid),
         .             /// An integral type variable (`{integer}`).
         .             ///
         .             /// These are created when the compiler sees an integer literal like
         .             /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).
-- line 622 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/alloc/src/raw_vec.rs
--------------------------------------------------------------------------------
Ir_______________ 

18,931,652 (0.2%)  <unknown (line 0)>

-- line 150 ----------------------------------------
         .                 Self { ptr: Unique::dangling(), cap: Cap::ZERO, alloc }
         .             }
         .         
         .             /// Like `with_capacity`, but parameterized over the choice of
         .             /// allocator for the returned `RawVec`.
         .             #[cfg(not(no_global_oom_handling))]
         .             #[inline]
         .             pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
    13,722 (0.0%)          match Self::try_allocate_in(capacity, AllocInit::Uninitialized, alloc) {
         .                     Ok(res) => res,
         .                     Err(err) => handle_error(err),
         .                 }
         .             }
         .         
         .             /// Like `try_with_capacity`, but parameterized over the choice of
         .             /// allocator for the returned `RawVec`.
         .             #[inline]
-- line 166 ----------------------------------------
-- line 207 ----------------------------------------
         .         
         .             fn try_allocate_in(
         .                 capacity: usize,
         .                 init: AllocInit,
         .                 alloc: A,
         .             ) -> Result<Self, TryReserveError> {
         .                 // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.
         .         
 4,238,735 (0.1%)          if T::IS_ZST || capacity == 0 {
         .                     Ok(Self::new_in(alloc))
         .                 } else {
         .                     // We avoid `unwrap_or_else` here because it bloats the amount of
         .                     // LLVM IR generated.
   876,388 (0.0%)              let layout = match Layout::array::<T>(capacity) {
         .                         Ok(layout) => layout,
         .                         Err(_) => return Err(CapacityOverflow.into()),
         .                     };
         .         
         .                     if let Err(err) = alloc_guard(layout.size()) {
         .                         return Err(err);
         .                     }
         .         
         .                     let result = match init {
         .                         AllocInit::Uninitialized => alloc.allocate(layout),
         .                         #[cfg(not(no_global_oom_handling))]
         .                         AllocInit::Zeroed => alloc.allocate_zeroed(layout),
         .                     };
 2,236,640 (0.0%)              let ptr = match result {
         .                         Ok(ptr) => ptr,
         .                         Err(_) => return Err(AllocError { layout, non_exhaustive: () }.into()),
         .                     };
         .         
         .                     // Allocators currently return a `NonNull<[u8]>` whose length
         .                     // matches the size requested. If that ever changes, the capacity
         .                     // here should change to `ptr.len() / mem::size_of::<T>()`.
         .                     Ok(Self { ptr: Unique::from(ptr.cast()), cap: unsafe { Cap(capacity) }, alloc })
-- line 242 ----------------------------------------
-- line 270 ----------------------------------------
         .                 Self { ptr: Unique::from(ptr), cap, alloc }
         .             }
         .         
         .             /// Gets a raw pointer to the start of the allocation. Note that this is
         .             /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must
         .             /// be careful.
         .             #[inline]
         .             pub fn ptr(&self) -> *mut T {
 8,325,695 (0.1%)          self.ptr.as_ptr()
         .             }
         .         
         .             #[inline]
         .             pub fn non_null(&self) -> NonNull<T> {
         .                 NonNull::from(self.ptr)
         .             }
         .         
         .             /// Gets the capacity of the allocation.
         .             ///
         .             /// This will always be `usize::MAX` if `T` is zero-sized.
         .             #[inline(always)]
         .             pub fn capacity(&self) -> usize {
 3,190,353 (0.0%)          if T::IS_ZST { usize::MAX } else { self.cap.0 }
         .             }
         .         
         .             /// Returns a shared reference to the allocator backing this `RawVec`.
         .             pub fn allocator(&self) -> &A {
         .                 &self.alloc
         .             }
         .         
         .             fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {
19,513,414 (0.2%)          if T::IS_ZST || self.cap.0 == 0 {
         .                     None
         .                 } else {
         .                     // We could use Layout::array here which ensures the absence of isize and usize overflows
         .                     // and could hypothetically handle differences between stride and size, but this memory
         .                     // has already been allocated so we know it can't overflow and currently Rust does not
         .                     // support such types. So we can do better by skipping some checks and avoid an unwrap.
         .                     const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };
         .                     unsafe {
         .                         let align = mem::align_of::<T>();
         .                         let size = mem::size_of::<T>().unchecked_mul(self.cap.0);
         .                         let layout = Layout::from_size_align_unchecked(size, align);
 1,841,741 (0.0%)                  Some((self.ptr.cast().into(), layout))
         .                     }
         .                 }
         .             }
         .         
         .             /// Ensures that the buffer contains at least enough space to hold `len +
         .             /// additional` elements. If it doesn't already have enough capacity, will
         .             /// reallocate enough space plus comfortable slack space to get amortized
         .             /// *O*(1) behavior. Will limit this behavior if it would needlessly cause
-- line 320 ----------------------------------------
-- line 336 ----------------------------------------
         .             #[cfg(not(no_global_oom_handling))]
         .             #[inline]
         .             pub fn reserve(&mut self, len: usize, additional: usize) {
         .                 // Callers expect this function to be very cheap when there is already sufficient capacity.
         .                 // Therefore, we move all the resizing and error-handling logic from grow_amortized and
         .                 // handle_reserve behind a call, while making sure that this function is likely to be
         .                 // inlined as just a comparison and a call if the comparison fails.
         .                 #[cold]
 3,300,155 (0.0%)          fn do_reserve_and_handle<T, A: Allocator>(
         .                     slf: &mut RawVec<T, A>,
         .                     len: usize,
         .                     additional: usize,
         .                 ) {
         .                     if let Err(err) = slf.grow_amortized(len, additional) {
         .                         handle_error(err);
         .                     }
 3,037,035 (0.0%)          }
         .         
 2,084,470 (0.0%)          if self.needs_to_grow(len, additional) {
 3,085,682 (0.0%)              do_reserve_and_handle(self, len, additional);
         .                 }
         .             }
         .         
         .             /// A specialized version of `self.reserve(len, 1)` which requires the
         .             /// caller to ensure `len == self.capacity()`.
         .             #[cfg(not(no_global_oom_handling))]
         .             #[inline(never)]
 4,012,440 (0.1%)      pub fn grow_one(&mut self) {
   802,488 (0.0%)          if let Err(err) = self.grow_amortized(self.cap.0, 1) {
         .                     handle_error(err);
         .                 }
 4,012,440 (0.1%)      }
         .         
         .             /// The same as `reserve`, but returns on errors instead of panicking or aborting.
         .             pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {
       223 (0.0%)          if self.needs_to_grow(len, additional) {
         .                     self.grow_amortized(len, additional)?;
         .                 }
         .                 unsafe {
         .                     // Inform the optimizer that the reservation has succeeded or wasn't needed
         .                     hint::assert_unchecked(!self.needs_to_grow(len, additional));
         .                 }
         .                 Ok(())
         .             }
-- line 379 ----------------------------------------
-- line 403 ----------------------------------------
         .             }
         .         
         .             /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.
         .             pub fn try_reserve_exact(
         .                 &mut self,
         .                 len: usize,
         .                 additional: usize,
         .             ) -> Result<(), TryReserveError> {
     7,773 (0.0%)          if self.needs_to_grow(len, additional) {
         .                     self.grow_exact(len, additional)?;
         .                 }
         .                 unsafe {
         .                     // Inform the optimizer that the reservation has succeeded or wasn't needed
         .                     hint::assert_unchecked(!self.needs_to_grow(len, additional));
         .                 }
         .                 Ok(())
         .             }
-- line 419 ----------------------------------------
-- line 435 ----------------------------------------
         .                 }
         .             }
         .         }
         .         
         .         impl<T, A: Allocator> RawVec<T, A> {
         .             /// Returns if the buffer needs to grow to fulfill the needed extra capacity.
         .             /// Mainly used to make inlining reserve-calls possible without inlining `grow`.
         .             fn needs_to_grow(&self, len: usize, additional: usize) -> bool {
 2,662,803 (0.0%)          additional > self.capacity().wrapping_sub(len)
         .             }
         .         
         .             /// # Safety:
         .             ///
         .             /// `cap` must not exceed `isize::MAX`.
         .             unsafe fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {
         .                 // Allocators currently return a `NonNull<[u8]>` whose length matches
         .                 // the size requested. If that ever changes, the capacity here should
         .                 // change to `ptr.len() / mem::size_of::<T>()`.
 1,439,436 (0.0%)          self.ptr = Unique::from(ptr.cast());
 1,467,957 (0.0%)          self.cap = unsafe { Cap(cap) };
         .             }
         .         
         .             // This method is usually instantiated many times. So we want it to be as
         .             // small as possible, to improve compile times. But we also want as much of
         .             // its contents to be statically computable as possible, to make the
         .             // generated code run faster. Therefore, this method is carefully written
         .             // so that all of the code that depends on `T` is within it, while as much
         .             // of the code that doesn't depend on `T` as possible is in functions that
-- line 462 ----------------------------------------
-- line 471 ----------------------------------------
         .                     return Err(CapacityOverflow.into());
         .                 }
         .         
         .                 // Nothing we can really do about these checks, sadly.
         .                 let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
         .         
         .                 // This guarantees exponential growth. The doubling cannot overflow
         .                 // because `cap <= isize::MAX` and the type of `cap` is `usize`.
 2,017,712 (0.0%)          let cap = cmp::max(self.cap.0 * 2, required_cap);
         .                 let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);
         .         
         .                 let new_layout = Layout::array::<T>(cap);
         .         
         .                 // `finish_grow` is non-generic over `T`.
 2,232,048 (0.0%)          let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;
         .                 // SAFETY: finish_grow would have resulted in a capacity overflow if we tried to allocate more than isize::MAX items
         .                 unsafe { self.set_ptr_and_cap(ptr, cap) };
         .                 Ok(())
         .             }
         .         
         .             // The constraints on this method are much the same as those on
         .             // `grow_amortized`, but this method is usually instantiated less often so
         .             // it's less critical.
-- line 493 ----------------------------------------
-- line 497 ----------------------------------------
         .                     // 0, getting to here necessarily means the `RawVec` is overfull.
         .                     return Err(CapacityOverflow.into());
         .                 }
         .         
         .                 let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
         .                 let new_layout = Layout::array::<T>(cap);
         .         
         .                 // `finish_grow` is non-generic over `T`.
    93,972 (0.0%)          let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;
         .                 // SAFETY: finish_grow would have resulted in a capacity overflow if we tried to allocate more than isize::MAX items
         .                 unsafe {
         .                     self.set_ptr_and_cap(ptr, cap);
         .                 }
         .                 Ok(())
         .             }
         .         
         .             #[cfg(not(no_global_oom_handling))]
         .             fn shrink(&mut self, cap: usize) -> Result<(), TryReserveError> {
         .                 assert!(cap <= self.capacity(), "Tried to shrink to a larger capacity");
         .         
     7,814 (0.0%)          let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };
         .                 // See current_memory() why this assert is here
         .                 const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };
         .         
         .                 // If shrinking to 0, deallocate the buffer. We don't reach this point
         .                 // for the T::IS_ZST case since current_memory() will have returned
         .                 // None.
    29,196 (0.0%)          if cap == 0 {
         .                     unsafe { self.alloc.deallocate(ptr, layout) };
         .                     self.ptr = Unique::dangling();
         .                     self.cap = Cap::ZERO;
         .                 } else {
         .                     let ptr = unsafe {
         .                         // `Layout::array` cannot overflow here because it would have
         .                         // overflowed earlier when capacity was larger.
         .                         let new_size = mem::size_of::<T>().unchecked_mul(cap);
-- line 532 ----------------------------------------
-- line 544 ----------------------------------------
         .             }
         .         }
         .         
         .         // This function is outside `RawVec` to minimize compile times. See the comment
         .         // above `RawVec::grow_amortized` for details. (The `A` parameter isn't
         .         // significant, because the number of different `A` types seen in practice is
         .         // much smaller than the number of `T` types.)
         .         #[inline(never)]
10,245,120 (0.1%)  fn finish_grow<A>(
         .             new_layout: Result<Layout, LayoutError>,
         .             current_memory: Option<(NonNull<u8>, Layout)>,
         .             alloc: &mut A,
         .         ) -> Result<NonNull<[u8]>, TryReserveError>
         .         where
         .             A: Allocator,
         .         {
         .             // Check for the error here to minimize the size of `RawVec::grow_*`.
         .             let new_layout = new_layout.map_err(|_| CapacityOverflow)?;
         .         
         .             alloc_guard(new_layout.size())?;
         .         
 3,372,157 (0.0%)      let memory = if let Some((ptr, old_layout)) = current_memory {
         .                 debug_assert_eq!(old_layout.align(), new_layout.align());
         .                 unsafe {
         .                     // The allocator checks for alignment equality
         .                     hint::assert_unchecked(old_layout.align() == new_layout.align());
         .                     alloc.grow(ptr, old_layout, new_layout)
         .                 }
         .             } else {
         .                 alloc.allocate(new_layout)
         .             };
         .         
         .             memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())
 8,724,288 (0.1%)  }
         .         
         .         unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {
         .             /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.
         .             fn drop(&mut self) {
         .                 if let Some((ptr, layout)) = self.current_memory() {
         .                     unsafe { self.alloc.deallocate(ptr, layout) }
         .                 }
         .             }
-- line 585 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/alloc/src/string.rs
--------------------------------------------------------------------------------
Ir______________ 

  121,825 (0.0%)  <unknown (line 0)>

-- line 441 ----------------------------------------
        .             /// ```
        .             /// let s = String::new();
        .             /// ```
        .             #[inline]
        .             #[rustc_const_stable(feature = "const_string_new", since = "1.39.0")]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             #[must_use]
        .             pub const fn new() -> String {
  636,597 (0.0%)          String { vec: Vec::new() }
        .             }
        .         
        .             /// Creates a new empty `String` with at least the specified capacity.
        .             ///
        .             /// `String`s have an internal buffer to hold their data. The capacity is
        .             /// the length of that buffer, and can be queried with the [`capacity`]
        .             /// method. This method creates an empty `String`, but one with an initial
        .             /// buffer that can hold at least `capacity` bytes. This is useful when you
-- line 457 ----------------------------------------
-- line 484 ----------------------------------------
        .             /// // ...but this may make the string reallocate
        .             /// s.push('a');
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             #[must_use]
        .             pub fn with_capacity(capacity: usize) -> String {
  211,085 (0.0%)          String { vec: Vec::with_capacity(capacity) }
        .             }
        .         
        .             /// Creates a new empty `String` with at least the specified capacity.
        .             ///
        .             /// # Errors
        .             ///
        .             /// Returns [`Err`] if the capacity exceeds `isize::MAX` bytes,
        .             /// or if the memory allocator reports failure.
-- line 500 ----------------------------------------
-- line 569 ----------------------------------------
        .             ///
        .             /// [`from_utf8_unchecked`]: String::from_utf8_unchecked
        .             /// [`Vec<u8>`]: crate::vec::Vec "Vec"
        .             /// [`&str`]: prim@str "&str"
        .             /// [`into_bytes`]: String::into_bytes
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {
    7,240 (0.0%)          match str::from_utf8(&vec) {
        .                     Ok(..) => Ok(String { vec }),
        .                     Err(e) => Err(FromUtf8Error { bytes: vec, error: e }),
        .                 }
        .             }
        .         
        .             /// Converts a slice of bytes to a string, including invalid characters.
        .             ///
        .             /// Strings are made of bytes ([`u8`]), and a slice of bytes
-- line 585 ----------------------------------------
-- line 627 ----------------------------------------
        .             /// let input = b"Hello \xF0\x90\x80World";
        .             /// let output = String::from_utf8_lossy(input);
        .             ///
        .             /// assert_eq!("Hello �World", output);
        .             /// ```
        .             #[must_use]
        .             #[cfg(not(no_global_oom_handling))]
        .             #[stable(feature = "rust1", since = "1.0.0")]
   67,690 (0.0%)      pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {
        .                 let mut iter = Utf8Chunks::new(v);
        .         
   32,559 (0.0%)          let first_valid = if let Some(chunk) = iter.next() {
        .                     let valid = chunk.valid();
   10,966 (0.0%)              if chunk.invalid().is_empty() {
        .                         debug_assert_eq!(valid.len(), v.len());
        .                         return Cow::Borrowed(valid);
        .                     }
        .                     valid
        .                 } else {
        .                     return Cow::Borrowed("");
        .                 };
        .         
-- line 648 ----------------------------------------
-- line 655 ----------------------------------------
        .                 for chunk in iter {
        .                     res.push_str(chunk.valid());
        .                     if !chunk.invalid().is_empty() {
        .                         res.push_str(REPLACEMENT);
        .                     }
        .                 }
        .         
        .                 Cow::Owned(res)
   60,921 (0.0%)      }
        .         
        .             /// Decode a UTF-16–encoded vector `v` into a `String`, returning [`Err`]
        .             /// if `v` contains any invalid data.
        .             ///
        .             /// # Examples
        .             ///
        .             /// ```
        .             /// // 𝄞music
-- line 671 ----------------------------------------
-- line 986 ----------------------------------------
        .             /// };
        .             ///
        .             /// assert_eq!("💖", sparkle_heart);
        .             /// ```
        .             #[inline]
        .             #[must_use]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
  156,229 (0.0%)          String { vec: bytes }
        .             }
        .         
        .             /// Converts a `String` into a byte vector.
        .             ///
        .             /// This consumes the `String`, so we do not need to copy its contents.
        .             ///
        .             /// # Examples
        .             ///
-- line 1002 ----------------------------------------
-- line 1059 ----------------------------------------
        .             ///
        .             /// assert_eq!("foobar", s);
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             #[rustc_confusables("append", "push")]
        .             pub fn push_str(&mut self, string: &str) {
      411 (0.0%)          self.vec.extend_from_slice(string.as_bytes())
        .             }
        .         
        .             /// Copies elements from `src` range to the end of the string.
        .             ///
        .             /// # Panics
        .             ///
        .             /// Panics if the starting point or end point do not lie on a [`char`]
        .             /// boundary, or if they're out of bounds.
-- line 1075 ----------------------------------------
-- line 1158 ----------------------------------------
        .             ///
        .             /// // ... doesn't actually increase.
        .             /// assert_eq!(capacity, s.capacity());
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn reserve(&mut self, additional: usize) {
    3,636 (0.0%)          self.vec.reserve(additional)
        .             }
        .         
        .             /// Reserves the minimum capacity for at least `additional` bytes more than
        .             /// the current length. Unlike [`reserve`], this will not
        .             /// deliberately over-allocate to speculatively avoid frequent allocations.
        .             /// After calling `reserve_exact`, capacity will be greater than or equal to
        .             /// `self.len() + additional`. Does nothing if the capacity is already
        .             /// sufficient.
-- line 1174 ----------------------------------------
-- line 1244 ----------------------------------------
        .             ///
        .             ///     Ok(output)
        .             /// }
        .             /// # process_data("rust").expect("why is the test harness OOMing on 4 bytes?");
        .             /// ```
        .             #[stable(feature = "try_reserve", since = "1.57.0")]
        .             pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
        .                 self.vec.try_reserve(additional)
    1,530 (0.0%)      }
        .         
        .             /// Tries to reserve the minimum capacity for at least `additional` bytes
        .             /// more than the current length. Unlike [`try_reserve`], this will not
        .             /// deliberately over-allocate to speculatively avoid frequent allocations.
        .             /// After calling `try_reserve_exact`, capacity will be greater than or
        .             /// equal to `self.len() + additional` if it returns `Ok(())`.
        .             /// Does nothing if the capacity is already sufficient.
        .             ///
-- line 1260 ----------------------------------------
-- line 1283 ----------------------------------------
        .             ///     // Now we know this can't OOM in the middle of our complex work
        .             ///     output.push_str(data);
        .             ///
        .             ///     Ok(output)
        .             /// }
        .             /// # process_data("rust").expect("why is the test harness OOMing on 4 bytes?");
        .             /// ```
        .             #[stable(feature = "try_reserve", since = "1.57.0")]
      654 (0.0%)      pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
        .                 self.vec.try_reserve_exact(additional)
      654 (0.0%)      }
        .         
        .             /// Shrinks the capacity of this `String` to match its length.
        .             ///
        .             /// # Examples
        .             ///
        .             /// ```
        .             /// let mut s = String::from("foo");
        .             ///
-- line 1301 ----------------------------------------
-- line 1350 ----------------------------------------
        .             /// s.push('2');
        .             /// s.push('3');
        .             ///
        .             /// assert_eq!("abc123", s);
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
1,432,039 (0.0%)      pub fn push(&mut self, ch: char) {
        .                 match ch.len_utf8() {
        .                     1 => self.vec.push(ch as u8),
        .                     _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0; 4]).as_bytes()),
        .                 }
1,227,462 (0.0%)      }
        .         
        .             /// Returns a byte slice of this `String`'s contents.
        .             ///
        .             /// The inverse of this method is [`from_utf8`].
        .             ///
        .             /// [`from_utf8`]: String::from_utf8
        .             ///
        .             /// # Examples
-- line 1371 ----------------------------------------
-- line 1374 ----------------------------------------
        .             /// let s = String::from("hello");
        .             ///
        .             /// assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());
        .             /// ```
        .             #[inline]
        .             #[must_use]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn as_bytes(&self) -> &[u8] {
    6,161 (0.0%)          &self.vec
        .             }
        .         
        .             /// Shortens this `String` to the specified length.
        .             ///
        .             /// If `new_len` is greater than the string's current length, this has no
        .             /// effect.
        .             ///
        .             /// Note that this method has no effect on the allocated capacity
-- line 1390 ----------------------------------------
-- line 1401 ----------------------------------------
        .             ///
        .             /// s.truncate(2);
        .             ///
        .             /// assert_eq!("he", s);
        .             /// ```
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn truncate(&mut self, new_len: usize) {
       18 (0.0%)          if new_len <= self.len() {
        9 (0.0%)              assert!(self.is_char_boundary(new_len));
        .                     self.vec.truncate(new_len)
        .                 }
        .             }
        .         
        .             /// Removes the last character from the string buffer and returns it.
        .             ///
        .             /// Returns [`None`] if this `String` is empty.
        .             ///
-- line 1418 ----------------------------------------
-- line 1425 ----------------------------------------
        .             /// assert_eq!(s.pop(), Some('b'));
        .             /// assert_eq!(s.pop(), Some('a'));
        .             ///
        .             /// assert_eq!(s.pop(), None);
        .             /// ```
        .             #[inline]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn pop(&mut self) -> Option<char> {
    9,798 (0.0%)          let ch = self.chars().rev().next()?;
    9,798 (0.0%)          let newlen = self.len() - ch.len_utf8();
        .                 unsafe {
        .                     self.vec.set_len(newlen);
        .                 }
        .                 Some(ch)
        .             }
        .         
        .             /// Removes a [`char`] from this `String` at a byte position and returns it.
        .             ///
-- line 1442 ----------------------------------------
-- line 1584 ----------------------------------------
        .                 struct SetLenOnDrop<'a> {
        .                     s: &'a mut String,
        .                     idx: usize,
        .                     del_bytes: usize,
        .                 }
        .         
        .                 impl<'a> Drop for SetLenOnDrop<'a> {
        .                     fn drop(&mut self) {
        3 (0.0%)                  let new_len = self.idx - self.del_bytes;
        .                         debug_assert!(new_len <= self.s.len());
        .                         unsafe { self.s.vec.set_len(new_len) };
        .                     }
        .                 }
        .         
        .                 let len = self.len();
        .                 let mut guard = SetLenOnDrop { s: self, idx: 0, del_bytes: 0 };
        .         
       64 (0.0%)          while guard.idx < len {
        .                     let ch =
        .                         // SAFETY: `guard.idx` is positive-or-zero and less that len so the `get_unchecked`
        .                         // is in bound. `self` is valid UTF-8 like string and the returned slice starts at
        .                         // a unicode code point so the `Chars` always return one character.
        .                         unsafe { guard.s.get_unchecked(guard.idx..len).chars().next().unwrap_unchecked() };
        .                     let ch_len = ch.len_utf8();
        .         
       32 (0.0%)              if !f(ch) {
       12 (0.0%)                  guard.del_bytes += ch_len;
       52 (0.0%)              } else if guard.del_bytes > 0 {
        .                         // SAFETY: `guard.idx` is in bound and `guard.del_bytes` represent the number of
        .                         // bytes that are erased from the string so the resulting `guard.idx -
        .                         // guard.del_bytes` always represent a valid unicode code point.
        .                         //
        .                         // `guard.del_bytes` >= `ch.len_utf8()`, so taking a slice with `ch.len_utf8()` len
        .                         // is safe.
        .                         ch.encode_utf8(unsafe {
        .                             crate::slice::from_raw_parts_mut(
       40 (0.0%)                          guard.s.as_mut_ptr().add(guard.idx - guard.del_bytes),
        .                                 ch.len_utf8(),
        .                             )
        .                         });
        .                     }
        .         
        .                     // Point idx to the next char
       32 (0.0%)              guard.idx += ch_len;
        .                 }
        .         
        .                 drop(guard);
        .             }
        .         
        .             /// Inserts a character into this `String` at a byte position.
        .             ///
        .             /// This is an *O*(*n*) operation as it requires copying every element in the
-- line 1635 ----------------------------------------
-- line 1661 ----------------------------------------
        .                 let bits = ch.encode_utf8(&mut bits).as_bytes();
        .         
        .                 unsafe {
        .                     self.insert_bytes(idx, bits);
        .                 }
        .             }
        .         
        .             #[cfg(not(no_global_oom_handling))]
   21,696 (0.0%)      unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {
        .                 let len = self.len();
        .                 let amt = bytes.len();
        .                 self.vec.reserve(amt);
        .         
        .                 unsafe {
    3,616 (0.0%)              ptr::copy(self.vec.as_ptr().add(idx), self.vec.as_mut_ptr().add(idx + amt), len - idx);
        .                     ptr::copy_nonoverlapping(bytes.as_ptr(), self.vec.as_mut_ptr().add(idx), amt);
    1,808 (0.0%)              self.vec.set_len(len + amt);
        .                 }
   14,464 (0.0%)      }
        .         
        .             /// Inserts a string slice into this `String` at a byte position.
        .             ///
        .             /// This is an *O*(*n*) operation as it requires copying every element in the
        .             /// buffer.
        .             ///
        .             /// # Panics
        .             ///
-- line 1687 ----------------------------------------
-- line 1699 ----------------------------------------
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[inline]
        .             #[stable(feature = "insert_str", since = "1.16.0")]
        .             pub fn insert_str(&mut self, idx: usize, string: &str) {
        .                 assert!(self.is_char_boundary(idx));
        .         
        .                 unsafe {
    9,040 (0.0%)              self.insert_bytes(idx, string.as_bytes());
        .                 }
        .             }
        .         
        .             /// Returns a mutable reference to the contents of this `String`.
        .             ///
        .             /// # Safety
        .             ///
        .             /// This function is unsafe because the returned `&mut Vec` allows writing
-- line 1715 ----------------------------------------
-- line 1769 ----------------------------------------
        .             ///
        .             /// v.push('a');
        .             /// assert!(!v.is_empty());
        .             /// ```
        .             #[inline]
        .             #[must_use]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             pub fn is_empty(&self) -> bool {
    8,743 (0.0%)          self.len() == 0
        .             }
        .         
        .             /// Splits the string into two at the given byte index.
        .             ///
        .             /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and
        .             /// the returned `String` contains bytes `[at, len)`. `at` must be on the
        .             /// boundary of a UTF-8 code point.
        .             ///
-- line 1785 ----------------------------------------
-- line 1953 ----------------------------------------
        .             ///
        .             /// let b = s.into_boxed_str();
        .             /// ```
        .             #[cfg(not(no_global_oom_handling))]
        .             #[stable(feature = "box_str", since = "1.4.0")]
        .             #[must_use = "`self` will be dropped if the result is not used"]
        .             #[inline]
        .             pub fn into_boxed_str(self) -> Box<str> {
    3,567 (0.0%)          let slice = self.vec.into_boxed_slice();
        .                 unsafe { from_boxed_utf8_unchecked(slice) }
        .             }
        .         
        .             /// Consumes and leaks the `String`, returning a mutable reference to the contents,
        .             /// `&'a mut str`.
        .             ///
        .             /// The caller has free choice over the returned lifetime, including `'static`. Indeed,
        .             /// this function is ideally used for data that lives for the remainder of the program's life,
-- line 1969 ----------------------------------------
-- line 2088 ----------------------------------------
        .             fn description(&self) -> &str {
        .                 "invalid utf-16"
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Clone for String {
  161,982 (0.0%)      fn clone(&self) -> Self {
   89,990 (0.0%)          String { vec: self.vec.clone() }
  161,982 (0.0%)      }
        .         
        .             fn clone_from(&mut self, source: &Self) {
        .                 self.vec.clone_from(&source.vec);
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl FromIterator<char> for String {
        .             fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> String {
        .                 let mut buf = String::new();
        .                 buf.extend(iter);
       85 (0.0%)          buf
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "string_from_iter_by_ref", since = "1.17.0")]
        .         impl<'a> FromIterator<&'a char> for String {
        .             fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {
        .                 let mut buf = String::new();
-- line 2119 ----------------------------------------
-- line 2123 ----------------------------------------
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl<'a> FromIterator<&'a str> for String {
        .             fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {
        .                 let mut buf = String::new();
        .                 buf.extend(iter);
      660 (0.0%)          buf
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "extend_string", since = "1.4.0")]
        .         impl FromIterator<String> for String {
        .             fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {
        .                 let mut iterator = iter.into_iter();
-- line 2139 ----------------------------------------
-- line 2165 ----------------------------------------
        .         #[stable(feature = "herd_cows", since = "1.19.0")]
        .         impl<'a> FromIterator<Cow<'a, str>> for String {
        .             fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {
        .                 let mut iterator = iter.into_iter();
        .         
        .                 // Because we're iterating over CoWs, we can (potentially) avoid at least
        .                 // one allocation by getting the first item and appending to it all the
        .                 // subsequent items.
      102 (0.0%)          match iterator.next() {
        .                     None => String::new(),
        .                     Some(cow) => {
        .                         let mut buf = cow.into_owned();
    5,865 (0.0%)                  buf.extend(iterator);
    1,380 (0.0%)                  buf
        .                     }
        .                 }
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Extend<char> for String {
        .             fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {
        .                 let iterator = iter.into_iter();
        .                 let (lower_bound, _) = iterator.size_hint();
        .                 self.reserve(lower_bound);
    8,588 (0.0%)          iterator.for_each(move |c| self.push(c));
      415 (0.0%)      }
        .         
        .             #[inline]
        .             fn extend_one(&mut self, c: char) {
        .                 self.push(c);
        .             }
        .         
        .             #[inline]
        .             fn extend_reserve(&mut self, additional: usize) {
-- line 2200 ----------------------------------------
-- line 2277 ----------------------------------------
        .         #[unstable(
        .             feature = "pattern",
        .             reason = "API not fully fleshed out and ready to be stabilized",
        .             issue = "27721"
        .         )]
        .         impl<'a, 'b> Pattern<'a> for &'b String {
        .             type Searcher = <&'b str as Pattern<'a>>::Searcher;
        .         
       45 (0.0%)      fn into_searcher(self, haystack: &'a str) -> <&'b str as Pattern<'a>>::Searcher {
       18 (0.0%)          self[..].into_searcher(haystack)
       45 (0.0%)      }
        .         
        .             #[inline]
        .             fn is_contained_in(self, haystack: &'a str) -> bool {
        .                 self[..].is_contained_in(haystack)
        .             }
        .         
        .             #[inline]
        .             fn is_prefix_of(self, haystack: &'a str) -> bool {
-- line 2295 ----------------------------------------
-- line 2337 ----------------------------------------
        .                     #[inline]
        .                     fn ne(&self, other: &$lhs) -> bool {
        .                         PartialEq::ne(&self[..], &other[..])
        .                     }
        .                 }
        .             };
        .         }
        .         
    2,612 (0.0%)  impl_eq! { String, str }
    7,663 (0.0%)  impl_eq! { String, &'a str }
        .         #[cfg(not(no_global_oom_handling))]
        .         impl_eq! { Cow<'a, str>, str }
        .         #[cfg(not(no_global_oom_handling))]
        .         impl_eq! { Cow<'a, str>, &'b str }
        .         #[cfg(not(no_global_oom_handling))]
        .         impl_eq! { Cow<'a, str>, String }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
-- line 2354 ----------------------------------------
-- line 2358 ----------------------------------------
        .             fn default() -> String {
        .                 String::new()
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl fmt::Display for String {
        .             #[inline]
  386,742 (0.0%)      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  403,335 (0.0%)          fmt::Display::fmt(&**self, f)
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl fmt::Debug for String {
        .             #[inline]
        .             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 fmt::Debug::fmt(&**self, f)
-- line 2375 ----------------------------------------
-- line 2470 ----------------------------------------
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl ops::Deref for String {
        .             type Target = str;
        .         
        .             #[inline]
        .             fn deref(&self) -> &str {
  620,194 (0.0%)          unsafe { str::from_utf8_unchecked(&self.vec) }
        .             }
        .         }
        .         
        .         #[unstable(feature = "deref_pure_trait", issue = "87121")]
        .         unsafe impl ops::DerefPure for String {}
        .         
        .         #[stable(feature = "derefmut_for_string", since = "1.3.0")]
        .         impl ops::DerefMut for String {
-- line 2486 ----------------------------------------
-- line 2544 ----------------------------------------
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl<T: fmt::Display + ?Sized> ToString for T {
        .             // A common guideline is to not inline generic functions. However,
        .             // removing `#[inline]` from this method causes non-negligible regressions.
        .             // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt
        .             // to try to remove it.
        .             #[inline]
    3,500 (0.0%)      default fn to_string(&self) -> String {
        .                 let mut buf = String::new();
        .                 let mut formatter = core::fmt::Formatter::new(&mut buf);
        .                 // Bypass format_args!() to avoid write_str with zero-length strs
   98,252 (0.0%)          fmt::Display::fmt(self, &mut formatter)
        .                     .expect("a Display implementation returned an error unexpectedly");
  356,618 (0.0%)          buf
    2,800 (0.0%)      }
        .         }
        .         
        .         #[doc(hidden)]
        .         #[cfg(not(no_global_oom_handling))]
        .         #[unstable(feature = "ascii_char", issue = "110998")]
        .         impl ToString for core::ascii::Char {
        .             #[inline]
        .             fn to_string(&self) -> String {
-- line 2567 ----------------------------------------
-- line 2810 ----------------------------------------
        .             /// ```
        .             /// # use std::borrow::Cow;
        .             /// assert_eq!(Cow::from("eggplant"), Cow::Borrowed("eggplant"));
        .             /// ```
        .             ///
        .             /// [`Borrowed`]: crate::borrow::Cow::Borrowed "borrow::Cow::Borrowed"
        .             #[inline]
        .             fn from(s: &'a str) -> Cow<'a, str> {
    4,268 (0.0%)          Cow::Borrowed(s)
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl<'a> From<String> for Cow<'a, str> {
        .             /// Converts a [`String`] into an [`Owned`] variant.
        .             /// No heap allocation is performed, and the string
-- line 2826 ----------------------------------------
-- line 2833 ----------------------------------------
        .             /// let s = "eggplant".to_string();
        .             /// let s2 = "eggplant".to_string();
        .             /// assert_eq!(Cow::from(s), Cow::<'static, str>::Owned(s2));
        .             /// ```
        .             ///
        .             /// [`Owned`]: crate::borrow::Cow::Owned "borrow::Cow::Owned"
        .             #[inline]
        .             fn from(s: String) -> Cow<'a, str> {
   43,104 (0.0%)          Cow::Owned(s)
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "cow_from_string_ref", since = "1.28.0")]
        .         impl<'a> From<&'a String> for Cow<'a, str> {
        .             /// Converts a [`String`] reference into a [`Borrowed`] variant.
        .             /// No heap allocation is performed, and the string
-- line 2849 ----------------------------------------
-- line 2906 ----------------------------------------
        .                 string.into_bytes()
        .             }
        .         }
        .         
        .         #[cfg(not(no_global_oom_handling))]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl fmt::Write for String {
        .             #[inline]
9,552,720 (0.1%)      fn write_str(&mut self, s: &str) -> fmt::Result {
        .                 self.push_str(s);
        .                 Ok(())
8,358,630 (0.1%)      }
        .         
        .             #[inline]
  121,706 (0.0%)      fn write_char(&mut self, c: char) -> fmt::Result {
   60,853 (0.0%)          self.push(c);
        .                 Ok(())
  182,559 (0.0%)      }
        .         }
        .         
        .         /// A draining iterator for `String`.
        .         ///
        .         /// This struct is created by the [`drain`] method on [`String`]. See its
        .         /// documentation for more.
        .         ///
        .         /// [`drain`]: String::drain
-- line 2931 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/fmt/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

7,974,919 (0.1%)  <unknown (line 0)>

-- line 186 ----------------------------------------
        .             ///     f.write_fmt(format_args!("{s}"))
        .             /// }
        .             ///
        .             /// let mut buf = String::new();
        .             /// writer(&mut buf, "world").unwrap();
        .             /// assert_eq!(&buf, "world");
        .             /// ```
        .             #[stable(feature = "rust1", since = "1.0.0")]
    5,667 (0.0%)      fn write_fmt(&mut self, args: Arguments<'_>) -> Result {
        .                 // We use a specialization for `Sized` types to avoid an indirection
        .                 // through `&mut self`
        .                 trait SpecWriteFmt {
        .                     fn spec_write_fmt(self, args: Arguments<'_>) -> Result;
        .                 }
        .         
        .                 impl<W: Write + ?Sized> SpecWriteFmt for &mut W {
        .                     #[inline]
-- line 202 ----------------------------------------
-- line 206 ----------------------------------------
        .                         } else {
        .                             write(&mut self, args)
        .                         }
        .                     }
        .                 }
        .         
        .                 impl<W: Write> SpecWriteFmt for &mut W {
        .                     #[inline]
      747 (0.0%)              fn spec_write_fmt(self, args: Arguments<'_>) -> Result {
        .                         if let Some(s) = args.as_statically_known_str() {
        .                             self.write_str(s)
        .                         } else {
  763,130 (0.0%)                      write(self, args)
        .                         }
        .                     }
        .                 }
        .         
      498 (0.0%)          self.spec_write_fmt(args)
        .             }
        .         }
        .         
        .         #[stable(feature = "fmt_write_blanket_impl", since = "1.4.0")]
        .         impl<W: Write + ?Sized> Write for &mut W {
        .             fn write_str(&mut self, s: &str) -> Result {
   93,341 (0.0%)          (**self).write_str(s)
        .             }
        .         
        .             fn write_char(&mut self, c: char) -> Result {
        .                 (**self).write_char(c)
        .             }
        .         
        2 (0.0%)      fn write_fmt(&mut self, args: Arguments<'_>) -> Result {
      261 (0.0%)          (**self).write_fmt(args)
        .             }
        .         }
        .         
        .         /// Configuration for formatting.
        .         ///
        .         /// A `Formatter` represents various options related to formatting. Users do not
        .         /// construct `Formatter`s directly; a mutable reference to one is passed to
        .         /// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].
-- line 246 ----------------------------------------
-- line 267 ----------------------------------------
        .             /// This can be used as a micro-optimization in cases where a full `Arguments`
        .             /// structure (as created by `format_args!`) is not necessary; `Arguments`
        .             /// is a little more expensive to use in simple formatting scenarios.
        .             ///
        .             /// Currently not intended for use outside of the standard library.
        .             #[unstable(feature = "fmt_internals", reason = "internal to standard library", issue = "none")]
        .             #[doc(hidden)]
        .             pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {
4,051,600 (0.1%)          Formatter {
        .                     flags: 0,
        .                     fill: ' ',
        .                     align: rt::Alignment::Unknown,
        .                     width: None,
        .                     precision: None,
        .                     buf,
        .                 }
        .             }
-- line 283 ----------------------------------------
-- line 325 ----------------------------------------
        .         #[unstable(feature = "fmt_internals", issue = "none")]
        .         impl<'a> Arguments<'a> {
        .             #[inline]
        .             #[rustc_const_unstable(feature = "const_fmt_arguments_new", issue = "none")]
        .             pub const fn new_const(pieces: &'a [&'static str]) -> Self {
        .                 if pieces.len() > 1 {
        .                     panic!("invalid args");
        .                 }
    6,623 (0.0%)          Arguments { pieces, fmt: None, args: &[] }
        .             }
        .         
        .             /// When using the format_args!() macro, this function is used to generate the
        .             /// Arguments structure.
        .             #[inline]
        .             pub fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {
        .                 if pieces.len() < args.len() || pieces.len() > args.len() + 1 {
        .                     panic!("invalid args");
        .                 }
3,517,220 (0.0%)          Arguments { pieces, fmt: None, args }
        .             }
        .         
        .             /// This function is used to specify nonstandard formatting parameters.
        .             ///
        .             /// An `rt::UnsafeArg` is required because the following invariants must be held
        .             /// in order for this function to be safe:
        .             /// 1. The `pieces` slice must be at least as long as `fmt`.
        .             /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.
-- line 351 ----------------------------------------
-- line 352 ----------------------------------------
        .             /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.
        .             #[inline]
        .             pub fn new_v1_formatted(
        .                 pieces: &'a [&'static str],
        .                 args: &'a [rt::Argument<'a>],
        .                 fmt: &'a [rt::Placeholder],
        .                 _unsafe_arg: rt::UnsafeArg,
        .             ) -> Arguments<'a> {
  492,869 (0.0%)          Arguments { pieces, fmt: Some(fmt), args }
        .             }
        .         
        .             /// Estimates the length of the formatted text.
        .             ///
        .             /// This is intended to be used for setting initial `String` capacity
        .             /// when using `format!`. Note: this is neither the lower nor upper bound.
        .             #[inline]
        .             pub fn estimated_capacity(&self) -> usize {
   88,156 (0.0%)          let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();
        .         
   88,156 (0.0%)          if self.args.is_empty() {
        .                     pieces_length
  308,546 (0.0%)          } else if !self.pieces.is_empty() && self.pieces[0].is_empty() && pieces_length < 16 {
        .                     // If the format string starts with an argument,
        .                     // don't preallocate anything, unless length
        .                     // of pieces is significant.
        .                     0
        .                 } else {
        .                     // There are some arguments, so any additional push
        .                     // will reallocate the string. To avoid that,
        .                     // we're "pre-doubling" the capacity here.
-- line 381 ----------------------------------------
-- line 427 ----------------------------------------
        .             /// assert_eq!(format_args!("").as_str(), Some(""));
        .             /// assert_eq!(format_args!("{:?}", std::env::current_dir()).as_str(), None);
        .             /// ```
        .             #[stable(feature = "fmt_as_str", since = "1.52.0")]
        .             #[rustc_const_unstable(feature = "const_arguments_as_str", issue = "103900")]
        .             #[must_use]
        .             #[inline]
        .             pub const fn as_str(&self) -> Option<&'static str> {
      302 (0.0%)          match (self.pieces, self.args) {
      718 (0.0%)              ([], []) => Some(""),
       94 (0.0%)              ([s], []) => Some(s),
        .                     _ => None,
        .                 }
        .             }
        .         
        .             /// Same as [`Arguments::as_str`], but will only return `Some(s)` if it can be determined at compile time.
        .             #[must_use]
        .             #[inline]
        .             fn as_statically_known_str(&self) -> Option<&'static str> {
-- line 445 ----------------------------------------
-- line 452 ----------------------------------------
        .         impl Debug for Arguments<'_> {
        .             fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {
        .                 Display::fmt(self, fmt)
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Display for Arguments<'_> {
   10,965 (0.0%)      fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {
   14,620 (0.0%)          write(fmt.buf, *self)
        .             }
        .         }
        .         
        .         /// `?` formatting.
        .         ///
        .         /// `Debug` should format the output in a programmer-facing, debugging context.
        .         ///
        .         /// Generally speaking, you should just `derive` a `Debug` implementation.
-- line 469 ----------------------------------------
-- line 1131 ----------------------------------------
        .         /// let mut output = String::new();
        .         /// write!(&mut output, "Hello {}!", "world")
        .         ///     .expect("Error occurred while trying to write in String");
        .         /// assert_eq!(output, "Hello world!");
        .         /// ```
        .         ///
        .         /// [`write!`]: crate::write!
        .         #[stable(feature = "rust1", since = "1.0.0")]
4,333,664 (0.1%)  pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {
        .             let mut formatter = Formatter::new(output);
        .             let mut idx = 0;
        .         
2,166,832 (0.0%)      match args.fmt {
        .                 None => {
        .                     // We can use default formatting parameters for all arguments.
  487,383 (0.0%)              for (i, arg) in args.args.iter().enumerate() {
        .                         // SAFETY: args.args and args.pieces come from the same Arguments,
        .                         // which guarantees the indexes are always within bounds.
        .                         let piece = unsafe { args.pieces.get_unchecked(i) };
1,889,559 (0.0%)                  if !piece.is_empty() {
  719,760 (0.0%)                      formatter.buf.write_str(*piece)?;
        .                         }
        .         
        .                         // SAFETY: There are no formatting parameters and hence no
        .                         // count arguments.
        .                         unsafe {
        .                             arg.fmt(&mut formatter)?;
        .                         }
  629,853 (0.0%)                  idx += 1;
        .                     }
        .                 }
   54,325 (0.0%)          Some(fmt) => {
        .                     // Every spec has a corresponding argument that is preceded by
        .                     // a string piece.
        .                     for (i, arg) in fmt.iter().enumerate() {
        .                         // SAFETY: fmt and args.pieces come from the same Arguments,
        .                         // which guarantees the indexes are always within bounds.
        .                         let piece = unsafe { args.pieces.get_unchecked(i) };
  457,848 (0.0%)                  if !piece.is_empty() {
  526,376 (0.0%)                      formatter.buf.write_str(*piece)?;
        .                         }
        .                         // SAFETY: arg and args.args come from the same Arguments,
        .                         // which guarantees the indexes are always within bounds.
        .                         unsafe { run(&mut formatter, arg, args.args) }?;
  152,616 (0.0%)                  idx += 1;
        .                     }
        .                 }
        .             }
        .         
        .             // There can be only one trailing string piece left.
  654,754 (0.0%)      if let Some(piece) = args.pieces.get(idx) {
  565,230 (0.0%)          formatter.buf.write_str(*piece)?;
        .             }
        .         
        .             Ok(())
4,333,664 (0.1%)  }
        .         
        .         unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[rt::Argument<'_>]) -> Result {
  305,232 (0.0%)      fmt.fill = arg.fill;
  305,232 (0.0%)      fmt.align = arg.align;
  305,232 (0.0%)      fmt.flags = arg.flags;
        .             // SAFETY: arg and args come from the same Arguments,
        .             // which guarantees the indexes are always within bounds.
        .             unsafe {
  610,464 (0.0%)          fmt.width = getcount(args, &arg.width);
  457,848 (0.0%)          fmt.precision = getcount(args, &arg.precision);
        .             }
        .         
        .             // Extract the correct argument
        .             debug_assert!(arg.position < args.len());
        .             // SAFETY: arg and args come from the same Arguments,
        .             // which guarantees its index is always within bounds.
  152,616 (0.0%)      let value = unsafe { args.get_unchecked(arg.position) };
        .         
        .             // Then actually do some printing
        .             // SAFETY: this is a placeholder argument.
        .             unsafe { value.fmt(fmt) }
        .         }
        .         
        .         unsafe fn getcount(args: &[rt::Argument<'_>], cnt: &rt::Count) -> Option<usize> {
  908,316 (0.0%)      match *cnt {
        .                 rt::Count::Is(n) => Some(n),
        .                 rt::Count::Implied => None,
        .                 rt::Count::Param(i) => {
        .                     debug_assert!(i < args.len());
        .                     // SAFETY: cnt and args come from the same Arguments,
        .                     // which guarantees this index is always within bounds.
        .                     unsafe { args.get_unchecked(i).as_usize() }
        .                 }
-- line 1219 ----------------------------------------
-- line 1303 ----------------------------------------
        .             ///
        .             /// assert_eq!(format!("{}", Foo::new(2)), "2");
        .             /// assert_eq!(format!("{}", Foo::new(-1)), "-1");
        .             /// assert_eq!(format!("{}", Foo::new(0)), "0");
        .             /// assert_eq!(format!("{:#}", Foo::new(-1)), "-Foo 1");
        .             /// assert_eq!(format!("{:0>#8}", Foo::new(-1)), "00-Foo 1");
        .             /// ```
        .             #[stable(feature = "rust1", since = "1.0.0")]
  904,956 (0.0%)      pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {
        .                 let mut width = buf.len();
        .         
        .                 let mut sign = None;
  150,826 (0.0%)          if !is_nonnegative {
        .                     sign = Some('-');
        .                     width += 1;
  150,826 (0.0%)          } else if self.sign_plus() {
        .                     sign = Some('+');
        .                     width += 1;
        .                 }
        .         
  150,826 (0.0%)          let prefix = if self.alternate() {
        .                     width += prefix.chars().count();
        .                     Some(prefix)
        .                 } else {
        .                     None
        .                 };
        .         
        .                 // Writes the sign if it exists, and then the prefix if it was requested
        .                 #[inline(never)]
  678,717 (0.0%)          fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, prefix: Option<&str>) -> Result {
  150,826 (0.0%)              if let Some(c) = sign {
        .                         f.buf.write_char(c)?;
        .                     }
  150,826 (0.0%)              if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }
  452,478 (0.0%)          }
        .         
        .                 // The `width` field is more of a `min-width` parameter at this point.
  150,826 (0.0%)          match self.width {
        .                     // If there's no minimum length requirements then we can just
        .                     // write the bytes.
        .                     None => {
  358,615 (0.0%)                  write_prefix(self, sign, prefix)?;
        .                         self.buf.write_str(buf)
        .                     }
        .                     // Check if we're over the minimum width, if so then we can also
        .                     // just write the bytes.
   11,070 (0.0%)              Some(min) if width >= min => {
   25,809 (0.0%)                  write_prefix(self, sign, prefix)?;
        .                         self.buf.write_str(buf)
        .                     }
        .                     // The sign and prefix goes before the padding if the fill character
        .                     // is zero
        6 (0.0%)              Some(min) if self.sign_aware_zero_pad() => {
        .                         let old_fill = crate::mem::replace(&mut self.fill, '0');
        .                         let old_align = crate::mem::replace(&mut self.align, rt::Alignment::Right);
       30 (0.0%)                  write_prefix(self, sign, prefix)?;
        .                         let post_padding = self.padding(min - width, Alignment::Right)?;
       12 (0.0%)                  self.buf.write_str(buf)?;
        .                         post_padding.write(self)?;
        6 (0.0%)                  self.fill = old_fill;
        9 (0.0%)                  self.align = old_align;
        .                         Ok(())
        .                     }
        .                     // Otherwise, the sign and prefix goes after the padding
        .                     Some(min) => {
        .                         let post_padding = self.padding(min - width, Alignment::Right)?;
        .                         write_prefix(self, sign, prefix)?;
        .                         self.buf.write_str(buf)?;
        .                         post_padding.write(self)
        .                     }
        .                 }
       27 (0.0%)      }
        .         
        .             /// This function takes a string slice and emits it to the internal buffer
        .             /// after applying the relevant formatting flags specified. The flags
        .             /// recognized for generic strings are:
        .             ///
        .             /// * width - the minimum width of what to emit
        .             /// * fill/align - what to emit and where to emit it if the string
        .             ///                provided needs to be padded
-- line 1382 ----------------------------------------
-- line 1397 ----------------------------------------
        .             ///         formatter.pad("Foo")
        .             ///     }
        .             /// }
        .             ///
        .             /// assert_eq!(format!("{Foo:<4}"), "Foo ");
        .             /// assert_eq!(format!("{Foo:0>4}"), "0Foo");
        .             /// ```
        .             #[stable(feature = "rust1", since = "1.0.0")]
3,844,910 (0.0%)      pub fn pad(&mut self, s: &str) -> Result {
        .                 // Make sure there's a fast path up front
        .                 if self.width.is_none() && self.precision.is_none() {
        .                     return self.buf.write_str(s);
        .                 }
        .                 // The `precision` field can be interpreted as a `max-width` for the
        .                 // string being formatted.
        .                 let s = if let Some(max) = self.precision {
        .                     // If our string is longer that the precision, then we must have
-- line 1413 ----------------------------------------
-- line 1465 ----------------------------------------
        .                 };
        .         
        .                 let (pre_pad, post_pad) = match align {
        .                     Alignment::Left => (0, padding),
        .                     Alignment::Right => (padding, 0),
        .                     Alignment::Center => (padding / 2, (padding + 1) / 2),
        .                 };
        .         
        6 (0.0%)          for _ in 0..pre_pad {
        9 (0.0%)              self.buf.write_char(self.fill)?;
        .                 }
        .         
        .                 Ok(PostPadding::new(self.fill, post_pad))
        .             }
        .         
        .             /// Takes the formatted parts and applies the padding.
        .             /// Assumes that the caller already has rendered the parts with required precision,
        .             /// so that `self.precision` can be ignored.
-- line 1482 ----------------------------------------
-- line 1593 ----------------------------------------
        .             ///         // write!(formatter, "Foo")
        .             ///     }
        .             /// }
        .             ///
        .             /// assert_eq!(format!("{Foo}"), "Foo");
        .             /// assert_eq!(format!("{Foo:0>8}"), "Foo");
        .             /// ```
        .             #[stable(feature = "rust1", since = "1.0.0")]
  680,972 (0.0%)      pub fn write_str(&mut self, data: &str) -> Result {
2,042,916 (0.0%)          self.buf.write_str(data)
        .             }
        .         
        .             /// Writes some formatted information into this instance.
        .             ///
        .             /// # Examples
        .             ///
        .             /// ```
        .             /// use std::fmt;
-- line 1610 ----------------------------------------
-- line 1617 ----------------------------------------
        .             ///     }
        .             /// }
        .             ///
        .             /// assert_eq!(format!("{}", Foo(-1)), "Foo -1");
        .             /// assert_eq!(format!("{:0>8}", Foo(2)), "Foo 2");
        .             /// ```
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             #[inline]
    9,506 (0.0%)      pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {
        .                 if let Some(s) = fmt.as_statically_known_str() {
   65,708 (0.0%)              self.buf.write_str(s)
        .                 } else {
  310,929 (0.0%)              write(self.buf, fmt)
        .                 }
        .             }
        .         
        .             /// Flags for formatting
        .             #[must_use]
        .             #[stable(feature = "rust1", since = "1.0.0")]
        .             #[deprecated(
        .                 since = "1.24.0",
-- line 1637 ----------------------------------------
-- line 1800 ----------------------------------------
        .             ///
        .             /// assert_eq!(format!("{:+}", Foo(23)), "Foo(+23)");
        .             /// assert_eq!(format!("{:+}", Foo(-23)), "Foo(-23)");
        .             /// assert_eq!(format!("{}", Foo(23)), "Foo(23)");
        .             /// ```
        .             #[must_use]
        .             #[stable(feature = "fmt_flags", since = "1.5.0")]
        .             pub fn sign_plus(&self) -> bool {
  301,652 (0.0%)          self.flags & (1 << rt::Flag::SignPlus as u32) != 0
        .             }
        .         
        .             /// Determines if the `-` flag was specified.
        .             ///
        .             /// # Examples
        .             ///
        .             /// ```
        .             /// use std::fmt;
-- line 1816 ----------------------------------------
-- line 2307 ----------------------------------------
        .         }
        .         
        .         #[stable(since = "1.2.0", feature = "formatter_write")]
        .         impl Write for Formatter<'_> {
        .             fn write_str(&mut self, s: &str) -> Result {
        .                 self.buf.write_str(s)
        .             }
        .         
    1,776 (0.0%)      fn write_char(&mut self, c: char) -> Result {
  188,147 (0.0%)          self.buf.write_char(c)
        .             }
        .         
        .             #[inline]
      708 (0.0%)      fn write_fmt(&mut self, args: Arguments<'_>) -> Result {
        .                 if let Some(s) = args.as_statically_known_str() {
        .                     self.buf.write_str(s)
        .                 } else {
  154,541 (0.0%)              write(self.buf, args)
        .                 }
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Display for Error {
        .             fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        .                 Display::fmt("an error occurred when formatting an argument", f)
-- line 2332 ----------------------------------------
-- line 2335 ----------------------------------------
        .         
        .         // Implementations of the core formatting traits
        .         
        .         macro_rules! fmt_refs {
        .             ($($tr:ident),*) => {
        .                 $(
        .                 #[stable(feature = "rust1", since = "1.0.0")]
        .                 impl<T: ?Sized + $tr> $tr for &T {
1,702,742 (0.0%)              fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }
        .                 }
        .                 #[stable(feature = "rust1", since = "1.0.0")]
        .                 impl<T: ?Sized + $tr> $tr for &mut T {
        .                     fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }
        .                 }
        .                 )*
        .             }
        .         }
        .         
    3,482 (0.0%)  fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }
        .         
        .         #[unstable(feature = "never_type", issue = "35121")]
        .         impl Debug for ! {
        .             #[inline]
        .             fn fmt(&self, _: &mut Formatter<'_>) -> Result {
        .                 *self
        .             }
        .         }
-- line 2361 ----------------------------------------
-- line 2405 ----------------------------------------
        .                 }
        .                 f.write_str(&self[from..])?;
        .                 f.write_char('"')
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Display for str {
1,922,455 (0.0%)      fn fmt(&self, f: &mut Formatter<'_>) -> Result {
1,153,473 (0.0%)          f.pad(self)
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl Debug for char {
        .             fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        .                 f.write_char('\'')?;
        .                 for c in self.escape_debug_ext(EscapeDebugExtArgs {
-- line 2422 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/iter/adapters/flatten.rs
--------------------------------------------------------------------------------
Ir______________ 

  480,922 (0.0%)  <unknown (line 0)>

-- line 17 ----------------------------------------
        .         #[must_use = "iterators are lazy and do nothing unless consumed"]
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         pub struct FlatMap<I, U: IntoIterator, F> {
        .             inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,
        .         }
        .         
        .         impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {
        .             pub(in crate::iter) fn new(iter: I, f: F) -> FlatMap<I, U, F> {
2,026,016 (0.0%)          FlatMap { inner: FlattenCompat::new(iter.map(f)) }
        .             }
        .         
        .             pub(crate) fn into_parts(self) -> (Option<U::IntoIter>, Option<I>, Option<U::IntoIter>) {
        .                 (
        .                     self.inner.frontiter,
        .                     self.inner.iter.into_inner().map(Map::into_inner),
        .                     self.inner.backiter,
        .                 )
-- line 33 ----------------------------------------
-- line 57 ----------------------------------------
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>
        .         where
        .             F: FnMut(I::Item) -> U,
        .         {
        .             type Item = U::Item;
        .         
        .             #[inline]
  714,583 (0.0%)      fn next(&mut self) -> Option<U::Item> {
  674,711 (0.0%)          self.inner.next()
  656,407 (0.0%)      }
        .         
        .             #[inline]
      520 (0.0%)      fn size_hint(&self) -> (usize, Option<usize>) {
        .                 self.inner.size_hint()
      520 (0.0%)      }
        .         
        .             #[inline]
        .             fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R
        .             where
        .                 Self: Sized,
        .                 Fold: FnMut(Acc, Self::Item) -> R,
        .                 R: Try<Output = Acc>,
        .             {
-- line 80 ----------------------------------------
-- line 81 ----------------------------------------
        .                 self.inner.try_fold(init, fold)
        .             }
        .         
        .             #[inline]
        .             fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc
        .             where
        .                 Fold: FnMut(Acc, Self::Item) -> Acc,
        .             {
       21 (0.0%)          self.inner.fold(init, fold)
        .             }
        .         
        .             #[inline]
        .             fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
        .                 self.inner.advance_by(n)
        .             }
        .         
        .             #[inline]
-- line 97 ----------------------------------------
-- line 254 ----------------------------------------
        .         #[must_use = "iterators are lazy and do nothing unless consumed"]
        .         #[stable(feature = "iterator_flatten", since = "1.29.0")]
        .         pub struct Flatten<I: Iterator<Item: IntoIterator>> {
        .             inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,
        .         }
        .         
        .         impl<I: Iterator<Item: IntoIterator>> Flatten<I> {
        .             pub(in super::super) fn new(iter: I) -> Flatten<I> {
  505,537 (0.0%)          Flatten { inner: FlattenCompat::new(iter) }
        .             }
        .         }
        .         
        .         #[stable(feature = "iterator_flatten", since = "1.29.0")]
        .         impl<I, U> fmt::Debug for Flatten<I>
        .         where
        .             I: fmt::Debug + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,
        .             U: fmt::Debug + Iterator,
-- line 270 ----------------------------------------
-- line 289 ----------------------------------------
        .         impl<I, U> Iterator for Flatten<I>
        .         where
        .             I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,
        .             U: Iterator,
        .         {
        .             type Item = U::Item;
        .         
        .             #[inline]
  777,595 (0.0%)      fn next(&mut self) -> Option<U::Item> {
  114,363 (0.0%)          self.inner.next()
  562,344 (0.0%)      }
        .         
        .             #[inline]
        .             fn size_hint(&self) -> (usize, Option<usize>) {
        .                 self.inner.size_hint()
        .             }
        .         
        .             #[inline]
        .             fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R
-- line 307 ----------------------------------------
-- line 433 ----------------------------------------
        .             /// ```
        .             fn default() -> Self {
        .                 Flatten::new(Default::default())
        .             }
        .         }
        .         
        .         /// Real logic of both `Flatten` and `FlatMap` which simply delegate to
        .         /// this type.
   18,792 (0.0%)  #[derive(Clone, Debug)]
        .         #[unstable(feature = "trusted_len", issue = "37572")]
        .         struct FlattenCompat<I, U> {
        .             iter: Fuse<I>,
        .             frontiter: Option<U>,
        .             backiter: Option<U>,
        .         }
        .         impl<I, U> FlattenCompat<I, U>
        .         where
        .             I: Iterator,
        .         {
        .             /// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.
        .             fn new(iter: I) -> FlattenCompat<I, U> {
    1,796 (0.0%)          FlattenCompat { iter: iter.fuse(), frontiter: None, backiter: None }
        .             }
        .         }
        .         
        .         impl<I, U> FlattenCompat<I, U>
        .         where
        .             I: Iterator<Item: IntoIterator<IntoIter = U>>,
        .         {
        .             /// Folds the inner iterators into an accumulator by applying an operation.
-- line 462 ----------------------------------------
-- line 467 ----------------------------------------
        .             fn iter_fold<Acc, Fold>(self, mut acc: Acc, mut fold: Fold) -> Acc
        .             where
        .                 Fold: FnMut(Acc, U) -> Acc,
        .             {
        .                 #[inline]
        .                 fn flatten<T: IntoIterator, Acc>(
        .                     fold: &mut impl FnMut(Acc, T::IntoIter) -> Acc,
        .                 ) -> impl FnMut(Acc, T) -> Acc + '_ {
       14 (0.0%)              move |acc, iter| fold(acc, iter.into_iter())
        .                 }
        .         
        6 (0.0%)          if let Some(iter) = self.frontiter {
        .                     acc = fold(acc, iter);
        .                 }
        .         
        4 (0.0%)          acc = self.iter.fold(acc, flatten(&mut fold));
        .         
        6 (0.0%)          if let Some(iter) = self.backiter {
        .                     acc = fold(acc, iter);
        .                 }
        .         
        .                 acc
        .             }
        .         
        .             /// Folds over the inner iterators as long as the given function returns successfully,
        .             /// always storing the most recent inner iterator in `self.frontiter`.
-- line 492 ----------------------------------------
-- line 499 ----------------------------------------
        .                 Fold: FnMut(Acc, &mut U) -> R,
        .                 R: Try<Output = Acc>,
        .             {
        .                 #[inline]
        .                 fn flatten<'a, T: IntoIterator, Acc, R: Try<Output = Acc>>(
        .                     frontiter: &'a mut Option<T::IntoIter>,
        .                     fold: &'a mut impl FnMut(Acc, &mut T::IntoIter) -> R,
        .                 ) -> impl FnMut(Acc, T) -> R + 'a {
      612 (0.0%)              move |acc, iter| fold(acc, frontiter.insert(iter.into_iter()))
        .                 }
        .         
   14,257 (0.0%)          if let Some(iter) = &mut self.frontiter {
      252 (0.0%)              acc = fold(acc, iter)?;
        .                 }
    3,712 (0.0%)          self.frontiter = None;
        .         
        .                 acc = self.iter.try_fold(acc, flatten(&mut self.frontiter, &mut fold))?;
   11,261 (0.0%)          self.frontiter = None;
        .         
   11,472 (0.0%)          if let Some(iter) = &mut self.backiter {
        .                     acc = fold(acc, iter)?;
        .                 }
   14,189 (0.0%)          self.backiter = None;
        .         
        .                 try { acc }
        .             }
        .         }
        .         
        .         impl<I, U> FlattenCompat<I, U>
        .         where
        .             I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U>>,
-- line 529 ----------------------------------------
-- line 597 ----------------------------------------
        .         impl<I, U> Iterator for FlattenCompat<I, U>
        .         where
        .             I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,
        .             U: Iterator,
        .         {
        .             type Item = U::Item;
        .         
        .             #[inline]
4,519,326 (0.1%)      default fn next(&mut self) -> Option<U::Item> {
    3,872 (0.0%)          loop {
   30,326 (0.0%)              if let elt @ Some(_) = and_then_or_clear(&mut self.frontiter, Iterator::next) {
1,816,432 (0.0%)                  return elt;
        .                     }
  611,554 (0.0%)              match self.iter.next() {
    4,741 (0.0%)                  None => return and_then_or_clear(&mut self.backiter, Iterator::next),
1,356,206 (0.0%)                  Some(inner) => self.frontiter = Some(inner.into_iter()),
        .                     }
        .                 }
2,672,124 (0.0%)      }
        .         
        .             #[inline]
        .             default fn size_hint(&self) -> (usize, Option<usize>) {
        .                 let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), U::size_hint);
        .                 let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), U::size_hint);
        .                 let lo = flo.saturating_add(blo);
        .         
        .                 if let Some(fixed_size) = <<I as Iterator>::Item as ConstSizeIntoIterator>::size() {
-- line 623 ----------------------------------------
-- line 625 ----------------------------------------
        .         
        .                     let lower = lower.saturating_mul(fixed_size).saturating_add(lo);
        .                     let upper =
        .                         try { fhi?.checked_add(bhi?)?.checked_add(fixed_size.checked_mul(upper?)?)? };
        .         
        .                     return (lower, upper);
        .                 }
        .         
    8,224 (0.0%)          match (self.iter.size_hint(), fhi, bhi) {
    2,125 (0.0%)              ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),
    7,045 (0.0%)              _ => (lo, None),
        .                 }
        .             }
        .         
        .             #[inline]
        .             default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R
        .             where
        .                 Self: Sized,
        .                 Fold: FnMut(Acc, Self::Item) -> R,
        .                 R: Try<Output = Acc>,
        .             {
        .                 #[inline]
        .                 fn flatten<U: Iterator, Acc, R: Try<Output = Acc>>(
        .                     mut fold: impl FnMut(Acc, U::Item) -> R,
        .                 ) -> impl FnMut(Acc, &mut U) -> R {
    1,300 (0.0%)              move |acc, iter| iter.try_fold(acc, &mut fold)
        .                 }
        .         
        .                 self.iter_try_fold(init, flatten(fold))
        .             }
        .         
        .             #[inline]
        .             default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc
        .             where
        .                 Fold: FnMut(Acc, Self::Item) -> Acc,
        .             {
        .                 #[inline]
        .                 fn flatten<U: Iterator, Acc>(
        .                     mut fold: impl FnMut(Acc, U::Item) -> Acc,
        .                 ) -> impl FnMut(Acc, U) -> Acc {
       42 (0.0%)              move |acc, iter| iter.fold(acc, &mut fold)
        .                 }
        .         
        .                 self.iter_fold(init, flatten(fold))
        .             }
        .         
        .             #[inline]
        .             #[rustc_inherit_overflow_checks]
        .             default fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
-- line 673 ----------------------------------------
-- line 831 ----------------------------------------
        .         impl<T, const N: usize> ConstSizeIntoIterator for &mut [T; N] {
        .             #[inline]
        .             fn size() -> Option<usize> {
        .                 Some(N)
        .             }
        .         }
        .         
        .         #[inline]
   53,352 (0.0%)  fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {
        .             let x = f(opt.as_mut()?);
        .             if x.is_none() {
  222,102 (0.0%)          *opt = None;
        .             }
  406,299 (0.0%)      x
   53,799 (0.0%)  }
        .         
        .         /// Specialization trait for iterator types that never return more than one item.
        .         ///
        .         /// Note that we still have to deal with the possibility that the iterator was
        .         /// already exhausted before it came into our control.
        .         #[rustc_specialization_trait]
        .         trait OneShot {}
        .         
-- line 853 ----------------------------------------
-- line 930 ----------------------------------------
        .         // An exception to that is `advance_by(0)` and `advance_back_by(0)`, where the generic impls may set
        .         // `frontiter` or `backiter` without consuming the item, so we **must** override those.
        .         impl<I, U> Iterator for FlattenCompat<I, U>
        .         where
        .             I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,
        .             U: Iterator + OneShot,
        .         {
        .             #[inline]
    3,195 (0.0%)      fn next(&mut self) -> Option<U::Item> {
  115,021 (0.0%)          while let Some(inner) = self.iter.next() {
   10,101 (0.0%)              if let item @ Some(_) = inner.into_iter().next() {
  270,113 (0.0%)                  return item;
        .                     }
        .                 }
       52 (0.0%)          None
    2,840 (0.0%)      }
        .         
        .             #[inline]
        .             fn size_hint(&self) -> (usize, Option<usize>) {
        .                 let (lower, upper) = self.iter.size_hint();
        .                 match <I::Item as ConstSizeIntoIterator>::size() {
        .                     Some(0) => (0, Some(0)),
        .                     Some(1) => (lower, upper),
        2 (0.0%)              _ => (0, upper),
        .                 }
        .             }
        .         
        .             #[inline]
        .             fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R
        .             where
        .                 Self: Sized,
        .                 Fold: FnMut(Acc, Self::Item) -> R,
-- line 961 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/iter/traits/iterator.rs
--------------------------------------------------------------------------------
Ir_______________ 

 4,432,621 (0.1%)  <unknown (line 0)>

-- line 225 ----------------------------------------
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[rustc_do_not_const_check]
         .             fn count(self) -> usize
         .             where
         .                 Self: Sized,
         .             {
        13 (0.0%)          self.fold(
         .                     0,
         .                     #[rustc_inherit_overflow_checks]
   183,106 (0.0%)              |count, _| count + 1,
         .                 )
         .             }
         .         
         .             /// Consumes the iterator, returning the last element.
         .             ///
         .             /// This method will evaluate the iterator until it returns [`None`]. While
         .             /// doing so, it keeps track of the current element. After [`None`] is
         .             /// returned, `last()` will then return the last element it saw.
-- line 244 ----------------------------------------
-- line 299 ----------------------------------------
         .             /// assert_eq!(iter.advance_by(0), Ok(()));
         .             /// assert_eq!(iter.advance_by(100), Err(NonZero::new(99).unwrap())); // only `&4` was skipped
         .             /// ```
         .             #[inline]
         .             #[unstable(feature = "iter_advance_by", reason = "recently added", issue = "77404")]
         .             #[rustc_do_not_const_check]
         .             fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
         .                 for i in 0..n {
       148 (0.0%)              if self.next().is_none() {
         .                         // SAFETY: `i` is always less than `n`.
         .                         return Err(unsafe { NonZero::new_unchecked(n - i) });
         .                     }
         .                 }
         .                 Ok(())
         .             }
         .         
         .             /// Returns the `n`th element of the iterator.
-- line 315 ----------------------------------------
-- line 349 ----------------------------------------
         .             ///
         .             /// ```
         .             /// let a = [1, 2, 3];
         .             /// assert_eq!(a.iter().nth(10), None);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[rustc_do_not_const_check]
    34,364 (0.0%)      fn nth(&mut self, n: usize) -> Option<Self::Item> {
         .                 self.advance_by(n).ok()?;
       958 (0.0%)          self.next()
    34,364 (0.0%)      }
         .         
         .             /// Creates an iterator starting at the same point, but stepping by
         .             /// the given amount at each iteration.
         .             ///
         .             /// Note 1: The first element of the iterator will always be returned,
         .             /// regardless of the step given.
         .             ///
         .             /// Note 2: The time at which ignored elements are pulled is not fixed.
-- line 368 ----------------------------------------
-- line 1995 ----------------------------------------
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[must_use = "if you really need to exhaust the iterator, consider `.for_each(drop)` instead"]
         .             #[cfg_attr(not(test), rustc_diagnostic_item = "iterator_collect_fn")]
         .             #[rustc_do_not_const_check]
         .             fn collect<B: FromIterator<Self::Item>>(self) -> B
         .             where
         .                 Self: Sized,
         .             {
    66,772 (0.0%)          FromIterator::from_iter(self)
         .             }
         .         
         .             /// Fallibly transforms an iterator into a collection, short circuiting if
         .             /// a failure is encountered.
         .             ///
         .             /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible
         .             /// conversions during collection. Its main use case is simplifying conversions from
         .             /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]
-- line 2011 ----------------------------------------
-- line 2077 ----------------------------------------
         .             #[rustc_do_not_const_check]
         .             fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>
         .             where
         .                 Self: Sized,
         .                 <Self as Iterator>::Item: Try,
         .                 <<Self as Iterator>::Item as Try>::Residual: Residual<B>,
         .                 B: FromIterator<<Self::Item as Try>::Output>,
         .             {
       108 (0.0%)          try_process(ByRefSized(self), |i| i.collect())
         .             }
         .         
         .             /// Collects all the items from an iterator into a collection.
         .             ///
         .             /// This method consumes the iterator and adds all its items to the
         .             /// passed collection. The collection is then returned, so the call chain
         .             /// can be continued.
         .             ///
-- line 2093 ----------------------------------------
-- line 2190 ----------------------------------------
         .             {
         .                 #[inline]
         .                 fn extend<'a, T, B: Extend<T>>(
         .                     mut f: impl FnMut(&T) -> bool + 'a,
         .                     left: &'a mut B,
         .                     right: &'a mut B,
         .                 ) -> impl FnMut((), T) + 'a {
         .                     move |(), x| {
     6,092 (0.0%)                  if f(&x) {
     3,384 (0.0%)                      left.extend_one(x);
         .                         } else {
     1,890 (0.0%)                      right.extend_one(x);
         .                         }
         .                     }
         .                 }
         .         
         .                 let mut left: B = Default::default();
         .                 let mut right: B = Default::default();
         .         
       957 (0.0%)          self.fold((), extend(f, &mut left, &mut right));
         .         
     3,331 (0.0%)          (left, right)
         .             }
         .         
         .             /// Reorders the elements of this iterator *in-place* according to the given predicate,
         .             /// such that all those that return `true` precede all those that return `false`.
         .             /// Returns the number of `true` elements found.
         .             ///
         .             /// The relative order of partitioned items is not maintained.
         .             ///
-- line 2219 ----------------------------------------
-- line 2393 ----------------------------------------
         .             ///         ControlFlow::Break(prev)
         .             ///     }
         .             /// });
         .             /// assert_eq!(triangular, ControlFlow::Continue(435));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "iterator_try_fold", since = "1.27.0")]
         .             #[rustc_do_not_const_check]
     1,097 (0.0%)      fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
         .             where
         .                 Self: Sized,
         .                 F: FnMut(B, Self::Item) -> R,
         .                 R: Try<Output = B>,
         .             {
         .                 let mut accum = init;
 6,300,916 (0.1%)          while let Some(x) = self.next() {
14,987,920 (0.2%)              accum = f(accum, x)?;
         .                 }
         .                 try { accum }
       261 (0.0%)      }
         .         
         .             /// An iterator method that applies a fallible function to each item in the
         .             /// iterator, stopping at the first error and returning that error.
         .             ///
         .             /// This can also be thought of as the fallible form of [`for_each()`]
         .             /// or as the stateless version of [`try_fold()`].
         .             ///
         .             /// [`for_each()`]: Iterator::for_each
-- line 2420 ----------------------------------------
-- line 2460 ----------------------------------------
         .             fn try_for_each<F, R>(&mut self, f: F) -> R
         .             where
         .                 Self: Sized,
         .                 F: FnMut(Self::Item) -> R,
         .                 R: Try<Output = ()>,
         .             {
         .                 #[inline]
         .                 fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {
     2,785 (0.0%)              move |(), x| f(x)
         .                 }
         .         
         .                 self.try_fold((), call(f))
         .             }
         .         
         .             /// Folds every element into an accumulator by applying an operation,
         .             /// returning the final result.
         .             ///
-- line 2476 ----------------------------------------
-- line 2572 ----------------------------------------
         .             /// assert_eq!(result, result2);
         .             /// ```
         .             ///
         .             /// [`reduce()`]: Iterator::reduce
         .             #[doc(alias = "inject", alias = "foldl")]
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[rustc_do_not_const_check]
       624 (0.0%)      fn fold<B, F>(mut self, init: B, mut f: F) -> B
         .             where
         .                 Self: Sized,
         .                 F: FnMut(B, Self::Item) -> B,
         .             {
         .                 let mut accum = init;
   543,729 (0.0%)          while let Some(x) = self.next() {
       544 (0.0%)              accum = f(accum, x);
         .                 }
         .                 accum
   167,905 (0.0%)      }
         .         
         .             /// Reduces the elements to a single one, by repeatedly applying a reducing
         .             /// operation.
         .             ///
         .             /// If the iterator is empty, returns [`None`]; otherwise, returns the
         .             /// result of the reduction.
         .             ///
         .             /// The reducing function is a closure with two arguments: an 'accumulator', and an element.
-- line 2598 ----------------------------------------
-- line 2616 ----------------------------------------
         .             #[stable(feature = "iterator_fold_self", since = "1.51.0")]
         .             #[rustc_do_not_const_check]
         .             fn reduce<F>(mut self, f: F) -> Option<Self::Item>
         .             where
         .                 Self: Sized,
         .                 F: FnMut(Self::Item, Self::Item) -> Self::Item,
         .             {
         .                 let first = self.next()?;
        77 (0.0%)          Some(self.fold(first, f))
         .             }
         .         
         .             /// Reduces the elements to a single one by repeatedly applying a reducing operation. If the
         .             /// closure returns a failure, the failure is propagated back to the caller immediately.
         .             ///
         .             /// The return type of this method depends on the return type of the closure. If the closure
         .             /// returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,
         .             /// E>`. If the closure returns `Option<Self::Item>`, then this function will return
-- line 2632 ----------------------------------------
-- line 2806 ----------------------------------------
         .             {
         .                 #[inline]
         .                 fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {
         .                     move |(), x| {
         .                         if f(x) { ControlFlow::Break(()) } else { ControlFlow::Continue(()) }
         .                     }
         .                 }
         .         
     3,140 (0.0%)          self.try_fold((), check(f)) == ControlFlow::Break(())
         .             }
         .         
         .             /// Searches for an element of an iterator that satisfies a predicate.
         .             ///
         .             /// `find()` takes a closure that returns `true` or `false`. It applies
         .             /// this closure to each element of the iterator, and if any of them return
         .             /// `true`, then `find()` returns [`Some(element)`]. If they all return
         .             /// `false`, it returns [`None`].
-- line 2822 ----------------------------------------
-- line 2866 ----------------------------------------
         .             fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
         .             where
         .                 Self: Sized,
         .                 P: FnMut(&Self::Item) -> bool,
         .             {
         .                 #[inline]
         .                 fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {
         .                     move |(), x| {
 1,865,121 (0.0%)                  if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }
     9,994 (0.0%)              }
         .                 }
         .         
         .                 self.try_fold((), check(predicate)).break_value()
         .             }
         .         
         .             /// Applies function to the elements of iterator and returns
         .             /// the first non-none result.
         .             ///
-- line 2883 ----------------------------------------
-- line 2897 ----------------------------------------
         .             #[rustc_do_not_const_check]
         .             fn find_map<B, F>(&mut self, f: F) -> Option<B>
         .             where
         .                 Self: Sized,
         .                 F: FnMut(Self::Item) -> Option<B>,
         .             {
         .                 #[inline]
         .                 fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> ControlFlow<B> {
   485,899 (0.0%)              move |(), x| match f(x) {
   243,936 (0.0%)                  Some(x) => ControlFlow::Break(x),
         .                         None => ControlFlow::Continue(()),
         .                     }
         .                 }
         .         
         .                 self.try_fold((), check(f)).break_value()
         .             }
         .         
         .             /// Applies function to the elements of iterator and returns
-- line 2914 ----------------------------------------
-- line 3043 ----------------------------------------
         .             {
         .                 #[inline]
         .                 fn check<'a, T>(
         .                     mut predicate: impl FnMut(T) -> bool + 'a,
         .                     acc: &'a mut usize,
         .                 ) -> impl FnMut((), T) -> ControlFlow<usize, ()> + 'a {
         .                     #[rustc_inherit_overflow_checks]
         .                     move |_, x| {
       296 (0.0%)                  if predicate(x) {
         .                             ControlFlow::Break(*acc)
         .                         } else {
    12,699 (0.0%)                      *acc += 1;
         .                             ControlFlow::Continue(())
         .                         }
         .                     }
         .                 }
         .         
         .                 let mut acc = 0;
         .                 self.try_fold((), check(predicate, &mut acc)).break_value()
         .             }
-- line 3062 ----------------------------------------
-- line 3385 ----------------------------------------
         .             fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB)
         .             where
         .                 FromA: Default + Extend<A>,
         .                 FromB: Default + Extend<B>,
         .                 Self: Sized + Iterator<Item = (A, B)>,
         .             {
         .                 let mut unzipped: (FromA, FromB) = Default::default();
         .                 unzipped.extend(self);
    10,910 (0.0%)          unzipped
         .             }
         .         
         .             /// Creates an iterator which copies all of its elements.
         .             ///
         .             /// This is useful when you have an iterator over `&T`, but you need an
         .             /// iterator over `T`.
         .             ///
         .             /// # Examples
-- line 3401 ----------------------------------------
-- line 3812 ----------------------------------------
         .                 F: FnMut(Self::Item, I::Item) -> bool,
         .             {
         .                 #[inline]
         .                 fn compare<X, Y, F>(mut eq: F) -> impl FnMut(X, Y) -> ControlFlow<()>
         .                 where
         .                     F: FnMut(X, Y) -> bool,
         .                 {
         .                     move |x, y| {
        61 (0.0%)                  if eq(x, y) { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }
         .                     }
         .                 }
         .         
     2,088 (0.0%)          match iter_compare(self, other.into_iter(), compare(eq)) {
         .                     ControlFlow::Continue(ord) => ord == Ordering::Equal,
         .                     ControlFlow::Break(()) => false,
         .                 }
         .             }
         .         
         .             /// Determines if the elements of this [`Iterator`] are not equal to those of
         .             /// another.
         .             ///
-- line 3832 ----------------------------------------
-- line 4078 ----------------------------------------
         .             #[inline]
         .             fn compare<'a, B, X, T>(
         .                 b: &'a mut B,
         .                 mut f: impl FnMut(X, B::Item) -> ControlFlow<T> + 'a,
         .             ) -> impl FnMut(X) -> ControlFlow<ControlFlow<T, Ordering>> + 'a
         .             where
         .                 B: Iterator,
         .             {
       576 (0.0%)          move |x| match b.next() {
         .                     None => ControlFlow::Break(ControlFlow::Continue(Ordering::Greater)),
       284 (0.0%)              Some(y) => f(x, y).map_break(ControlFlow::Break),
         .                 }
         .             }
         .         
         .             match a.try_for_each(compare(&mut b, f)) {
        21 (0.0%)          ControlFlow::Continue(()) => ControlFlow::Continue(match b.next() {
         .                     None => Ordering::Equal,
         .                     Some(_) => Ordering::Less,
         .                 }),
         .                 ControlFlow::Break(x) => x,
         .             }
         .         }
         .         
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         impl<I: Iterator + ?Sized> Iterator for &mut I {
         .             type Item = I::Item;
         .             #[inline]
     3,718 (0.0%)      fn next(&mut self) -> Option<I::Item> {
   253,297 (0.0%)          (**self).next()
         .             }
         .             fn size_hint(&self) -> (usize, Option<usize>) {
        25 (0.0%)          (**self).size_hint()
         .             }
         .             fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
         .                 (**self).advance_by(n)
         .             }
         .             fn nth(&mut self, n: usize) -> Option<Self::Item> {
         .                 (**self).nth(n)
         .             }
         .             fn fold<B, F>(self, init: B, f: F) -> B
-- line 4117 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/mem/mod.rs
--------------------------------------------------------------------------------
Ir_______________ 

       343 (0.0%)  <unknown (line 0)>

-- line 336 ----------------------------------------
         .         /// [`size_of::<T>()`]: size_of
         .         #[inline]
         .         #[must_use]
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         #[rustc_const_unstable(feature = "const_size_of_val", issue = "46571")]
         .         #[cfg_attr(not(test), rustc_diagnostic_item = "mem_size_of_val")]
         .         pub const fn size_of_val<T: ?Sized>(val: &T) -> usize {
         .             // SAFETY: `val` is a reference, so it's a valid raw pointer
     7,488 (0.0%)      unsafe { intrinsics::size_of_val(val) }
         .         }
         .         
         .         /// Returns the size of the pointed-to value in bytes.
         .         ///
         .         /// This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no
         .         /// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],
         .         /// then `size_of_val_raw` can be used to get the dynamically-known size.
         .         ///
-- line 352 ----------------------------------------
-- line 386 ----------------------------------------
         .         /// assert_eq!(13, unsafe { mem::size_of_val_raw(y) });
         .         /// ```
         .         #[inline]
         .         #[must_use]
         .         #[unstable(feature = "layout_for_ptr", issue = "69835")]
         .         #[rustc_const_unstable(feature = "const_size_of_val_raw", issue = "46571")]
         .         pub const unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {
         .             // SAFETY: the caller must provide a valid raw pointer
   170,958 (0.0%)      unsafe { intrinsics::size_of_val(val) }
         .         }
         .         
         .         /// Returns the [ABI]-required minimum alignment of a type in bytes.
         .         ///
         .         /// Every reference to a value of the type `T` must be a multiple of this number.
         .         ///
         .         /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.
         .         ///
-- line 402 ----------------------------------------
-- line 723 ----------------------------------------
         .         /// ```
         .         #[inline]
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         #[rustc_const_unstable(feature = "const_swap", issue = "83163")]
         .         #[rustc_diagnostic_item = "mem_swap"]
         .         pub const fn swap<T>(x: &mut T, y: &mut T) {
         .             // SAFETY: `&mut` guarantees these are typed readable and writable
         .             // as well as non-overlapping.
     2,088 (0.0%)      unsafe { intrinsics::typed_swap(x, y) }
         .         }
         .         
         .         /// Replaces `dest` with the default value of `T`, returning the previous `dest` value.
         .         ///
         .         /// * If you want to replace the values of two variables, see [`swap`].
         .         /// * If you want to replace with a passed value instead of the default value, see [`replace`].
         .         ///
         .         /// # Examples
-- line 739 ----------------------------------------
-- line 930 ----------------------------------------
         .         ///
         .         /// println!("x: {}, y: {}", x, y.0); // still available
         .         /// ```
         .         ///
         .         /// [`RefCell`]: crate::cell::RefCell
         .         #[inline]
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         #[cfg_attr(not(test), rustc_diagnostic_item = "mem_drop")]
    27,046 (0.0%)  pub fn drop<T>(_x: T) {}
         .         
         .         /// Bitwise-copies a value.
         .         ///
         .         /// This function is not magic; it is literally defined as
         .         /// ```
         .         /// pub fn copy<T: Copy>(x: &T) -> T { *x }
         .         /// ```
         .         ///
-- line 946 ----------------------------------------
-- line 1155 ----------------------------------------
         .         /// // ⚠️ This is undefined behavior. Don't do this. ⚠️
         .         /// // assert_eq!(0, unsafe { std::mem::transmute::<_, u8>(std::mem::discriminant(&unit_like)) });
         .         /// ```
         .         #[stable(feature = "discriminant_value", since = "1.21.0")]
         .         #[rustc_const_stable(feature = "const_discriminant", since = "1.75.0")]
         .         #[cfg_attr(not(test), rustc_diagnostic_item = "mem_discriminant")]
         .         #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
         .         pub const fn discriminant<T>(v: &T) -> Discriminant<T> {
29,965,245 (0.4%)      Discriminant(intrinsics::discriminant_value(v))
         .         }
         .         
         .         /// Returns the number of variants in the enum type `T`.
         .         ///
         .         /// If `T` is not an enum, calling this function will not result in undefined behavior, but the
         .         /// return value is unspecified. Equally, if `T` is an enum with more variants than `usize::MAX`
         .         /// the return value is unspecified. Uninhabited variants will be counted.
         .         ///
-- line 1171 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/num/mod.rs
--------------------------------------------------------------------------------
Ir________________ 

  4,911,458 (0.1%)  <unknown (line 0)>

-- line 327 ----------------------------------------
          .                 be_bytes = "[0x12, 0x34]",
          .                 to_xe_bytes_doc = "",
          .                 from_xe_bytes_doc = "",
          .                 bound_condition = "",
          .             }
          .         }
          .         
          .         impl i32 {
    880,981 (0.0%)      int_impl! {
          .                 Self = i32,
          .                 ActualT = i32,
          .                 UnsignedT = u32,
          .                 BITS = 32,
          .                 BITS_MINUS_ONE = 31,
          .                 Min = -2147483648,
          .                 Max = 2147483647,
          .                 rot = 8,
-- line 343 ----------------------------------------
-- line 447 ----------------------------------------
          .                 to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),
          .                 from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),
          .                 bound_condition = " on 32-bit targets",
          .             }
          .         }
          .         
          .         #[cfg(target_pointer_width = "64")]
          .         impl isize {
  4,086,126 (0.1%)      int_impl! {
          .                 Self = isize,
          .                 ActualT = i64,
          .                 UnsignedT = usize,
          .                 BITS = 64,
          .                 BITS_MINUS_ONE = 63,
          .                 Min = -9223372036854775808,
          .                 Max = 9223372036854775807,
          .                 rot = 12,
-- line 463 ----------------------------------------
-- line 473 ----------------------------------------
          .                 bound_condition = " on 64-bit targets",
          .             }
          .         }
          .         
          .         /// If the 6th bit is set ascii is lower case.
          .         const ASCII_CASE_MASK: u8 = 0b0010_0000;
          .         
          .         impl u8 {
    218,602 (0.0%)      uint_impl! {
          .                 Self = u8,
          .                 ActualT = u8,
          .                 SignedT = i8,
          .                 NonZeroT = NonZero<u8>,
          .                 BITS = 8,
          .                 MAX = 255,
          .                 rot = 2,
          .                 rot_op = "0x82",
-- line 489 ----------------------------------------
-- line 511 ----------------------------------------
          .             /// assert!(ascii.is_ascii());
          .             /// assert!(!non_ascii.is_ascii());
          .             /// ```
          .             #[must_use]
          .             #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
          .             #[rustc_const_stable(feature = "const_u8_is_ascii", since = "1.43.0")]
          .             #[inline]
          .             pub const fn is_ascii(&self) -> bool {
     23,561 (0.0%)          *self <= 127
          .             }
          .         
          .             /// If the value of this byte is within the ASCII range, returns it as an
          .             /// [ASCII character](ascii::Char).  Otherwise, returns `None`.
          .             #[must_use]
          .             #[unstable(feature = "ascii_char", issue = "110998")]
          .             #[inline]
          .             pub const fn as_ascii(&self) -> Option<ascii::Char> {
-- line 527 ----------------------------------------
-- line 545 ----------------------------------------
          .             ///
          .             /// [`make_ascii_uppercase`]: Self::make_ascii_uppercase
          .             #[must_use = "to uppercase the value in-place, use `make_ascii_uppercase()`"]
          .             #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
          .             #[rustc_const_stable(feature = "const_ascii_methods_on_intrinsics", since = "1.52.0")]
          .             #[inline]
          .             pub const fn to_ascii_uppercase(&self) -> u8 {
          .                 // Toggle the 6th bit if this is a lowercase letter
      7,638 (0.0%)          *self ^ ((self.is_ascii_lowercase() as u8) * ASCII_CASE_MASK)
          .             }
          .         
          .             /// Makes a copy of the value in its ASCII lower case equivalent.
          .             ///
          .             /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',
          .             /// but non-ASCII letters are unchanged.
          .             ///
          .             /// To lowercase the value in-place, use [`make_ascii_lowercase`].
-- line 561 ----------------------------------------
-- line 570 ----------------------------------------
          .             ///
          .             /// [`make_ascii_lowercase`]: Self::make_ascii_lowercase
          .             #[must_use = "to lowercase the value in-place, use `make_ascii_lowercase()`"]
          .             #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
          .             #[rustc_const_stable(feature = "const_ascii_methods_on_intrinsics", since = "1.52.0")]
          .             #[inline]
          .             pub const fn to_ascii_lowercase(&self) -> u8 {
          .                 // Set the 6th bit if this is an uppercase letter
    320,592 (0.0%)          *self | (self.is_ascii_uppercase() as u8 * ASCII_CASE_MASK)
          .             }
          .         
          .             /// Assumes self is ascii
          .             #[inline]
          .             pub(crate) const fn ascii_change_case_unchecked(&self) -> u8 {
          .                 *self ^ ASCII_CASE_MASK
          .             }
          .         
-- line 586 ----------------------------------------
-- line 595 ----------------------------------------
          .             /// let uppercase_a = 65u8;
          .             ///
          .             /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));
          .             /// ```
          .             #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
          .             #[rustc_const_stable(feature = "const_ascii_methods_on_intrinsics", since = "1.52.0")]
          .             #[inline]
          .             pub const fn eq_ignore_ascii_case(&self, other: &u8) -> bool {
     25,820 (0.0%)          self.to_ascii_lowercase() == other.to_ascii_lowercase()
          .             }
          .         
          .             /// Converts this value to its ASCII upper case equivalent in-place.
          .             ///
          .             /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',
          .             /// but non-ASCII letters are unchanged.
          .             ///
          .             /// To return a new uppercased value without modifying the existing one, use
-- line 611 ----------------------------------------
-- line 645 ----------------------------------------
          .             ///
          .             /// assert_eq!(b'a', byte);
          .             /// ```
          .             ///
          .             /// [`to_ascii_lowercase`]: Self::to_ascii_lowercase
          .             #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
          .             #[inline]
          .             pub fn make_ascii_lowercase(&mut self) {
     33,092 (0.0%)          *self = self.to_ascii_lowercase();
          .             }
          .         
          .             /// Checks if the value is an ASCII alphabetic character:
          .             ///
          .             /// - U+0041 'A' ..= U+005A 'Z', or
          .             /// - U+0061 'a' ..= U+007A 'z'.
          .             ///
          .             /// # Examples
-- line 661 ----------------------------------------
-- line 715 ----------------------------------------
          .             /// assert!(!lf.is_ascii_uppercase());
          .             /// assert!(!esc.is_ascii_uppercase());
          .             /// ```
          .             #[must_use]
          .             #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
          .             #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
          .             #[inline]
          .             pub const fn is_ascii_uppercase(&self) -> bool {
  1,231,653 (0.0%)          matches!(*self, b'A'..=b'Z')
          .             }
          .         
          .             /// Checks if the value is an ASCII lowercase character:
          .             /// U+0061 'a' ..= U+007A 'z'.
          .             ///
          .             /// # Examples
          .             ///
          .             /// ```
-- line 731 ----------------------------------------
-- line 749 ----------------------------------------
          .             /// assert!(!lf.is_ascii_lowercase());
          .             /// assert!(!esc.is_ascii_lowercase());
          .             /// ```
          .             #[must_use]
          .             #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
          .             #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
          .             #[inline]
          .             pub const fn is_ascii_lowercase(&self) -> bool {
     38,190 (0.0%)          matches!(*self, b'a'..=b'z')
          .             }
          .         
          .             /// Checks if the value is an ASCII alphanumeric character:
          .             ///
          .             /// - U+0041 'A' ..= U+005A 'Z', or
          .             /// - U+0061 'a' ..= U+007A 'z', or
          .             /// - U+0030 '0' ..= U+0039 '9'.
          .             ///
-- line 765 ----------------------------------------
-- line 820 ----------------------------------------
          .             /// assert!(!lf.is_ascii_digit());
          .             /// assert!(!esc.is_ascii_digit());
          .             /// ```
          .             #[must_use]
          .             #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
          .             #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
          .             #[inline]
          .             pub const fn is_ascii_digit(&self) -> bool {
      2,012 (0.0%)          matches!(*self, b'0'..=b'9')
          .             }
          .         
          .             /// Checks if the value is an ASCII octal digit:
          .             /// U+0030 '0' ..= U+0037 '7'.
          .             ///
          .             /// # Examples
          .             ///
          .             /// ```
-- line 836 ----------------------------------------
-- line 1083 ----------------------------------------
          .             #[inline]
          .             pub fn escape_ascii(self) -> ascii::EscapeDefault {
          .                 ascii::escape_default(self)
          .             }
          .         
          .             #[inline]
          .             pub(crate) const fn is_utf8_char_boundary(self) -> bool {
          .                 // This is bit magic equivalent to: b < 128 || b >= 192
  1,023,714 (0.0%)          (self as i8) >= -0x40
          .             }
          .         }
          .         
          .         impl u16 {
  5,070,656 (0.1%)      uint_impl! {
          .                 Self = u16,
          .                 ActualT = u16,
          .                 SignedT = i16,
          .                 NonZeroT = NonZero<u16>,
          .                 BITS = 16,
          .                 MAX = 65535,
          .                 rot = 4,
          .                 rot_op = "0xa003",
-- line 1104 ----------------------------------------
-- line 1137 ----------------------------------------
          .             #[rustc_const_unstable(feature = "utf16_extra_const", issue = "94919")]
          .             #[inline]
          .             pub const fn is_utf16_surrogate(self) -> bool {
          .                 matches!(self, 0xD800..=0xDFFF)
          .             }
          .         }
          .         
          .         impl u32 {
  7,902,273 (0.1%)      uint_impl! {
          .                 Self = u32,
          .                 ActualT = u32,
          .                 SignedT = i32,
          .                 NonZeroT = NonZero<u32>,
          .                 BITS = 32,
          .                 MAX = 4294967295,
          .                 rot = 8,
          .                 rot_op = "0x10000b3",
-- line 1153 ----------------------------------------
-- line 1161 ----------------------------------------
          .                 from_xe_bytes_doc = "",
          .                 bound_condition = "",
          .             }
          .             widening_impl! { u32, u64, 32, unsigned }
          .             midpoint_impl! { u32, u64, unsigned }
          .         }
          .         
          .         impl u64 {
 36,788,568 (0.5%)      uint_impl! {
          .                 Self = u64,
          .                 ActualT = u64,
          .                 SignedT = i64,
          .                 NonZeroT = NonZero<u64>,
          .                 BITS = 64,
          .                 MAX = 18446744073709551615,
          .                 rot = 12,
          .                 rot_op = "0xaa00000000006e1",
-- line 1177 ----------------------------------------
-- line 1185 ----------------------------------------
          .                 from_xe_bytes_doc = "",
          .                 bound_condition = "",
          .             }
          .             widening_impl! { u64, u128, 64, unsigned }
          .             midpoint_impl! { u64, u128, unsigned }
          .         }
          .         
          .         impl u128 {
     10,304 (0.0%)      uint_impl! {
          .                 Self = u128,
          .                 ActualT = u128,
          .                 SignedT = i128,
          .                 NonZeroT = NonZero<u128>,
          .                 BITS = 128,
          .                 MAX = 340282366920938463463374607431768211455,
          .                 rot = 16,
          .                 rot_op = "0x13f40000000000000000000000004f76",
-- line 1201 ----------------------------------------
-- line 1261 ----------------------------------------
          .                 bound_condition = " on 32-bit targets",
          .             }
          .             widening_impl! { usize, u64, 32, unsigned }
          .             midpoint_impl! { usize, u64, unsigned }
          .         }
          .         
          .         #[cfg(target_pointer_width = "64")]
          .         impl usize {
102,156,086 (1.3%)      uint_impl! {
          .                 Self = usize,
          .                 ActualT = u64,
          .                 SignedT = isize,
          .                 NonZeroT = NonZero<usize>,
          .                 BITS = 64,
          .                 MAX = 18446744073709551615,
          .                 rot = 12,
          .                 rot_op = "0xaa00000000006e1",
-- line 1277 ----------------------------------------
-- line 1288 ----------------------------------------
          .             widening_impl! { usize, u128, 64, unsigned }
          .             midpoint_impl! { usize, u128, unsigned }
          .         }
          .         
          .         impl usize {
          .             /// Returns an `usize` where every byte is equal to `x`.
          .             #[inline]
          .             pub(crate) const fn repeat_u8(x: u8) -> usize {
  1,139,620 (0.0%)          usize::from_ne_bytes([x; mem::size_of::<usize>()])
          .             }
          .         
          .             /// Returns an `usize` where every byte pair is equal to `x`.
          .             #[inline]
          .             pub(crate) const fn repeat_u16(x: u16) -> usize {
          .                 let mut r = 0usize;
          .                 let mut i = 0;
          .                 while i < mem::size_of::<usize>() {
-- line 1304 ----------------------------------------
-- line 1374 ----------------------------------------
          .             Normal,
          .         }
          .         
          .         macro_rules! from_str_radix_int_impl {
          .             ($($t:ty)*) => {$(
          .                 #[stable(feature = "rust1", since = "1.0.0")]
          .                 impl FromStr for $t {
          .                     type Err = ParseIntError;
     94,580 (0.0%)              fn from_str(src: &str) -> Result<Self, ParseIntError> {
      4,882 (0.0%)                  <$t>::from_str_radix(src, 10)
     76,268 (0.0%)              }
          .                 }
          .             )*}
          .         }
          .         from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }
          .         
          .         /// Determines if a string of text of that length of that radix could be guaranteed to be
          .         /// stored in the given type T.
          .         /// Note that if the radix is known to the compiler, it is just the check of digits.len that
          .         /// is done at runtime.
          .         #[doc(hidden)]
          .         #[inline(always)]
          .         #[unstable(issue = "none", feature = "std_internals")]
          .         pub const fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits: &[u8]) -> bool {
     16,945 (0.0%)      radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize
          .         }
          .         
          .         #[track_caller]
          .         const fn from_str_radix_panic_ct(_radix: u32) -> ! {
          .             panic!("from_str_radix_int: must lie in the range `[2, 36]`");
          .         }
          .         
          .         #[track_caller]
-- line 1406 ----------------------------------------
-- line 1408 ----------------------------------------
          .             panic!("from_str_radix_int: must lie in the range `[2, 36]` - found {}", radix);
          .         }
          .         
          .         #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never))]
          .         #[cfg_attr(feature = "panic_immediate_abort", inline)]
          .         #[cold]
          .         #[track_caller]
          .         const fn from_str_radix_assert(radix: u32) {
     37,080 (0.0%)      if 2 > radix || radix > 36 {
          .                 // The only difference between these two functions is their panic message.
          .                 intrinsics::const_eval_select((radix,), from_str_radix_panic_ct, from_str_radix_panic_rt);
          .             }
     12,360 (0.0%)  }
          .         
          .         macro_rules! from_str_radix {
          .             ($($int_ty:ty)+) => {$(
          .                 impl $int_ty {
          .                     /// Converts a string slice in a given base to an integer.
          .                     ///
          .                     /// The string is expected to be an optional `+` sign
          .                     /// followed by digits.
-- line 1428 ----------------------------------------
-- line 1441 ----------------------------------------
          .                     ///
          .                     /// Basic usage:
          .                     ///
          .                     /// ```
          .                     #[doc = concat!("assert_eq!(", stringify!($int_ty), "::from_str_radix(\"A\", 16), Ok(10));")]
          .                     /// ```
          .                     #[stable(feature = "rust1", since = "1.0.0")]
          .                     #[rustc_const_unstable(feature = "const_int_from_str", issue = "59133")]
     35,232 (0.0%)              pub const fn from_str_radix(src: &str, radix: u32) -> Result<$int_ty, ParseIntError> {
          .                         use self::IntErrorKind::*;
          .                         use self::ParseIntError as PIE;
          .         
     37,097 (0.0%)                  from_str_radix_assert(radix);
          .         
     48,900 (0.0%)                  if src.is_empty() {
        336 (0.0%)                      return Err(PIE { kind: Empty });
          .                         }
          .         
          .                         #[allow(unused_comparisons)]
          .                         let is_signed_ty = 0 > <$int_ty>::MIN;
          .         
          .                         // all valid digits are ascii, so we will just iterate over the utf8 bytes
          .                         // and cast them to chars. .to_digit() will safely return None for anything
          .                         // other than a valid ascii digit for the given radix, including the first-byte
          .                         // of multi-byte sequences
          .                         let src = src.as_bytes();
          .         
     34,636 (0.0%)                  let (is_positive, mut digits) = match src {
          .                             [b'+' | b'-'] => {
          .                                 return Err(PIE { kind: InvalidDigit });
          .                             }
          .                             [b'+', rest @ ..] => (true, rest),
          .                             [b'-', rest @ ..] if is_signed_ty => (false, rest),
          .                             _ => (true, src),
          .                         };
          .         
-- line 1476 ----------------------------------------
-- line 1500 ----------------------------------------
          .                                         result = result * (radix as $int_ty);
          .                                         let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit);
          .                                         result = result $unchecked_additive_op (x as $int_ty);
          .                                         digits = rest;
          .                                     }
          .                                 }};
          .                             }
          .                             if is_positive {
     49,150 (0.0%)                          run_unchecked_loop!(+)
          .                             } else {
          .                                 run_unchecked_loop!(-)
          .                             };
          .                         } else {
          .                             macro_rules! run_checked_loop {
          .                                 ($checked_additive_op:ident, $overflow_err:ident) => {{
          .                                     while let [c, rest @ ..] = digits {
          .                                         // When `radix` is passed in as a literal, rather than doing a slow `imul`
-- line 1516 ----------------------------------------
-- line 1527 ----------------------------------------
          .                                         let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit) as $int_ty;
          .                                         result = unwrap_or_PIE!(mul, $overflow_err);
          .                                         result = unwrap_or_PIE!(<$int_ty>::$checked_additive_op(result, x), $overflow_err);
          .                                         digits = rest;
          .                                     }
          .                                 }};
          .                             }
          .                             if is_positive {
      1,216 (0.0%)                          run_checked_loop!(checked_add, PosOverflow)
          .                             } else {
          .                                 run_checked_loop!(checked_sub, NegOverflow)
          .                             };
          .                         }
      3,070 (0.0%)                  Ok(result)
     25,672 (0.0%)              }
          .                 }
          .             )+}
          .         }
          .         
          .         from_str_radix! { i8 u8 i16 u16 i32 u32 i64 u64 i128 u128 }
          .         
          .         // Re-use the relevant implementation of from_str_radix for isize and usize to avoid outputting two
          .         // identical functions.
-- line 1549 ----------------------------------------
-- line 1571 ----------------------------------------
          .                 ///
          .                 /// ```
          .                 #[doc = concat!("assert_eq!(", stringify!($size), "::from_str_radix(\"A\", 16), Ok(10));")]
          .                 /// ```
          .                 #[stable(feature = "rust1", since = "1.0.0")]
          .                 #[rustc_const_unstable(feature = "const_int_from_str", issue = "59133")]
          .                 pub const fn from_str_radix(src: &str, radix: u32) -> Result<$size, ParseIntError> {
          .                     match <$t>::from_str_radix(src, radix) {
      1,926 (0.0%)                  Ok(x) => Ok(x as $size),
     17,024 (0.0%)                  Err(e) => Err(e),
          .                     }
          .                 }
          .             })*}
          .         }
          .         
          .         #[cfg(target_pointer_width = "16")]
          .         from_str_radix_size_impl! { i16 isize, u16 usize }
          .         #[cfg(target_pointer_width = "32")]
-- line 1588 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/ptr/mod.rs
--------------------------------------------------------------------------------
Ir________________ 

  6,523,755 (0.1%)  <unknown (line 0)>

-- line 506 ----------------------------------------
          .         ///
          .         /// // Ensure that the last item was dropped.
          .         /// assert!(weak.upgrade().is_none());
          .         /// ```
          .         #[stable(feature = "drop_in_place", since = "1.8.0")]
          .         #[lang = "drop_in_place"]
          .         #[allow(unconditional_recursion)]
          .         #[rustc_diagnostic_item = "ptr_drop_in_place"]
170,177,843 (2.1%)  pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
          .             // Code here does not matter - this is replaced by the
          .             // real drop glue by the compiler.
          .         
          .             // SAFETY: see comment above
          .             unsafe { drop_in_place(to_drop) }
          .         }
          .         
          .         /// Creates a null raw pointer.
-- line 522 ----------------------------------------
-- line 934 ----------------------------------------
          .         /// ```
          .         #[inline]
          .         #[stable(feature = "rust1", since = "1.0.0")]
          .         #[rustc_const_unstable(feature = "const_swap", issue = "83163")]
          .         #[rustc_diagnostic_item = "ptr_swap"]
          .         pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {
          .             // Give ourselves some scratch space to work with.
          .             // We do not have to worry about drops: `MaybeUninit` does nothing when dropped.
      1,889 (0.0%)      let mut tmp = MaybeUninit::<T>::uninit();
          .         
          .             // Perform the swap
          .             // SAFETY: the caller must guarantee that `x` and `y` are
          .             // valid for writes and properly aligned. `tmp` cannot be
          .             // overlapping either `x` or `y` because `tmp` was just allocated
          .             // on the stack as a separate allocated object.
          .             unsafe {
          .                 copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);
-- line 950 ----------------------------------------
-- line 1289 ----------------------------------------
          .                 ub_checks::assert_unsafe_precondition!(
          .                     check_language_ub,
          .                     "ptr::read requires that the pointer argument is aligned and non-null",
          .                     (
          .                         addr: *const () = src as *const (),
          .                         align: usize = align_of::<T>(),
          .                     ) => ub_checks::is_aligned_and_not_null(addr, align)
          .                 );
 27,773,715 (0.3%)          crate::intrinsics::read_via_copy(src)
          .             }
          .         }
          .         
          .         /// Reads the value from `src` without moving it. This leaves the
          .         /// memory in `src` unchanged.
          .         ///
          .         /// Unlike [`read`], `read_unaligned` works with unaligned pointers.
          .         ///
-- line 1305 ----------------------------------------
-- line 1498 ----------------------------------------
          .                 ub_checks::assert_unsafe_precondition!(
          .                     check_language_ub,
          .                     "ptr::write requires that the pointer argument is aligned and non-null",
          .                     (
          .                         addr: *mut () = dst as *mut (),
          .                         align: usize = align_of::<T>(),
          .                     ) => ub_checks::is_aligned_and_not_null(addr, align)
          .                 );
118,970,451 (1.5%)          intrinsics::write_via_move(dst, src)
          .             }
          .         }
          .         
          .         /// Overwrites a memory location with the given value without reading or
          .         /// dropping the old value.
          .         ///
          .         /// Unlike [`write()`], the pointer may be unaligned.
          .         ///
-- line 1514 ----------------------------------------
-- line 1670 ----------------------------------------
          .                 ub_checks::assert_unsafe_precondition!(
          .                     check_language_ub,
          .                     "ptr::read_volatile requires that the pointer argument is aligned and non-null",
          .                     (
          .                         addr: *const () = src as *const (),
          .                         align: usize = align_of::<T>(),
          .                     ) => ub_checks::is_aligned_and_not_null(addr, align)
          .                 );
  7,821,114 (0.1%)          intrinsics::volatile_load(src)
          .             }
          .         }
          .         
          .         /// Performs a volatile write of a memory location with the given value without
          .         /// reading or dropping the old value.
          .         ///
          .         /// Volatile operations are intended to act on I/O memory, and are guaranteed
          .         /// to not be elided or reordered by the compiler across other volatile
-- line 1686 ----------------------------------------
-- line 1878 ----------------------------------------
          .                 // redistributes operations around the load-bearing, but pessimizing `and` instruction
          .                 // sufficiently for LLVM to be able to utilize the various optimizations it knows about.
          .                 //
          .                 // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated
          .                 // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`
          .                 // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`
          .                 // computation produces.
          .         
    471,470 (0.0%)          let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);
        109 (0.0%)          let byte_offset = wrapping_sub(aligned_address, addr);
          .                 // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>
          .                 // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced
          .                 // the value by more than `a-1`, so even though the intermediate values might have
          .                 // wrapped, the byte_offset is always in `[0, a)`.
          .                 unsafe { assume(byte_offset < a) };
          .         
          .                 // SAFETY: `stride == 0` case has been handled by the special case above.
          .                 let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };
-- line 1895 ----------------------------------------
-- line 2006 ----------------------------------------
          .         /// assert!(!std::ptr::eq(&a[0..2], &a[1..3]));
          .         /// ```
          .         #[stable(feature = "ptr_eq", since = "1.17.0")]
          .         #[inline(always)]
          .         #[must_use = "pointer comparison produces a value"]
          .         #[rustc_diagnostic_item = "ptr_eq"]
          .         #[allow(ambiguous_wide_pointer_comparisons)] // it's actually clear here
          .         pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {
  8,581,911 (0.1%)      a == b
          .         }
          .         
          .         /// Compares the *addresses* of the two pointers for equality,
          .         /// ignoring any metadata in fat pointers.
          .         ///
          .         /// If the arguments are thin pointers of the same type,
          .         /// then this is the same as [`eq`].
          .         ///
-- line 2022 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/result.rs
--------------------------------------------------------------------------------
Ir_______________ 

 9,594,073 (0.1%)  <unknown (line 0)>

-- line 490 ----------------------------------------
         .         
         .         use crate::iter::{self, FusedIterator, TrustedLen};
         .         use crate::ops::{self, ControlFlow, Deref, DerefMut};
         .         use crate::{convert, fmt, hint};
         .         
         .         /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).
         .         ///
         .         /// See the [module documentation](self) for details.
       343 (0.0%)  #[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]
         .         #[must_use = "this `Result` may be an `Err` variant, which should be handled"]
         .         #[rustc_diagnostic_item = "Result"]
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         pub enum Result<T, E> {
         .             /// Contains the success value
         .             #[lang = "Ok"]
         .             #[stable(feature = "rust1", since = "1.0.0")]
        42 (0.0%)      Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
         .         
         .             /// Contains the error value
         .             #[lang = "Err"]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             Err(#[stable(feature = "rust1", since = "1.0.0")] E),
         .         }
         .         
         .         /////////////////////////////////////////////////////////////////////////////
-- line 514 ----------------------------------------
-- line 531 ----------------------------------------
         .             /// let x: Result<i32, &str> = Err("Some error message");
         .             /// assert_eq!(x.is_ok(), false);
         .             /// ```
         .             #[must_use = "if you intended to assert that this is ok, consider `.unwrap()` instead"]
         .             #[rustc_const_stable(feature = "const_result_basics", since = "1.48.0")]
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub const fn is_ok(&self) -> bool {
    73,233 (0.0%)          matches!(*self, Ok(_))
         .             }
         .         
         .             /// Returns `true` if the result is [`Ok`] and the value inside of it matches a predicate.
         .             ///
         .             /// # Examples
         .             ///
         .             /// ```
         .             /// let x: Result<u32, &str> = Ok(2);
-- line 547 ----------------------------------------
-- line 552 ----------------------------------------
         .             ///
         .             /// let x: Result<u32, &str> = Err("hey");
         .             /// assert_eq!(x.is_ok_and(|x| x > 1), false);
         .             /// ```
         .             #[must_use]
         .             #[inline]
         .             #[stable(feature = "is_some_and", since = "1.70.0")]
         .             pub fn is_ok_and(self, f: impl FnOnce(T) -> bool) -> bool {
     3,715 (0.0%)          match self {
         .                     Err(_) => false,
     6,372 (0.0%)              Ok(x) => f(x),
         .                 }
         .             }
         .         
         .             /// Returns `true` if the result is [`Err`].
         .             ///
         .             /// # Examples
         .             ///
         .             /// ```
-- line 570 ----------------------------------------
-- line 624 ----------------------------------------
         .             /// assert_eq!(x.ok(), Some(2));
         .             ///
         .             /// let x: Result<u32, &str> = Err("Nothing here");
         .             /// assert_eq!(x.ok(), None);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn ok(self) -> Option<T> {
    64,764 (0.0%)          match self {
    17,778 (0.0%)              Ok(x) => Some(x),
         .                     Err(_) => None,
         .                 }
       323 (0.0%)      }
         .         
         .             /// Converts from `Result<T, E>` to [`Option<E>`].
         .             ///
         .             /// Converts `self` into an [`Option<E>`], consuming `self`,
         .             /// and discarding the success value, if any.
         .             ///
         .             /// # Examples
         .             ///
-- line 644 ----------------------------------------
-- line 647 ----------------------------------------
         .             /// assert_eq!(x.err(), None);
         .             ///
         .             /// let x: Result<u32, &str> = Err("Nothing here");
         .             /// assert_eq!(x.err(), Some("Nothing here"));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn err(self) -> Option<E> {
     8,328 (0.0%)          match self {
         .                     Ok(_) => None,
         .                     Err(x) => Some(x),
         .                 }
         .             }
         .         
         .             /////////////////////////////////////////////////////////////////////////
         .             // Adapter for working with references
         .             /////////////////////////////////////////////////////////////////////////
-- line 663 ----------------------------------------
-- line 675 ----------------------------------------
         .             ///
         .             /// let x: Result<u32, &str> = Err("Error");
         .             /// assert_eq!(x.as_ref(), Err(&"Error"));
         .             /// ```
         .             #[inline]
         .             #[rustc_const_stable(feature = "const_result_basics", since = "1.48.0")]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub const fn as_ref(&self) -> Result<&T, &E> {
    15,436 (0.0%)          match *self {
         .                     Ok(ref x) => Ok(x),
         .                     Err(ref x) => Err(x),
         .                 }
         .             }
         .         
         .             /// Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.
         .             ///
         .             /// # Examples
-- line 691 ----------------------------------------
-- line 705 ----------------------------------------
         .             /// let mut x: Result<i32, i32> = Err(13);
         .             /// mutate(&mut x);
         .             /// assert_eq!(x.unwrap_err(), 0);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[rustc_const_unstable(feature = "const_result", issue = "82814")]
         .             pub const fn as_mut(&mut self) -> Result<&mut T, &mut E> {
         6 (0.0%)          match *self {
         .                     Ok(ref mut x) => Ok(x),
         .                     Err(ref mut x) => Err(x),
         .                 }
         .             }
         .         
         .             /////////////////////////////////////////////////////////////////////////
         .             // Transforming contained values
         .             /////////////////////////////////////////////////////////////////////////
-- line 721 ----------------------------------------
-- line 737 ----------------------------------------
         .             ///         Ok(n) => println!("{n}"),
         .             ///         Err(..) => {}
         .             ///     }
         .             /// }
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U, E> {
 1,058,927 (0.0%)          match self {
   775,633 (0.0%)              Ok(t) => Ok(op(t)),
 1,834,114 (0.0%)              Err(e) => Err(e),
         .                 }
         .             }
         .         
         .             /// Returns the provided default (if [`Err`]), or
         .             /// applies a function to the contained value (if [`Ok`]).
         .             ///
         .             /// Arguments passed to `map_or` are eagerly evaluated; if you are passing
         .             /// the result of a function call, it is recommended to use [`map_or_else`],
-- line 755 ----------------------------------------
-- line 765 ----------------------------------------
         .             ///
         .             /// let x: Result<&str, _> = Err("bar");
         .             /// assert_eq!(x.map_or(42, |v| v.len()), 42);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "result_map_or", since = "1.41.0")]
         .             #[must_use = "if you don't need the returned value, use `if let` instead"]
         .             pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {
     1,512 (0.0%)          match self {
       435 (0.0%)              Ok(t) => f(t),
         .                     Err(_) => default,
         .                 }
         .             }
         .         
         .             /// Maps a `Result<T, E>` to `U` by applying fallback function `default` to
         .             /// a contained [`Err`] value, or function `f` to a contained [`Ok`] value.
         .             ///
         .             /// This function can be used to unpack a successful result
-- line 782 ----------------------------------------
-- line 819 ----------------------------------------
         .             /// assert_eq!(x.map_err(stringify), Ok(2));
         .             ///
         .             /// let x: Result<u32, u32> = Err(13);
         .             /// assert_eq!(x.map_err(stringify), Err("error code: 13".to_string()));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T, F> {
 6,238,054 (0.1%)          match self {
 6,125,569 (0.1%)              Ok(t) => Ok(t),
    17,356 (0.0%)              Err(e) => Err(op(e)),
         .                 }
        60 (0.0%)      }
         .         
         .             /// Calls a function with a reference to the contained value if [`Ok`].
         .             ///
         .             /// Returns the original result.
         .             ///
         .             /// # Examples
         .             ///
         .             /// ```
-- line 839 ----------------------------------------
-- line 841 ----------------------------------------
         .             ///     .parse::<u8>()
         .             ///     .inspect(|x| println!("original: {x}"))
         .             ///     .map(|x| x.pow(3))
         .             ///     .expect("failed to parse number");
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "result_option_inspect", since = "1.76.0")]
         .             pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {
     1,478 (0.0%)          if let Ok(ref t) = self {
         .                     f(t);
         .                 }
         .         
     4,434 (0.0%)          self
         .             }
         .         
         .             /// Calls a function with a reference to the contained value if [`Err`].
         .             ///
         .             /// Returns the original result.
         .             ///
         .             /// # Examples
         .             ///
-- line 861 ----------------------------------------
-- line 1020 ----------------------------------------
         .             ///
         .             /// For more detail on expect message styles and the reasoning behind our recommendation please
         .             /// refer to the section on ["Common Message
         .             /// Styles"](../../std/error/index.html#common-message-styles) in the
         .             /// [`std::error`](../../std/error/index.html) module docs.
         .             #[inline]
         .             #[track_caller]
         .             #[stable(feature = "result_expect", since = "1.4.0")]
         4 (0.0%)      pub fn expect(self, msg: &str) -> T
         .             where
         .                 E: fmt::Debug,
         .             {
   300,331 (0.0%)          match self {
    28,847 (0.0%)              Ok(t) => t,
         .                     Err(e) => unwrap_failed(msg, &e),
         .                 }
         4 (0.0%)      }
         .         
         .             /// Returns the contained [`Ok`] value, consuming the `self` value.
         .             ///
         .             /// Because this function may panic, its use is generally discouraged.
         .             /// Instead, prefer to use pattern matching and handle the [`Err`]
         .             /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or
         .             /// [`unwrap_or_default`].
         .             ///
-- line 1044 ----------------------------------------
-- line 1067 ----------------------------------------
         .             /// ```
         .             #[inline(always)]
         .             #[track_caller]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn unwrap(self) -> T
         .             where
         .                 E: fmt::Debug,
         .             {
   740,238 (0.0%)          match self {
     6,420 (0.0%)              Ok(t) => t,
         .                     Err(e) => unwrap_failed("called `Result::unwrap()` on an `Err` value", &e),
         .                 }
         .             }
         .         
         .             /// Returns the contained [`Ok`] value or a default
         .             ///
         .             /// Consumes the `self` argument then, if [`Ok`], returns the contained
         .             /// value, otherwise if [`Err`], returns the default value for that
-- line 1084 ----------------------------------------
-- line 1104 ----------------------------------------
         .             /// [`parse`]: str::parse
         .             /// [`FromStr`]: crate::str::FromStr
         .             #[inline]
         .             #[stable(feature = "result_unwrap_or_default", since = "1.16.0")]
         .             pub fn unwrap_or_default(self) -> T
         .             where
         .                 T: Default,
         .             {
       114 (0.0%)          match self {
        68 (0.0%)              Ok(x) => x,
         .                     Err(_) => Default::default(),
         .                 }
         .             }
         .         
         .             /// Returns the contained [`Err`] value, consuming the `self` value.
         .             ///
         .             /// # Panics
         .             ///
-- line 1121 ----------------------------------------
-- line 1162 ----------------------------------------
         .             /// ```
         .             #[inline]
         .             #[track_caller]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn unwrap_err(self) -> E
         .             where
         .                 T: fmt::Debug,
         .             {
   129,650 (0.0%)          match self {
         .                     Ok(t) => unwrap_failed("called `Result::unwrap_err()` on an `Ok` value", &t),
         .                     Err(e) => e,
         .                 }
         .             }
         .         
         .             /// Returns the contained [`Ok`] value, but never panics.
         .             ///
         .             /// Unlike [`unwrap`], this method is known to never panic on the
-- line 1178 ----------------------------------------
-- line 1272 ----------------------------------------
         .             ///
         .             /// let x: Result<u32, &str> = Ok(2);
         .             /// let y: Result<&str, &str> = Ok("different result type");
         .             /// assert_eq!(x.and(y), Ok("different result type"));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {
     2,441 (0.0%)          match self {
         .                     Ok(_) => res,
         .                     Err(e) => Err(e),
         .                 }
         .             }
         .         
         .             /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.
         .             ///
         .             ///
-- line 1288 ----------------------------------------
-- line 1312 ----------------------------------------
         .             /// let should_fail = Path::new("/bad/path").metadata().and_then(|md| md.modified());
         .             /// assert!(should_fail.is_err());
         .             /// assert_eq!(should_fail.unwrap_err().kind(), ErrorKind::NotFound);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             #[rustc_confusables("flat_map", "flatmap")]
         .             pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {
     8,904 (0.0%)          match self {
     3,768 (0.0%)              Ok(t) => op(t),
         4 (0.0%)              Err(e) => Err(e),
         .                 }
         .             }
         .         
         .             /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.
         .             ///
         .             /// Arguments passed to `or` are eagerly evaluated; if you are passing the
         .             /// result of a function call, it is recommended to use [`or_else`], which is
         .             /// lazily evaluated.
-- line 1330 ----------------------------------------
-- line 1373 ----------------------------------------
         .             /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));
         .             /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));
         .             /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));
         .             /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {
    10,015 (0.0%)          match self {
     4,691 (0.0%)              Ok(t) => Ok(t),
         .                     Err(e) => op(e),
         .                 }
         .             }
         .         
         .             /// Returns the contained [`Ok`] value or a provided default.
         .             ///
         .             /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
         .             /// the result of a function call, it is recommended to use [`unwrap_or_else`],
-- line 1390 ----------------------------------------
-- line 1400 ----------------------------------------
         .             /// assert_eq!(x.unwrap_or(default), 9);
         .             ///
         .             /// let x: Result<u32, &str> = Err("error");
         .             /// assert_eq!(x.unwrap_or(default), default);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn unwrap_or(self, default: T) -> T {
     9,369 (0.0%)          match self {
       146 (0.0%)              Ok(t) => t,
         .                     Err(_) => default,
         .                 }
        22 (0.0%)      }
         .         
         .             /// Returns the contained [`Ok`] value or computes it from a closure.
         .             ///
         .             ///
         .             /// # Examples
         .             ///
         .             /// ```
         .             /// fn count(x: &str) -> usize { x.len() }
-- line 1420 ----------------------------------------
-- line 1421 ----------------------------------------
         .             ///
         .             /// assert_eq!(Ok(2).unwrap_or_else(count), 2);
         .             /// assert_eq!(Err("foo").unwrap_or_else(count), 3);
         .             /// ```
         .             #[inline]
         .             #[track_caller]
         .             #[stable(feature = "rust1", since = "1.0.0")]
         .             pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {
    39,054 (0.0%)          match self {
    13,310 (0.0%)              Ok(t) => t,
         .                     Err(e) => op(e),
         .                 }
         .             }
         .         
         .             /// Returns the contained [`Ok`] value, consuming the `self` value,
         .             /// without checking that the value is not an [`Err`].
         .             ///
         .             /// # Safety
-- line 1438 ----------------------------------------
-- line 1511 ----------------------------------------
         .             /// assert_eq!(copied, Ok(12));
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "result_copied", since = "1.59.0")]
         .             pub fn copied(self) -> Result<T, E>
         .             where
         .                 T: Copy,
         .             {
   610,147 (0.0%)          self.map(|&t| t)
         .             }
         .         
         .             /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the
         .             /// `Ok` part.
         .             ///
         .             /// # Examples
         .             ///
         .             /// ```
-- line 1527 ----------------------------------------
-- line 1600 ----------------------------------------
         .             /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));
         .             /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));
         .             /// assert_eq!(x.transpose(), y);
         .             /// ```
         .             #[inline]
         .             #[stable(feature = "transpose_result", since = "1.33.0")]
         .             #[rustc_const_unstable(feature = "const_result", issue = "82814")]
         .             pub const fn transpose(self) -> Option<Result<T, E>> {
        10 (0.0%)          match self {
        10 (0.0%)              Ok(Some(x)) => Some(Ok(x)),
         .                     Ok(None) => None,
         .                     Err(e) => Some(Err(e)),
         .                 }
         .             }
         .         }
         .         
         .         impl<T, E> Result<Result<T, E>, E> {
         .             /// Converts from `Result<Result<T, E>, E>` to `Result<T, E>`
-- line 1617 ----------------------------------------
-- line 1672 ----------------------------------------
         .         
         .         #[stable(feature = "rust1", since = "1.0.0")]
         .         impl<T, E> Clone for Result<T, E>
         .         where
         .             T: Clone,
         .             E: Clone,
         .         {
         .             #[inline]
 1,063,872 (0.0%)      fn clone(&self) -> Self {
   878,482 (0.0%)          match self {
   819,180 (0.0%)              Ok(x) => Ok(x.clone()),
    80,856 (0.0%)              Err(x) => Err(x.clone()),
         .                 }
 1,063,872 (0.0%)      }
         .         
         .             #[inline]
         .             fn clone_from(&mut self, source: &Self) {
         .                 match (self, source) {
         .                     (Ok(to), Ok(from)) => to.clone_from(from),
         .                     (Err(to), Err(from)) => to.clone_from(from),
         .                     (to, from) => *to = from.clone(),
         .                 }
-- line 1693 ----------------------------------------
-- line 1938 ----------------------------------------
         .         
         .         #[unstable(feature = "try_trait_v2", issue = "84277")]
         .         impl<T, E> ops::Try for Result<T, E> {
         .             type Output = T;
         .             type Residual = Result<convert::Infallible, E>;
         .         
         .             #[inline]
         .             fn from_output(output: Self::Output) -> Self {
    20,170 (0.0%)          Ok(output)
         .             }
         .         
         .             #[inline]
         .             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
15,997,607 (0.2%)          match self {
 9,467,222 (0.1%)              Ok(v) => ControlFlow::Continue(v),
 4,826,868 (0.1%)              Err(e) => ControlFlow::Break(Err(e)),
         .                 }
         .             }
         .         }
         .         
         .         #[unstable(feature = "try_trait_v2", issue = "84277")]
         .         impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
         .             #[inline]
         .             #[track_caller]
         .             fn from_residual(residual: Result<convert::Infallible, E>) -> Self {
         .                 match residual {
 4,516,646 (0.1%)              Err(e) => Err(From::from(e)),
         .                 }
         .             }
         .         }
         .         
         .         #[unstable(feature = "try_trait_v2_yeet", issue = "96374")]
         .         impl<T, E, F: From<E>> ops::FromResidual<ops::Yeet<E>> for Result<T, F> {
         .             #[inline]
         .             fn from_residual(ops::Yeet(e): ops::Yeet<E>) -> Self {
-- line 1972 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/slice/cmp.rs
--------------------------------------------------------------------------------
Ir______________ 

2,970,873 (0.0%)  <unknown (line 0)>

-- line 8 ----------------------------------------
        .         use super::memchr;
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
        .         impl<T, U> PartialEq<[U]> for [T]
        .         where
        .             T: PartialEq<U>,
        .         {
        .             fn eq(&self, other: &[U]) -> bool {
   31,998 (0.0%)          SlicePartialEq::equal(self, other)
        .             }
        .         
        .             fn ne(&self, other: &[U]) -> bool {
        .                 SlicePartialEq::not_equal(self, other)
        .             }
        .         }
        .         
        .         #[stable(feature = "rust1", since = "1.0.0")]
-- line 24 ----------------------------------------
-- line 41 ----------------------------------------
        .         }
        .         
        .         #[doc(hidden)]
        .         // intermediate trait for specialization of slice's PartialEq
        .         trait SlicePartialEq<B> {
        .             fn equal(&self, other: &[B]) -> bool;
        .         
        .             fn not_equal(&self, other: &[B]) -> bool {
    1,514 (0.0%)          !self.equal(other)
        .             }
        .         }
        .         
        .         // Generic slice equality
        .         impl<A, B> SlicePartialEq<B> for [A]
        .         where
        .             A: PartialEq<B>,
        .         {
        .             default fn equal(&self, other: &[B]) -> bool {
3,003,409 (0.0%)          if self.len() != other.len() {
        .                     return false;
        .                 }
        .         
        .                 // Implemented as explicit indexing rather
        .                 // than zipped iterators for performance reasons.
        .                 // See PR https://github.com/rust-lang/rust/pull/116846
        .                 for idx in 0..self.len() {
        .                     // bound checks are optimized away
4,693,467 (0.1%)              if self[idx] != other[idx] {
        .                         return false;
        .                     }
        .                 }
        .         
        .                 true
   12,131 (0.0%)      }
        .         }
        .         
        .         // When each element can be compared byte-wise, we can compare all the bytes
        .         // from the whole size in one call to the intrinsics.
        .         impl<A, B> SlicePartialEq<B> for [A]
        .         where
        .             A: BytewiseEq<B>,
        .         {
        .             fn equal(&self, other: &[B]) -> bool {
1,898,365 (0.0%)          if self.len() != other.len() {
        .                     return false;
        .                 }
        .         
        .                 // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.
        .                 // The two slices have been checked to have the same size above.
        .                 unsafe {
        .                     let size = mem::size_of_val(self);
4,283,598 (0.1%)              compare_bytes(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0
        .                 }
        3 (0.0%)      }
        .         }
        .         
        .         #[doc(hidden)]
        .         // intermediate trait for specialization of slice's PartialOrd
        .         trait SlicePartialOrd: Sized {
        .             fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;
        .         }
        .         
-- line 102 ----------------------------------------
-- line 187 ----------------------------------------
        .         // `compare_bytes` compares a sequence of unsigned bytes lexicographically.
        .         // this matches the order we want for [u8], but no others (not even [i8]).
        .         impl SliceOrd for u8 {
        .             #[inline]
        .             fn compare(left: &[Self], right: &[Self]) -> Ordering {
        .                 // Since the length of a slice is always less than or equal to isize::MAX, this never underflows.
        .                 let diff = left.len() as isize - right.len() as isize;
        .                 // This comparison gets optimized away (on x86_64 and ARM) because the subtraction updates flags.
  215,425 (0.0%)          let len = if left.len() < right.len() { left.len() } else { right.len() };
        .                 // SAFETY: `left` and `right` are references and are thus guaranteed to be valid.
        .                 // We use the minimum of both lengths which guarantees that both regions are
        .                 // valid for reads in that interval.
  128,308 (0.0%)          let mut order = unsafe { compare_bytes(left.as_ptr(), right.as_ptr(), len) as isize };
  103,386 (0.0%)          if order == 0 {
        .                     order = diff;
        .                 }
        .                 order.cmp(&0)
        .             }
        .         }
        .         
        .         pub(super) trait SliceContains: Sized {
        .             fn slice_contains(&self, x: &[Self]) -> bool;
        .         }
        .         
        .         impl<T> SliceContains for T
        .         where
        .             T: PartialEq,
        .         {
        .             default fn slice_contains(&self, x: &[Self]) -> bool {
  714,114 (0.0%)          x.iter().any(|y| *y == *self)
        .             }
        .         }
        .         
        .         impl SliceContains for u8 {
        .             #[inline]
        .             fn slice_contains(&self, x: &[Self]) -> bool {
        .                 memchr::memchr(*self, x).is_some()
        .             }
-- line 224 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/core/src/slice/memchr.rs
--------------------------------------------------------------------------------
Ir______________ 

2,104,500 (0.0%)  <unknown (line 0)>

-- line 12 ----------------------------------------
        .         /// From *Matters Computational*, J. Arndt:
        .         ///
        .         /// "The idea is to subtract one from each of the bytes and then look for
        .         /// bytes where the borrow propagated all the way to the most significant
        .         /// bit."
        .         #[inline]
        .         #[rustc_const_stable(feature = "const_memchr", since = "1.65.0")]
        .         const fn contains_zero_byte(x: usize) -> bool {
3,604,128 (0.0%)      x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0
        .         }
        .         
        .         /// Returns the first index matching the byte `x` in `text`.
        .         #[inline]
        .         #[must_use]
        .         #[rustc_const_stable(feature = "const_memchr", since = "1.65.0")]
        .         pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {
        .             // Fast path for small slices.
  724,224 (0.0%)      if text.len() < 2 * USIZE_BYTES {
        .                 return memchr_naive(x, text);
        .             }
        .         
  749,464 (0.0%)      memchr_aligned(x, text)
        .         }
        .         
        .         #[inline]
        .         #[rustc_const_stable(feature = "const_memchr", since = "1.65.0")]
        .         const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {
        .             let mut i = 0;
        .         
        .             // FIXME(const-hack): Replace with `text.iter().pos(|c| *c == x)`.
5,473,550 (0.1%)      while i < text.len() {
4,684,357 (0.1%)          if text[i] == x {
        .                     return Some(i);
        .                 }
        .         
2,270,688 (0.0%)          i += 1;
        .             }
        .         
        .             None
        .         }
        .         
        .         #[rustc_allow_const_fn_unstable(const_cmp)]
        .         #[rustc_allow_const_fn_unstable(const_slice_index)]
        .         #[rustc_allow_const_fn_unstable(const_align_offset)]
        .         #[rustc_const_stable(feature = "const_memchr", since = "1.65.0")]
  928,608 (0.0%)  const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {
        .             // Scan for a single byte value by reading two `usize` words at a time.
        .             //
        .             // Split `text` in three parts
        .             // - unaligned initial part, before the first word aligned address in text
        .             // - body, scan by 2 words at a time
        .             // - the last remaining part, < 2 word size
        .         
        .             // search up to an aligned boundary
        .             let len = text.len();
        .             let ptr = text.as_ptr();
        .             let mut offset = ptr.align_offset(USIZE_BYTES);
        .         
  466,620 (0.0%)      if offset > 0 {
        .                 // FIXME(const-hack, fee1-dead): replace with min
   54,890 (0.0%)          offset = if offset < len { offset } else { len };
        .                 // FIXME(const-hack, fee1-dead): replace with range slicing
        .                 // SAFETY: offset is within bounds
        .                 let slice = unsafe { super::from_raw_parts(text.as_ptr(), offset) };
        .                 if let Some(index) = memchr_naive(x, slice) {
        .                     return Some(index);
        .                 }
        .             }
        .         
        .             // search the body of the text
        .             let repeated_x = usize::repeat_u8(x);
1,495,326 (0.0%)      while offset <= len - 2 * USIZE_BYTES {
        .                 // SAFETY: the while's predicate guarantees a distance of at least 2 * usize_bytes
        .                 // between the offset and the end of the slice.
        .                 unsafe {
    4,243 (0.0%)              let u = *(ptr.add(offset) as *const usize);
        .                     let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);
        .         
        .                     // break if there is a matching byte
  719,864 (0.0%)              let zu = contains_zero_byte(u ^ repeated_x);
  719,864 (0.0%)              let zv = contains_zero_byte(v ^ repeated_x);
2,180,807 (0.0%)              if zu || zv {
        .                         break;
        .                     }
        .                 }
  724,107 (0.0%)          offset += USIZE_BYTES * 2;
        .             }
        .         
        .             // Find the byte after the point the body loop stopped.
        .             // FIXME(const-hack): Use `?` instead.
        .             // FIXME(const-hack, fee1-dead): use range slicing
        .             // SAFETY: offset is within bounds
        .             let slice = unsafe { super::from_raw_parts(text.as_ptr().add(offset), text.len() - offset) };
  228,115 (0.0%)      if let Some(i) = memchr_naive(x, slice) { Some(offset + i) } else { None }
1,160,760 (0.0%)  }
        .         
        .         /// Returns the last index matching the byte `x` in `text`.
        .         #[must_use]
      654 (0.0%)  pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {
        .             // Scan for a single byte value by reading two `usize` words at a time.
        .             //
        .             // Split `text` in three parts:
        .             // - unaligned tail, after the last word aligned address in text,
        .             // - body, scanned by 2 words at a time,
        .             // - the first remaining bytes, < 2 word size.
        .             let len = text.len();
        .             let ptr = text.as_ptr();
-- line 118 ----------------------------------------
-- line 119 ----------------------------------------
        .             type Chunk = usize;
        .         
        .             let (min_aligned_offset, max_aligned_offset) = {
        .                 // We call this just to obtain the length of the prefix and suffix.
        .                 // In the middle we always process two chunks at once.
        .                 // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences
        .                 // which are handled by `align_to`.
        .                 let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };
      218 (0.0%)          (prefix.len(), len - suffix.len())
        .             };
        .         
        .             let mut offset = max_aligned_offset;
    1,504 (0.0%)      if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {
        .                 return Some(offset + index);
        .             }
        .         
        .             // Search the body of the text, make sure we don't cross min_aligned_offset.
        .             // offset is always aligned, so just testing `>` is sufficient and avoids possible
        .             // overflow.
        .             let repeated_x = usize::repeat_u8(x);
        .             let chunk_bytes = mem::size_of::<Chunk>();
        .         
      436 (0.0%)      while offset > min_aligned_offset {
        .                 // SAFETY: offset starts at len - suffix.len(), as long as it is greater than
        .                 // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.
        .                 unsafe {
      226 (0.0%)              let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);
        .                     let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);
        .         
        .                     // Break if there is a matching byte.
      113 (0.0%)              let zu = contains_zero_byte(u ^ repeated_x);
      113 (0.0%)              let zv = contains_zero_byte(v ^ repeated_x);
      339 (0.0%)              if zu || zv {
        .                         break;
        .                     }
        .                 }
        .                 offset -= 2 * chunk_bytes;
        .             }
        .         
        .             // Find the byte before the point the body loop stopped.
      462 (0.0%)      text[..offset].iter().rposition(|elt| *elt == x)
      662 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/std/src/alloc.rs
--------------------------------------------------------------------------------
Ir______________ 

-- line 381 ----------------------------------------
        .         
        .             // for symbol names src/librustc_ast/expand/allocator.rs
        .             // for signatures src/librustc_allocator/lib.rs
        .         
        .             // linkage directives are provided as part of the current compiler allocator
        .             // ABI
        .         
        .             #[rustc_std_internal_symbol]
4,442,521 (0.1%)      pub unsafe extern "C" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {
        .                 // SAFETY: see the guarantees expected by `Layout::from_size_align` and
        .                 // `GlobalAlloc::alloc`.
        .                 unsafe {
        .                     let layout = Layout::from_size_align_unchecked(size, align);
        .                     System.alloc(layout)
        .                 }
      174 (0.0%)      }
        .         
        .             #[rustc_std_internal_symbol]
8,888,388 (0.1%)      pub unsafe extern "C" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {
        .                 // SAFETY: see the guarantees expected by `Layout::from_size_align` and
        .                 // `GlobalAlloc::dealloc`.
        .                 unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }
        .             }
        .         
        .             #[rustc_std_internal_symbol]
4,411,863 (0.1%)      pub unsafe extern "C" fn __rdl_realloc(
        .                 ptr: *mut u8,
        .                 old_size: usize,
        .                 align: usize,
        .                 new_size: usize,
        .             ) -> *mut u8 {
        .                 // SAFETY: see the guarantees expected by `Layout::from_size_align` and
        .                 // `GlobalAlloc::realloc`.
        .                 unsafe {
        .                     let old_layout = Layout::from_size_align_unchecked(old_size, align);
        .                     System.realloc(ptr, old_layout, new_size)
        .                 }
        .             }
        .         
        .             #[rustc_std_internal_symbol]
   12,654 (0.0%)      pub unsafe extern "C" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {
        .                 // SAFETY: see the guarantees expected by `Layout::from_size_align` and
        .                 // `GlobalAlloc::alloc_zeroed`.
        .                 unsafe {
        .                     let layout = Layout::from_size_align_unchecked(size, align);
        .                     System.alloc_zeroed(layout)
        .                 }
        .             }
        .         }
-- line 429 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/library/std/src/sys/pal/unix/alloc.rs
--------------------------------------------------------------------------------
Ir_______________ 

        58 (0.0%)  <unknown (line 0)>

-- line 5 ----------------------------------------
         .         #[stable(feature = "alloc_system_type", since = "1.28.0")]
         .         unsafe impl GlobalAlloc for System {
         .             #[inline]
         .             unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
         .                 // jemalloc provides alignment less than MIN_ALIGN for small allocations.
         .                 // So only rely on MIN_ALIGN if size >= align.
         .                 // Also see <https://github.com/rust-lang/rust/issues/45955> and
         .                 // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.
17,769,968 (0.2%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
 8,885,100 (0.1%)              libc::malloc(layout.size()) as *mut u8
         .                 } else {
         .                     #[cfg(target_os = "macos")]
         .                     {
         .                         if layout.align() > (1 << 31) {
         .                             return ptr::null_mut();
         .                         }
         .                     }
         .                     aligned_malloc(&layout)
         .                 }
         .             }
         .         
         .             #[inline]
         .             unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
         .                 // See the comment above in `alloc` for why this check looks the way it does.
     8,436 (0.0%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
    14,763 (0.0%)              libc::calloc(layout.size(), 1) as *mut u8
         .                 } else {
         .                     let ptr = self.alloc(layout);
         .                     if !ptr.is_null() {
         .                         ptr::write_bytes(ptr, 0, layout.size());
         .                     }
         .                     ptr
         .                 }
         .             }
         .         
         .             #[inline]
         .             unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
 8,888,388 (0.1%)          libc::free(ptr as *mut libc::c_void)
         .             }
         .         
         .             #[inline]
         .             unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
 1,960,828 (0.0%)          if layout.align() <= MIN_ALIGN && layout.align() <= new_size {
 3,921,656 (0.0%)              libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8
         .                 } else {
         .                     realloc_fallback(self, ptr, layout, new_size)
         .                 }
         .             }
         .         }
         .         
         .         cfg_if::cfg_if! {
         .             if #[cfg(any(
-- line 56 ----------------------------------------
-- line 94 ----------------------------------------
         .                 }
         .             } else {
         .                 #[inline]
         .                 unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
         .                     let mut out = ptr::null_mut();
         .                     // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.
         .                     // Since these are all powers of 2, we can just use max.
         .                     let align = layout.align().max(crate::mem::size_of::<usize>());
       116 (0.0%)              let ret = libc::posix_memalign(&mut out, align, layout.size());
       116 (0.0%)              if ret != 0 { ptr::null_mut() } else { out as *mut u8 }
         .                 }
         .             }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/src/librustdoc/clean/mod.rs
--------------------------------------------------------------------------------
Ir______________ 

2,421,896 (0.0%)  <unknown (line 0)>

-- line 41 ----------------------------------------
        .         use crate::formats::item_type::ItemType;
        .         use crate::visit_ast::Module as DocModule;
        .         
        .         use utils::*;
        .         
        .         pub(crate) use self::types::*;
        .         pub(crate) use self::utils::{krate, register_res, synthesize_auto_trait_and_blanket_impls};
        .         
      590 (0.0%)  pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<'tcx>) -> Item {
        .             let mut items: Vec<Item> = vec![];
        .             let mut inserted = FxHashSet::default();
       59 (0.0%)      items.extend(doc.foreigns.iter().map(|(item, renamed)| {
        .                 let item = clean_maybe_renamed_foreign_item(cx, item, *renamed);
        .                 if let Some(name) = item.name
        .                     && (cx.render_options.document_hidden || !item.is_doc_hidden())
        .                 {
        .                     inserted.insert((item.type_(), name));
        .                 }
        .                 item
        .             }));
       59 (0.0%)      items.extend(doc.mods.iter().filter_map(|x| {
       58 (0.0%)          if !inserted.insert((ItemType::Module, x.name)) {
        .                     return None;
        .                 }
      232 (0.0%)          let item = clean_doc_module(x, cx);
      116 (0.0%)          if !cx.render_options.document_hidden && item.is_doc_hidden() {
        .                     // Hidden modules are stripped at a later stage.
        .                     // If a hidden module has the same name as a visible one, we want
        .                     // to keep both of them around.
        .                     inserted.remove(&(ItemType::Module, x.name));
        .                 }
      580 (0.0%)          Some(item)
        .             }));
        .         
        .             // Split up imports from all other items.
        .             //
        .             // This covers the case where somebody does an import which should pull in an item,
        .             // but there's already an item with the same namespace and same name. Rust gives
        .             // priority to the not-imported one, so we should, too.
      118 (0.0%)      items.extend(doc.items.values().flat_map(|(item, renamed, import_id)| {
        .                 // First, lower everything other than glob imports.
    4,659 (0.0%)          if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {
        .                     return Vec::new();
        .                 }
    4,444 (0.0%)          let v = clean_maybe_renamed_item(cx, item, *renamed, *import_id);
        .                 for item in &v {
    4,556 (0.0%)              if let Some(name) = item.name
      666 (0.0%)                  && (cx.render_options.document_hidden || !item.is_doc_hidden())
        .                     {
        .                         inserted.insert((item.type_(), name));
        .                     }
        .                 }
    1,111 (0.0%)          v
        .             }));
      118 (0.0%)      items.extend(doc.inlined_foreigns.iter().flat_map(|((_, renamed), (res, local_import_id))| {
        .                 let Some(def_id) = res.opt_def_id() else { return Vec::new() };
        .                 let name = renamed.unwrap_or_else(|| cx.tcx.item_name(def_id));
       39 (0.0%)          let import = cx.tcx.hir().expect_item(*local_import_id);
       26 (0.0%)          match import.kind {
       13 (0.0%)              hir::ItemKind::Use(path, kind) => {
       26 (0.0%)                  let hir::UsePath { segments, span, .. } = *path;
       91 (0.0%)                  let path = hir::Path { segments, res: *res, span };
      117 (0.0%)                  clean_use_statement_inner(import, name, &path, kind, cx, &mut Default::default())
       13 (0.0%)              }
        .                     _ => unreachable!(),
        .                 }
        .             }));
        .             items.extend(doc.items.values().flat_map(|(item, renamed, _)| {
        .                 // Now we actually lower the imports, skipping everything else.
    3,548 (0.0%)          if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {
        6 (0.0%)              let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));
       18 (0.0%)              clean_use_statement(item, name, path, hir::UseKind::Glob, cx, &mut inserted)
        .                 } else {
        .                     // skip everything else
        .                     Vec::new()
        .                 }
        .             }));
        .         
        .             // determine if we should display the inner contents or
        .             // the outer `mod` item for the source code.
        .         
        .             let span = Span::new({
      177 (0.0%)          let where_outer = doc.where_outer(cx.tcx);
        .                 let sm = cx.sess().source_map();
      177 (0.0%)          let outer = sm.lookup_char_pos(where_outer.lo());
      236 (0.0%)          let inner = sm.lookup_char_pos(doc.where_inner.lo());
       59 (0.0%)          if outer.file.start_pos == inner.file.start_pos {
        .                     // mod foo { ... }
        .                     where_outer
        .                 } else {
        .                     // mod foo; (and a separate SourceFile for the contents)
        .                     doc.where_inner
        .                 }
        .             });
        .         
      413 (0.0%)      let kind = ModuleItem(Module { items, span });
      472 (0.0%)      generate_item_with_correct_attrs(
        .                 cx,
        .                 kind,
        .                 doc.def_id.to_def_id(),
       59 (0.0%)          doc.name,
       59 (0.0%)          doc.import_id,
      118 (0.0%)          doc.renamed,
        .             )
      590 (0.0%)  }
        .         
        .         fn is_glob_import(tcx: TyCtxt<'_>, import_id: LocalDefId) -> bool {
       52 (0.0%)      if let hir::Node::Item(item) = tcx.hir_node_by_def_id(import_id)
       52 (0.0%)          && let hir::ItemKind::Use(_, use_kind) = item.kind
        .             {
        .                 use_kind == hir::UseKind::Glob
        .             } else {
        .                 false
        .             }
        .         }
        .         
    6,048 (0.0%)  fn generate_item_with_correct_attrs(
        .             cx: &mut DocContext<'_>,
        .             kind: ItemKind,
        .             def_id: DefId,
        .             name: Symbol,
        .             import_id: Option<LocalDefId>,
        .             renamed: Option<Symbol>,
        .         ) -> Item {
    1,008 (0.0%)      let target_attrs = inline::load_attrs(cx, def_id);
    1,512 (0.0%)      let attrs = if let Some(import_id) = import_id {
        .                 // glob reexports are treated the same as `#[doc(inline)]` items.
        .                 //
        .                 // For glob re-exports the item may or may not exist to be re-exported (potentially the cfgs
        .                 // on the path up until the glob can be removed, and only cfgs on the globbed item itself
        .                 // matter), for non-inlined re-exports see #85043.
       52 (0.0%)          let is_inline = inline::load_attrs(cx, import_id.to_def_id())
        .                     .lists(sym::doc)
        .                     .get_word_attr(sym::inline)
        .                     .is_some()
       52 (0.0%)              || (is_glob_import(cx.tcx, import_id)
        .                         && (cx.render_options.document_hidden || !cx.tcx.is_doc_hidden(def_id)));
       78 (0.0%)          let mut attrs = get_all_import_attributes(cx, import_id, def_id, is_inline);
       78 (0.0%)          add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);
      104 (0.0%)          attrs
        .             } else {
        .                 // We only keep the item's attributes.
        .                 target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()
        .             };
        .         
    1,086 (0.0%)      let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);
    6,488 (0.0%)      let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);
        .         
        .             let name = renamed.or(Some(name));
    8,064 (0.0%)      let mut item = Item::from_def_id_and_attrs_and_parts(def_id, name, kind, Box::new(attrs), cfg);
    1,512 (0.0%)      item.inline_stmt_id = import_id.map(|local| local.to_def_id());
    7,560 (0.0%)      item
    4,536 (0.0%)  }
        .         
   10,615 (0.0%)  fn clean_generic_bound<'tcx>(
        .             bound: &hir::GenericBound<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Option<GenericBound> {
   14,475 (0.0%)      Some(match *bound {
      530 (0.0%)          hir::GenericBound::Outlives(lt) => GenericBound::Outlives(clean_lifetime(lt, cx)),
      859 (0.0%)          hir::GenericBound::Trait(ref t, modifier) => {
        .                     // `T: ~const Destruct` is hidden because `T: Destruct` is a no-op.
    1,718 (0.0%)              if modifier == hir::TraitBoundModifier::MaybeConst
        .                         && cx.tcx.lang_items().destruct_trait() == Some(t.trait_ref.trait_def_id().unwrap())
        .                     {
        .                         return None;
        .                     }
        .         
        .                     GenericBound::TraitBound(clean_poly_trait_ref(t, cx), modifier)
        .                 }
        .             })
    7,720 (0.0%)  }
        .         
  568,100 (0.0%)  pub(crate) fn clean_trait_ref_with_bindings<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             trait_ref: ty::PolyTraitRef<'tcx>,
        .             bindings: ThinVec<TypeBinding>,
        .         ) -> Path {
   43,700 (0.0%)      let kind = cx.tcx.def_kind(trait_ref.def_id()).into();
        .             if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {
        .                 span_bug!(cx.tcx.def_span(trait_ref.def_id()), "`TraitRef` had unexpected kind {kind:?}");
        .             }
  218,500 (0.0%)      inline::record_extern_fqn(cx, trait_ref.def_id(), kind);
  349,600 (0.0%)      let path = clean_middle_path(
        .                 cx,
        .                 trait_ref.def_id(),
        .                 true,
        .                 bindings,
   43,700 (0.0%)          trait_ref.map_bound(|tr| tr.args),
        .             );
        .         
   43,700 (0.0%)      debug!(?trait_ref);
        .         
  218,500 (0.0%)      path
  349,600 (0.0%)  }
        .         
        .         fn clean_poly_trait_ref_with_bindings<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             poly_trait_ref: ty::PolyTraitRef<'tcx>,
        .             bindings: ThinVec<TypeBinding>,
        .         ) -> GenericBound {
        .             GenericBound::TraitBound(
  145,632 (0.0%)          PolyTrait {
   91,020 (0.0%)              trait_: clean_trait_ref_with_bindings(cx, poly_trait_ref, bindings),
   18,204 (0.0%)              generic_params: clean_bound_vars(poly_trait_ref.bound_vars()),
        .                 },
        .                 hir::TraitBoundModifier::None,
        .             )
        .         }
        .         
    1,841 (0.0%)  fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {
    1,052 (0.0%)      if let Some(
        .                 rbv::ResolvedArg::EarlyBound(did)
        .                 | rbv::ResolvedArg::LateBound(_, _, did)
        .                 | rbv::ResolvedArg::Free(_, did),
    1,315 (0.0%)      ) = cx.tcx.named_bound_var(lifetime.hir_id)
        .                 && let Some(lt) = cx.args.get(&did).and_then(|arg| arg.as_lt())
        .             {
        .                 return lt.clone();
        .             }
      263 (0.0%)      Lifetime(lifetime.ident.name)
    1,315 (0.0%)  }
        .         
        .         pub(crate) fn clean_const<'tcx>(constant: &hir::ConstArg, cx: &mut DocContext<'tcx>) -> Constant {
        .             let def_id = cx.tcx.hir().body_owner_def_id(constant.value.body).to_def_id();
        .             Constant {
        .                 type_: Box::new(clean_middle_ty(
        .                     ty::Binder::dummy(cx.tcx.type_of(def_id).instantiate_identity()),
        .                     cx,
        .                     Some(def_id),
        .                     None,
        .                 )),
        .                 generics: Generics::default(),
        .                 kind: ConstantKind::Anonymous { body: constant.value.body },
        .             }
        .         }
        .         
   41,004 (0.0%)  pub(crate) fn clean_middle_const<'tcx>(
        .             constant: ty::Binder<'tcx, ty::Const<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Constant {
        .             // FIXME: instead of storing the stringified expression, store `self` directly instead.
   27,336 (0.0%)      Constant {
   36,448 (0.0%)          type_: Box::new(clean_middle_ty(constant.map_bound(|c| c.ty()), cx, None, None)),
        .                 generics: Generics::default(),
        .                 kind: ConstantKind::TyConst { expr: constant.skip_binder().to_string().into() },
        .             }
   31,892 (0.0%)  }
        .         
  189,366 (0.0%)  pub(crate) fn clean_middle_region<'tcx>(region: ty::Region<'tcx>) -> Option<Lifetime> {
  161,320 (0.0%)      match *region {
        .                 ty::ReStatic => Some(Lifetime::statik()),
   93,765 (0.0%)          _ if !region.has_name() => None,
        .                 ty::ReBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => Some(Lifetime(name)),
   13,404 (0.0%)          ty::ReEarlyParam(ref data) => Some(Lifetime(data.name)),
        .                 ty::ReBound(..)
        .                 | ty::ReLateParam(..)
        .                 | ty::ReVar(..)
        .                 | ty::ReError(_)
        .                 | ty::RePlaceholder(..)
        .                 | ty::ReErased => {
        .                     debug!("cannot clean region {region:?}");
        .                     None
        .                 }
        .             }
  157,805 (0.0%)  }
        .         
        .         fn clean_where_predicate<'tcx>(
        .             predicate: &hir::WherePredicate<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Option<WherePredicate> {
      619 (0.0%)      if !predicate.in_where_clause() {
        .                 return None;
        .             }
        .             Some(match *predicate {
        .                 hir::WherePredicate::BoundPredicate(ref wbp) => {
      438 (0.0%)              let bound_params = wbp
        .                         .bound_generic_params
        .                         .iter()
        .                         .map(|param| clean_generic_param(cx, None, param))
        .                         .collect();
    1,752 (0.0%)              WherePredicate::BoundPredicate {
    1,752 (0.0%)                  ty: clean_ty(wbp.bounded_ty, cx),
    6,212 (0.0%)                  bounds: wbp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),
    1,752 (0.0%)                  bound_params,
        .                     }
        .                 }
        .         
        .                 hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {
        .                     lifetime: clean_lifetime(wrp.lifetime, cx),
        .                     bounds: wrp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),
        .                 },
        .         
        .                 hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {
        .                     lhs: clean_ty(wrp.lhs_ty, cx),
        .                     rhs: clean_ty(wrp.rhs_ty, cx).into(),
        .                 },
        .             })
        .         }
        .         
  239,921 (0.0%)  pub(crate) fn clean_predicate<'tcx>(
        .             predicate: ty::Clause<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Option<WherePredicate> {
   21,811 (0.0%)      let bound_predicate = predicate.kind();
  153,723 (0.0%)      match bound_predicate.skip_binder() {
        .                 ty::ClauseKind::Trait(pred) => clean_poly_trait_predicate(bound_predicate.rebind(pred), cx),
        .                 ty::ClauseKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),
        .                 ty::ClauseKind::TypeOutlives(pred) => {
        .                     clean_type_outlives_predicate(bound_predicate.rebind(pred), cx)
        .                 }
        .                 ty::ClauseKind::Projection(pred) => {
   13,598 (0.0%)              Some(clean_projection_predicate(bound_predicate.rebind(pred), cx))
        .                 }
        .                 // FIXME(generic_const_exprs): should this do something?
        .                 ty::ClauseKind::ConstEvaluatable(..)
        .                 | ty::ClauseKind::WellFormed(..)
        .                 | ty::ClauseKind::ConstArgHasType(..) => None,
        .             }
  174,488 (0.0%)  }
        .         
        .         fn clean_poly_trait_predicate<'tcx>(
        .             pred: ty::PolyTraitPredicate<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Option<WherePredicate> {
        .             // `T: ~const Destruct` is hidden because `T: Destruct` is a no-op.
        .             // FIXME(effects) check constness
   54,612 (0.0%)      if Some(pred.skip_binder().def_id()) == cx.tcx.lang_items().destruct_trait() {
        .                 return None;
        .             }
        .         
        .             let poly_trait_ref = pred.map_bound(|pred| pred.trait_ref);
  254,856 (0.0%)      Some(WherePredicate::BoundPredicate {
  163,836 (0.0%)          ty: clean_middle_ty(poly_trait_ref.self_ty(), cx, None, None),
  273,060 (0.0%)          bounds: vec![clean_poly_trait_ref_with_bindings(cx, poly_trait_ref, ThinVec::new())],
        .                 bound_params: Vec::new(),
        .             })
        .         }
        .         
        .         fn clean_region_outlives_predicate<'tcx>(
        .             pred: ty::RegionOutlivesPredicate<'tcx>,
        .         ) -> Option<WherePredicate> {
        .             let ty::OutlivesPredicate(a, b) = pred;
        .         
       96 (0.0%)      Some(WherePredicate::RegionPredicate {
       32 (0.0%)          lifetime: clean_middle_region(a).expect("failed to clean lifetime"),
       32 (0.0%)          bounds: vec![GenericBound::Outlives(
       32 (0.0%)              clean_middle_region(b).expect("failed to clean bounds"),
        .                 )],
        .             })
        .         }
        .         
        .         fn clean_type_outlives_predicate<'tcx>(
        .             pred: ty::Binder<'tcx, ty::TypeOutlivesPredicate<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Option<WherePredicate> {
        .             let ty::OutlivesPredicate(ty, lt) = pred.skip_binder();
        .         
    4,290 (0.0%)      Some(WherePredicate::BoundPredicate {
    2,640 (0.0%)          ty: clean_middle_ty(pred.rebind(ty), cx, None, None),
      660 (0.0%)          bounds: vec![GenericBound::Outlives(
      660 (0.0%)              clean_middle_region(lt).expect("failed to clean lifetimes"),
        .                 )],
        .                 bound_params: Vec::new(),
        .             })
        .         }
        .         
        .         fn clean_middle_term<'tcx>(
        .             term: ty::Binder<'tcx, ty::Term<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Term {
    2,202 (0.0%)      match term.skip_binder().unpack() {
   13,417 (0.0%)          ty::TermKind::Ty(ty) => Term::Type(clean_middle_ty(term.rebind(ty), cx, None, None)),
        .                 ty::TermKind::Const(c) => Term::Constant(clean_middle_const(term.rebind(c), cx)),
        .             }
        .         }
        .         
        .         fn clean_hir_term<'tcx>(term: &hir::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Term {
      228 (0.0%)      match term {
    1,254 (0.0%)          hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),
        .                 hir::Term::Const(c) => Term::Constant(clean_middle_const(
        .                     ty::Binder::dummy(ty::Const::from_anon_const(cx.tcx, c.def_id)),
        .                     cx,
        .                 )),
        .             }
        .         }
        .         
        .         fn clean_projection_predicate<'tcx>(
        .             pred: ty::Binder<'tcx, ty::ProjectionPredicate<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> WherePredicate {
    4,184 (0.0%)      WherePredicate::EqPredicate {
    6,276 (0.0%)          lhs: clean_projection(pred.map_bound(|p| p.projection_ty), cx, None),
        .                 rhs: clean_middle_term(pred.map_bound(|p| p.term), cx),
        .             }
        .         }
        .         
  127,972 (0.0%)  fn clean_projection<'tcx>(
        .             ty: ty::Binder<'tcx, ty::AliasTy<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .             def_id: Option<DefId>,
        .         ) -> Type {
  127,972 (0.0%)      if cx.tcx.is_impl_trait_in_trait(ty.skip_binder().def_id) {
        .                 let bounds = cx
        .                     .tcx
        .                     .explicit_item_bounds(ty.skip_binder().def_id)
        .                     .iter_instantiated_copied(cx.tcx, ty.skip_binder().args)
        .                     .map(|(pred, _)| pred)
        .                     .collect::<Vec<_>>();
        .                 return clean_middle_opaque_bounds(cx, bounds);
        .             }
        .         
        .             let trait_ =
   98,440 (0.0%)          clean_trait_ref_with_bindings(cx, ty.map_bound(|ty| ty.trait_ref(cx.tcx)), ThinVec::new());
   98,440 (0.0%)      let self_type = clean_middle_ty(ty.map_bound(|ty| ty.self_ty()), cx, None, None);
   19,688 (0.0%)      let self_def_id = if let Some(def_id) = def_id {
    4,660 (0.0%)          cx.tcx.opt_parent(def_id).or(Some(def_id))
        .             } else {
   15,028 (0.0%)          self_type.def_id(&cx.cache)
        .             };
   19,688 (0.0%)      let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);
   98,440 (0.0%)      Type::QPath(Box::new(QPathData {
   19,688 (0.0%)          assoc: projection_to_path_segment(ty, cx),
        .                 should_show_cast,
   39,376 (0.0%)          self_type,
   39,376 (0.0%)          trait_: Some(trait_),
        .             }))
   78,752 (0.0%)  }
        .         
        .         fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type: &Type) -> bool {
   19,772 (0.0%)      !trait_.segments.is_empty()
        .                 && self_def_id
        .                     .zip(Some(trait_.def_id()))
        .                     .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)
        .         }
        .         
   89,046 (0.0%)  fn projection_to_path_segment<'tcx>(
        .             ty: ty::Binder<'tcx, ty::AliasTy<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> PathSegment {
   59,364 (0.0%)      let def_id = ty.skip_binder().def_id;
    9,894 (0.0%)      let item = cx.tcx.associated_item(def_id);
        .             let generics = cx.tcx.generics_of(def_id);
   59,364 (0.0%)      PathSegment {
        .                 name: item.name,
        .                 args: GenericArgs::AngleBracketed {
   59,364 (0.0%)              args: clean_middle_generic_args(
        .                         cx,
    9,894 (0.0%)                  ty.map_bound(|ty| &ty.args[generics.parent_count..]),
        .                         false,
        .                         def_id,
        .                     )
        .                     .into(),
        .                     bindings: Default::default(),
        .                 },
        .             }
   79,152 (0.0%)  }
        .         
  134,970 (0.0%)  fn clean_generic_param_def<'tcx>(
        .             def: &ty::GenericParamDef,
        .             defaults: ParamDefaults,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> GenericParamDef {
   63,289 (0.0%)      let (name, kind) = match def.kind {
        .                 ty::GenericParamDefKind::Lifetime => {
    6,294 (0.0%)              (def.name, GenericParamDefKind::Lifetime { outlives: ThinVec::new() })
        .                 }
   21,644 (0.0%)          ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {
   32,466 (0.0%)              let default = if let ParamDefaults::Yes = defaults
        .                         && has_default
        .                     {
      455 (0.0%)                  Some(clean_middle_ty(
      105 (0.0%)                      ty::Binder::dummy(cx.tcx.type_of(def.def_id).instantiate_identity()),
        .                             cx,
        .                             Some(def.def_id),
       70 (0.0%)                      None,
        .                         ))
        .                     } else {
        .                         None
        .                     };
        .                     (
   32,431 (0.0%)                  def.name,
        .                         GenericParamDefKind::Type {
        .                             bounds: ThinVec::new(), // These are filled in from the where-clauses.
        .                             default: default.map(Box::new),
        .                             synthetic,
        .                         },
        .                     )
        .                 }
    4,039 (0.0%)          ty::GenericParamDefKind::Const { has_default, is_host_effect } => (
    1,154 (0.0%)              def.name,
        .                     GenericParamDefKind::Const {
    5,770 (0.0%)                  ty: Box::new(clean_middle_ty(
        .                             ty::Binder::dummy(
      577 (0.0%)                          cx.tcx
    1,154 (0.0%)                              .type_of(def.def_id)
        .                                     .no_bound_vars()
        .                                     .expect("const parameter types cannot be generic"),
        .                             ),
        .                             cx,
        .                             Some(def.def_id),
    1,154 (0.0%)                      None,
        .                         )),
    1,731 (0.0%)                  default: if let ParamDefaults::Yes = defaults
        .                             && has_default
        .                         {
        .                             Some(Box::new(
        .                                 cx.tcx.const_param_default(def.def_id).instantiate_identity().to_string(),
        .                             ))
        .                         } else {
        .                             None
        .                         },
        .                         is_host_effect,
        .                     },
        .                 ),
        .             };
        .         
   94,479 (0.0%)      GenericParamDef { name, def_id: def.def_id, kind }
  107,976 (0.0%)  }
        .         
        .         /// Whether to clean generic parameter defaults or not.
        .         enum ParamDefaults {
        .             Yes,
        .             No,
        .         }
        .         
    9,870 (0.0%)  fn clean_generic_param<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             generics: Option<&hir::Generics<'tcx>>,
        .             param: &hir::GenericParam<'tcx>,
        .         ) -> GenericParamDef {
    6,737 (0.0%)      let (name, kind) = match param.kind {
        .                 hir::GenericParamKind::Lifetime { .. } => {
      172 (0.0%)              let outlives = if let Some(generics) = generics {
        .                         generics
       84 (0.0%)                      .outlives_for_param(param.def_id)
        .                             .filter(|bp| !bp.in_where_clause)
        .                             .flat_map(|bp| bp.bounds)
        .                             .map(|bound| match bound {
        .                                 hir::GenericBound::Outlives(lt) => clean_lifetime(lt, cx),
        .                                 _ => panic!(),
        .                             })
        .                             .collect()
        .                     } else {
        .                         ThinVec::new()
        .                     };
        .                     (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })
        .                 }
      901 (0.0%)          hir::GenericParamKind::Type { ref default, synthetic } => {
    2,703 (0.0%)              let bounds = if let Some(generics) = generics {
        .                         generics
    1,802 (0.0%)                      .bounds_for_param(param.def_id)
        .                             .filter(|bp| bp.origin != PredicateOrigin::WhereClause)
        .                             .flat_map(|bp| bp.bounds)
    1,339 (0.0%)                      .filter_map(|x| clean_generic_bound(x, cx))
        .                             .collect()
        .                     } else {
        .                         ThinVec::new()
        .                     };
        .                     (
        .                         param.name.ident().name,
        .                         GenericParamDefKind::Type {
      901 (0.0%)                      bounds,
      923 (0.0%)                      default: default.map(|t| clean_ty(t, cx)).map(Box::new),
        .                             synthetic,
        .                         },
        .                     )
        .                 }
        .                 hir::GenericParamKind::Const { ty, default, is_host_effect } => (
        .                     param.name.ident().name,
        .                     GenericParamDefKind::Const {
        .                         ty: Box::new(clean_ty(ty, cx)),
        .                         default: default
        .                             .map(|ct| Box::new(ty::Const::from_anon_const(cx.tcx, ct.def_id).to_string())),
        .                         is_host_effect,
        .                     },
        .                 ),
        .             };
        .         
   10,857 (0.0%)      GenericParamDef { name, def_id: param.def_id.to_def_id(), kind }
    7,896 (0.0%)  }
        .         
        .         /// Synthetic type-parameters are inserted after normal ones.
        .         /// In order for normal parameters to be able to refer to synthetic ones,
        .         /// scans them first.
        .         fn is_impl_trait(param: &hir::GenericParam<'_>) -> bool {
   13,528 (0.0%)      match param.kind {
      901 (0.0%)          hir::GenericParamKind::Type { synthetic, .. } => synthetic,
        .                 _ => false,
        .             }
        .         }
        .         
        .         /// This can happen for `async fn`, e.g. `async fn f<'_>(&'_ self)`.
        .         ///
        .         /// See `lifetime_to_generic_param` in `rustc_ast_lowering` for more information.
        .         fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {
       24 (0.0%)      matches!(
    3,903 (0.0%)          param.kind,
        .                 hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided(_) }
        .             )
        .         }
        .         
   16,209 (0.0%)  pub(crate) fn clean_generics<'tcx>(
        .             gens: &hir::Generics<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Generics {
    3,602 (0.0%)      let impl_trait_params = gens
        .                 .params
        .                 .iter()
      901 (0.0%)          .filter(|param| is_impl_trait(param))
        .                 .map(|param| {
       30 (0.0%)              let param = clean_generic_param(cx, Some(gens), param);
       60 (0.0%)              match param.kind {
        .                         GenericParamDefKind::Lifetime { .. } => unreachable!(),
        .                         GenericParamDefKind::Type { ref bounds, .. } => {
       15 (0.0%)                      cx.impl_trait_bounds.insert(param.def_id.into(), bounds.to_vec());
        .                         }
        .                         GenericParamDefKind::Const { .. } => unreachable!(),
        .                     }
       90 (0.0%)              param
        .                 })
        .                 .collect::<Vec<_>>();
        .         
        .             let mut bound_predicates = FxIndexMap::default();
        .             let mut region_predicates = FxIndexMap::default();
        .             let mut eq_predicates = ThinVec::default();
    1,801 (0.0%)      for pred in gens.predicates.iter().filter_map(|x| clean_where_predicate(x, cx)) {
      876 (0.0%)          match pred {
    6,132 (0.0%)              WherePredicate::BoundPredicate { ty, bounds, bound_params } => {
    3,504 (0.0%)                  match bound_predicates.entry(ty) {
        .                             IndexEntry::Vacant(v) => {
    5,642 (0.0%)                          v.insert((bounds, bound_params));
        .                             }
       12 (0.0%)                      IndexEntry::Occupied(mut o) => {
        .                                 // we merge both bounds.
       80 (0.0%)                          for bound in bounds {
       24 (0.0%)                              if !o.get().0.contains(&bound) {
        .                                         o.get_mut().0.push(bound);
        .                                     }
        .                                 }
       36 (0.0%)                          for bound_param in bound_params {
        .                                     if !o.get().1.contains(&bound_param) {
        .                                         o.get_mut().1.push(bound_param);
        .                                     }
        .                                 }
        .                             }
        .                         }
        .                     }
        .                     WherePredicate::RegionPredicate { lifetime, bounds } => {
-- line 689 ----------------------------------------
-- line 702 ----------------------------------------
        .                         }
        .                     }
        .                     WherePredicate::EqPredicate { lhs, rhs } => {
        .                         eq_predicates.push(WherePredicate::EqPredicate { lhs, rhs });
        .                     }
        .                 }
        .             }
        .         
   11,631 (0.0%)      let mut params = ThinVec::with_capacity(gens.params.len());
        .             // In this loop, we gather the generic parameters (`<'a, B: 'a>`) and check if they have
        .             // bounds in the where predicates. If so, we move their bounds into the where predicates
        .             // while also preventing duplicates.
        .             for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {
    4,850 (0.0%)          let mut p = clean_generic_param(cx, Some(gens), p);
    6,622 (0.0%)          match &mut p.kind {
        .                     GenericParamDefKind::Lifetime { ref mut outlives } => {
        .                         if let Some(region_pred) = region_predicates.get_mut(&Lifetime(p.name)) {
        .                             // We merge bounds in the `where` clause.
        .                             for outlive in outlives.drain(..) {
        .                                 let outlive = GenericBound::Outlives(outlive);
        .                                 if !region_pred.contains(&outlive) {
        .                                     region_pred.push(outlive);
        .                                 }
        .                             }
        .                         }
        .                     }
        .                     GenericParamDefKind::Type { bounds, synthetic: false, .. } => {
    7,974 (0.0%)                  if let Some(bound_pred) = bound_predicates.get_mut(&Type::Generic(p.name)) {
        .                             // We merge bounds in the `where` clause.
    1,902 (0.0%)                      for bound in bounds.drain(..) {
       24 (0.0%)                          if !bound_pred.0.contains(&bound) {
        .                                     bound_pred.0.push(bound);
        .                                 }
       14 (0.0%)                      }
        .                         }
    1,772 (0.0%)              }
        .                     GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {
        .                         // nothing to do here.
        .                     }
        .                 }
    6,790 (0.0%)          params.push(p);
        .             }
    1,801 (0.0%)      params.extend(impl_trait_params);
        .         
    7,204 (0.0%)      Generics {
    3,602 (0.0%)          params,
    9,005 (0.0%)          where_predicates: bound_predicates
        .                     .into_iter()
    1,736 (0.0%)              .map(|(ty, (bounds, bound_params))| WherePredicate::BoundPredicate {
        .                         ty,
        .                         bounds,
        .                         bound_params,
        .                     })
        .                     .chain(
    9,005 (0.0%)                  region_predicates
        .                             .into_iter()
        .                             .map(|(lifetime, bounds)| WherePredicate::RegionPredicate { lifetime, bounds }),
        .                     )
    1,801 (0.0%)              .chain(eq_predicates)
        .                     .collect(),
        .             }
   14,408 (0.0%)  }
        .         
  451,680 (0.0%)  fn clean_ty_generics<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             gens: &ty::Generics,
        .             preds: ty::GenericPredicates<'tcx>,
        .         ) -> Generics {
        .             // Don't populate `cx.impl_trait_bounds` before cleaning where clauses,
        .             // since `clean_predicate` would consume them.
        .             let mut impl_trait = BTreeMap::<u32, Vec<GenericBound>>::default();
        .         
        .             let params: ThinVec<_> = gens
        .                 .params
        .                 .iter()
   79,390 (0.0%)          .filter(|param| match param.kind {
        .                     ty::GenericParamDefKind::Lifetime => !param.is_anonymous_lifetime(),
   10,054 (0.0%)              ty::GenericParamDefKind::Type { synthetic, .. } => {
   20,516 (0.0%)                  if param.name == kw::SelfUpper {
        .                             debug_assert_eq!(param.index, 0);
        .                             return false;
        .                         }
   10,054 (0.0%)                  if synthetic {
       11 (0.0%)                      impl_trait.insert(param.index, vec![]);
        .                             return false;
        .                         }
        .                         true
        .                     }
        .                     ty::GenericParamDefKind::Const { is_host_effect, .. } => !is_host_effect,
    2,215 (0.0%)          })
   50,428 (0.0%)          .map(|param| clean_generic_param_def(param, ParamDefaults::Yes, cx))
        .                 .collect();
        .         
        .             // param index -> [(trait DefId, associated type name & generics, term)]
        .             let mut impl_trait_proj =
        .                 FxHashMap::<u32, Vec<(DefId, PathSegment, ty::Binder<'_, ty::Term<'_>>)>>::default();
        .         
        .             let where_predicates = preds
        .                 .predicates
        .                 .iter()
        .                 .flat_map(|(pred, _)| {
        .                     let mut projection = None;
        .                     let param_idx = (|| {
   81,384 (0.0%)                  let bound_p = pred.kind();
  198,616 (0.0%)                  match bound_p.skip_binder() {
   50,217 (0.0%)                      ty::ClauseKind::Trait(pred) => {
   66,956 (0.0%)                          if let ty::Param(param) = pred.self_ty().kind() {
        .                                     return Some(param.index);
        .                                 }
        .                             }
        .                             ty::ClauseKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {
      994 (0.0%)                          if let ty::Param(param) = ty.kind() {
        .                                     return Some(param.index);
        .                                 }
        .                             }
        .                             ty::ClauseKind::Projection(p) => {
    6,276 (0.0%)                          if let ty::Param(param) = p.projection_ty.self_ty().kind() {
        .                                     projection = Some(bound_p.rebind(p));
        .                                     return Some(param.index);
        .                                 }
        .                             }
        .                             _ => (),
        .                         }
        .         
        .                         None
        .                     })();
        .         
        .                     if let Some(param_idx) = param_idx
   33,530 (0.0%)                  && let Some(bounds) = impl_trait.get_mut(&param_idx)
        .                     {
      135 (0.0%)                  let pred = clean_predicate(*pred, cx)?;
        .         
        .                         bounds.extend(pred.get_bounds().into_iter().flatten().cloned());
        .         
       91 (0.0%)                  if let Some(proj) = projection
       45 (0.0%)                      && let lhs = clean_projection(proj.map_bound(|p| p.projection_ty), cx, None)
       20 (0.0%)                      && let Some((_, trait_did, name)) = lhs.projection()
        .                         {
       30 (0.0%)                      impl_trait_proj.entry(param_idx).or_default().push((
        .                                 trait_did,
       30 (0.0%)                          name,
        .                                 proj.map_bound(|p| p.term),
        .                             ));
       10 (0.0%)                  }
        .         
        .                         return None;
       54 (0.0%)              }
        .         
        .                     Some(pred)
        .                 })
        .                 .collect::<Vec<_>>();
        .         
  602,361 (0.0%)      for (idx, mut bounds) in impl_trait {
        .                 let mut has_sized = false;
        .                 bounds.retain(|b| {
       44 (0.0%)              if b.is_sized_bound(cx) {
        .                         has_sized = true;
        .                         false
        .                     } else {
        .                         true
        .                     }
        .                 });
       22 (0.0%)          if !has_sized {
        .                     bounds.push(GenericBound::maybe_sized(cx));
        .                 }
        .         
        .                 // Move trait bounds to the front.
       44 (0.0%)          bounds.sort_by_key(|b| !b.is_trait_bound());
        .         
        .                 // Add back a `Sized` bound if there are no *trait* bounds remaining (incl. `?Sized`).
        .                 // Since all potential trait bounds are at the front we can just check the first bound.
       11 (0.0%)          if bounds.first().map_or(true, |b| !b.is_trait_bound()) {
        .                     bounds.insert(0, GenericBound::sized(cx));
        .                 }
        .         
        .                 if let Some(proj) = impl_trait_proj.remove(&idx) {
       85 (0.0%)              for (trait_did, name, rhs) in proj {
        .                         let rhs = clean_middle_term(rhs, cx);
       45 (0.0%)                  simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);
        .                     }
        .                 }
        .         
        .                 cx.impl_trait_bounds.insert(idx.into(), bounds);
        .             }
        .         
        .             // Now that `cx.impl_trait_bounds` is populated, we can process
        .             // remaining predicates which could contain `impl Trait`.
        .             let where_predicates =
   60,957 (0.0%)          where_predicates.into_iter().flat_map(|p| clean_predicate(*p, cx)).collect();
        .         
  263,480 (0.0%)      let mut generics = Generics { params, where_predicates };
   75,280 (0.0%)      simplify::sized_bounds(cx, &mut generics);
  188,200 (0.0%)      generics.where_predicates = simplify::where_clauses(cx, generics.where_predicates);
  188,200 (0.0%)      generics
  301,120 (0.0%)  }
        .         
      234 (0.0%)  fn clean_ty_alias_inner_type<'tcx>(
        .             ty: Ty<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .             ret: &mut Vec<Item>,
        .         ) -> Option<TypeAliasInnerType> {
       52 (0.0%)      let ty::Adt(adt_def, args) = ty.kind() else {
        8 (0.0%)          return None;
        .             };
        .         
      110 (0.0%)      if !adt_def.did().is_local() {
        .                 cx.with_param_env(adt_def.did(), |cx| {
       72 (0.0%)              inline::build_impls(cx, adt_def.did(), None, ret);
        .                 });
        .             }
        .         
      220 (0.0%)      Some(if adt_def.is_enum() {
        .                 let variants: rustc_index::IndexVec<_, _> = adt_def
        .                     .variants()
        .                     .iter()
       30 (0.0%)              .map(|variant| clean_variant_def_with_args(variant, args, cx))
        .                     .collect();
        .         
       10 (0.0%)          if !adt_def.did().is_local() {
        9 (0.0%)              inline::record_extern_fqn(cx, adt_def.did(), ItemType::Enum);
        .                 }
        .         
       45 (0.0%)          TypeAliasInnerType::Enum {
        .                     variants,
        .                     is_non_exhaustive: adt_def.is_variant_list_non_exhaustive(),
        .                 }
        .             } else {
        .                 let variant = adt_def
        .                     .variants()
        .                     .iter()
        .                     .next()
        .                     .unwrap_or_else(|| bug!("a struct or union should always have one variant def"));
        .         
        .                 let fields: Vec<_> =
      187 (0.0%)              clean_variant_def_with_args(variant, args, cx).kind.inner_items().cloned().collect();
        .         
       17 (0.0%)          if adt_def.is_struct() {
       17 (0.0%)              if !adt_def.did().is_local() {
       18 (0.0%)                  inline::record_extern_fqn(cx, adt_def.did(), ItemType::Struct);
        .                     }
        .                     TypeAliasInnerType::Struct { ctor_kind: variant.ctor_kind(), fields }
        .                 } else {
        .                     if !adt_def.did().is_local() {
        .                         inline::record_extern_fqn(cx, adt_def.did(), ItemType::Union);
        .                     }
        .                     TypeAliasInnerType::Union { fields }
        .                 }
        .             })
      208 (0.0%)  }
        .         
        .         fn clean_proc_macro<'tcx>(
        .             item: &hir::Item<'tcx>,
        .             name: &mut Symbol,
        .             kind: MacroKind,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> ItemKind {
        .             let attrs = cx.tcx.hir().attrs(item.hir_id());
-- line 958 ----------------------------------------
-- line 982 ----------------------------------------
        .         fn clean_fn_or_proc_macro<'tcx>(
        .             item: &hir::Item<'tcx>,
        .             sig: &hir::FnSig<'tcx>,
        .             generics: &hir::Generics<'tcx>,
        .             body_id: hir::BodyId,
        .             name: &mut Symbol,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> ItemKind {
      396 (0.0%)      let attrs = cx.tcx.hir().attrs(item.hir_id());
        .             let macro_kind = attrs.iter().find_map(|a| {
       57 (0.0%)          if a.has_name(sym::proc_macro) {
        .                     Some(MacroKind::Bang)
        .                 } else if a.has_name(sym::proc_macro_derive) {
        .                     Some(MacroKind::Derive)
        .                 } else if a.has_name(sym::proc_macro_attribute) {
        .                     Some(MacroKind::Attr)
        .                 } else {
        .                     None
        .                 }
        .             });
        .             match macro_kind {
        .                 Some(kind) => clean_proc_macro(item, name, kind, cx),
        .                 None => {
      726 (0.0%)              let mut func = clean_function(cx, sig, generics, FunctionArgs::Body(body_id));
        .                     clean_fn_decl_legacy_const_generics(&mut func, attrs);
      198 (0.0%)              FunctionItem(func)
        .                 }
        .             }
        .         }
        .         
        .         /// This is needed to make it more "readable" when documenting functions using
        .         /// `rustc_legacy_const_generics`. More information in
        .         /// <https://github.com/rust-lang/rust/issues/83167>.
        .         fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attribute]) {
-- line 1015 ----------------------------------------
-- line 1042 ----------------------------------------
        .             }
        .         }
        .         
        .         enum FunctionArgs<'tcx> {
        .             Body(hir::BodyId),
        .             Names(&'tcx [Ident]),
        .         }
        .         
   10,296 (0.0%)  fn clean_function<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             sig: &hir::FnSig<'tcx>,
        .             generics: &hir::Generics<'tcx>,
        .             args: FunctionArgs<'tcx>,
        .         ) -> Box<Function> {
    4,680 (0.0%)      let (generics, decl) = enter_impl_trait(cx, |cx| {
        .                 // NOTE: generics must be cleaned before args
    2,808 (0.0%)          let generics = clean_generics(generics, cx);
    2,808 (0.0%)          let args = match args {
    1,802 (0.0%)              FunctionArgs::Body(body_id) => {
    2,703 (0.0%)                  clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id)
        .                     }
       35 (0.0%)              FunctionArgs::Names(names) => {
      210 (0.0%)                  clean_args_from_types_and_names(cx, sig.decl.inputs, names)
        .                     }
        .                 };
        .                 let decl = clean_fn_decl_with_args(cx, sig.decl, Some(&sig.header), args);
   11,232 (0.0%)          (generics, decl)
        .             });
        .             Box::new(Function { decl, generics })
    7,488 (0.0%)  }
        .         
      390 (0.0%)  fn clean_args_from_types_and_names<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             types: &[hir::Ty<'tcx>],
        .             names: &[Ident],
        .         ) -> Arguments {
       78 (0.0%)      Arguments {
        .                 values: types
        .                     .iter()
        .                     .enumerate()
      296 (0.0%)              .map(|(i, ty)| Argument {
      413 (0.0%)                  type_: clean_ty(ty, cx),
        .                         name: names
        .                             .get(i)
       74 (0.0%)                      .map(|ident| ident.name)
        .                             .filter(|ident| !ident.is_empty())
        .                             .unwrap_or(kw::Underscore),
        .                         is_const: false,
        .                     })
        .                     .collect(),
        .             }
      312 (0.0%)  }
        .         
        .         fn clean_args_from_types_and_body_id<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             types: &[hir::Ty<'tcx>],
        .             body_id: hir::BodyId,
        .         ) -> Arguments {
    1,802 (0.0%)      let body = cx.tcx.hir().body(body_id);
        .         
        .             Arguments {
        .                 values: types
        .                     .iter()
        .                     .enumerate()
        .                     .map(|(i, ty)| Argument {
    5,500 (0.0%)                  name: name_from_pat(body.params[i].pat),
    5,500 (0.0%)                  type_: clean_ty(ty, cx),
        .                         is_const: false,
        .                     })
        .                     .collect(),
        .             }
        .         }
        .         
        .         fn clean_fn_decl_with_args<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             decl: &hir::FnDecl<'tcx>,
        .             header: Option<&hir::FnHeader>,
        .             args: Arguments,
        .         ) -> FnDecl {
    1,880 (0.0%)      let mut output = match decl.output {
    3,224 (0.0%)          hir::FnRetTy::Return(typ) => clean_ty(typ, cx),
      800 (0.0%)          hir::FnRetTy::DefaultReturn(..) => Type::Tuple(Vec::new()),
        .             };
        .             if let Some(header) = header
        .                 && header.is_async()
        .             {
       75 (0.0%)          output = output.sugared_async_return_type();
        .             }
    8,476 (0.0%)      FnDecl { inputs: args, output, c_variadic: decl.c_variadic }
        .         }
        .         
  197,010 (0.0%)  fn clean_poly_fn_sig<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             did: Option<DefId>,
        .             sig: ty::PolyFnSig<'tcx>,
        .         ) -> FnDecl {
   17,907 (0.0%)      let mut names = did.map_or(&[] as &[_], |did| cx.tcx.fn_arg_names(did)).iter();
        .         
        .             // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,
        .             // but shouldn't change any code meaning.
  197,010 (0.0%)      let mut output = clean_middle_ty(sig.output(), cx, None, None);
        .         
        .             // If the return type isn't an `impl Trait`, we can safely assume that this
        .             // function isn't async without needing to execute the query `asyncness` at
        .             // all which gives us a noticeable performance boost.
   71,634 (0.0%)      if let Some(did) = did
        .                 && let Type::ImplTrait(_) = output
        .                 && cx.tcx.asyncness(did).is_async()
        .             {
        .                 output = output.sugared_async_return_type();
        .             }
        .         
  125,370 (0.0%)      FnDecl {
        .                 output,
   35,820 (0.0%)          c_variadic: sig.skip_binder().c_variadic,
        .                 inputs: Arguments {
        .                     values: sig
        .                         .inputs()
        .                         .iter()
  113,712 (0.0%)                  .map(|t| Argument {
  308,790 (0.0%)                      type_: clean_middle_ty(t.map_bound(|t| *t), cx, None, None),
        .                             name: names
        .                                 .next()
   28,425 (0.0%)                          .map(|i| i.name)
        .                                 .filter(|i| !i.is_empty())
        .                                 .unwrap_or(kw::Underscore),
        .                             is_const: false,
        .                         })
        .                         .collect(),
        .                 },
        .             }
  143,280 (0.0%)  }
        .         
        .         fn clean_trait_ref<'tcx>(trait_ref: &hir::TraitRef<'tcx>, cx: &mut DocContext<'tcx>) -> Path {
    2,652 (0.0%)      let path = clean_path(trait_ref.path, cx);
    3,462 (0.0%)      register_res(cx, path.res);
    4,616 (0.0%)      path
        .         }
        .         
        .         fn clean_poly_trait_ref<'tcx>(
        .             poly_trait_ref: &hir::PolyTraitRef<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> PolyTrait {
   11,245 (0.0%)      PolyTrait {
        .                 trait_: clean_trait_ref(&poly_trait_ref.trait_ref, cx),
    2,308 (0.0%)          generic_params: poly_trait_ref
        .                     .bound_generic_params
        .                     .iter()
        .                     .filter(|p| !is_elided_lifetime(p))
       12 (0.0%)              .map(|x| clean_generic_param(cx, None, x))
        .                     .collect(),
        .             }
        .         }
        .         
        .         fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext<'tcx>) -> Item {
       68 (0.0%)      let local_did = trait_item.owner_id.to_def_id();
        .             cx.with_param_env(local_did, |cx| {
      882 (0.0%)          let inner = match trait_item.kind {
        .                     hir::TraitItemKind::Const(ty, Some(default)) => {
        .                         let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));
        .                         AssocConstItem(
        .                             generics,
        .                             Box::new(clean_ty(ty, cx)),
        .                             ConstantKind::Local { def_id: local_did, body: default },
        .                         )
        .                     }
        .                     hir::TraitItemKind::Const(ty, None) => {
        5 (0.0%)                  let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));
        8 (0.0%)                  TyAssocConstItem(generics, Box::new(clean_ty(ty, cx)))
        .                     }
        6 (0.0%)              hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {
       42 (0.0%)                  let m = clean_function(cx, sig, trait_item.generics, FunctionArgs::Body(body));
        .                         MethodItem(m, None)
        .                     }
       35 (0.0%)              hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {
      245 (0.0%)                  let m = clean_function(cx, sig, trait_item.generics, FunctionArgs::Names(names));
        .                         TyMethodItem(m)
        .                     }
        .                     hir::TraitItemKind::Type(bounds, Some(default)) => {
        .                         let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));
        .                         let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();
        .                         let item_type =
        .                             clean_middle_ty(ty::Binder::dummy(lower_ty(cx.tcx, default)), cx, None, None);
        .                         AssocTypeItem(
-- line 1225 ----------------------------------------
-- line 1228 ----------------------------------------
        .                                 generics,
        .                                 inner_type: None,
        .                                 item_type: Some(item_type),
        .                             }),
        .                             bounds,
        .                         )
        .                     }
        .                     hir::TraitItemKind::Type(bounds, None) => {
      156 (0.0%)                  let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));
      234 (0.0%)                  let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();
      182 (0.0%)                  TyAssocTypeItem(generics, bounds)
        .                     }
        .                 };
    1,564 (0.0%)          Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx)
        .             })
        .         }
        .         
   10,054 (0.0%)  pub(crate) fn clean_impl_item<'tcx>(
        .             impl_: &hir::ImplItem<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Item {
      914 (0.0%)      let local_did = impl_.owner_id.to_def_id();
        .             cx.with_param_env(local_did, |cx| {
   10,038 (0.0%)          let inner = match impl_.kind {
       24 (0.0%)              hir::ImplItemKind::Const(ty, expr) => {
       40 (0.0%)                  let generics = clean_generics(impl_.generics, cx);
        8 (0.0%)                  let default = ConstantKind::Local { def_id: local_did, body: expr };
       64 (0.0%)                  AssocConstItem(generics, Box::new(clean_ty(ty, cx)), default)
        .                     }
      829 (0.0%)              hir::ImplItemKind::Fn(ref sig, body) => {
    7,461 (0.0%)                  let m = clean_function(cx, sig, impl_.generics, FunctionArgs::Body(body));
      829 (0.0%)                  let defaultness = cx.tcx.defaultness(impl_.owner_id);
        .                         MethodItem(m, Some(defaultness))
        .                     }
      154 (0.0%)              hir::ImplItemKind::Type(hir_ty) => {
      231 (0.0%)                  let type_ = clean_ty(hir_ty, cx);
      308 (0.0%)                  let generics = clean_generics(impl_.generics, cx);
        .                         let item_type =
      924 (0.0%)                      clean_middle_ty(ty::Binder::dummy(lower_ty(cx.tcx, hir_ty)), cx, None, None);
        .                         AssocTypeItem(
       77 (0.0%)                      Box::new(TypeAlias {
      308 (0.0%)                          type_,
      154 (0.0%)                          generics,
        .                                 inner_type: None,
      308 (0.0%)                          item_type: Some(item_type),
        .                             }),
        .                             Vec::new(),
        .                         )
        .                     }
        .                 };
        .         
   14,624 (0.0%)          Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx)
        .             })
    7,312 (0.0%)  }
        .         
  228,830 (0.0%)  pub(crate) fn clean_middle_assoc_item<'tcx>(
        .             assoc_item: &ty::AssocItem,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Item {
   22,883 (0.0%)      let tcx = cx.tcx;
  159,897 (0.0%)      let kind = match assoc_item.kind {
        .                 ty::AssocKind::Const => {
    1,420 (0.0%)              let ty = Box::new(clean_middle_ty(
      284 (0.0%)                  ty::Binder::dummy(tcx.type_of(assoc_item.def_id).instantiate_identity()),
        .                         cx,
        .                         Some(assoc_item.def_id),
      284 (0.0%)                  None,
        .                     ));
        .         
      710 (0.0%)              let mut generics = clean_ty_generics(
        .                         cx,
        .                         tcx.generics_of(assoc_item.def_id),
        .                         tcx.explicit_predicates_of(assoc_item.def_id),
        .                     );
      142 (0.0%)              simplify::move_bounds_to_generic_parameters(&mut generics);
        .         
      284 (0.0%)              let provided = match assoc_item.container {
        .                         ty::ImplContainer => true,
        .                         ty::TraitContainer => tcx.defaultness(assoc_item.def_id).has_value(),
        .                     };
        .                     if provided {
        .                         AssocConstItem(generics, ty, ConstantKind::Extern { def_id: assoc_item.def_id })
        .                     } else {
        .                         TyAssocConstItem(generics, ty)
        .                     }
        .                 }
        .                 ty::AssocKind::Fn => {
  143,256 (0.0%)              let mut item = inline::build_function(cx, assoc_item.def_id);
        .         
   35,814 (0.0%)              if assoc_item.fn_has_self_parameter {
   31,288 (0.0%)                  let self_ty = match assoc_item.container {
        .                             ty::ImplContainer => {
        .                                 tcx.type_of(assoc_item.container_id(tcx)).instantiate_identity()
        .                             }
      811 (0.0%)                      ty::TraitContainer => tcx.types.self_param,
        .                         };
        .                         let self_arg_ty =
        .                             tcx.fn_sig(assoc_item.def_id).instantiate_identity().input(0).skip_binder();
   15,644 (0.0%)                  if self_arg_ty == self_ty {
   64,240 (0.0%)                      item.decl.inputs.values[0].type_ = Generic(kw::SelfUpper);
   18,440 (0.0%)                  } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {
    8,814 (0.0%)                      if ty == self_ty {
   26,424 (0.0%)                          match item.decl.inputs.values[0].type_ {
   61,656 (0.0%)                              BorrowedRef { ref mut type_, .. } => **type_ = Generic(kw::SelfUpper),
        .                                     _ => unreachable!(),
        .                                 }
        .                             }
        .                         }
        .                     }
        .         
   35,814 (0.0%)              let provided = match assoc_item.container {
        .                         ty::ImplContainer => true,
      843 (0.0%)                  ty::TraitContainer => assoc_item.defaultness(tcx).has_value(),
        .                     };
      843 (0.0%)              if provided {
        .                         let defaultness = match assoc_item.container {
   17,064 (0.0%)                      ty::ImplContainer => Some(assoc_item.defaultness(tcx)),
        .                             ty::TraitContainer => None,
        .                         };
        .                         MethodItem(item, defaultness)
        .                     } else {
        .                         TyMethodItem(item)
        .                     }
        .                 }
        .                 ty::AssocKind::Type => {
    9,668 (0.0%)              let my_name = assoc_item.name;
        .         
        .                     fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {
      150 (0.0%)                  match (&param.kind, arg) {
        .                             (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))
        .                                 if *ty == param.name =>
        .                             {
        .                                 true
        .                             }
        .                             (GenericParamDefKind::Lifetime { .. }, GenericArg::Lifetime(Lifetime(lt)))
        .                                 if *lt == param.name =>
        .                             {
-- line 1364 ----------------------------------------
-- line 1367 ----------------------------------------
        .                             (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => match &c.kind {
        .                                 ConstantKind::TyConst { expr } => **expr == *param.name.as_str(),
        .                                 _ => false,
        .                             },
        .                             _ => false,
        .                         }
        .                     }
        .         
    9,668 (0.0%)              let mut predicates = tcx.explicit_predicates_of(assoc_item.def_id).predicates;
   33,838 (0.0%)              if let ty::TraitContainer = assoc_item.container {
        .                         let bounds =
        .                             tcx.explicit_item_bounds(assoc_item.def_id).instantiate_identity_iter_copied();
      525 (0.0%)                  predicates = tcx.arena.alloc_from_iter(bounds.chain(predicates.iter().copied()));
        .                     }
   38,672 (0.0%)              let mut generics = clean_ty_generics(
        .                         cx,
        .                         tcx.generics_of(assoc_item.def_id),
        .                         ty::GenericPredicates { parent: None, predicates },
        .                     );
    9,668 (0.0%)              simplify::move_bounds_to_generic_parameters(&mut generics);
        .         
    4,834 (0.0%)              if let ty::TraitContainer = assoc_item.container {
        .                         // Move bounds that are (likely) directly attached to the associated type
        .                         // from the where-clause to the associated type.
        .                         // There is no guarantee that this is what the user actually wrote but we have
        .                         // no way of knowing.
        .                         let mut bounds: Vec<GenericBound> = Vec::new();
      790 (0.0%)                  generics.where_predicates.retain_mut(|pred| match *pred {
        .                             WherePredicate::BoundPredicate {
        .                                 ty:
        .                                     QPath(box QPathData {
        .                                         ref assoc,
        .                                         ref self_type,
        .                                         trait_: Some(ref trait_),
        .                                         ..
        .                                     }),
        .                                 bounds: ref mut pred_bounds,
        .                                 ..
        .                             } => {
       87 (0.0%)                          if assoc.name != my_name {
        .                                     return true;
        .                                 }
        .                                 if trait_.def_id() != assoc_item.container_id(tcx) {
        .                                     return true;
        .                                 }
      261 (0.0%)                          match *self_type {
      174 (0.0%)                              Generic(ref s) if *s == kw::SelfUpper => {}
        .                                     _ => return true,
        .                                 }
      174 (0.0%)                          match &assoc.args {
        .                                     GenericArgs::AngleBracketed { args, bindings } => {
      174 (0.0%)                                  if !bindings.is_empty()
       42 (0.0%)                                      || generics
        .                                                 .params
        .                                                 .iter()
       87 (0.0%)                                          .zip(args.iter())
        .                                                 .any(|(param, arg)| !param_eq_arg(param, arg))
        .                                         {
        .                                             return true;
        .                                         }
        .                                     }
        .                                     GenericArgs::Parenthesized { .. } => {
        .                                         // The only time this happens is if we're inside the rustdoc for Fn(),
        .                                         // which only has one associated type, which is not a GAT, so whatever.
-- line 1430 ----------------------------------------
-- line 1435 ----------------------------------------
        .                             }
        .                             _ => true,
        .                         });
        .                         // Our Sized/?Sized bound didn't get handled when creating the generics
        .                         // because we didn't actually get our whole set of bounds until just now
        .                         // (some of them may have come from the trait). If we do have a sized
        .                         // bound, we remove it, and if we don't then we add the `?Sized` bound
        .                         // at the end.
       90 (0.0%)                  match bounds.iter().position(|b| b.is_sized_bound(cx)) {
        .                             Some(i) => {
      261 (0.0%)                          bounds.remove(i);
        .                             }
        .                             None => bounds.push(GenericBound::maybe_sized(cx)),
        .                         }
        .         
        .                         if tcx.defaultness(assoc_item.def_id).has_value() {
        .                             AssocTypeItem(
        .                                 Box::new(TypeAlias {
        .                                     type_: clean_middle_ty(
-- line 1453 ----------------------------------------
-- line 1460 ----------------------------------------
        .                                     ),
        .                                     generics,
        .                                     inner_type: None,
        .                                     item_type: None,
        .                                 }),
        .                                 bounds,
        .                             )
        .                         } else {
      720 (0.0%)                      TyAssocTypeItem(generics, bounds)
        .                         }
        .                     } else {
        .                         AssocTypeItem(
   37,952 (0.0%)                      Box::new(TypeAlias {
   42,696 (0.0%)                          type_: clean_middle_ty(
        .                                     ty::Binder::dummy(
        .                                         tcx.type_of(assoc_item.def_id).instantiate_identity(),
        .                                     ),
        .                                     cx,
        .                                     Some(assoc_item.def_id),
    4,744 (0.0%)                              None,
        .                                 ),
    9,488 (0.0%)                          generics,
        .                                 inner_type: None,
        .                                 item_type: None,
        .                             }),
        .                             // Associated types inside trait or inherent impls are not allowed to have
        .                             // item bounds. Thus we don't attempt to move any bounds there.
        .                             Vec::new(),
        .                         )
        .                     }
        .                 }
        .             };
        .         
  434,777 (0.0%)      Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx)
  183,064 (0.0%)  }
        .         
    4,240 (0.0%)  fn first_non_private_clean_path<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             path: &hir::Path<'tcx>,
        .             new_path_segments: &'tcx [hir::PathSegment<'tcx>],
        .             new_path_span: rustc_span::Span,
        .         ) -> Path {
        .             let new_hir_path =
    1,696 (0.0%)          hir::Path { segments: new_path_segments, res: path.res, span: new_path_span };
        .             let mut new_clean_path = clean_path(&new_hir_path, cx);
        .             // In here we need to play with the path data one last time to provide it the
        .             // missing `args` and `res` of the final `Path` we get, which, since it comes
        .             // from a re-export, doesn't have the generics that were originally there, so
        .             // we add them by hand.
      424 (0.0%)      if let Some(path_last) = path.segments.last().as_ref()
        .                 && let Some(new_path_last) = new_clean_path.segments[..].last_mut()
        .                 && let Some(path_last_args) = path_last.args.as_ref()
        .                 && path_last.args.is_some()
        .             {
        .                 assert!(new_path_last.args.is_empty());
    1,976 (0.0%)          new_path_last.args = clean_generic_args(path_last_args, cx);
        .             }
    2,544 (0.0%)      new_clean_path
    2,968 (0.0%)  }
        .         
        .         /// The goal of this function is to return the first `Path` which is not private (ie not private
        .         /// or `doc(hidden)`). If it's not possible, it'll return the "end type".
        .         ///
        .         /// If the path is not a re-export or is public, it'll return `None`.
        .         fn first_non_private<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             hir_id: hir::HirId,
        .             path: &hir::Path<'tcx>,
        .         ) -> Option<Path> {
        .             let target_def_id = path.res.opt_def_id()?;
        .             let (parent_def_id, ident) = match &path.segments {
   36,408 (0.0%)          [] => return None,
        .                 // Relative paths are available in the same scope as the owner.
   15,824 (0.0%)          [leaf] => (cx.tcx.local_parent(hir_id.owner.def_id), leaf.ident),
        .                 // So are self paths.
    1,722 (0.0%)          [parent, leaf] if parent.ident.name == kw::SelfLower => {
        .                     (cx.tcx.local_parent(hir_id.owner.def_id), leaf.ident)
        .                 }
        .                 // Crate paths are not. We start from the crate root.
        .                 [parent, leaf] if matches!(parent.ident.name, kw::Crate | kw::PathRoot) => {
      610 (0.0%)              (LOCAL_CRATE.as_def_id().as_local()?, leaf.ident)
        .                 }
        .                 [parent, leaf] if parent.ident.name == kw::Super => {
        .                     let parent_mod = cx.tcx.parent_module(hir_id);
        .                     if let Some(super_parent) = cx.tcx.opt_local_parent(parent_mod.to_local_def_id()) {
        .                         (super_parent, leaf.ident)
        .                     } else {
        .                         // If we can't find the parent of the parent, then the parent is already the crate.
        .                         (LOCAL_CRATE.as_def_id().as_local()?, leaf.ident)
        .                     }
        .                 }
        .                 // Absolute paths are not. We start from the parent of the item.
    2,676 (0.0%)          [.., parent, leaf] => (parent.res.opt_def_id()?.as_local()?, leaf.ident),
        .             };
        .             // First we try to get the `DefId` of the item.
        .             for child in
   12,798 (0.0%)          cx.tcx.module_children_local(parent_def_id).iter().filter(move |c| c.ident == ident)
        .             {
    4,748 (0.0%)          if let Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) = child.res {
        .                     continue;
        .                 }
        .         
        .                 if let Some(def_id) = child.res.opt_def_id()
    1,118 (0.0%)              && target_def_id == def_id
        .                 {
        .                     let mut last_path_res = None;
        .                     'reexps: for reexp in child.reexport_chain.iter() {
        .                         if let Some(use_def_id) = reexp.id()
        .                             && let Some(local_use_def_id) = use_def_id.as_local()
    1,998 (0.0%)                      && let hir::Node::Item(item) = cx.tcx.hir_node_by_def_id(local_use_def_id)
    1,332 (0.0%)                      && !item.ident.name.is_empty()
    1,986 (0.0%)                      && let hir::ItemKind::Use(path, _) = item.kind
        .                         {
        .                             for res in &path.res {
    5,958 (0.0%)                          if let Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) = res {
        .                                     continue;
        .                                 }
    1,324 (0.0%)                          if (cx.render_options.document_hidden ||
    1,986 (0.0%)                              !cx.tcx.is_doc_hidden(use_def_id)) &&
        .                                     // We never check for "cx.render_options.document_private"
        .                                     // because if a re-export is not fully public, it's never
        .                                     // documented.
    1,986 (0.0%)                              cx.tcx.local_visibility(local_use_def_id).is_public()
        .                                 {
        .                                     break 'reexps;
        .                                 }
        .                                 last_path_res = Some((path, res));
        .                                 continue 'reexps;
        .                             }
        .                         }
        .                     }
    3,332 (0.0%)              if !child.reexport_chain.is_empty() {
        .                         // So in here, we use the data we gathered from iterating the reexports. If
        .                         // `last_path_res` is set, it can mean two things:
        .                         //
        .                         // 1. We found a public reexport.
        .                         // 2. We didn't find a public reexport so it's the "end type" path.
    1,096 (0.0%)                  if let Some((new_path, _)) = last_path_res {
    3,392 (0.0%)                      return Some(first_non_private_clean_path(
        .                                 cx,
        .                                 path,
    2,120 (0.0%)                          new_path.segments,
        .                                 new_path.span,
        .                             ));
        .                         }
        .                         // If `last_path_res` is `None`, it can mean two things:
        .                         //
        .                         // 1. The re-export is public, no need to change anything, just use the path as is.
        .                         // 2. Nothing was found, so let's just return the original path.
        .                         return None;
        .                     }
        .                 }
        .             }
        .             None
        .         }
        .         
   51,504 (0.0%)  fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {
        .             let hir::Ty { hir_id, span, ref kind } = *hir_ty;
   12,876 (0.0%)      let hir::TyKind::Path(qpath) = kind else { unreachable!() };
        .         
   38,374 (0.0%)      match qpath {
        .                 hir::QPath::Resolved(None, path) => {
   40,266 (0.0%)              if let Res::Def(DefKind::TyParam, did) = path.res {
       72 (0.0%)                  if let Some(new_ty) = cx.args.get(&did).and_then(|p| p.as_ty()).cloned() {
      216 (0.0%)                      return new_ty;
        .                         }
    5,880 (0.0%)                  if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {
      120 (0.0%)                      return ImplTrait(bounds);
        .                         }
        .                     }
        .         
      400 (0.0%)              if let Some(expanded) = maybe_expand_private_type_alias(cx, path) {
      480 (0.0%)                  expanded
        .                     } else {
        .                         // First we check if it's a private re-export.
    3,392 (0.0%)                  let path = if let Some(path) = first_non_private(cx, hir_id, &path) {
        .                             path
        .                         } else {
        .                             clean_path(path, cx)
        .                         };
   45,006 (0.0%)                  resolve_type(cx, path)
        .                     }
   12,082 (0.0%)          }
        .                 hir::QPath::Resolved(Some(qself), p) => {
        .                     // Try to normalize `<X as Y>::T` to a type
       36 (0.0%)              let ty = lower_ty(cx.tcx, hir_ty);
        .                     // `hir_to_ty` can return projection types with escaping vars for GATs, e.g. `<() as Trait>::Gat<'_>`
       12 (0.0%)              if !ty.has_escaping_bound_vars()
       84 (0.0%)                  && let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty))
        .                     {
        .                         return clean_middle_ty(normalized_value, cx, None, None);
        .                     }
        .         
       48 (0.0%)              let trait_segments = &p.segments[..p.segments.len() - 1];
       96 (0.0%)              let trait_def = cx.tcx.associated_item(p.res.def_id()).container_id(cx.tcx);
       96 (0.0%)              let trait_ = self::Path {
        .                         res: Res::Def(DefKind::Trait, trait_def),
        .                         segments: trait_segments.iter().map(|x| clean_path_segment(x, cx)).collect(),
        .                     };
       24 (0.0%)              register_res(cx, trait_.res);
       24 (0.0%)              let self_def_id = DefId::local(qself.hir_id.owner.def_id.local_def_index);
       24 (0.0%)              let self_type = clean_ty(qself, cx);
        .                     let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);
       84 (0.0%)              Type::QPath(Box::new(QPathData {
        .                         assoc: clean_path_segment(p.segments.last().expect("segments were empty"), cx),
        .                         should_show_cast,
       48 (0.0%)                  self_type,
       48 (0.0%)                  trait_: Some(trait_),
        .                     }))
        .                 }
        .                 hir::QPath::TypeRelative(qself, segment) => {
    1,270 (0.0%)              let ty = lower_ty(cx.tcx, hir_ty);
    1,016 (0.0%)              let self_type = clean_ty(qself, cx);
        .         
    3,048 (0.0%)              let (trait_, should_show_cast) = match ty.kind() {
        .                         ty::Alias(ty::Projection, proj) => {
    2,032 (0.0%)                      let res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);
        .                             let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);
      508 (0.0%)                      register_res(cx, trait_.res);
        .                             let self_def_id = res.opt_def_id();
        .                             let should_show_cast =
        .                                 compute_should_show_cast(self_def_id, &trait_, &self_type);
        .         
    1,524 (0.0%)                      (Some(trait_), should_show_cast)
        .                         }
        .                         ty::Alias(ty::Inherent, _) => (None, false),
        .                         // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.
        .                         ty::Error(_) => return Type::Infer,
        .                         _ => bug!("clean: expected associated type, found `{ty:?}`"),
        .                     };
        .         
    1,778 (0.0%)              Type::QPath(Box::new(QPathData {
      254 (0.0%)                  assoc: clean_path_segment(segment, cx),
        .                         should_show_cast,
    1,016 (0.0%)                  self_type,
    1,016 (0.0%)                  trait_,
        .                     }))
        .                 }
        .                 hir::QPath::LangItem(..) => bug!("clean: requiring documentation of lang item"),
        .             }
   51,504 (0.0%)  }
        .         
        .         fn maybe_expand_private_type_alias<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             path: &hir::Path<'tcx>,
        .         ) -> Option<Type> {
   20,921 (0.0%)      let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };
        .             // Substitute private type aliases
        .             let def_id = def_id.as_local()?;
      480 (0.0%)      let alias = if !cx.cache.effective_visibilities.is_exported(cx.tcx, def_id.to_def_id())
      160 (0.0%)          && !cx.current_type_aliases.contains_key(&def_id.to_def_id())
        .             {
      240 (0.0%)          &cx.tcx.hir().expect_item(def_id).kind
        .             } else {
        .                 return None;
        .             };
      400 (0.0%)      let hir::ItemKind::TyAlias(ty, generics) = alias else { return None };
        .         
      160 (0.0%)      let provided_params = &path.segments.last().expect("segments were empty");
        .             let mut args = DefIdMap::default();
        .             let generic_args = provided_params.args();
        .         
        .             let mut indices: hir::GenericParamCount = Default::default();
      160 (0.0%)      for param in generics.params.iter() {
      170 (0.0%)          match param.kind {
        .                     hir::GenericParamKind::Lifetime { .. } => {
        .                         let mut j = 0;
        .                         let lifetime = generic_args.args.iter().find_map(|arg| match arg {
        .                             hir::GenericArg::Lifetime(lt) => {
        .                                 if indices.lifetimes == j {
        .                                     return Some(lt);
        .                                 }
        .                                 j += 1;
-- line 1732 ----------------------------------------
-- line 1741 ----------------------------------------
        .                                 Lifetime::elided()
        .                             };
        .                             args.insert(param.def_id.to_def_id(), GenericArg::Lifetime(lt));
        .                         }
        .                         indices.lifetimes += 1;
        .                     }
        .                     hir::GenericParamKind::Type { ref default, .. } => {
        .                         let mut j = 0;
      316 (0.0%)                  let type_ = generic_args.args.iter().find_map(|arg| match arg {
        .                             hir::GenericArg::Type(ty) => {
      112 (0.0%)                          if indices.types == j {
        .                                     return Some(*ty);
        .                                 }
       44 (0.0%)                          j += 1;
        .                                 None
        .                             }
        .                             _ => None,
        .                         });
        .                         if let Some(ty) = type_.or(*default) {
      272 (0.0%)                      args.insert(param.def_id.to_def_id(), GenericArg::Type(clean_ty(ty, cx)));
        .                         }
       68 (0.0%)                  indices.types += 1;
        .                     }
        .                     // FIXME(#82852): Instantiate const parameters.
        .                     hir::GenericParamKind::Const { .. } => {}
        .                 }
        .             }
        .         
      880 (0.0%)      Some(cx.enter_alias(args, def_id.to_def_id(), |cx| {
      400 (0.0%)          cx.with_param_env(def_id.to_def_id(), |cx| clean_ty(&ty, cx))
        .             }))
        .         }
        .         
   71,451 (0.0%)  pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {
        .             use rustc_hir::*;
        .         
   47,634 (0.0%)      match ty.kind {
        .                 TyKind::Never => Primitive(PrimitiveType::Never),
        .                 TyKind::Ptr(ref m) => RawPointer(m.mutbl, Box::new(clean_ty(m.ty, cx))),
        .                 TyKind::Ref(ref l, ref m) => {
    1,664 (0.0%)              let lifetime = if l.is_anonymous() { None } else { Some(clean_lifetime(*l, cx)) };
   11,540 (0.0%)              BorrowedRef { lifetime, mutability: m.mutbl, type_: Box::new(clean_ty(m.ty, cx)) }
        .                 }
      266 (0.0%)          TyKind::Slice(ty) => Slice(Box::new(clean_ty(ty, cx))),
        .                 TyKind::Pat(ty, pat) => Type::Pat(Box::new(clean_ty(ty, cx)), format!("{pat:?}").into()),
        2 (0.0%)          TyKind::Array(ty, ref length) => {
        4 (0.0%)              let length = match length {
        .                         hir::ArrayLen::Infer(..) => "_".to_string(),
        .                         hir::ArrayLen::Body(anon_const) => {
        .                             // NOTE(min_const_generics): We can't use `const_eval_poly` for constants
        .                             // as we currently do not supply the parent generics to anonymous constants
        .                             // but do allow `ConstKind::Param`.
        .                             //
        .                             // `const_eval_poly` tries to first substitute generic parameters which
        .                             // results in an ICE while manually constructing the constant and using `eval`
        .                             // does nothing for `ConstKind::Param`.
       12 (0.0%)                      let ct = ty::Const::from_anon_const(cx.tcx, anon_const.def_id);
        2 (0.0%)                      let param_env = cx.tcx.param_env(anon_const.def_id);
       16 (0.0%)                      print_const(cx, ct.normalize(cx.tcx, param_env))
        .                         }
        .                     };
        .         
       20 (0.0%)              Array(Box::new(clean_ty(ty, cx)), length.into())
        .                 }
    1,591 (0.0%)          TyKind::Tup(tys) => Tuple(tys.iter().map(|ty| clean_ty(ty, cx)).collect()),
       30 (0.0%)          TyKind::OpaqueDef(item_id, _, _) => {
       60 (0.0%)              let item = cx.tcx.hir().item(item_id);
       60 (0.0%)              if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {
      500 (0.0%)                  ImplTrait(ty.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect())
        .                     } else {
        .                         unreachable!()
        .                     }
        .                 }
   57,942 (0.0%)          TyKind::Path(_) => clean_qpath(ty, cx),
      106 (0.0%)          TyKind::TraitObject(bounds, ref lifetime, _) => {
        .                     let bounds = bounds.iter().map(|bound| clean_poly_trait_ref(bound, cx)).collect();
        .                     let lifetime =
      110 (0.0%)                  if !lifetime.is_elided() { Some(clean_lifetime(*lifetime, cx)) } else { None };
      636 (0.0%)              DynTrait(bounds, lifetime)
        .                 }
       20 (0.0%)          TyKind::BareFn(barefn) => BareFunction(Box::new(clean_bare_fn_ty(barefn, cx))),
        .                 // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.
        .                 TyKind::Infer | TyKind::Err(_) | TyKind::Typeof(..) | TyKind::InferDelegation(..) => Infer,
        .                 TyKind::AnonAdt(..) => {
        .                     unimplemented!("Anonymous structs or unions are not supported yet")
        .                 }
        .             }
   12,008 (0.0%)  }
        .         
        .         /// Returns `None` if the type could not be normalized
1,942,160 (0.0%)  fn normalize<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             ty: ty::Binder<'tcx, Ty<'tcx>>,
        .         ) -> Option<ty::Binder<'tcx, Ty<'tcx>>> {
        .             // HACK: low-churn fix for #79459 while we wait for a trait normalization fix
  582,648 (0.0%)      if !cx.tcx.sess.opts.unstable_opts.normalize_docs {
        .                 return None;
        .             }
        .         
        .             use crate::rustc_trait_selection::infer::TyCtxtInferExt;
        .             use crate::rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;
        .             use rustc_middle::traits::ObligationCause;
        .         
        .             // Try to normalize `<X as Y>::T` to a type
-- line 1844 ----------------------------------------
-- line 1852 ----------------------------------------
        .                     debug!("normalized {ty:?} to {normalized_value:?}");
        .                     Some(normalized_value)
        .                 }
        .                 Err(err) => {
        .                     debug!("failed to normalize {ty:?}: {err:?}");
        .                     None
        .                 }
        .             }
1,942,160 (0.0%)  }
        .         
        .         fn clean_trait_object_lifetime_bound<'tcx>(
        .             region: ty::Region<'tcx>,
        .             container: Option<ContainerTy<'_, 'tcx>>,
        .             preds: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,
        .             tcx: TyCtxt<'tcx>,
        .         ) -> Option<Lifetime> {
      356 (0.0%)      if can_elide_trait_object_lifetime_bound(region, container, preds, tcx) {
        .                 return None;
        .             }
        .         
        .             // Since there is a semantic difference between an implicitly elided (i.e. "defaulted") object
        .             // lifetime and an explicitly elided object lifetime (`'_`), we intentionally don't hide the
        .             // latter contrary to `clean_middle_region`.
      444 (0.0%)      match *region {
        .                 ty::ReStatic => Some(Lifetime::statik()),
      116 (0.0%)          ty::ReEarlyParam(region) if region.name != kw::Empty => Some(Lifetime(region.name)),
        .                 ty::ReBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) if name != kw::Empty => {
        .                     Some(Lifetime(name))
        .                 }
        .                 ty::ReEarlyParam(_)
        .                 | ty::ReBound(..)
        .                 | ty::ReLateParam(_)
        .                 | ty::ReVar(_)
        .                 | ty::RePlaceholder(_)
-- line 1885 ----------------------------------------
-- line 1901 ----------------------------------------
        .             let default = container
        .                 .map_or(ObjectLifetimeDefault::Empty, |container| container.object_lifetime_default(tcx));
        .         
        .             // > If there is a unique bound from the containing type then that is the default
        .             // If there is a default object lifetime and the given region is lexically equal to it, elide it.
        .             match default {
        .                 ObjectLifetimeDefault::Static => return *region == ty::ReStatic,
        .                 // FIXME(fmease): Don't compare lexically but respect de Bruijn indices etc. to handle shadowing correctly.
      476 (0.0%)          ObjectLifetimeDefault::Arg(default) => return region.get_name() == default.get_name(),
        .                 // > If there is more than one bound from the containing type then an explicit bound must be specified
        .                 // Due to ambiguity there is no default trait-object lifetime and thus elision is impossible.
        .                 // Don't elide the lifetime.
        .                 ObjectLifetimeDefault::Ambiguous => return false,
        .                 // There is no meaningful bound. Further processing is needed...
        .                 ObjectLifetimeDefault::Empty => {}
        .             }
        .         
        .             // > If neither of those rules apply, then the bounds on the trait are used:
      590 (0.0%)      match *object_region_bounds(tcx, preds) {
        .                 // > If the trait has no lifetime bounds, then the lifetime is inferred in expressions
        .                 // > and is 'static outside of expressions.
        .                 // FIXME: If we are in an expression context (i.e. fn bodies and const exprs) then the default is
        .                 // `'_` and not `'static`. Only if we are in a non-expression one, the default is `'static`.
        .                 // Note however that at the time of this writing it should be fine to disregard this subtlety
        .                 // as we neither render const exprs faithfully anyway (hiding them in some places or using `_` instead)
        .                 // nor show the contents of fn bodies.
      382 (0.0%)          [] => *region == ty::ReStatic,
        .                 // > If the trait is defined with a single lifetime bound then that bound is used.
        .                 // > If 'static is used for any lifetime bound then 'static is used.
        .                 // FIXME(fmease): Don't compare lexically but respect de Bruijn indices etc. to handle shadowing correctly.
      225 (0.0%)          [object_region] => object_region.get_name() == region.get_name(),
        .                 // There are several distinct trait regions and none are `'static`.
        .                 // Due to ambiguity there is no default trait-object lifetime and thus elision is impossible.
        .                 // Don't elide the lifetime.
        .                 _ => false,
        .             }
      118 (0.0%)  }
        .         
        .         #[derive(Debug)]
        .         pub(crate) enum ContainerTy<'a, 'tcx> {
        .             Ref(ty::Region<'tcx>),
        .             Regular {
        .                 ty: DefId,
        .                 /// The arguments *have* to contain an arg for the self type if the corresponding generics
        .                 /// contain a self type.
        .                 args: ty::Binder<'tcx, &'a [ty::GenericArg<'tcx>]>,
        .                 arg: usize,
        .             },
        .         }
        .         
        .         impl<'tcx> ContainerTy<'_, 'tcx> {
        .             fn object_lifetime_default(self, tcx: TyCtxt<'tcx>) -> ObjectLifetimeDefault<'tcx> {
      316 (0.0%)          match self {
        .                     Self::Ref(region) => ObjectLifetimeDefault::Arg(region),
        .                     Self::Regular { ty: container, args, arg: index } => {
      270 (0.0%)                  let (DefKind::Struct
        .                         | DefKind::Union
        .                         | DefKind::Enum
        .                         | DefKind::TyAlias
        .                         | DefKind::Trait) = tcx.def_kind(container)
        .                         else {
        .                             return ObjectLifetimeDefault::Empty;
        .                         };
        .         
        .                         let generics = tcx.generics_of(container);
        .                         debug_assert_eq!(generics.parent_count, 0);
        .         
      450 (0.0%)                  let param = generics.params[index].def_id;
        .                         let default = tcx.object_lifetime_default(param);
      720 (0.0%)                  match default {
        .                             rbv::ObjectLifetimeDefault::Param(lifetime) => {
        .                                 // The index is relative to the parent generics but since we don't have any,
        .                                 // we don't need to translate it.
        .                                 let index = generics.param_def_id_to_index[&lifetime];
        .                                 let arg = args.skip_binder()[index as usize].expect_region();
        .                                 ObjectLifetimeDefault::Arg(arg)
        .                             }
        .                             rbv::ObjectLifetimeDefault::Empty => ObjectLifetimeDefault::Empty,
-- line 1978 ----------------------------------------
-- line 1987 ----------------------------------------
        .         #[derive(Debug, Clone, Copy)]
        .         pub(crate) enum ObjectLifetimeDefault<'tcx> {
        .             Empty,
        .             Static,
        .             Ambiguous,
        .             Arg(ty::Region<'tcx>),
        .         }
        .         
8,927,055 (0.1%)  #[instrument(level = "trace", skip(cx), ret)]
        .         pub(crate) fn clean_middle_ty<'tcx>(
        .             bound_ty: ty::Binder<'tcx, Ty<'tcx>>,
        .             cx: &mut DocContext<'tcx>,
        .             parent_def_id: Option<DefId>,
        .             container: Option<ContainerTy<'_, 'tcx>>,
        .         ) -> Type {
1,553,632 (0.0%)      let bound_ty = normalize(cx, bound_ty).unwrap_or(bound_ty);
1,014,985 (0.0%)      match *bound_ty.skip_binder().kind() {
       70 (0.0%)          ty::Never => Primitive(PrimitiveType::Never),
    3,516 (0.0%)          ty::Bool => Primitive(PrimitiveType::Bool),
      234 (0.0%)          ty::Char => Primitive(PrimitiveType::Char),
   16,086 (0.0%)          ty::Int(int_ty) => Primitive(int_ty.into()),
   24,315 (0.0%)          ty::Uint(uint_ty) => Primitive(uint_ty.into()),
    1,632 (0.0%)          ty::Float(float_ty) => Primitive(float_ty.into()),
    1,816 (0.0%)          ty::Str => Primitive(PrimitiveType::Str),
   18,210 (0.0%)          ty::Slice(ty) => Slice(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None))),
        .                 ty::Pat(ty, pat) => Type::Pat(
        .                     Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None)),
        .                     format!("{pat:?}").into_boxed_str(),
        .                 ),
    1,410 (0.0%)          ty::Array(ty, mut n) => {
      940 (0.0%)              n = n.normalize(cx.tcx, ty::ParamEnv::reveal_all());
    2,820 (0.0%)              let n = print_const(cx, n);
    7,990 (0.0%)              Array(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None)), n.into())
        .                 }
      992 (0.0%)          ty::RawPtr(ty, mutbl) => {
    7,440 (0.0%)              RawPointer(mutbl, Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None)))
        .                 }
  264,066 (0.0%)          ty::Ref(r, ty, mutbl) => BorrowedRef {
   48,012 (0.0%)              lifetime: clean_middle_region(r),
        .                     mutability: mutbl,
  216,054 (0.0%)              type_: Box::new(clean_middle_ty(
        .                         bound_ty.rebind(ty),
        .                         cx,
        .                         None,
   72,018 (0.0%)                  Some(ContainerTy::Ref(r)),
        .                     )),
        .                 },
        .                 ty::FnDef(..) | ty::FnPtr(_) => {
        .                     // FIXME: should we merge the outer and inner binders somehow?
       18 (0.0%)              let sig = bound_ty.skip_binder().fn_sig(cx.tcx);
        6 (0.0%)              let decl = clean_poly_fn_sig(cx, None, sig);
        3 (0.0%)              let generic_params = clean_bound_vars(sig.bound_vars());
        .         
       30 (0.0%)              BareFunction(Box::new(BareFunctionDecl {
        .                         unsafety: sig.unsafety(),
        .                         generic_params,
       24 (0.0%)                  decl,
        .                         abi: sig.abi(),
        .                     }))
        .                 }
  100,788 (0.0%)          ty::Adt(def, args) => {
        .                     let did = def.did();
  453,546 (0.0%)              let kind = match def.adt_kind() {
        .                         AdtKind::Struct => ItemType::Struct,
        .                         AdtKind::Union => ItemType::Union,
        .                         AdtKind::Enum => ItemType::Enum,
        .                     };
  151,182 (0.0%)              inline::record_extern_fqn(cx, did, kind);
  604,728 (0.0%)              let path = clean_middle_path(cx, did, false, ThinVec::new(), bound_ty.rebind(args));
        .                     Type::Path { path }
        .                 }
        .                 ty::Foreign(did) => {
        .                     inline::record_extern_fqn(cx, did, ItemType::ForeignType);
        .                     let path = clean_middle_path(
        .                         cx,
        .                         did,
        .                         false,
        .                         ThinVec::new(),
        .                         ty::Binder::dummy(ty::GenericArgs::empty()),
        .                     );
        .                     Type::Path { path }
        .                 }
      186 (0.0%)          ty::Dynamic(obj, ref reg, _) => {
        .                     // HACK: pick the first `did` as the `did` of the trait object. Someone
        .                     // might want to implement "native" support for marker-trait-only
        .                     // trait objects.
        .                     let mut dids = obj.auto_traits();
      186 (0.0%)              let did = obj
        .                         .principal_def_id()
        .                         .or_else(|| dids.next())
        .                         .unwrap_or_else(|| panic!("found trait object `{bound_ty:?}` with no traits?"));
      930 (0.0%)              let args = match obj.principal() {
      744 (0.0%)                  Some(principal) => principal.map_bound(|p| p.args),
        .                         // marker traits have no args.
        .                         _ => ty::Binder::dummy(ty::GenericArgs::empty()),
        .                     };
        .         
      744 (0.0%)              inline::record_extern_fqn(cx, did, ItemType::Trait);
        .         
      744 (0.0%)              let lifetime = clean_trait_object_lifetime_bound(*reg, container, obj, cx.tcx);
        .         
        .                     let mut bounds = dids
    1,764 (0.0%)                  .map(|did| {
        .                             let empty = ty::Binder::dummy(ty::GenericArgs::empty());
    1,638 (0.0%)                      let path = clean_middle_path(cx, did, false, ThinVec::new(), empty);
      630 (0.0%)                      inline::record_extern_fqn(cx, did, ItemType::Trait);
    1,008 (0.0%)                      PolyTrait { trait_: path, generic_params: Vec::new() }
    1,008 (0.0%)                  })
        .                         .collect::<Vec<_>>();
        .         
        .                     let bindings = obj
        .                         .projection_bounds()
      250 (0.0%)                  .map(|pb| TypeBinding {
      200 (0.0%)                      assoc: projection_to_path_segment(
        .                                 pb.map_bound(|pb| {
      250 (0.0%)                              pb
        .                                         // HACK(compiler-errors): Doesn't actually matter what self
        .                                         // type we put here, because we're only using the GAT's args.
      100 (0.0%)                                  .with_self_ty(cx.tcx, cx.tcx.types.self_param)
        .                                         .projection_ty
        .                                 }),
        .                                 cx,
        .                             ),
      300 (0.0%)                      kind: TypeBindingKind::Equality {
        .                                 term: clean_middle_term(pb.map_bound(|pb| pb.term), cx),
        .                             },
        .                         })
        .                         .collect();
        .         
        .                     let late_bound_regions: FxIndexSet<_> = obj
        .                         .iter()
        .                         .flat_map(|pred| pred.bound_vars())
-- line 2118 ----------------------------------------
-- line 2122 ----------------------------------------
        .                             {
        .                                 Some(GenericParamDef::lifetime(def_id, name))
        .                             }
        .                             _ => None,
        .                         })
        .                         .collect();
        .                     let late_bound_regions = late_bound_regions.into_iter().collect();
        .         
    1,860 (0.0%)              let path = clean_middle_path(cx, did, false, bindings, args);
    1,488 (0.0%)              bounds.insert(0, PolyTrait { trait_: path, generic_params: late_bound_regions });
        .         
    1,116 (0.0%)              DynTrait(bounds, lifetime)
        .                 }
    6,326 (0.0%)          ty::Tuple(t) => {
   43,958 (0.0%)              Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None, None)).collect())
        .                 }
        .         
   17,586 (0.0%)          ty::Alias(ty::Projection, data) => {
   35,172 (0.0%)              clean_projection(bound_ty.rebind(data), cx, parent_def_id)
        .                 }
        .         
        .                 ty::Alias(ty::Inherent, alias_ty) => {
        .                     let def_id = alias_ty.def_id;
        .                     let alias_ty = bound_ty.rebind(alias_ty);
        .                     let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None, None);
        .         
        .                     Type::QPath(Box::new(QPathData {
-- line 2148 ----------------------------------------
-- line 2179 ----------------------------------------
        .                         Type::Path { path }
        .                     } else {
        .                         let ty = cx.tcx.type_of(data.def_id).instantiate(cx.tcx, data.args);
        .                         clean_middle_ty(bound_ty.rebind(ty), cx, None, None)
        .                     }
        .                 }
        .         
        .                 ty::Param(ref p) => {
  229,436 (0.0%)              if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {
        .                         ImplTrait(bounds)
        .                     } else {
  114,674 (0.0%)                  Generic(p.name)
        .                     }
        .                 }
        .         
        .                 ty::Bound(_, ref ty) => match ty.kind {
        .                     ty::BoundTyKind::Param(_, name) => Generic(name),
        .                     ty::BoundTyKind::Anon => panic!("unexpected anonymous bound type variable"),
        .                 },
        .         
-- line 2198 ----------------------------------------
-- line 2296 ----------------------------------------
        .             if bounds.first().map_or(true, |b| !b.is_trait_bound()) {
        .                 bounds.insert(0, GenericBound::sized(cx));
        .             }
        .         
        .             ImplTrait(bounds)
        .         }
        .         
        .         pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {
    2,416 (0.0%)      clean_field_with_def_id(field.def_id.to_def_id(), field.ident.name, clean_ty(field.ty, cx), cx)
        .         }
        .         
      660 (0.0%)  pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext<'tcx>) -> Item {
        .             clean_field_with_def_id(
      138 (0.0%)          field.did,
       74 (0.0%)          field.name,
      482 (0.0%)          clean_middle_ty(
       68 (0.0%)              ty::Binder::dummy(cx.tcx.type_of(field.did).instantiate_identity()),
        .                     cx,
        .                     Some(field.did),
       68 (0.0%)              None,
        .                 ),
        .                 cx,
        .             )
      528 (0.0%)  }
        .         
        .         pub(crate) fn clean_field_with_def_id(
        .             def_id: DefId,
        .             name: Symbol,
        .             ty: Type,
        .             cx: &mut DocContext<'_>,
        .         ) -> Item {
    3,426 (0.0%)      Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx)
        .         }
        .         
        .         pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocContext<'tcx>) -> Item {
        4 (0.0%)      let discriminant = match variant.discr {
        .                 ty::VariantDiscr::Explicit(def_id) => Some(Discriminant { expr: None, value: def_id }),
        .                 ty::VariantDiscr::Relative(_) => None,
        .             };
        .         
        4 (0.0%)      let kind = match variant.ctor_kind() {
        .                 Some(CtorKind::Const) => VariantKind::CLike,
        .                 Some(CtorKind::Fn) => VariantKind::Tuple(
       10 (0.0%)              variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),
        .                 ),
        .                 None => VariantKind::Struct(VariantStruct {
        .                     fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),
        .                 }),
        .             };
        .         
        8 (0.0%)      Item::from_def_id_and_parts(
        4 (0.0%)          variant.def_id,
        2 (0.0%)          Some(variant.name),
       24 (0.0%)          VariantItem(Variant { kind, discriminant }),
        .                 cx,
        .             )
        .         }
        .         
      253 (0.0%)  pub(crate) fn clean_variant_def_with_args<'tcx>(
        .             variant: &ty::VariantDef,
        .             args: &GenericArgsRef<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Item {
       69 (0.0%)      let discriminant = match variant.discr {
        .                 ty::VariantDiscr::Explicit(def_id) => Some(Discriminant { expr: None, value: def_id }),
        .                 ty::VariantDiscr::Relative(_) => None,
        .             };
        .         
        .             use rustc_middle::traits::ObligationCause;
        .             use rustc_trait_selection::infer::TyCtxtInferExt;
        .             use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;
        .         
      161 (0.0%)      let infcx = cx.tcx.infer_ctxt().build();
       18 (0.0%)      let kind = match variant.ctor_kind() {
        .                 Some(CtorKind::Const) => VariantKind::CLike,
        .                 Some(CtorKind::Fn) => VariantKind::Tuple(
        .                     variant
        .                         .fields
        .                         .iter()
        .                         .map(|field| {
       60 (0.0%)                      let ty = cx.tcx.type_of(field.did).instantiate(cx.tcx, args);
        .         
        .                             // normalize the type to only show concrete types
        .                             // note: we do not use try_normalize_erasing_regions since we
        .                             // do care about showing the regions
       40 (0.0%)                      let ty = infcx
       10 (0.0%)                          .at(&ObligationCause::dummy(), cx.param_env)
        .                                 .query_normalize(ty)
        .                                 .map(|normalized| normalized.value)
        .                                 .unwrap_or(ty);
        .         
        .                             clean_field_with_def_id(
        .                                 field.did,
       20 (0.0%)                          field.name,
      100 (0.0%)                          clean_middle_ty(ty::Binder::dummy(ty), cx, Some(field.did), None),
        .                                 cx,
        .                             )
        .                         })
        .                         .collect(),
        .                 ),
        .                 None => VariantKind::Struct(VariantStruct {
        .                     fields: variant
        .                         .fields
        .                         .iter()
        .                         .map(|field| {
      222 (0.0%)                      let ty = cx.tcx.type_of(field.did).instantiate(cx.tcx, args);
        .         
        .                             // normalize the type to only show concrete types
        .                             // note: we do not use try_normalize_erasing_regions since we
        .                             // do care about showing the regions
      148 (0.0%)                      let ty = infcx
       37 (0.0%)                          .at(&ObligationCause::dummy(), cx.param_env)
        .                                 .query_normalize(ty)
        .                                 .map(|normalized| normalized.value)
        .                                 .unwrap_or(ty);
        .         
        .                             clean_field_with_def_id(
        .                                 field.did,
       74 (0.0%)                          field.name,
      370 (0.0%)                          clean_middle_ty(ty::Binder::dummy(ty), cx, Some(field.did), None),
        .                                 cx,
        .                             )
        .                         })
        .                         .collect(),
        .                 }),
        .             };
        .         
       69 (0.0%)      Item::from_def_id_and_parts(
       46 (0.0%)          variant.def_id,
       23 (0.0%)          Some(variant.name),
      276 (0.0%)          VariantItem(Variant { kind, discriminant }),
        .                 cx,
        .             )
      207 (0.0%)  }
        .         
        .         fn clean_variant_data<'tcx>(
        .             variant: &hir::VariantData<'tcx>,
        .             disr_expr: &Option<hir::AnonConst>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Variant {
      316 (0.0%)      let discriminant = disr_expr
        .                 .map(|disr| Discriminant { expr: Some(disr.body), value: disr.def_id.to_def_id() });
        .         
      716 (0.0%)      let kind = match variant {
        .                 hir::VariantData::Struct { fields, .. } => VariantKind::Struct(VariantStruct {
       74 (0.0%)              fields: fields.iter().map(|x| clean_field(x, cx)).collect(),
        .                 }),
        .                 hir::VariantData::Tuple(..) => {
       39 (0.0%)              VariantKind::Tuple(variant.fields().iter().map(|x| clean_field(x, cx)).collect())
        .                 }
        .                 hir::VariantData::Unit(..) => VariantKind::CLike,
        .             };
        .         
        .             Variant { discriminant, kind }
        .         }
        .         
    9,670 (0.0%)  fn clean_path<'tcx>(path: &hir::Path<'tcx>, cx: &mut DocContext<'tcx>) -> Path {
   31,077 (0.0%)      Path {
   31,521 (0.0%)          res: path.res,
   15,853 (0.0%)          segments: path.segments.iter().map(|x| clean_path_segment(x, cx)).collect(),
        .             }
    7,736 (0.0%)  }
        .         
  103,212 (0.0%)  fn clean_generic_args<'tcx>(
        .             generic_args: &hir::GenericArgs<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> GenericArgs {
        .             // FIXME(return_type_notation): Fix RTN parens rendering
   45,872 (0.0%)      if generic_args.parenthesized == hir::GenericArgsParentheses::ParenSugar {
      140 (0.0%)          let output = clean_ty(generic_args.bindings[0].ty(), cx);
      154 (0.0%)          let output = if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };
        .                 let inputs =
       97 (0.0%)              generic_args.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();
       70 (0.0%)          GenericArgs::Parenthesized { inputs, output }
       32 (0.0%)      } else {
   22,908 (0.0%)          let args = generic_args
        .                     .args
        .                     .iter()
   26,750 (0.0%)              .filter_map(|arg| {
   34,775 (0.0%)                  Some(match arg {
      305 (0.0%)                      hir::GenericArg::Lifetime(lt) if !lt.is_anonymous() => {
      280 (0.0%)                          GenericArg::Lifetime(clean_lifetime(*lt, cx))
        .                             }
        .                             hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),
   23,700 (0.0%)                      hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),
        .                             // Checking for `is_desugared_from_effects` on the `AnonConst` not only accounts for the case
        .                             // where the argument is `host` but for all possible cases (e.g., `true`, `false`).
        .                             hir::GenericArg::Const(hir::ConstArg {
        .                                 is_desugared_from_effects: true,
        .                                 ..
        .                             }) => {
        .                                 return None;
        .                             }
        .                             hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),
        .                             hir::GenericArg::Infer(_inf) => GenericArg::Infer,
        .                         })
   21,400 (0.0%)              })
        .                     .collect::<Vec<_>>()
        .                     .into();
        .                 let bindings =
   22,908 (0.0%)              generic_args.bindings.iter().map(|x| clean_type_binding(x, cx)).collect::<ThinVec<_>>();
   57,270 (0.0%)          GenericArgs::AngleBracketed { args, bindings }
        .             }
   91,744 (0.0%)  }
        .         
        .         fn clean_path_segment<'tcx>(
        .             path: &hir::PathSegment<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> PathSegment {
   99,431 (0.0%)      PathSegment { name: path.ident.name, args: clean_generic_args(path.args(), cx) }
        .         }
        .         
        .         fn clean_bare_fn_ty<'tcx>(
        .             bare_fn: &hir::BareFnTy<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> BareFunctionDecl {
       84 (0.0%)      let (generic_params, decl) = enter_impl_trait(cx, |cx| {
        .                 // NOTE: generics must be cleaned before args
        .                 let generic_params = bare_fn
        .                     .generic_params
        .                     .iter()
        .                     .filter(|p| !is_elided_lifetime(p))
        .                     .map(|x| clean_generic_param(cx, None, x))
        .                     .collect();
       28 (0.0%)          let args = clean_args_from_types_and_names(cx, bare_fn.decl.inputs, bare_fn.param_names);
        .                 let decl = clean_fn_decl_with_args(cx, bare_fn.decl, None, args);
       64 (0.0%)          (generic_params, decl)
        .             });
       16 (0.0%)      BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }
        .         }
        .         
      574 (0.0%)  pub(crate) fn reexport_chain<'tcx>(
        .             tcx: TyCtxt<'tcx>,
        .             import_def_id: LocalDefId,
        .             target_def_id: DefId,
        .         ) -> &'tcx [Reexport] {
      123 (0.0%)      for child in tcx.module_children_local(tcx.local_parent(import_def_id)) {
      638 (0.0%)          if child.res.opt_def_id() == Some(target_def_id)
      205 (0.0%)              && child.reexport_chain.first().and_then(|r| r.id()) == Some(import_def_id.to_def_id())
        .                 {
        .                     return &child.reexport_chain;
        .                 }
        .             }
        .             &[]
      369 (0.0%)  }
        .         
        .         /// Collect attributes from the whole import chain.
        .         fn get_all_import_attributes<'hir>(
        .             cx: &mut DocContext<'hir>,
        .             import_def_id: LocalDefId,
        .             target_def_id: DefId,
        .             is_inline: bool,
        .         ) -> Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> {
        .             let mut attrs = Vec::new();
        .             let mut first = true;
      104 (0.0%)      for def_id in reexport_chain(cx.tcx, import_def_id, target_def_id)
        .                 .iter()
       26 (0.0%)          .flat_map(|reexport| reexport.id())
        .             {
        .                 let import_attrs = inline::load_attrs(cx, def_id);
       52 (0.0%)          if first {
        .                     // This is the "original" reexport so we get all its attributes without filtering them.
      156 (0.0%)              attrs = import_attrs.iter().map(|attr| (Cow::Borrowed(attr), Some(def_id))).collect();
        .                     first = false;
        .                 // We don't add attributes of an intermediate re-export if it has `#[doc(hidden)]`.
        .                 } else if cx.render_options.document_hidden || !cx.tcx.is_doc_hidden(def_id) {
        .                     add_without_unwanted_attributes(&mut attrs, import_attrs, is_inline, Some(def_id));
        .                 }
        .             }
      156 (0.0%)      attrs
        .         }
        .         
        .         fn filter_tokens_from_list(
        .             args_tokens: &TokenStream,
        .             should_retain: impl Fn(&TokenTree) -> bool,
        .         ) -> Vec<TokenTree> {
        .             let mut tokens = Vec::with_capacity(args_tokens.len());
        .             let mut skip_next_comma = false;
-- line 2573 ----------------------------------------
-- line 2594 ----------------------------------------
        .             } else {
        .                 ident == sym::cfg
        .             }
        .         }
        .         
        .         /// Remove attributes from `normal` that should not be inherited by `use` re-export.
        .         /// Before calling this function, make sure `normal` is a `#[doc]` attribute.
        .         fn filter_doc_attr(normal: &mut ast::NormalAttr, is_inline: bool) {
       12 (0.0%)      match normal.item.args {
        .                 ast::AttrArgs::Delimited(ref mut args) => {
        .                     let tokens = filter_tokens_from_list(&args.tokens, |token| {
        .                         !matches!(
        .                             token,
        .                             TokenTree::Token(
        .                                 Token {
        .                                     kind: TokenKind::Ident(
        .                                         ident,
-- line 2610 ----------------------------------------
-- line 2637 ----------------------------------------
        .         /// pub use Foo2 as Bar;
        .         /// ```
        .         ///
        .         /// So `Bar` at the end will have both `cfg(feature = "...")`. However, we don't want to merge all
        .         /// attributes so we filter out the following ones:
        .         /// * `doc(inline)`
        .         /// * `doc(no_inline)`
        .         /// * `doc(hidden)`
      234 (0.0%)  fn add_without_unwanted_attributes<'hir>(
        .             attrs: &mut Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)>,
        .             new_attrs: &'hir [ast::Attribute],
        .             is_inline: bool,
        .             import_parent: Option<DefId>,
        .         ) {
        .             for attr in new_attrs {
    1,726 (0.0%)          if matches!(attr.kind, ast::AttrKind::DocComment(..)) {
    3,412 (0.0%)              attrs.push((Cow::Borrowed(attr), import_parent));
        .                     continue;
        .                 }
        .                 let mut attr = attr.clone();
        .                 match attr.kind {
        .                     ast::AttrKind::Normal(ref mut normal) => {
       20 (0.0%)                  if let [ident] = &*normal.item.path.segments {
       10 (0.0%)                      let ident = ident.ident.name;
       20 (0.0%)                      if ident == sym::doc {
        .                                 filter_doc_attr(normal, is_inline);
       96 (0.0%)                          attrs.push((Cow::Owned(attr), import_parent));
        7 (0.0%)                      } else if is_inline || ident != sym::cfg {
        .                                 // If it's not a `cfg()` attribute, we keep it.
       30 (0.0%)                          attrs.push((Cow::Owned(attr), import_parent));
        .                             }
        .                         }
        .                     }
        .                     _ => unreachable!(),
        .                 }
        .             }
      208 (0.0%)  }
        .         
        .         fn clean_maybe_renamed_item<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             item: &hir::Item<'tcx>,
        .             renamed: Option<Symbol>,
        .             import_id: Option<LocalDefId>,
        .         ) -> Vec<Item> {
        .             use hir::ItemKind;
        .         
    1,111 (0.0%)      let def_id = item.owner_id.to_def_id();
    4,388 (0.0%)      let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));
   21,109 (0.0%)      cx.with_param_env(def_id, |cx| {
   10,029 (0.0%)          let kind = match item.kind {
        .                     ItemKind::Static(ty, mutability, body_id) => {
        .                         StaticItem(Static { type_: clean_ty(ty, cx), mutability, expr: Some(body_id) })
        .                     }
      338 (0.0%)              ItemKind::Const(ty, generics, body_id) => ConstantItem(Constant {
      104 (0.0%)                  type_: Box::new(clean_ty(ty, cx)),
       78 (0.0%)                  generics: clean_generics(generics, cx),
       52 (0.0%)                  kind: ConstantKind::Local { body: body_id, def_id },
        .                     }),
        .                     ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {
        .                         bounds: ty.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),
        .                         generics: clean_generics(ty.generics, cx),
        .                     }),
      104 (0.0%)              ItemKind::TyAlias(hir_ty, generics) => {
      130 (0.0%)                  *cx.current_type_aliases.entry(def_id).or_insert(0) += 1;
      130 (0.0%)                  let rustdoc_ty = clean_ty(hir_ty, cx);
        .                         let type_ =
      338 (0.0%)                      clean_middle_ty(ty::Binder::dummy(lower_ty(cx.tcx, hir_ty)), cx, None, None);
       52 (0.0%)                  let generics = clean_generics(generics, cx);
        .                         if let Some(count) = cx.current_type_aliases.get_mut(&def_id) {
       26 (0.0%)                      *count -= 1;
       26 (0.0%)                      if *count == 0 {
        .                                 cx.current_type_aliases.remove(&def_id);
        .                             }
        .                         }
        .         
       26 (0.0%)                  let ty = cx.tcx.type_of(def_id).instantiate_identity();
        .         
        .                         let mut ret = Vec::new();
       78 (0.0%)                  let inner_type = clean_ty_alias_inner_type(ty, cx, &mut ret);
        .         
      182 (0.0%)                  ret.push(generate_item_with_correct_attrs(
        .                             cx,
      182 (0.0%)                      TypeAliasItem(Box::new(TypeAlias {
       52 (0.0%)                          generics,
        .                                 inner_type,
      104 (0.0%)                          type_: rustdoc_ty,
      104 (0.0%)                          item_type: Some(type_),
        .                             })),
       52 (0.0%)                      item.owner_id.def_id.to_def_id(),
       52 (0.0%)                      name,
       52 (0.0%)                      import_id,
       78 (0.0%)                      renamed,
        .                         ));
      104 (0.0%)                  return ret;
        .                     }
      864 (0.0%)              ItemKind::Enum(ref def, generics) => EnumItem(Enum {
       54 (0.0%)                  variants: def.variants.iter().map(|v| clean_variant(v, cx)).collect(),
      108 (0.0%)                  generics: clean_generics(generics, cx),
        .                     }),
        .                     ItemKind::TraitAlias(generics, bounds) => TraitAliasItem(TraitAlias {
        .                         generics: clean_generics(generics, cx),
        .                         bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),
        .                     }),
        .                     ItemKind::Union(ref variant_data, generics) => UnionItem(Union {
        .                         generics: clean_generics(generics, cx),
        .                         fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),
        .                     }),
    1,694 (0.0%)              ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {
      121 (0.0%)                  ctor_kind: variant_data.ctor_kind(),
      242 (0.0%)                  generics: clean_generics(generics, cx),
      115 (0.0%)                  fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),
        .                     }),
      360 (0.0%)              ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),
        .                     ItemKind::Macro(ref macro_def, MacroKind::Bang) => {
       50 (0.0%)                  let ty_vis = cx.tcx.visibility(def_id);
       30 (0.0%)                  MacroItem(Macro {
        .                             // FIXME this shouldn't be false
      120 (0.0%)                      source: display_macro_source(cx, name, macro_def, def_id, ty_vis, false),
        .                         })
        .                     }
        .                     ItemKind::Macro(_, macro_kind) => clean_proc_macro(item, &mut name, macro_kind, cx),
        .                     // proc macros can have a name set by attributes
      264 (0.0%)              ItemKind::Fn(ref sig, generics, body_id) => {
      264 (0.0%)                  clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)
        .                     }
      116 (0.0%)              ItemKind::Trait(_, _, generics, bounds, item_ids) => {
        .                         let items = item_ids
        .                             .iter()
      204 (0.0%)                      .map(|ti| clean_trait_item(cx.tcx.hir().trait_item(ti.id), cx))
        .                             .collect();
        .         
      348 (0.0%)                  TraitItem(Box::new(Trait {
      145 (0.0%)                      def_id,
        .                             items,
       58 (0.0%)                      generics: clean_generics(generics, cx),
      213 (0.0%)                      bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),
        .                         }))
        .                     }
        2 (0.0%)              ItemKind::ExternCrate(orig_name) => {
        5 (0.0%)                  return clean_extern_crate(item, name, orig_name, cx);
        .                     }
    1,316 (0.0%)              ItemKind::Use(path, kind) => {
    4,606 (0.0%)                  return clean_use_statement(item, name, path, kind, cx, &mut FxHashSet::default());
        .                     }
        .                     _ => unreachable!("not yet converted"),
        .                 };
        .         
    2,142 (0.0%)          vec![generate_item_with_correct_attrs(
        .                     cx,
    2,754 (0.0%)              kind,
      612 (0.0%)              item.owner_id.def_id.to_def_id(),
      612 (0.0%)              name,
      612 (0.0%)              import_id,
      612 (0.0%)              renamed,
        .                 )]
    8,888 (0.0%)      })
        .         }
        .         
        .         fn clean_variant<'tcx>(variant: &hir::Variant<'tcx>, cx: &mut DocContext<'tcx>) -> Item {
    1,896 (0.0%)      let kind = VariantItem(clean_variant_data(&variant.data, &variant.disr_expr, cx));
    1,106 (0.0%)      Item::from_def_id_and_parts(variant.def_id.to_def_id(), Some(variant.ident.name), kind, cx)
        .         }
        .         
        .         fn clean_impl<'tcx>(
        .             impl_: &hir::Impl<'tcx>,
        .             def_id: LocalDefId,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Vec<Item> {
      240 (0.0%)      let tcx = cx.tcx;
        .             let mut ret = Vec::new();
        .             let trait_ = impl_.of_trait.as_ref().map(|t| clean_trait_ref(t, cx));
      120 (0.0%)      let items = impl_
        .                 .items
        .                 .iter()
    3,096 (0.0%)          .map(|ii| clean_impl_item(tcx.hir().impl_item(ii.id), cx))
        .                 .collect::<Vec<_>>();
        .         
        .             // If this impl block is an implementation of the Deref trait, then we
        .             // need to try inlining the target's inherent impl blocks as well.
      600 (0.0%)      if trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() {
        .                 build_deref_target_impls(cx, &items, &mut ret);
        .             }
        .         
      480 (0.0%)      let for_ = clean_ty(impl_.self_ty, cx);
        .             let type_alias =
      720 (0.0%)          for_.def_id(&cx.cache).and_then(|alias_def_id: DefId| match tcx.def_kind(alias_def_id) {
        .                     DefKind::TyAlias => Some(clean_middle_ty(
        .                         ty::Binder::dummy(tcx.type_of(def_id).instantiate_identity()),
        .                         cx,
        .                         Some(def_id.to_def_id()),
        .                         None,
        .                     )),
        .                     _ => None,
        .                 });
    2,280 (0.0%)      let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {
    2,520 (0.0%)          let kind = ImplItem(Box::new(Impl {
      360 (0.0%)              unsafety: impl_.unsafety,
      600 (0.0%)              generics: clean_generics(impl_.generics, cx),
        .                     trait_,
        .                     for_,
        .                     items,
      480 (0.0%)              polarity: tcx.impl_polarity(def_id),
    1,080 (0.0%)              kind: if utils::has_doc_flag(tcx, def_id.to_def_id(), sym::fake_variadic) {
        .                         ImplKind::FakeVariadic
        .                     } else {
        .                         ImplKind::Normal
        .                     },
        .                 }));
      840 (0.0%)          Item::from_def_id_and_parts(def_id.to_def_id(), None, kind, cx)
      960 (0.0%)      };
        .             if let Some(type_alias) = type_alias {
        .                 ret.push(make_item(trait_.clone(), type_alias, items.clone()));
        .             }
    2,160 (0.0%)      ret.push(make_item(trait_, for_, items));
      480 (0.0%)      ret
        .         }
        .         
        .         fn clean_extern_crate<'tcx>(
        .             krate: &hir::Item<'tcx>,
        .             name: Symbol,
        .             orig_name: Option<Symbol>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> Vec<Item> {
        .             // this is the ID of the `extern crate` statement
        1 (0.0%)      let cnum = cx.tcx.extern_mod_stmt_cnum(krate.owner_id.def_id).unwrap_or(LOCAL_CRATE);
        .             // this is the ID of the crate itself
        .             let crate_def_id = cnum.as_def_id();
        6 (0.0%)      let attrs = cx.tcx.hir().attrs(krate.hir_id());
        .             let ty_vis = cx.tcx.visibility(krate.owner_id);
        .             let please_inline = ty_vis.is_public()
        .                 && attrs.iter().any(|a| {
        .                     a.has_name(sym::doc)
        .                         && match a.meta_item_list() {
        .                             Some(l) => attr::list_contains_name(&l, sym::inline),
        .                             None => false,
        .                         }
-- line 2872 ----------------------------------------
-- line 2881 ----------------------------------------
        .                     name,
        .                     Some((attrs, Some(krate_owner_def_id))),
        .                     &mut Default::default(),
        .                 ) {
        .                     return items;
        .                 }
        .             }
        .         
        5 (0.0%)      vec![Item::from_def_id_and_parts(
        .                 krate_owner_def_id,
        .                 Some(name),
        5 (0.0%)          ExternCrateItem { src: orig_name },
        .                 cx,
        .             )]
        .         }
        .         
    7,920 (0.0%)  fn clean_use_statement<'tcx>(
        .             import: &hir::Item<'tcx>,
        .             name: Symbol,
        .             path: &hir::UsePath<'tcx>,
        .             kind: hir::UseKind,
        .             cx: &mut DocContext<'tcx>,
        .             inlined_names: &mut FxHashSet<(ItemType, Symbol)>,
        .         ) -> Vec<Item> {
        .             let mut items = Vec::new();
        .             let hir::UsePath { segments, ref res, span } = *path;
    4,044 (0.0%)      for &res in res {
    2,022 (0.0%)          let path = hir::Path { segments, res, span };
    6,066 (0.0%)          items.append(&mut clean_use_statement_inner(import, name, &path, kind, cx, inlined_names));
        .             }
    3,300 (0.0%)      items
    5,280 (0.0%)  }
        .         
    6,870 (0.0%)  fn clean_use_statement_inner<'tcx>(
        .             import: &hir::Item<'tcx>,
        .             name: Symbol,
        .             path: &hir::Path<'tcx>,
        .             kind: hir::UseKind,
        .             cx: &mut DocContext<'tcx>,
        .             inlined_names: &mut FxHashSet<(ItemType, Symbol)>,
        .         ) -> Vec<Item> {
    2,060 (0.0%)      if should_ignore_res(path.res) {
        .                 return Vec::new();
        .             }
        .             // We need this comparison because some imports (for std types for example)
        .             // are "inserted" as well but directly by the compiler and they should not be
        .             // taken into account.
    4,713 (0.0%)      if import.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {
        .                 return Vec::new();
        .             }
        .         
    1,344 (0.0%)      let visibility = cx.tcx.visibility(import.owner_id);
    4,032 (0.0%)      let attrs = cx.tcx.hir().attrs(import.hir_id());
    1,344 (0.0%)      let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);
        .             let pub_underscore = visibility.is_public() && name == kw::Underscore;
    3,360 (0.0%)      let current_mod = cx.tcx.parent_module_from_def_id(import.owner_id.def_id);
        .             let import_def_id = import.owner_id.def_id.to_def_id();
        .         
        .             // The parent of the module in which this import resides. This
        .             // is the same as `current_mod` if that's already the top
        .             // level module.
    2,016 (0.0%)      let parent_mod = cx.tcx.parent_module_from_def_id(current_mod.to_local_def_id());
        .         
        .             // This checks if the import can be seen from a higher level module.
        .             // In other words, it checks if the visibility is the equivalent of
        .             // `pub(super)` or higher. If the current module is the top level
        .             // module, there isn't really a parent module, which makes the results
        .             // meaningless. In this case, we make sure the answer is `false`.
        .             let is_visible_from_parent_mod =
    2,654 (0.0%)          visibility.is_accessible_from(parent_mod, cx.tcx) && !current_mod.is_top_level_module();
        .         
       17 (0.0%)      if pub_underscore && let Some(ref inline) = inline_attr {
        .                 struct_span_code_err!(
        .                     cx.tcx.dcx(),
        .                     inline.span(),
        .                     E0780,
        .                     "anonymous imports cannot be inlined"
        .                 )
        .                 .with_span_label(import.span, "anonymous import")
        .                 .emit();
-- line 2960 ----------------------------------------
-- line 2961 ----------------------------------------
        .             }
        .         
        .             // We consider inlining the documentation of `pub use` statements, but we
        .             // forcefully don't inline if this is not public or if the
        .             // #[doc(no_inline)] attribute is present.
        .             // Don't inline doc(hidden) imports so they can be stripped at a later stage.
        .             let mut denied = cx.output_format.is_json()
        .                 || !(visibility.is_public()
    1,370 (0.0%)              || (cx.render_options.document_private && is_visible_from_parent_mod))
       17 (0.0%)          || pub_underscore
        .                 || attrs.iter().any(|a| {
        7 (0.0%)              a.has_name(sym::doc)
       24 (0.0%)                  && match a.meta_item_list() {
        4 (0.0%)                      Some(l) => {
       20 (0.0%)                          attr::list_contains_name(&l, sym::no_inline)
        4 (0.0%)                              || attr::list_contains_name(&l, sym::hidden)
        .                             }
        .                             None => false,
        .                         }
        .                 });
        .         
        .             // Also check whether imports were asked to be inlined, in case we're trying to re-export a
        .             // crate in Rust 2018+
      672 (0.0%)      let path = clean_path(path, cx);
    1,999 (0.0%)      let inner = if kind == hir::UseKind::Glob {
        .                 if !denied {
        .                     let mut visited = DefIdSet::default();
        .                     if let Some(items) = inline::try_inline_glob(
        .                         cx,
        .                         path.res,
        .                         current_mod,
        .                         &mut visited,
        .                         inlined_names,
        .                         import,
        .                     ) {
        .                         return items;
        .                     }
        .                 }
        4 (0.0%)          Import::new_glob(resolve_use_source(cx, path), true)
        .             } else {
        .                 if inline_attr.is_none()
        .                     && let Res::Def(DefKind::Mod, did) = path.res
        .                     && !did.is_local()
      208 (0.0%)              && did.is_crate_root()
        .                 {
        .                     // if we're `pub use`ing an extern crate root, don't inline it unless we
        .                     // were specifically asked for it
        .                     denied = true;
        .                 }
    1,238 (0.0%)          if !denied
      100 (0.0%)              && let Some(mut items) = inline::try_inline(
        .                         cx,
        .                         path.res,
        .                         name,
       65 (0.0%)                  Some((attrs, Some(import_def_id))),
        .                         &mut Default::default(),
        .                     )
        .                 {
       60 (0.0%)              items.push(Item::from_def_id_and_parts(
        .                         import_def_id,
        .                         None,
      132 (0.0%)                  ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),
        .                         cx,
        .                     ));
       36 (0.0%)              return items;
       13 (0.0%)          }
    2,636 (0.0%)          Import::new_simple(name, resolve_use_source(cx, path), true)
        .             };
        .         
   15,180 (0.0%)      vec![Item::from_def_id_and_parts(import_def_id, None, ImportItem(inner), cx)]
    5,496 (0.0%)  }
        .         
        .         fn clean_maybe_renamed_foreign_item<'tcx>(
        .             cx: &mut DocContext<'tcx>,
        .             item: &hir::ForeignItem<'tcx>,
        .             renamed: Option<Symbol>,
        .         ) -> Item {
        .             let def_id = item.owner_id.to_def_id();
        .             cx.with_param_env(def_id, |cx| {
-- line 3039 ----------------------------------------
-- line 3062 ----------------------------------------
        .                 )
        .             })
        .         }
        .         
        .         fn clean_type_binding<'tcx>(
        .             type_binding: &hir::TypeBinding<'tcx>,
        .             cx: &mut DocContext<'tcx>,
        .         ) -> TypeBinding {
      684 (0.0%)      TypeBinding {
      570 (0.0%)          assoc: PathSegment {
      114 (0.0%)              name: type_binding.ident.name,
      570 (0.0%)              args: clean_generic_args(type_binding.gen_args, cx),
        .                 },
      342 (0.0%)          kind: match type_binding.kind {
        .                     hir::TypeBindingKind::Equality { ref term } => {
        .                         TypeBindingKind::Equality { term: clean_hir_term(term, cx) }
        .                     }
        .                     hir::TypeBindingKind::Constraint { bounds } => TypeBindingKind::Constraint {
        .                         bounds: bounds.iter().filter_map(|b| clean_generic_bound(b, cx)).collect(),
        .                     },
        .                 },
        .             }
        .         }
        .         
  325,026 (0.0%)  fn clean_bound_vars<'tcx>(
        .             bound_vars: &'tcx ty::List<ty::BoundVariableKind>,
        .         ) -> Vec<GenericParamDef> {
        .             bound_vars
        .                 .into_iter()
  247,880 (0.0%)          .filter_map(|var| match var {
        .                     ty::BoundVariableKind::Region(ty::BrNamed(def_id, name))
        .                         if name != kw::UnderscoreLifetime =>
        .                     {
        .                         Some(GenericParamDef::lifetime(def_id, name))
        .                     }
        .                     ty::BoundVariableKind::Ty(ty::BoundTyKind::Param(def_id, name)) => {
        .                         Some(GenericParamDef {
        .                             name,
-- line 3099 ----------------------------------------
-- line 3105 ----------------------------------------
        .                             },
        .                         })
        .                     }
        .                     // FIXME(non_lifetime_binders): Support higher-ranked const parameters.
        .                     ty::BoundVariableKind::Const => None,
        .                     _ => None,
        .                 })
        .                 .collect()
  288,912 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/src/librustdoc/html/escape.rs
--------------------------------------------------------------------------------
Ir______________ 

  752,181 (0.0%)  <unknown (line 0)>

-- line 5 ----------------------------------------
        .         
        .         use std::fmt;
        .         
        .         /// Wrapper struct which will emit the HTML-escaped version of the contained
        .         /// string when passed to a format string.
        .         pub(crate) struct Escape<'a>(pub &'a str);
        .         
        .         impl<'a> fmt::Display for Escape<'a> {
   79,560 (0.0%)      fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 // Because the internet is always right, turns out there's not that many
        .                 // characters to escape: http://stackoverflow.com/questions/7381974
   17,680 (0.0%)          let Escape(s) = *self;
        .                 let pile_o_bits = s;
        .                 let mut last = 0;
  955,417 (0.0%)          for (i, ch) in s.char_indices() {
        .                     let s = match ch {
        .                         '>' => "&gt;",
        .                         '<' => "&lt;",
        .                         '&' => "&amp;",
        .                         '\'' => "&#39;",
        .                         '"' => "&quot;",
        .                         _ => continue,
        .                     };
      104 (0.0%)              fmt.write_str(&pile_o_bits[last..i])?;
      416 (0.0%)              fmt.write_str(s)?;
        .                     // NOTE: we only expect single byte characters here - which is fine as long as we
        .                     // only match single byte characters
      832 (0.0%)              last = i + 1;
        .                 }
        .         
   26,520 (0.0%)          if last < s.len() {
   26,298 (0.0%)              fmt.write_str(&pile_o_bits[last..])?;
        .                 }
        .                 Ok(())
   70,720 (0.0%)      }
        .         }
        .         
        .         /// Wrapper struct which will emit the HTML-escaped version of the contained
        .         /// string when passed to a format string.
        .         ///
        .         /// This is only safe to use for text nodes. If you need your output to be
        .         /// safely contained in an attribute, use [`Escape`]. If you don't know the
        .         /// difference, use [`Escape`].
        .         pub(crate) struct EscapeBodyText<'a>(pub &'a str);
        .         
        .         impl<'a> fmt::Display for EscapeBodyText<'a> {
1,548,954 (0.0%)      fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                 // Because the internet is always right, turns out there's not that many
        .                 // characters to escape: http://stackoverflow.com/questions/7381974
  344,212 (0.0%)          let EscapeBodyText(s) = *self;
        .                 let pile_o_bits = s;
        .                 let mut last = 0;
5,135,968 (0.1%)          for (i, ch) in s.char_indices() {
        .                     let s = match ch {
        .                         '>' => "&gt;",
        .                         '<' => "&lt;",
        .                         '&' => "&amp;",
        .                         _ => continue,
        .                     };
   27,351 (0.0%)              fmt.write_str(&pile_o_bits[last..i])?;
   36,468 (0.0%)              fmt.write_str(s)?;
        .                     // NOTE: we only expect single byte characters here - which is fine as long as we
        .                     // only match single byte characters
   63,819 (0.0%)              last = i + 1;
        .                 }
        .         
  516,318 (0.0%)          if last < s.len() {
  493,281 (0.0%)              fmt.write_str(&pile_o_bits[last..])?;
        .                 }
        .                 Ok(())
1,376,848 (0.0%)      }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /data/code/rust/src/librustdoc/html/highlight.rs
--------------------------------------------------------------------------------
Ir______________ 

3,796,749 (0.0%)  <unknown (line 0)>

-- line 32 ----------------------------------------
        .             pub(crate) current_href: String,
        .         }
        .         
        .         /// Decorations are represented as a map from CSS class to vector of character ranges.
        .         /// Each range will be wrapped in a span with that class.
        .         #[derive(Default)]
        .         pub(crate) struct DecorationInfo(pub(crate) FxHashMap<&'static str, Vec<(u32, u32)>>);
        .         
    1,035 (0.0%)  #[derive(Eq, PartialEq, Clone, Copy)]
        .         pub(crate) enum Tooltip {
        .             Ignore,
        .             CompileFail,
        .             ShouldPanic,
        .             Edition(Edition),
        .             None,
        .         }
        .         
        .         /// Highlights `src` as an inline example, returning the HTML output.
    4,140 (0.0%)  pub(crate) fn render_example_with_highlighting(
        .             src: &str,
        .             out: &mut Buffer,
        .             tooltip: Tooltip,
        .             playground_button: Option<&str>,
        .             extra_classes: &[String],
        .         ) {
        .             write_header(out, "rust-example-rendered", None, tooltip, extra_classes);
    3,450 (0.0%)      write_code(out, src, None, None);
        .             write_footer(out, playground_button);
    2,760 (0.0%)  }
        .         
        .         /// Highlights `src` as an item-decl, returning the HTML output.
        .         pub(crate) fn render_item_decl_with_highlighting(src: &str, out: &mut Buffer) {
        .             write!(out, "<pre class=\"rust item-decl\">");
        .             write_code(out, src, None, None);
        .             write!(out, "</pre>");
        .         }
        .         
        .         fn write_header(
        .             out: &mut Buffer,
        .             class: &str,
        .             extra_content: Option<Buffer>,
        .             tooltip: Tooltip,
        .             extra_classes: &[String],
        .         ) {
    1,380 (0.0%)      write!(
        .                 out,
        .                 "<div class=\"example-wrap{}\">",
    5,175 (0.0%)          match tooltip {
        8 (0.0%)              Tooltip::Ignore => " ignore",
        .                     Tooltip::CompileFail => " compile_fail",
       14 (0.0%)              Tooltip::ShouldPanic => " should_panic",
        .                     Tooltip::Edition(_) => " edition",
    1,344 (0.0%)              Tooltip::None => "",
        .                 },
        .             );
        .         
        .             if tooltip != Tooltip::None {
        .                 let edition_code;
       18 (0.0%)          write!(
        .                     out,
        .                     "<a href=\"#\" class=\"tooltip\" title=\"{}\">ⓘ</a>",
       27 (0.0%)              match tooltip {
        8 (0.0%)                  Tooltip::Ignore => "This example is not tested",
        .                         Tooltip::CompileFail => "This example deliberately fails to compile",
       28 (0.0%)                  Tooltip::ShouldPanic => "This example panics",
        .                         Tooltip::Edition(edition) => {
        .                             edition_code = format!("This example runs with edition {edition}");
        .                             &edition_code
        .                         }
        .                         Tooltip::None => unreachable!(),
        .                     },
        .                 );
        .             }
-- line 104 ----------------------------------------
-- line 109 ----------------------------------------
        .             if class.is_empty() {
        .                 write!(
        .                     out,
        .                     "<pre class=\"rust{}{}\">",
        .                     if extra_classes.is_empty() { "" } else { " " },
        .                     extra_classes.join(" "),
        .                 );
        .             } else {
    2,760 (0.0%)          write!(
        .                     out,
        .                     "<pre class=\"rust {class}{}{}\">",
    3,105 (0.0%)              if extra_classes.is_empty() { "" } else { " " },
        .                     extra_classes.join(" "),
        .                 );
        .             }
        .             write!(out, "<code>");
        .         }
        .         
        .         /// Check if two `Class` can be merged together. In the following rules, "unclassified" means `None`
        .         /// basically (since it's `Option<Class>`). The following rules apply:
        .         ///
        .         /// * If two `Class` have the same variant, then they can be merged.
        .         /// * If the other `Class` is unclassified and only contains white characters (backline,
        .         ///   whitespace, etc), it can be merged.
        .         /// * `Class::Ident` is considered the same as unclassified (because it doesn't have an associated
        .         ///    CSS class).
        .         fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {
1,030,955 (0.0%)      match (class1, class2) {
  102,642 (0.0%)          (Some(c1), Some(c2)) => c1.is_equal_to(c2),
        .                 (Some(Class::Ident(_)), None) | (None, Some(Class::Ident(_))) => true,
        .                 (Some(Class::Macro(_)), _) => false,
        .                 (Some(_), None) | (None, Some(_)) => text.trim().is_empty(),
        .                 (None, None) => true,
        .             }
        .         }
        .         
        .         /// This type is used as a conveniency to prevent having to pass all its fields as arguments into
-- line 145 ----------------------------------------
-- line 156 ----------------------------------------
        .             current_class: Option<Class>,
        .             /// We need to keep the `Class` for each element because it could contain a `Span` which is
        .             /// used to generate links.
        .             pending_elems: Vec<(&'a str, Option<Class>)>,
        .             href_context: Option<HrefContext<'a, 'tcx>>,
        .         }
        .         
        .         impl<'a, 'tcx, F: Write> TokenHandler<'a, 'tcx, F> {
   11,936 (0.0%)      fn handle_exit_span(&mut self) {
        .                 // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is
        .                 // being used in `write_pending_elems`.
   16,415 (0.0%)          let class = self.closing_tags.last().expect("ExitSpan without EnterSpan").1;
        .                 // We flush everything just in case...
    2,345 (0.0%)          self.write_pending_elems(Some(class));
        .         
    3,623 (0.0%)          exit_span(self.out, self.closing_tags.pop().expect("ExitSpan without EnterSpan").0);
    2,345 (0.0%)          self.pending_exit_span = None;
   11,936 (0.0%)      }
        .         
        .             /// Write all the pending elements sharing a same (or at mergeable) `Class`.
        .             ///
        .             /// If there is a "parent" (if a `EnterSpan` event was encountered) and the parent can be merged
        .             /// with the elements' class, then we simply write the elements since the `ExitSpan` event will
        .             /// close the tag.
        .             ///
        .             /// Otherwise, if there is only one pending element, we let the `string` function handle both
        .             /// opening and closing the tag, otherwise we do it into this function.
        .             ///
        .             /// It returns `true` if `current_class` must be set to `None` afterwards.
  323,832 (0.0%)      fn write_pending_elems(&mut self, current_class: Option<Class>) -> bool {
  161,916 (0.0%)          if self.pending_elems.is_empty() {
        .                     return false;
        .                 }
   84,589 (0.0%)          if let Some((_, parent_class)) = self.closing_tags.last()
   21,992 (0.0%)              && can_merge(current_class, Some(*parent_class), "")
        .                 {
    4,692 (0.0%)              for (text, class) in self.pending_elems.iter() {
   84,480 (0.0%)                  string(self.out, EscapeBodyText(text), *class, &self.href_context, false);
        .                     }
        .                 } else {
        .                     // We only want to "open" the tag ourselves if we have more than one pending and if the
        .                     // current parent tag is not the same as our pending content.
  150,996 (0.0%)              let close_tag = if self.pending_elems.len() > 1
        .                         && let Some(current_class) = current_class
        .                     {
  108,810 (0.0%)                  Some(enter_span(self.out, current_class, &self.href_context))
        .                     } else {
        .                         None
        .                     };
  113,247 (0.0%)              for (text, class) in self.pending_elems.iter() {
  657,704 (0.0%)                  string(
        .                             self.out,
  328,852 (0.0%)                      EscapeBodyText(text),
  657,704 (0.0%)                      *class,
        .                             &self.href_context,
        .                             close_tag.is_none(),
        .                         );
        .                     }
  105,393 (0.0%)              if let Some(close_tag) = close_tag {
   21,762 (0.0%)                  exit_span(self.out, close_tag);
        .                     }
        .                 }
        .                 self.pending_elems.clear();
        .                 true
  323,832 (0.0%)      }
        .         }
        .         
        .         impl<'a, 'tcx, F: Write> Drop for TokenHandler<'a, 'tcx, F> {
        .             /// When leaving, we need to flush all pending data to not have missing content.
        .             fn drop(&mut self) {
        .                 if self.pending_exit_span.is_some() {
        .                     self.handle_exit_span();
        .                 } else {
    3,184 (0.0%)              self.write_pending_elems(self.current_class);
        .                 }
        .             }
        .         }
        .         
        .         /// Convert the given `src` source code into HTML by adding classes for highlighting.
        .         ///
        .         /// This code is used to render code blocks (in the documentation) as well as the source code pages.
        .         ///
        .         /// Some explanations on the last arguments:
        .         ///
        .         /// In case we are rendering a code block and not a source code file, `href_context` will be `None`.
        .         /// To put it more simply: if `href_context` is `None`, the code won't try to generate links to an
        .         /// item definition.
        .         ///
        .         /// More explanations about spans and how we use them here are provided in the
    3,582 (0.0%)  pub(super) fn write_code(
        .             out: &mut impl Write,
        .             src: &str,
        .             href_context: Option<HrefContext<'_, '_>>,
        .             decoration_info: Option<DecorationInfo>,
        .         ) {
        .             // This replace allows to fix how the code source with DOS backline characters is displayed.
    2,388 (0.0%)      let src = src.replace("\r\n", "\n");
    6,766 (0.0%)      let mut token_handler = TokenHandler {
        .                 out,
        .                 closing_tags: Vec::new(),
        .                 pending_exit_span: None,
        .                 current_class: None,
        .                 pending_elems: Vec::new(),
        .                 href_context,
        .             };
        .         
    2,786 (0.0%)      Classifier::new(
        .                 &src,
        .                 token_handler.href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),
        .                 decoration_info,
        .             )
1,594,496 (0.0%)      .highlight(&mut |highlight| {
1,604,130 (0.0%)          match highlight {
  860,530 (0.0%)              Highlight::Token { text, class } => {
        .                         // If we received a `ExitSpan` event and then have a non-compatible `Class`, we
        .                         // need to close the `<span>`.
  523,300 (0.0%)                  let need_current_class_update = if let Some(pending) =
        .                             token_handler.pending_exit_span
   22,866 (0.0%)                      && !can_merge(Some(pending), class, text)
        .                         {
    4,662 (0.0%)                      token_handler.handle_exit_span();
        .                             true
        .                         // If the two `Class` are different, time to flush the current content and start
        .                         // a new one.
1,635,238 (0.0%)                  } else if !can_merge(token_handler.current_class, class, text) {
  318,645 (0.0%)                      token_handler.write_pending_elems(token_handler.current_class);
        .                             true
        .                         } else {
        .                             token_handler.current_class.is_none()
        .                         };
        .         
        .                         if need_current_class_update {
  392,868 (0.0%)                      token_handler.current_class = class.map(Class::dummy);
        .                         }
    1,319 (0.0%)                  token_handler.pending_elems.push((text, class));
        .                     }
    2,508 (0.0%)              Highlight::EnterSpan { class } => {
        .                         let mut should_add = true;
    7,524 (0.0%)                  if let Some(pending_exit_span) = token_handler.pending_exit_span {
      708 (0.0%)                      if class.is_equal_to(pending_exit_span) {
        .                                 should_add = false;
        .                             } else {
       28 (0.0%)                          token_handler.handle_exit_span();
        .                             }
        .                         } else {
        .                             // We flush everything just in case...
   20,979 (0.0%)                      if token_handler.write_pending_elems(token_handler.current_class) {
    4,594 (0.0%)                          token_handler.current_class = None;
        .                             }
        .                         }
        .                         if should_add {
        .                             let closing_tag =
   14,070 (0.0%)                          enter_span(token_handler.out, class, &token_handler.href_context);
        .                             token_handler.closing_tags.push((closing_tag, class));
        .                         }
        .         
    2,508 (0.0%)                  token_handler.current_class = None;
    5,016 (0.0%)                  token_handler.pending_exit_span = None;
        .                     }
        .                     Highlight::ExitSpan => {
    5,016 (0.0%)                  token_handler.current_class = None;
   12,540 (0.0%)                  token_handler.pending_exit_span = Some(
    5,016 (0.0%)                      token_handler
        .                                 .closing_tags
        .                                 .last()
        .                                 .as_ref()
        .                                 .expect("ExitSpan without EnterSpan")
        .                                 .1,
        .                         );
        .                     }
        .                 };
1,416,976 (0.0%)      });
    2,786 (0.0%)  }
        .         
        .         fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {
      690 (0.0%)      writeln!(out, "</code></pre>{}</div>", playground_button.unwrap_or_default());
        .         }
        .         
        .         /// How a span of text is classified. Mostly corresponds to token kinds.
   62,794 (0.0%)  #[derive(Clone, Copy, Debug, Eq, PartialEq)]
        .         enum Class {
        .             Comment,
        .             DocComment,
        .             Attribute,
        .             KeyWord,
        .             /// Keywords that do pointer/reference stuff.
        .             RefKeyWord,
        .             Self_(Span),
-- line 343 ----------------------------------------
-- line 355 ----------------------------------------
        .             Decoration(&'static str),
        .         }
        .         
        .         impl Class {
        .             /// It is only looking at the variant, not the variant content.
        .             ///
        .             /// It is used mostly to group multiple similar HTML elements into one `<span>` instead of
        .             /// multiple ones.
  181,524 (0.0%)      fn is_equal_to(self, other: Self) -> bool {
  351,489 (0.0%)          match (self, other) {
        .                     (Self::Self_(_), Self::Self_(_))
        .                     | (Self::Macro(_), Self::Macro(_))
        .                     | (Self::Ident(_), Self::Ident(_)) => true,
        .                     (Self::Decoration(c1), Self::Decoration(c2)) => c1 == c2,
        .                     (x, y) => x == y,
        .                 }
   90,762 (0.0%)      }
        .         
        .             /// If `self` contains a `Span`, it'll be replaced with `DUMMY_SP` to prevent creating links
        .             /// on "empty content" (because of the attributes merge).
        .             fn dummy(self) -> Self {
        .                 match self {
        .                     Self::Self_(_) => Self::Self_(DUMMY_SP),
        .                     Self::Macro(_) => Self::Macro(DUMMY_SP),
        .                     Self::Ident(_) => Self::Ident(DUMMY_SP),
  104,154 (0.0%)              s => s,
        .                 }
        .             }
        .         
        .             /// Returns the css class expected by rustdoc for each `Class`.
        .             fn as_html(self) -> &'static str {
  174,926 (0.0%)          match self {
        .                     Class::Comment => "comment",
        .                     Class::DocComment => "doccomment",
        .                     Class::Attribute => "attr",
        .                     Class::KeyWord => "kw",
        .                     Class::RefKeyWord => "kw-2",
        .                     Class::Self_(_) => "self",
        .                     Class::Macro(_) => "macro",
        .                     Class::MacroNonTerminal => "macro-nonterminal",
-- line 394 ----------------------------------------
-- line 403 ----------------------------------------
        .                     Class::Decoration(kind) => kind,
        .                 }
        .             }
        .         
        .             /// In case this is an item which can be converted into a link to a definition, it'll contain
        .             /// a "span" (a tuple representing `(lo, hi)` equivalent of `Span`).
        .             fn get_span(self) -> Option<Span> {
        .                 match self {
   46,723 (0.0%)              Self::Ident(sp) | Self::Self_(sp) | Self::Macro(sp) => Some(sp),
        .                     Self::Comment
        .                     | Self::DocComment
        .                     | Self::Attribute
        .                     | Self::KeyWord
        .                     | Self::RefKeyWord
        .                     | Self::MacroNonTerminal
        .                     | Self::String
        .                     | Self::Number
-- line 419 ----------------------------------------
-- line 436 ----------------------------------------
        .         struct TokenIter<'a> {
        .             src: &'a str,
        .             cursor: Cursor<'a>,
        .         }
        .         
        .         impl<'a> Iterator for TokenIter<'a> {
        .             type Item = (TokenKind, &'a str);
        .             fn next(&mut self) -> Option<(TokenKind, &'a str)> {
  708,406 (0.0%)          let token = self.cursor.advance_token();
  951,900 (0.0%)          if token.kind == TokenKind::Eof {
      796 (0.0%)              return None;
        .                 }
  756,744 (0.0%)          let (text, rest) = self.src.split_at(token.len as usize);
  378,372 (0.0%)          self.src = rest;
  189,186 (0.0%)          Some((token.kind, text))
        .             }
        .         }
        .         
        .         /// Classifies into identifier class; returns `None` if this is a non-keyword identifier.
  469,722 (0.0%)  fn get_real_ident_class(text: &str, allow_path_keywords: bool) -> Option<Class> {
        .             let ignore: &[&str] =
  384,318 (0.0%)          if allow_path_keywords { &["self", "Self", "super", "crate"] } else { &["self", "Self"] };
        .             if ignore.iter().any(|k| *k == text) {
        .                 return None;
        .             }
        .             Some(match text {
   38,617 (0.0%)          "ref" | "mut" => Class::RefKeyWord,
   13,906 (0.0%)          "false" | "true" => Class::Bool,
  286,763 (0.0%)          _ if Symbol::intern(text).is_reserved(|| Edition::Edition2021) => Class::KeyWord,
        .                 _ => return None,
        .             })
  341,616 (0.0%)  }
        .         
        .         /// This iterator comes from the same idea than "Peekable" except that it allows to "peek" more than
        .         /// just the next item by using `peek_next`. The `peek` method always returns the next item after
        .         /// the current one whereas `peek_next` will return the next item after the last one peeked.
        .         ///
        .         /// You can use both `peek` and `peek_next` at the same time without problem.
        .         struct PeekIter<'a> {
        .             stored: VecDeque<(TokenKind, &'a str)>,
-- line 475 ----------------------------------------
-- line 478 ----------------------------------------
        .             iter: TokenIter<'a>,
        .         }
        .         
        .         impl<'a> PeekIter<'a> {
        .             fn new(iter: TokenIter<'a>) -> Self {
        .                 Self { stored: VecDeque::new(), peek_pos: 0, iter }
        .             }
        .             /// Returns the next item after the current one. It doesn't interfere with `peek_next` output.
2,752,096 (0.0%)      fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {
  980,548 (0.0%)          if self.stored.is_empty()
  378,372 (0.0%)              && let Some(next) = self.iter.next()
        .                 {
        .                     self.stored.push_back(next);
        .                 }
        .                 self.stored.front()
2,408,084 (0.0%)      }
        .             /// Returns the next item after the last one peeked. It doesn't interfere with `peek` output.
        .             fn peek_next(&mut self) -> Option<&(TokenKind, &'a str)> {
        .                 self.peek_pos += 1;
        .                 if self.peek_pos - 1 < self.stored.len() {
        .                     self.stored.get(self.peek_pos - 1)
        .                 } else if let Some(next) = self.iter.next() {
        .                     self.stored.push_back(next);
        .                     self.stored.back()
-- line 501 ----------------------------------------
-- line 502 ----------------------------------------
        .                 } else {
        .                     None
        .                 }
        .             }
        .         }
        .         
        .         impl<'a> Iterator for PeekIter<'a> {
        .             type Item = (TokenKind, &'a str);
1,091,760 (0.0%)      fn next(&mut self) -> Option<Self::Item> {
  202,108 (0.0%)          self.peek_pos = 0;
1,343,469 (0.0%)          if let Some(first) = self.stored.pop_front() { Some(first) } else { self.iter.next() }
  955,290 (0.0%)      }
        .         }
        .         
        .         /// Custom spans inserted into the source. Eg --scrape-examples uses this to highlight function calls
        .         struct Decorations {
        .             starts: Vec<(u32, &'static str)>,
        .             ends: Vec<u32>,
        .         }
        .         
-- line 521 ----------------------------------------
-- line 547 ----------------------------------------
        .             file_span: Span,
        .             src: &'src str,
        .             decorations: Option<Decorations>,
        .         }
        .         
        .         impl<'src> Classifier<'src> {
        .             /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code
        .             /// file span which will be used later on by the `span_correspondence_map`.
    3,980 (0.0%)      fn new(src: &str, file_span: Span, decoration_info: Option<DecorationInfo>) -> Classifier<'_> {
        .                 let tokens = PeekIter::new(TokenIter { src, cursor: Cursor::new(src) });
        .                 let decorations = decoration_info.map(Decorations::new);
   10,348 (0.0%)          Classifier {
        .                     tokens,
        .                     in_attribute: false,
        .                     in_macro: false,
        .                     in_macro_nonterminal: false,
        .                     byte_pos: 0,
        .                     file_span,
        .                     src,
        .                     decorations,
        .                 }
    3,184 (0.0%)      }
        .         
        .             /// Convenient wrapper to create a [`Span`] from a position in the file.
  403,608 (0.0%)      fn new_span(&self, lo: u32, text: &str) -> Span {
   33,634 (0.0%)          let hi = lo + text.len() as u32;
        .                 let file_lo = self.file_span.lo();
        .                 self.file_span.with_lo(file_lo + BytePos(lo)).with_hi(file_lo + BytePos(hi))
        .             }
        .         
        .             /// Concatenate colons and idents as one when possible.
        .             fn get_full_ident_path(&mut self) -> Vec<(TokenKind, usize, usize)> {
  220,430 (0.0%)          let start = self.byte_pos as usize;
        .                 let mut pos = start;
        .                 let mut has_ident = false;
        .         
        .                 loop {
        .                     let mut nb = 0;
  219,586 (0.0%)              while let Some((TokenKind::Colon, _)) = self.tokens.peek() {
        .                         self.tokens.next();
        .                         nb += 1;
        .                     }
        .                     // Ident path can start with "::" but if we already have content in the ident path,
        .                     // the "::" is mandatory.
  169,214 (0.0%)              if has_ident && nb == 0 {
        .                         return vec![(TokenKind::Ident, start, pos)];
  103,058 (0.0%)              } else if nb != 0 && nb != 2 {
    4,934 (0.0%)                  if has_ident {
    7,293 (0.0%)                      return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];
        .                         } else {
      216 (0.0%)                      return vec![(TokenKind::Colon, start, pos + nb)];
        .                         }
        .                     }
        .         
        .                     if let Some((None, text)) = self.tokens.peek().map(|(token, text)| {
  245,310 (0.0%)                  if *token == TokenKind::Ident {
   97,432 (0.0%)                      let class = get_real_ident_class(text, true);
        .                             (class, text)
        .                         } else {
        .                             // Doesn't matter which Class we put in here...
        .                             (Some(Class::Comment), text)
        .                         }
        .                     }) {
        .                         // We only "add" the colon if there is an ident behind.
        .                         pos += text.len() + nb;
        .                         has_ident = true;
  112,170 (0.0%)                  self.tokens.next();
    9,579 (0.0%)              } else if nb > 0 && has_ident {
      692 (0.0%)                  return vec![(TokenKind::Ident, start, pos), (TokenKind::Colon, pos, pos + nb)];
    8,195 (0.0%)              } else if nb > 0 {
        .                         return vec![(TokenKind::Colon, start, start + nb)];
   16,390 (0.0%)              } else if has_ident {
        .                         return vec![(TokenKind::Ident, start, pos)];
        .                     } else {
        .                         return Vec::new();
        .                     }
        .                 }
        .             }
        .         
        .             /// Wraps the tokens iteration to ensure that the `byte_pos` is always correct.
        .             ///
        .             /// It returns the token's kind, the token as a string and its byte position in the source
        .             /// string.
   21,408 (0.0%)      fn next(&mut self) -> Option<(TokenKind, &'src str, u32)> {
1,082,538 (0.0%)          if let Some((kind, text)) = self.tokens.next() {
  136,072 (0.0%)              let before = self.byte_pos;
  272,144 (0.0%)              self.byte_pos += text.len() as u32;
    8,028 (0.0%)              Some((kind, text, before))
        .                 } else {
    1,990 (0.0%)              None
        .                 }
   13,380 (0.0%)      }
        .         
        .             /// Exhausts the `Classifier` writing the output into `sink`.
        .             ///
        .             /// The general structure for this method is to iterate over each token,
        .             /// possibly giving it an HTML span with a class specifying what flavor of
        .             /// token is used.
    7,562 (0.0%)      fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'src>)) {
        .                 loop {
        .                     if let Some(decs) = self.decorations.as_mut() {
  141,097 (0.0%)                  let byte_pos = self.byte_pos;
  282,194 (0.0%)                  let n_starts = decs.starts.iter().filter(|(i, _)| byte_pos >= *i).count();
  846,582 (0.0%)                  for (_, kind) in decs.starts.drain(0..n_starts) {
        .                             sink(Highlight::EnterSpan { class: Class::Decoration(kind) });
        .                         }
        .         
  282,194 (0.0%)                  let n_ends = decs.ends.iter().filter(|i| byte_pos >= **i).count();
  846,582 (0.0%)                  for _ in decs.ends.drain(0..n_ends) {
        .                             sink(Highlight::ExitSpan);
        .                         }
        .                     }
        .         
  847,231 (0.0%)              if self
        .                         .tokens
        .                         .peek()
  338,574 (0.0%)                  .map(|t| matches!(t.0, TokenKind::Colon | TokenKind::Ident))
        .                         .unwrap_or(false)
        .                     {
        .                         let tokens = self.get_full_ident_path();
        .                         for (token, start, end) in &tokens {
  154,672 (0.0%)                      let text = &self.src[*start..*end];
  270,676 (0.0%)                      self.advance(*token, text, sink, *start as u32);
   38,668 (0.0%)                      self.byte_pos += text.len() as u32;
        .                         }
        .                         if !tokens.is_empty() {
        .                             continue;
        .                         }
        .                     }
  267,588 (0.0%)              if let Some((token, text, before)) = self.next() {
1,067,168 (0.0%)                  self.advance(token, text, sink, before);
        .                     } else {
        .                         break;
        .                     }
        .                 }
    3,184 (0.0%)      }
        .         
        .             /// Single step of highlighting. This will classify `token`, but maybe also a couple of
        .             /// following ones as well.
        .             ///
        .             /// `before` is the position of the given token in the `source` string and is used as "lo" byte
        .             /// in case we want to try to generate a link for this token using the
        .             /// `span_correspondence_map`.
2,408,896 (0.0%)      fn advance(
        .                 &mut self,
        .                 token: TokenKind,
        .                 text: &'src str,
        .                 sink: &mut dyn FnMut(Highlight<'src>),
        .                 before: u32,
        .             ) {
  172,064 (0.0%)          let lookahead = self.peek();
  233,142 (0.0%)          let no_highlight = |sink: &mut dyn FnMut(_)| sink(Highlight::Token { text, class: None });
  860,320 (0.0%)          let class = match token {
        .                     TokenKind::Whitespace => return no_highlight(sink),
        .                     TokenKind::LineComment { doc_style } | TokenKind::BlockComment { doc_style, .. } => {
        .                         if doc_style.is_some() {
        .                             Class::DocComment
        .                         } else {
        .                             Class::Comment
        .                         }
        .                     }
        .                     // Consider this as part of a macro invocation if there was a
        .                     // leading identifier.
    3,032 (0.0%)              TokenKind::Bang if self.in_macro => {
    1,348 (0.0%)                  self.in_macro = false;
    5,392 (0.0%)                  sink(Highlight::Token { text, class: None });
        .                         sink(Highlight::ExitSpan);
        .                         return;
        .                     }
        .         
        .                     // Assume that '&' or '*' is the reference or dereference operator
        .                     // or a reference or pointer type. Unless, of course, it looks like
        .                     // a logical and or a multiplication operator: `&&` or `* `.
    1,877 (0.0%)              TokenKind::Star => match self.tokens.peek() {
        .                         Some((TokenKind::Whitespace, _)) => return no_highlight(sink),
      346 (0.0%)                  Some((TokenKind::Ident, "mut")) => {
       12 (0.0%)                      self.next();
       12 (0.0%)                      sink(Highlight::Token { text: "*mut", class: Some(Class::RefKeyWord) });
        .                             return;
        .                         }
        8 (0.0%)                  Some((TokenKind::Ident, "const")) => {
        4 (0.0%)                      self.next();
       10 (0.0%)                      sink(Highlight::Token { text: "*const", class: Some(Class::RefKeyWord) });
        .                             return;
        .                         }
        .                         _ => Class::RefKeyWord,
        .                     },
   24,039 (0.0%)              TokenKind::And => match self.tokens.peek() {
        .                         Some((TokenKind::And, _)) => {
       72 (0.0%)                      self.next();
       72 (0.0%)                      sink(Highlight::Token { text: "&&", class: None });
        .                             return;
        .                         }
        .                         Some((TokenKind::Eq, _)) => {
        2 (0.0%)                      self.next();
        3 (0.0%)                      sink(Highlight::Token { text: "&=", class: None });
        .                             return;
        .                         }
        .                         Some((TokenKind::Whitespace, _)) => return no_highlight(sink),
    2,320 (0.0%)                  Some((TokenKind::Ident, "mut")) => {
    2,010 (0.0%)                      self.next();
    3,015 (0.0%)                      sink(Highlight::Token { text: "&mut", class: Some(Class::RefKeyWord) });
        .                             return;
        .                         }
        .                         _ => Class::RefKeyWord,
        .                     },
        .         
        .                     // These can either be operators, or arrows.
   20,088 (0.0%)              TokenKind::Eq => match lookahead {
        .                         Some(TokenKind::Eq) => {
      198 (0.0%)                      self.next();
      297 (0.0%)                      sink(Highlight::Token { text: "==", class: None });
        .                             return;
        .                         }
        .                         Some(TokenKind::Gt) => {
    1,410 (0.0%)                      self.next();
    2,115 (0.0%)                      sink(Highlight::Token { text: "=>", class: None });
        .                             return;
        .                         }
        .                         _ => return no_highlight(sink),
        .                     },
    1,638 (0.0%)              TokenKind::Minus if lookahead == Some(TokenKind::Gt) => {
    1,560 (0.0%)                  self.next();
    2,340 (0.0%)                  sink(Highlight::Token { text: "->", class: None });
        .                         return;
        .                     }
        .         
        .                     // Other operators.
        .                     TokenKind::Minus
        .                     | TokenKind::Plus
        .                     | TokenKind::Or
        .                     | TokenKind::Slash
-- line 778 ----------------------------------------
-- line 793 ----------------------------------------
        .                     | TokenKind::OpenBracket
        .                     | TokenKind::At
        .                     | TokenKind::Tilde
        .                     | TokenKind::Colon
        .                     | TokenKind::Unknown => return no_highlight(sink),
        .         
        .                     TokenKind::Question => Class::QuestionMark,
        .         
       88 (0.0%)              TokenKind::Dollar => match lookahead {
        .                         Some(TokenKind::Ident) => {
      102 (0.0%)                      self.in_macro_nonterminal = true;
        .                             Class::MacroNonTerminal
        .                         }
        .                         _ => return no_highlight(sink),
        .                     },
        .         
        .                     // This might be the start of an attribute. We're going to want to
        .                     // continue highlighting it as an attribute until the ending ']' is
        .                     // seen, so skip out early. Down below we terminate the attribute
        .                     // span when we see the ']'.
        .                     TokenKind::Pound => {
    2,488 (0.0%)                  match lookahead {
        .                             // Case 1: #![inner_attribute]
        .                             Some(TokenKind::Bang) => {
       84 (0.0%)                          self.next();
       84 (0.0%)                          if let Some(TokenKind::OpenBracket) = self.peek() {
       42 (0.0%)                              self.in_attribute = true;
      210 (0.0%)                              sink(Highlight::EnterSpan { class: Class::Attribute });
        .                                 }
      336 (0.0%)                          sink(Highlight::Token { text: "#", class: None });
      336 (0.0%)                          sink(Highlight::Token { text: "!", class: None });
        .                                 return;
        .                             }
        .                             // Case 2: #[outer_attribute]
        .                             Some(TokenKind::OpenBracket) => {
    1,118 (0.0%)                          self.in_attribute = true;
   10,062 (0.0%)                          sink(Highlight::EnterSpan { class: Class::Attribute });
        .                             }
        .                             _ => (),
        .                         }
        .                         return no_highlight(sink);
        .                     }
        .                     TokenKind::CloseBracket => {
    3,398 (0.0%)                  if self.in_attribute {
    1,160 (0.0%)                      self.in_attribute = false;
    4,640 (0.0%)                      sink(Highlight::Token { text: "]", class: None });
        .                             sink(Highlight::ExitSpan);
        .                             return;
        .                         }
        .                         return no_highlight(sink);
        .                     }
    8,116 (0.0%)              TokenKind::Literal { kind, .. } => match kind {
        .                         // Text literals.
        .                         LiteralKind::Byte { .. }
        .                         | LiteralKind::Char { .. }
        .                         | LiteralKind::Str { .. }
        .                         | LiteralKind::ByteStr { .. }
        .                         | LiteralKind::RawStr { .. }
        .                         | LiteralKind::RawByteStr { .. }
        .                         | LiteralKind::CStr { .. }
        .                         | LiteralKind::RawCStr { .. } => Class::String,
        .                         // Number literals.
        .                         LiteralKind::Float { .. } | LiteralKind::Int { .. } => Class::Number,
        .                     },
   88,100 (0.0%)              TokenKind::Ident | TokenKind::RawIdent if lookahead == Some(TokenKind::Bang) => {
    1,348 (0.0%)                  self.in_macro = true;
   14,828 (0.0%)                  sink(Highlight::EnterSpan { class: Class::Macro(self.new_span(before, text)) });
    5,392 (0.0%)                  sink(Highlight::Token { text, class: None });
        .                         return;
        .                     }
  298,914 (0.0%)              TokenKind::Ident => match get_real_ident_class(text, false) {
        .                         None => match text {
    5,626 (0.0%)                      "Option" | "Result" => Class::PreludeTy,
   18,934 (0.0%)                      "Some" | "None" | "Ok" | "Err" => Class::PreludeVal,
        .                             // "union" is a weak keyword and is only considered as a keyword when declaring
        .                             // a union type.
    2,391 (0.0%)                      "union" if self.check_if_is_union_keyword() => Class::KeyWord,
   64,640 (0.0%)                      _ if self.in_macro_nonterminal => {
      102 (0.0%)                          self.in_macro_nonterminal = false;
        .                                 Class::MacroNonTerminal
        .                             }
   19,404 (0.0%)                      "self" | "Self" => Class::Self_(self.new_span(before, text)),
        .                             _ => Class::Ident(self.new_span(before, text)),
        .                         },
   51,840 (0.0%)                  Some(c) => c,
        .                     },
        .                     TokenKind::RawIdent | TokenKind::UnknownPrefix | TokenKind::InvalidIdent => {
        .                         Class::Ident(self.new_span(before, text))
        .                     }
        .                     TokenKind::Lifetime { .. } => Class::Lifetime,
        .                     TokenKind::Eof => panic!("Eof in advance"),
        .                 };
        .                 // Anything that didn't return above is the simple case where we the
        .                 // class just spans a single token, so we can use the `string` method.
  310,536 (0.0%)          sink(Highlight::Token { text, class: Some(class) });
1,376,512 (0.0%)      }
        .         
        .             fn peek(&mut self) -> Option<TokenKind> {
  172,148 (0.0%)          self.tokens.peek().map(|(token_kind, _text)| *token_kind)
        .             }
        .         
        .             fn check_if_is_union_keyword(&mut self) -> bool {
        .                 while let Some(kind) = self.tokens.peek_next().map(|(token_kind, _text)| token_kind) {
        .                     if *kind == TokenKind::Whitespace {
        .                         continue;
        .                     }
        .                     return *kind == TokenKind::Ident;
        .                 }
        .                 false
        .             }
        .         }
        .         
        .         /// Called when we start processing a span of text that should be highlighted.
        .         /// The `Class` argument specifies how it should be highlighted.
  289,284 (0.0%)  fn enter_span(
        .             out: &mut impl Write,
        .             klass: Class,
        .             href_context: &Option<HrefContext<'_, '_>>,
        .         ) -> &'static str {
        .             string_without_closing_tag(out, "", Some(klass), href_context, true).expect(
        .                 "internal error: enter_span was called with Some(klass) but did not return a \
        .                     closing HTML tag",
        .             )
  192,856 (0.0%)  }
        .         
        .         /// Called at the end of a span of highlighted text.
        .         fn exit_span(out: &mut impl Write, closing_tag: &str) {
   38,736 (0.0%)      out.write_str(closing_tag).unwrap();
        .         }
        .         
        .         /// Called for a span of text. If the text should be highlighted differently
        .         /// from the surrounding text, then the `Class` argument will be a value other
        .         /// than `None`.
        .         ///
        .         /// The following sequences of callbacks are equivalent:
        .         /// ```plain
-- line 928 ----------------------------------------
-- line 931 ----------------------------------------
        .         /// ```
        .         ///
        .         /// The latter can be thought of as a shorthand for the former, which is more
        .         /// flexible.
        .         ///
        .         /// Note that if `context` is not `None` and that the given `klass` contains a `Span`, the function
        .         /// will then try to find this `span` in the `span_correspondence_map`. If found, it'll then
        .         /// generate a link for this element (which corresponds to where its definition is located).
1,721,060 (0.0%)  fn string<T: Display>(
        .             out: &mut impl Write,
        .             text: T,
        .             klass: Option<Class>,
        .             href_context: &Option<HrefContext<'_, '_>>,
        .             open_tag: bool,
        .         ) {
  117,398 (0.0%)      if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)
        .             {
   15,840 (0.0%)          out.write_str(closing_tag).unwrap();
        .             }
1,376,848 (0.0%)  }
        .         
        .         /// This function writes `text` into `out` with some modifications depending on `klass`:
        .         ///
        .         /// * If `klass` is `None`, `text` is written into `out` with no modification.
        .         /// * If `klass` is `Some` but `klass.get_span()` is `None`, it writes the text wrapped in a
        .         ///   `<span>` with the provided `klass`.
        .         /// * If `klass` is `Some` and has a [`rustc_span::Span`], it then tries to generate a link (`<a>`
        .         ///   element) by retrieving the link information from the `span_correspondence_map` that was filled
-- line 958 ----------------------------------------
-- line 960 ----------------------------------------
        .         ///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).
        .         fn string_without_closing_tag<T: Display>(
        .             out: &mut impl Write,
        .             text: T,
        .             klass: Option<Class>,
        .             href_context: &Option<HrefContext<'_, '_>>,
        .             open_tag: bool,
        .         ) -> Option<&'static str> {
  948,644 (0.0%)      let Some(klass) = klass else {
  358,011 (0.0%)          write!(out, "{text}").unwrap();
        .                 return None;
        .             };
        .             let Some(def_span) = klass.get_span() else {
   40,966 (0.0%)          if !open_tag {
   35,391 (0.0%)              write!(out, "{text}").unwrap();
        .                     return None;
        .                 }
  173,890 (0.0%)          write!(out, "<span class=\"{klass}\">{text}", klass = klass.as_html()).unwrap();
        .                 return Some("</span>");
        .             };
        .         
        .             let mut text_s = text.to_string();
   93,446 (0.0%)      if text_s.contains("::") {
   93,965 (0.0%)          text_s = text_s.split("::").intersperse("::").fold(String::new(), |mut path, t| {
        .                     match t {
    3,945 (0.0%)                  "self" | "Self" => write!(
        .                             &mut path,
        .                             "<span class=\"{klass}\">{t}</span>",
      696 (0.0%)                      klass = Class::Self_(DUMMY_SP).as_html(),
        .                         ),
    1,754 (0.0%)                  "crate" | "super" => {
    2,610 (0.0%)                      write!(
        .                                 &mut path,
        .                                 "<span class=\"{klass}\">{t}</span>",
    1,740 (0.0%)                          klass = Class::KeyWord.as_html(),
        .                             )
        .                         }
   76,662 (0.0%)                  t => write!(&mut path, "{t}"),
        .                     }
        .                     .expect("Failed to build source HTML path");
   44,126 (0.0%)              path
   43,385 (0.0%)          });
        .             }
        .         
   93,446 (0.0%)      if let Some(href_context) = href_context {
        .                 if let Some(href) =
   39,638 (0.0%)              href_context.context.shared.span_correspondence_map.get(&def_span).and_then(|href| {
        .                         let context = href_context.context;
        .                         // FIXME: later on, it'd be nice to provide two links (if possible) for all items:
        .                         // one to the documentation page and one to the source definition.
        .                         // FIXME: currently, external items only generate a link to their documentation,
        .                         // a link to their definition can be generated using this:
        .                         // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338
        .                         match href {
        .                             LinkFromSrc::Local(span) => {
-- line 1014 ----------------------------------------
-- line 1044 ----------------------------------------
        .                             write!(out, "<a href=\"{href}\">{text_s}").unwrap();
        .                         } else {
        .                             write!(out, "<a class=\"{klass_s}\" href=\"{href}\">{text_s}").unwrap();
        .                         }
        .                     }
        .                     return Some("</a>");
        .                 }
        .             }
  101,301 (0.0%)      if !open_tag {
   91,371 (0.0%)          write!(out, "{}", text_s).unwrap();
        .                 return None;
        .             }
   58,214 (0.0%)      let klass_s = klass.as_html();
        .             if klass_s.is_empty() {
   21,620 (0.0%)          out.write_str(&text_s).unwrap();
        .                 Some("")
        .             } else {
   23,975 (0.0%)          write!(out, "<span class=\"{klass_s}\">{text_s}").unwrap();
        .                 Some("</span>")
        .             }
        .         }
        .         
        .         #[cfg(test)]
        .         mod tests;

--------------------------------------------------------------------------------
-- Annotated source file: /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/map.rs
--------------------------------------------------------------------------------
Ir______________ 

6,567,634 (0.1%)  <unknown (line 0)>

-- line 188 ----------------------------------------
        .         /// // use the values stored in map
        .         /// ```
        .         pub struct HashMap<K, V, S = DefaultHashBuilder, A: Allocator = Global> {
        .             pub(crate) hash_builder: S,
        .             pub(crate) table: RawTable<(K, V), A>,
        .         }
        .         
        .         impl<K: Clone, V: Clone, S: Clone, A: Allocator + Clone> Clone for HashMap<K, V, S, A> {
    2,328 (0.0%)      fn clone(&self) -> Self {
    1,746 (0.0%)          HashMap {
        .                     hash_builder: self.hash_builder.clone(),
        .                     table: self.table.clone(),
        .                 }
    2,328 (0.0%)      }
        .         
        .             fn clone_from(&mut self, source: &Self) {
        .                 self.table.clone_from(&source.table);
        .         
        .                 // Update hash_builder only if we successfully cloned all elements.
        .                 self.hash_builder.clone_from(&source.hash_builder);
        .             }
        .         }
-- line 209 ----------------------------------------
-- line 221 ----------------------------------------
        .         
        .         /// Ensures that a single closure type across uses of this which, in turn prevents multiple
        .         /// instances of any functions like RawTable::reserve from being generated
        .         #[cfg_attr(feature = "inline-more", inline)]
        .         fn equivalent_key<Q, K, V>(k: &Q) -> impl Fn(&(K, V)) -> bool + '_
        .         where
        .             Q: ?Sized + Equivalent<K>,
        .         {
    3,212 (0.0%)      move |x| k.equivalent(&x.0)
        .         }
        .         
        .         /// Ensures that a single closure type across uses of this which, in turn prevents multiple
        .         /// instances of any functions like RawTable::reserve from being generated
        .         #[cfg_attr(feature = "inline-more", inline)]
        .         fn equivalent<Q, K>(k: &Q) -> impl Fn(&K) -> bool + '_
        .         where
        .             Q: ?Sized + Equivalent<K>,
-- line 237 ----------------------------------------
-- line 254 ----------------------------------------
        .         
        .         #[cfg(feature = "nightly")]
        .         #[cfg_attr(feature = "inline-more", inline)]
        .         pub(crate) fn make_hash<Q, S>(hash_builder: &S, val: &Q) -> u64
        .         where
        .             Q: Hash + ?Sized,
        .             S: BuildHasher,
        .         {
   57,222 (0.0%)      hash_builder.hash_one(val)
        .         }
        .         
        .         #[cfg(feature = "ahash")]
        .         impl<K, V> HashMap<K, V, DefaultHashBuilder> {
        .             /// Creates an empty `HashMap`.
        .             ///
        .             /// The hash map is initially created with a capacity of 0, so it will not allocate until it
        .             /// is first inserted into.
-- line 270 ----------------------------------------
-- line 840 ----------------------------------------
        .             ///
        .             /// let mut a = HashMap::new();
        .             /// assert!(a.is_empty());
        .             /// a.insert(1, "a");
        .             /// assert!(!a.is_empty());
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             pub fn is_empty(&self) -> bool {
   15,571 (0.0%)          self.len() == 0
        .             }
        .         
        .             /// Clears the map, returning all key-value pairs as an iterator. Keeps the
        .             /// allocated memory for reuse.
        .             ///
        .             /// If the returned iterator is dropped before being fully consumed, it
        .             /// drops the remaining key-value pairs. The returned iterator keeps a
        .             /// mutable borrow on the vector to optimize its implementation.
-- line 856 ----------------------------------------
-- line 1099 ----------------------------------------
        .             /// map.reserve(10);
        .             ///
        .             /// // And now map can hold at least 10 elements
        .             /// assert!(map.capacity() >= 10);
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             pub fn reserve(&mut self, additional: usize) {
        .                 self.table
    4,637 (0.0%)              .reserve(additional, make_hasher::<_, V, S>(&self.hash_builder));
        .             }
        .         
        .             /// Tries to reserve capacity for at least `additional` more elements to be inserted
        .             /// in the given `HashMap<K,V>`. The collection may reserve more space to avoid
        .             /// frequent reallocations.
        .             ///
        .             /// # Errors
        .             ///
-- line 1115 ----------------------------------------
-- line 1300 ----------------------------------------
        .             /// use hashbrown::HashMap;
        .             ///
        .             /// let mut map = HashMap::new();
        .             /// map.insert(1, "a");
        .             /// assert_eq!(map.get(&1), Some(&"a"));
        .             /// assert_eq!(map.get(&2), None);
        .             /// ```
        .             #[inline]
  138,006 (0.0%)      pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
        .                 // Avoid `Option::map` because it bloats LLVM IR.
   58,409 (0.0%)          match self.get_inner(k) {
        .                     Some((_, v)) => Some(v),
        .                     None => None,
        .                 }
  130,096 (0.0%)      }
        .         
        .             /// Returns the key-value pair corresponding to the supplied key.
        .             ///
        .             /// The supplied key may be any borrowed form of the map's key type, but
        .             /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for
        .             /// the key type.
        .             ///
        .             /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html
-- line 1325 ----------------------------------------
-- line 1347 ----------------------------------------
        .                 }
        .             }
        .         
        .             #[inline]
        .             fn get_inner<Q: ?Sized>(&self, k: &Q) -> Option<&(K, V)>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
4,830,812 (0.1%)          if self.table.is_empty() {
        .                     None
        .                 } else {
        .                     let hash = make_hash::<Q, S>(&self.hash_builder, k);
4,048,552 (0.1%)              self.table.get(hash, equivalent_key(k))
        .                 }
        .             }
        .         
        .             /// Returns the key-value pair corresponding to the supplied key, with a mutable reference to value.
        .             ///
        .             /// The supplied key may be any borrowed form of the map's key type, but
        .             /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for
        .             /// the key type.
-- line 1367 ----------------------------------------
-- line 1415 ----------------------------------------
        .             /// assert_eq!(map.contains_key(&2), false);
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
        .                 self.get_inner(k).is_some()
   26,648 (0.0%)      }
        .         
        .             /// Returns a mutable reference to the value corresponding to the key.
        .             ///
        .             /// The key may be any borrowed form of the map's key type, but
        .             /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for
        .             /// the key type.
        .             ///
        .             /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html
-- line 1431 ----------------------------------------
-- line 1441 ----------------------------------------
        .             /// if let Some(x) = map.get_mut(&1) {
        .             ///     *x = "b";
        .             /// }
        .             /// assert_eq!(map[&1], "b");
        .             ///
        .             /// assert_eq!(map.get_mut(&2), None);
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
   53,505 (0.0%)      pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
        .                 // Avoid `Option::map` because it bloats LLVM IR.
    5,986 (0.0%)          match self.get_inner_mut(k) {
        .                     Some(&mut (_, ref mut v)) => Some(v),
        .                     None => None,
        .                 }
   47,592 (0.0%)      }
        .         
        .             #[inline]
        .             fn get_inner_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut (K, V)>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
   20,258 (0.0%)          if self.table.is_empty() {
        .                     None
        .                 } else {
        .                     let hash = make_hash::<Q, S>(&self.hash_builder, k);
   20,360 (0.0%)              self.table.get_mut(hash, equivalent_key(k))
        .                 }
        .             }
        .         
        .             /// Attempts to get mutable references to `N` values in the map at once.
        .             ///
        .             /// Returns an array of length `N` with the results of each query. For soundness, at most one
        .             /// mutable reference will be returned to any value. `None` will be returned if any of the
        .             /// keys are duplicates or missing.
-- line 1477 ----------------------------------------
-- line 1743 ----------------------------------------
        .             /// assert_eq!(map.insert(37, "a"), None);
        .             /// assert_eq!(map.is_empty(), false);
        .             ///
        .             /// map.insert(37, "b");
        .             /// assert_eq!(map.insert(37, "c"), Some("b"));
        .             /// assert_eq!(map[&37], "c");
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
8,706,076 (0.1%)      pub fn insert(&mut self, k: K, v: V) -> Option<V> {
  309,550 (0.0%)          let hash = make_hash::<K, S>(&self.hash_builder, &k);
        .                 let hasher = make_hasher::<_, V, S>(&self.hash_builder);
        .                 match self
        .                     .table
        .                     .find_or_find_insert_slot(hash, equivalent_key(&k), hasher)
        .                 {
  138,197 (0.0%)              Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().1 }, v)),
        .                     Err(slot) => {
        .                         unsafe {
3,287,315 (0.0%)                      self.table.insert_in_slot(hash, slot, (k, v));
        .                         }
  149,562 (0.0%)                  None
        .                     }
        .                 }
7,673,751 (0.1%)      }
        .         
        .             /// Insert a key-value pair into the map without checking
        .             /// if the key already exists in the map.
        .             ///
        .             /// Returns a reference to the key and value just inserted.
        .             ///
        .             /// This operation is safe if a key does not exist in the map.
        .             ///
-- line 1774 ----------------------------------------
-- line 1887 ----------------------------------------
        .             ///
        .             /// assert_eq!(map.remove(&1), Some("a"));
        .             /// assert_eq!(map.remove(&1), None);
        .             ///
        .             /// // Now map holds none elements
        .             /// assert!(map.is_empty());
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
4,034,203 (0.1%)      pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
        .                 // Avoid `Option::map` because it bloats LLVM IR.
1,302,086 (0.0%)          match self.remove_entry(k) {
5,476,277 (0.1%)              Some((_, v)) => Some(v),
  140,328 (0.0%)              None => None,
        .                 }
3,421,867 (0.0%)      }
        .         
        .             /// Removes a key from the map, returning the stored key and value if the
        .             /// key was previously in the map. Keeps the allocated memory for reuse.
        .             ///
        .             /// The key may be any borrowed form of the map's key type, but
        .             /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for
        .             /// the key type.
        .             ///
-- line 1912 ----------------------------------------
-- line 1931 ----------------------------------------
        .             /// assert!(map.is_empty());
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>
        .             where
        .                 Q: Hash + Equivalent<K>,
        .             {
        .                 let hash = make_hash::<Q, S>(&self.hash_builder, k);
1,578,063 (0.0%)          self.table.remove_entry(hash, equivalent_key(k))
        .             }
        .         }
        .         
        .         impl<K, V, S, A: Allocator> HashMap<K, V, S, A> {
        .             /// Creates a raw entry builder for the HashMap.
        .             ///
        .             /// Raw entries provide the lowest level of control for searching and
        .             /// manipulating a map. They must be manually initialized with a hash and
-- line 1947 ----------------------------------------
-- line 3233 ----------------------------------------
        .                 self.search(hash, is_match)
        .             }
        .         
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn search<F>(self, hash: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S, A>
        .             where
        .                 for<'b> F: FnMut(&'b K) -> bool,
        .             {
   25,616 (0.0%)          match self.map.table.find(hash, |(k, _)| is_match(k)) {
        .                     Some(elem) => RawEntryMut::Occupied(RawOccupiedEntryMut {
        .                         elem,
        .                         table: &mut self.map.table,
        .                         hash_builder: &self.map.hash_builder,
        .                     }),
        .                     None => RawEntryMut::Vacant(RawVacantEntryMut {
        .                         table: &mut self.map.table,
  516,725 (0.0%)                  hash_builder: &self.map.hash_builder,
        .                     }),
        .                 }
        .             }
        .         }
        .         
        .         impl<'a, K, V, S, A: Allocator> RawEntryBuilder<'a, K, V, S, A> {
        .             /// Access an immutable entry by key.
        .             ///
-- line 3257 ----------------------------------------
-- line 3336 ----------------------------------------
        .             /// assert_eq!(map.raw_entry().from_hash(hash, |k| k == &key), Some((&"a", &100)));
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             #[allow(clippy::wrong_self_convention)]
        .             pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>
        .             where
        .                 F: FnMut(&K) -> bool,
        .             {
6,058,939 (0.1%)          self.search(hash, is_match)
        .             }
        .         }
        .         
        .         impl<'a, K, V, S, A: Allocator> RawEntryMut<'a, K, V, S, A> {
        .             /// Sets the value of the entry, and returns a RawOccupiedEntryMut.
        .             ///
        .             /// # Examples
        .             ///
-- line 3352 ----------------------------------------
-- line 3993 ----------------------------------------
        .             ///         (&mut "c", &mut 300)
        .             ///     ),
        .             /// }
        .             ///
        .             /// assert_eq!(map[&"c"], 300);
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             #[allow(clippy::shadow_unrelated)]
  163,014 (0.0%)      pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)
        .             where
        .                 K: Hash,
        .                 S: BuildHasher,
        .             {
        .                 let &mut (ref mut k, ref mut v) = self.table.insert_entry(
        .                     hash,
        .                     (key, value),
        .                     make_hasher::<_, V, S>(self.hash_builder),
        .                 );
        .                 (k, v)
  163,014 (0.0%)      }
        .         
        .             /// Set the value of an entry with a custom hasher function.
        .             ///
        .             /// # Examples
        .             ///
        .             /// ```
        .             /// use core::hash::{BuildHasher, Hash};
        .             /// use hashbrown::hash_map::{HashMap, RawEntryMut};
-- line 4020 ----------------------------------------
-- line 4721 ----------------------------------------
        .         }
        .         
        .         impl<'a, K, V> Iterator for Iter<'a, K, V> {
        .             type Item = (&'a K, &'a V);
        .         
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn next(&mut self) -> Option<(&'a K, &'a V)> {
        .                 // Avoid `Option::map` because it bloats LLVM IR.
1,855,347 (0.0%)          match self.inner.next() {
        .                     Some(x) => unsafe {
        .                         let r = x.as_ref();
        .                         Some((&r.0, &r.1))
        .                     },
        .                     None => None,
        .                 }
      121 (0.0%)      }
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn size_hint(&self) -> (usize, Option<usize>) {
        .                 self.inner.size_hint()
        .             }
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn fold<B, F>(self, init: B, mut f: F) -> B
        .             where
        .                 Self: Sized,
        .                 F: FnMut(B, Self::Item) -> B,
        .             {
        .                 self.inner.fold(init, |acc, x| unsafe {
        .                     let (k, v) = x.as_ref();
      561 (0.0%)              f(acc, (k, v))
        .                 })
        .             }
        .         }
        .         impl<K, V> ExactSizeIterator for Iter<'_, K, V> {
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn len(&self) -> usize {
        .                 self.inner.len()
        .             }
-- line 4757 ----------------------------------------
-- line 6497 ----------------------------------------
        .             /// ```
        .             #[cfg_attr(feature = "inline-more", inline)]
        .             fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {
        .                 // Keys may be already present or show multiple times in the iterator.
        .                 // Reserve the entire hint lower bound if the map is empty.
        .                 // Otherwise reserve half the hint (rounded up), so the map
        .                 // will only resize twice in the worst case.
        .                 let iter = iter.into_iter();
   61,636 (0.0%)          let reserve = if self.is_empty() {
        1 (0.0%)              iter.size_hint().0
        .                 } else {
        .                     (iter.size_hint().0 + 1) / 2
        .                 };
        .                 self.reserve(reserve);
      198 (0.0%)          iter.for_each(move |(k, v)| {
  203,792 (0.0%)              self.insert(k, v);
        .                 });
        .             }
        .         
        .             #[inline]
        .             #[cfg(feature = "nightly")]
        .             fn extend_one(&mut self, (k, v): (K, V)) {
        .                 self.insert(k, v);
        .             }
-- line 6520 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.3/src/raw/mod.rs
--------------------------------------------------------------------------------
Ir________________ 

 38,779,305 (0.5%)  <unknown (line 0)>

-- line 108 ----------------------------------------
          .         const EMPTY: u8 = 0b1111_1111;
          .         
          .         /// Control byte value for a deleted bucket.
          .         const DELETED: u8 = 0b1000_0000;
          .         
          .         /// Checks whether a control byte represents a full bucket (top bit is clear).
          .         #[inline]
          .         fn is_full(ctrl: u8) -> bool {
  7,135,955 (0.1%)      ctrl & 0x80 == 0
          .         }
          .         
          .         /// Checks whether a control byte represents a special value (top bit is set).
          .         #[inline]
          .         fn is_special(ctrl: u8) -> bool {
          .             ctrl & 0x80 != 0
          .         }
          .         
          .         /// Checks whether a special control value is EMPTY (just check 1 bit).
          .         #[inline]
          .         fn special_is_empty(ctrl: u8) -> bool {
          .             debug_assert!(is_special(ctrl));
  3,659,125 (0.0%)      ctrl & 0x01 != 0
          .         }
          .         
          .         /// Primary hash function, used to select the initial bucket to probe from.
          .         #[inline]
          .         #[allow(clippy::cast_possible_truncation)]
          .         fn h1(hash: u64) -> usize {
          .             // On 32-bit platforms we simply ignore the higher hash bits.
          .             hash as usize
-- line 137 ----------------------------------------
-- line 147 ----------------------------------------
          .         /// Secondary hash function, saved in the low 7 bits of the control byte.
          .         #[inline]
          .         #[allow(clippy::cast_possible_truncation)]
          .         fn h2(hash: u64) -> u8 {
          .             // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
          .             // value, some hash functions (such as FxHash) produce a usize result
          .             // instead, which means that the top 32 bits are 0 on 32-bit platforms.
          .             // So we use MIN_HASH_LEN constant to handle this.
106,158,212 (1.3%)      let top7 = hash >> (MIN_HASH_LEN * 8 - 7);
          .             (top7 & 0x7f) as u8 // truncation
          .         }
          .         
          .         /// Probe sequence based on triangular numbers, which is guaranteed (since our
          .         /// table size is a power of two) to visit every group of elements exactly once.
          .         ///
          .         /// A triangular probe has us jump by 1 more group every time. So first we
          .         /// jump by 1 group (meaning we just continue our linear scan), then 2 groups
-- line 163 ----------------------------------------
-- line 174 ----------------------------------------
          .             #[inline]
          .             fn move_next(&mut self, bucket_mask: usize) {
          .                 // We should have found an empty bucket by now and ended the probe.
          .                 debug_assert!(
          .                     self.stride <= bucket_mask,
          .                     "Went past end of probe sequence"
          .                 );
          .         
  1,074,735 (0.0%)          self.stride += Group::WIDTH;
  1,196,612 (0.0%)          self.pos += self.stride;
    504,962 (0.0%)          self.pos &= bucket_mask;
          .             }
          .         }
          .         
          .         /// Returns the number of buckets needed to hold the given number of items,
          .         /// taking the maximum load factor into account.
          .         ///
          .         /// Returns `None` if an overflow occurs.
          .         // Workaround for emscripten bug emscripten-core/emscripten-fastcomp#258
          .         #[cfg_attr(target_os = "emscripten", inline(never))]
          .         #[cfg_attr(not(target_os = "emscripten"), inline)]
          .         fn capacity_to_buckets(cap: usize) -> Option<usize> {
          .             debug_assert_ne!(cap, 0);
          .         
          .             // For small tables we require at least 1 empty bucket so that lookups are
          .             // guaranteed to terminate if an element doesn't exist in the table.
    731,941 (0.0%)      if cap < 8 {
          .                 // We don't bother with a table size of 2 buckets since that can only
          .                 // hold a single element. Instead we skip directly to a 4 bucket table
          .                 // which can hold 3 elements.
  1,312,159 (0.0%)          return Some(if cap < 4 { 4 } else { 8 });
          .             }
          .         
          .             // Otherwise require 1/8 buckets to be empty (87.5% load)
          .             //
          .             // Be careful when modifying this, calculate_layout relies on the
          .             // overflow check here.
    378,366 (0.0%)      let adjusted_cap = cap.checked_mul(8)? / 7;
          .         
          .             // Any overflows will have been caught by the checked_mul. Also, any
          .             // rounding errors from the division above will be cleaned up by
          .             // next_power_of_two (which can't overflow because of the previous division).
          .             Some(adjusted_cap.next_power_of_two())
          .         }
          .         
          .         /// Returns the maximum effective capacity for the given bucket mask, taking
          .         /// the maximum load factor into account.
          .         #[inline]
          .         fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
  5,516,494 (0.1%)      if bucket_mask < 8 {
          .                 // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
          .                 // Keep in mind that the bucket mask is one less than the bucket count.
          .                 bucket_mask
          .             } else {
          .                 // For larger tables we reserve 12.5% of the slots as empty.
          .                 ((bucket_mask + 1) / 8) * 7
          .             }
          .         }
-- line 231 ----------------------------------------
-- line 254 ----------------------------------------
          .         
          .             #[inline]
          .             fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
          .                 debug_assert!(buckets.is_power_of_two());
          .         
          .                 let TableLayout { size, ctrl_align } = self;
          .                 // Manual layout calculation since Layout methods are not yet stable.
          .                 let ctrl_offset =
    608,078 (0.0%)              size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
    733,174 (0.0%)          let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
          .         
          .                 // We need an additional check to ensure that the allocation doesn't
          .                 // exceed `isize::MAX` (https://github.com/rust-lang/rust/pull/95295).
     19,812 (0.0%)          if len > isize::MAX as usize - (ctrl_align - 1) {
          .                     return None;
          .                 }
          .         
          .                 Some((
          .                     unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
          .                     ctrl_offset,
          .                 ))
          .             }
-- line 275 ----------------------------------------
-- line 843 ----------------------------------------
          .             /// Creates a new empty hash table without allocating any memory, using the
          .             /// given allocator.
          .             ///
          .             /// In effect this returns a table with exactly 1 bucket. However we can
          .             /// leave the data pointer dangling since that bucket is never written to
          .             /// due to our load factor forcing us to always have at least 1 free bucket.
          .             #[inline]
          .             pub const fn new_in(alloc: A) -> Self {
    190,793 (0.0%)          Self {
          .                     table: RawTableInner::NEW,
          .                     alloc,
          .                     marker: PhantomData,
          .                 }
          .             }
          .         
          .             /// Allocates a new hash table with the given number of buckets.
          .             ///
-- line 859 ----------------------------------------
-- line 892 ----------------------------------------
          .                     alloc,
          .                     marker: PhantomData,
          .                 })
          .             }
          .         
          .             /// Allocates a new hash table using the given allocator, with at least enough capacity for
          .             /// inserting the given number of elements without reallocating.
          .             pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
      9,430 (0.0%)          Self {
          .                     table: RawTableInner::with_capacity(&alloc, Self::TABLE_LAYOUT, capacity),
          .                     alloc,
          .                     marker: PhantomData,
          .                 }
          .             }
          .         
          .             /// Returns a reference to the underlying allocator.
          .             #[inline]
-- line 908 ----------------------------------------
-- line 933 ----------------------------------------
          .                 //        CT0...CT_n - control bytes or metadata for `data`.
          .                 //        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search
          .                 //                        with loading `Group` bytes from the heap works properly, even if the result
          .                 //                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also
          .                 //                        `RawTableInner::set_ctrl` function.
          .                 //
          .                 // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number
          .                 // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
     26,216 (0.0%)          unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().cast()) }
          .             }
          .         
          .             /// Returns pointer to start of data table.
          .             #[inline]
          .             #[cfg(any(feature = "raw", feature = "nightly"))]
          .             pub unsafe fn data_start(&self) -> NonNull<T> {
          .                 NonNull::new_unchecked(self.data_end().as_ptr().wrapping_sub(self.buckets()))
          .             }
-- line 949 ----------------------------------------
-- line 1071 ----------------------------------------
          .                 )
          .             }
          .         
          .             /// Finds and removes an element from the table, returning it.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {
          .                 // Avoid `Option::map` because it bloats LLVM IR.
          .                 match self.find(hash, eq) {
  4,252,456 (0.1%)              Some(bucket) => Some(unsafe { self.remove(bucket).0 }),
          .                     None => None,
          .                 }
          .             }
          .         
          .             /// Marks all table buckets as empty without dropping their contents.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub fn clear_no_drop(&mut self) {
          .                 self.table.clear_no_drop();
          .             }
          .         
          .             /// Removes all elements from the table without freeing the backing memory.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub fn clear(&mut self) {
    382,306 (0.0%)          if self.is_empty() {
          .                     // Special case empty table to avoid surprising O(capacity) time.
          .                     return;
          .                 }
          .                 // Ensure that the table is reset even if one of the drops panic
          .                 let mut self_ = guard(self, |self_| self_.clear_no_drop());
          .                 unsafe {
          .                     // SAFETY: ScopeGuard sets to zero the `items` field of the table
          .                     // even in case of panic during the dropping of the elements so
-- line 1101 ----------------------------------------
-- line 1168 ----------------------------------------
          .                     }
          .                 }
          .             }
          .         
          .             /// Ensures that at least `additional` items can be inserted into the table
          .             /// without reallocation.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
  9,200,993 (0.1%)          if unlikely(additional > self.table.growth_left) {
          .                     // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
          .                     unsafe {
          .                         // SAFETY: The [`RawTableInner`] must already have properly initialized control
          .                         // bytes since we will never expose RawTable::new_uninitialized in a public API.
  1,746,410 (0.0%)                  if self
          .                             .reserve_rehash(additional, hasher, Fallibility::Infallible)
          .                             .is_err()
          .                         {
          .                             // SAFETY: All allocation errors will be caught inside `RawTableInner::reserve_rehash`.
          .                             hint::unreachable_unchecked()
          .                         }
          .                     }
          .                 }
-- line 1189 ----------------------------------------
-- line 1211 ----------------------------------------
          .             /// # Safety
          .             ///
          .             /// The [`RawTableInner`] must have properly initialized control bytes,
          .             /// otherwise calling this function results in [`undefined behavior`]
          .             ///
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[cold]
          .             #[inline(never)]
  3,554,347 (0.0%)      unsafe fn reserve_rehash(
          .                 &mut self,
          .                 additional: usize,
          .                 hasher: impl Fn(&T) -> u64,
          .                 fallibility: Fallibility,
          .             ) -> Result<(), TryReserveError> {
          .                 unsafe {
          .                     // SAFETY:
          .                     // 1. We know for sure that `alloc` and `layout` matches the [`Allocator`] and
-- line 1227 ----------------------------------------
-- line 1228 ----------------------------------------
          .                     //    [`TableLayout`] that were used to allocate this table.
          .                     // 2. The `drop` function is the actual drop function of the elements stored in
          .                     //    the table.
          .                     // 3. The caller ensures that the control bytes of the `RawTableInner`
          .                     //    are already initialized.
          .                     self.table.reserve_rehash_inner(
          .                         &self.alloc,
          .                         additional,
  1,843,540 (0.0%)                  &|table, index| hasher(table.bucket::<T>(index).as_ref()),
          .                         fallibility,
          .                         Self::TABLE_LAYOUT,
          .                         if T::NEEDS_DROP {
          .                             Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
          .                         } else {
          .                             None
          .                         },
          .                     )
          .                 }
  2,905,881 (0.0%)      }
          .         
          .             /// Allocates a new table of a different size and moves the contents of the
          .             /// current table into it.
          .             ///
          .             /// # Safety
          .             ///
          .             /// The [`RawTableInner`] must have properly initialized control bytes,
          .             /// otherwise calling this function results in [`undefined behavior`]
-- line 1254 ----------------------------------------
-- line 1299 ----------------------------------------
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
          .                 unsafe {
          .                     // SAFETY:
          .                     // 1. The [`RawTableInner`] must already have properly initialized control bytes since
          .                     //    we will never expose `RawTable::new_uninitialized` in a public API.
          .                     //
          .                     // 2. We reserve additional space (if necessary) right after calling this function.
    531,302 (0.0%)              let mut slot = self.table.find_insert_slot(hash);
          .         
          .                     // We can avoid growing the table once we have reached our load factor if we are replacing
          .                     // a tombstone. This works since the number of EMPTY slots does not change in this case.
          .                     //
          .                     // SAFETY: The function is guaranteed to return [`InsertSlot`] that contains an index
          .                     // in the range `0..=self.buckets()`.
          .                     let old_ctrl = *self.table.ctrl(slot.index);
    874,919 (0.0%)              if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
          .                         self.reserve(1, hasher);
          .                         // SAFETY: We know for sure that `RawTableInner` has control bytes
          .                         // initialized and that there is extra space in the table.
     36,962 (0.0%)                  slot = self.table.find_insert_slot(hash);
          .                     }
          .         
          .                     self.insert_in_slot(hash, slot, value)
          .                 }
          .             }
          .         
          .             /// Attempts to insert a new element without growing the table and return its raw bucket.
          .             ///
-- line 1327 ----------------------------------------
-- line 1355 ----------------------------------------
          .             /// Inserts a new element into the table, without growing the table.
          .             ///
          .             /// There must be enough space in the table to insert the new element.
          .             ///
          .             /// This does not check if the given element already exists in the table.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             #[cfg(any(feature = "raw", feature = "rustc-internal-api"))]
          .             pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {
  1,595,856 (0.0%)          let (index, old_ctrl) = self.table.prepare_insert_slot(hash);
          .                 let bucket = self.table.bucket(index);
          .         
          .                 // If we are replacing a DELETED entry then we don't need to update
          .                 // the load counter.
  2,574,132 (0.0%)          self.table.growth_left -= special_is_empty(old_ctrl) as usize;
          .         
          .                 bucket.write(value);
  1,039,316 (0.0%)          self.table.items += 1;
          .                 bucket
          .             }
          .         
          .             /// Temporary removes a bucket, applying the given function to the removed
          .             /// element and optionally put back the returned value in the same bucket.
          .             ///
          .             /// Returns `true` if the bucket still contains an element
          .             ///
-- line 1379 ----------------------------------------
-- line 1417 ----------------------------------------
          .                 unsafe {
          .                     // SAFETY:
          .                     // 1. We know for sure that there is at least one empty `bucket` in the table.
          .                     // 2. The [`RawTableInner`] must already have properly initialized control bytes since we will
          .                     //    never expose `RawTable::new_uninitialized` in a public API.
          .                     // 3. The `find_or_find_insert_slot_inner` function returns the `index` of only the full bucket,
          .                     //    which is in the range `0..self.buckets()` (since there is at least one empty `bucket` in
          .                     //    the table), so calling `self.bucket(index)` and `Bucket::as_ref` is safe.
  6,794,050 (0.1%)              match self
          .                         .table
  2,000,330 (0.0%)                  .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref()))
          .                     {
          .                         // SAFETY: See explanation above.
          .                         Ok(index) => Ok(self.bucket(index)),
          .                         Err(slot) => Err(slot),
          .                     }
          .                 }
          .             }
          .         
-- line 1435 ----------------------------------------
-- line 1438 ----------------------------------------
          .             ///
          .             /// # Safety
          .             ///
          .             /// `slot` must point to a slot previously returned by
          .             /// `find_or_find_insert_slot`, and no mutation of the table must have
          .             /// occurred since that call.
          .             #[inline]
          .             pub unsafe fn insert_in_slot(&mut self, hash: u64, slot: InsertSlot, value: T) -> Bucket<T> {
      5,052 (0.0%)          let old_ctrl = *self.table.ctrl(slot.index);
          .                 self.table.record_item_insert_at(slot.index, old_ctrl, hash);
          .         
          .                 let bucket = self.bucket(slot.index);
          .                 bucket.write(value);
          .                 bucket
          .             }
          .         
          .             /// Searches for an element in the table.
          .             #[inline]
      4,608 (0.0%)      pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
          .                 unsafe {
          .                     // SAFETY:
          .                     // 1. The [`RawTableInner`] must already have properly initialized control bytes since we
          .                     //    will never expose `RawTable::new_uninitialized` in a public API.
          .                     // 1. The `find_inner` function returns the `index` of only the full bucket, which is in
          .                     //    the range `0..self.buckets()`, so calling `self.bucket(index)` and `Bucket::as_ref`
          .                     //    is safe.
          .                     let result = self
          .                         .table
 17,389,070 (0.2%)                  .find_inner(hash, &mut |index| eq(self.bucket(index).as_ref()));
          .         
          .                     // Avoid `Option::map` because it bloats LLVM IR.
          .                     match result {
          .                         // SAFETY: See explanation above.
          .                         Some(index) => Some(self.bucket(index)),
          .                         None => None,
          .                     }
          .                 }
      3,840 (0.0%)      }
          .         
          .             /// Gets a reference to an element in the table.
          .             #[inline]
          .             pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
          .                 // Avoid `Option::map` because it bloats LLVM IR.
    147,396 (0.0%)          match self.find(hash, eq) {
          .                     Some(bucket) => Some(unsafe { bucket.as_ref() }),
          .                     None => None,
          .                 }
          .             }
          .         
          .             /// Gets a mutable reference to an element in the table.
          .             #[inline]
          .             pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {
          .                 // Avoid `Option::map` because it bloats LLVM IR.
     29,834 (0.0%)          match self.find(hash, eq) {
          .                     Some(bucket) => Some(unsafe { bucket.as_mut() }),
          .                     None => None,
          .                 }
          .             }
          .         
          .             /// Attempts to get mutable references to `N` entries in the table at once.
          .             ///
          .             /// Returns an array of length `N` with the results of each query.
-- line 1499 ----------------------------------------
-- line 1552 ----------------------------------------
          .             }
          .         
          .             /// Returns the number of elements the map can hold without reallocating.
          .             ///
          .             /// This number is a lower bound; the table might be able to hold
          .             /// more, but is guaranteed to be able to hold at least this many.
          .             #[inline]
          .             pub fn capacity(&self) -> usize {
    103,949 (0.0%)          self.table.items + self.table.growth_left
          .             }
          .         
          .             /// Returns the number of elements in the table.
          .             #[inline]
          .             pub fn len(&self) -> usize {
    529,079 (0.0%)          self.table.items
          .             }
          .         
          .             /// Returns `true` if the table contains no elements.
          .             #[inline]
          .             pub fn is_empty(&self) -> bool {
          .                 self.len() == 0
          .             }
          .         
          .             /// Returns the number of buckets in the table.
          .             #[inline]
          .             pub fn buckets(&self) -> usize {
          1 (0.0%)          self.table.bucket_mask + 1
          .             }
          .         
          .             /// Checks whether the bucket at `index` is full.
          .             ///
          .             /// # Safety
          .             ///
          .             /// The caller must ensure `index` is less than the number of buckets.
          .             #[inline]
-- line 1586 ----------------------------------------
-- line 1660 ----------------------------------------
          .                     marker: PhantomData,
          .                 }
          .             }
          .         
          .             /// Converts the table into a raw allocation. The contents of the table
          .             /// should be dropped using a `RawIter` before freeing the allocation.
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout, A)> {
     24,222 (0.0%)          let alloc = if self.table.is_empty_singleton() {
          .                     None
          .                 } else {
          .                     // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
          .                     let (layout, ctrl_offset) =
          .                         match Self::TABLE_LAYOUT.calculate_layout_for(self.table.buckets()) {
          .                             Some(lco) => lco,
          .                             None => unsafe { hint::unreachable_unchecked() },
          .                         };
-- line 1676 ----------------------------------------
-- line 1744 ----------------------------------------
          .                 debug_assert!(buckets.is_power_of_two());
          .         
          .                 // Avoid `Option::ok_or_else` because it bloats LLVM IR.
          .                 let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {
          .                     Some(lco) => lco,
          .                     None => return Err(fallibility.capacity_overflow()),
          .                 };
          .         
    735,029 (0.0%)          let ptr: NonNull<u8> = match do_alloc(alloc, layout) {
          .                     Ok(block) => block.cast(),
          .                     Err(_) => return Err(fallibility.alloc_err(layout)),
          .                 };
          .         
          .                 // SAFETY: null pointer will be caught in above check
          .                 let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
          .                 Ok(Self {
          .                     ctrl,
    365,971 (0.0%)              bucket_mask: buckets - 1,
          .                     items: 0,
          .                     growth_left: bucket_mask_to_capacity(buckets - 1),
          .                 })
          .             }
          .         
          .             /// Attempts to allocate a new [`RawTableInner`] with at least enough
          .             /// capacity for inserting the given number of elements without reallocating.
          .             ///
          .             /// All the control bytes are initialized with the [`EMPTY`] bytes.
          .             #[inline]
    335,016 (0.0%)      fn fallible_with_capacity<A>(
          .                 alloc: &A,
          .                 table_layout: TableLayout,
          .                 capacity: usize,
          .                 fallibility: Fallibility,
          .             ) -> Result<Self, TryReserveError>
          .             where
          .                 A: Allocator,
          .             {
     92,448 (0.0%)          if capacity == 0 {
          .                     Ok(Self::NEW)
          .                 } else {
          .                     // SAFETY: We checked that we could successfully allocate the new table, and then
          .                     // initialized all control bytes with the constant `EMPTY` byte.
          .                     unsafe {
          .                         let buckets =
          .                             capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
          .         
          .                         let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
          .                         // SAFETY: We checked that the table is allocated and therefore the table already has
          .                         // `self.bucket_mask + 1 + Group::WIDTH` number of control bytes (see TableLayout::calculate_layout_for)
          .                         // so writing `self.num_ctrl_bytes() == bucket_mask + 1 + Group::WIDTH` bytes is safe.
          .                         result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
          .         
    148,896 (0.0%)                  Ok(result)
          .                     }
          .                 }
    297,792 (0.0%)      }
          .         
          .             /// Allocates a new [`RawTableInner`] with at least enough capacity for inserting
          .             /// the given number of elements without reallocating.
          .             ///
          .             /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program
          .             /// in case of allocation error. Use [`fallible_with_capacity`] instead if you want to
          .             /// handle memory allocation failure.
          .             ///
-- line 1807 ----------------------------------------
-- line 1809 ----------------------------------------
          .             ///
          .             /// [`fallible_with_capacity`]: RawTableInner::fallible_with_capacity
          .             /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html
          .             fn with_capacity<A>(alloc: &A, table_layout: TableLayout, capacity: usize) -> Self
          .             where
          .                 A: Allocator,
          .             {
          .                 // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
      8,212 (0.0%)          match Self::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible) {
          .                     Ok(table_inner) => table_inner,
          .                     // SAFETY: All allocation errors will be caught inside `RawTableInner::new_uninitialized`.
          .                     Err(_) => unsafe { hint::unreachable_unchecked() },
          .                 }
          .             }
          .         
          .             /// Fixes up an insertion slot returned by the [`RawTableInner::find_insert_slot_in_group`] method.
          .             ///
-- line 1825 ----------------------------------------
-- line 1863 ----------------------------------------
          .             /// [`RawTableInner::ctrl`] function (`index < self.bucket_mask + 1 + Group::WIDTH`).
          .             ///
          .             /// [`RawTableInner::ctrl`]: RawTableInner::ctrl
          .             /// [`RawTableInner::find_insert_slot_in_group`]: RawTableInner::find_insert_slot_in_group
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline]
          .             unsafe fn fix_insert_slot(&self, mut index: usize) -> InsertSlot {
          .                 // SAFETY: The caller of this function ensures that `index` is in the range `0..=self.bucket_mask`.
  8,275,640 (0.1%)          if unlikely(self.is_bucket_full(index)) {
          .                     debug_assert!(self.bucket_mask < Group::WIDTH);
          .                     // SAFETY:
          .                     //
          .                     // * Since the caller of this function ensures that the control bytes are properly
          .                     //   initialized and `ptr = self.ctrl(0)` points to the start of the array of control
          .                     //   bytes, therefore: `ctrl` is valid for reads, properly aligned to `Group::WIDTH`
          .                     //   and points to the properly initialized control bytes (see also
          .                     //   `TableLayout::calculate_layout_for` and `ptr::read`);
-- line 1879 ----------------------------------------
-- line 1901 ----------------------------------------
          .             /// before it's used.**
          .             ///
          .             /// The function is guaranteed to return the index of an empty or deleted [`Bucket`]
          .             /// in the range `0..self.buckets()` (`0..=self.bucket_mask`).
          .             #[inline]
          .             fn find_insert_slot_in_group(&self, group: &Group, probe_seq: &ProbeSeq) -> Option<usize> {
          .                 let bit = group.match_empty_or_deleted().lowest_set_bit();
          .         
 14,891,366 (0.2%)          if likely(bit.is_some()) {
          .                     // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number
          .                     // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
          .                     Some((probe_seq.pos + bit.unwrap()) & self.bucket_mask)
          .                 } else {
          .                     None
          .                 }
          .             }
          .         
-- line 1917 ----------------------------------------
-- line 1974 ----------------------------------------
          .                     //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control
          .                     //   byte will never be read for the allocated table);
          .                     //
          .                     // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will
          .                     //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`
          .                     //   bytes, which is safe (see RawTableInner::new).
          .                     let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
          .         
  1,142,764 (0.0%)              for bit in group.match_byte(h2_hash) {
  1,725,392 (0.0%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
          .         
  2,094,469 (0.0%)                  if likely(eq(index)) {
          .                             return Ok(index);
          .                         }
          .                     }
          .         
          .                     // We didn't find the element we were looking for in the group, try to get an
          .                     // insertion slot from the group if we don't have one yet.
  2,575,827 (0.0%)              if likely(insert_slot.is_none()) {
          .                         insert_slot = self.find_insert_slot_in_group(&group, &probe_seq);
          .                     }
          .         
          .                     // Only stop the search if the group contains at least one empty element.
          .                     // Otherwise, the element that we are looking for might be in a following group.
  3,069,579 (0.0%)              if likely(group.match_empty().any_bit_set()) {
          .                         // We must have found a insert slot by now, since the current group contains at
          .                         // least one. For tables smaller than the group width, there will still be an
          .                         // empty element in the current (and only) group due to the load factor.
          .                         unsafe {
          .                             // SAFETY:
          .                             // * Caller of this function ensures that the control bytes are properly initialized.
          .                             //
          .                             // * We use this function with the slot / index found by `self.find_insert_slot_in_group`
-- line 2006 ----------------------------------------
-- line 2069 ----------------------------------------
          .                 // SAFETY: Caller of this function ensures that the control bytes are properly initialized.
          .                 let index: usize = self.find_insert_slot(hash).index;
          .                 // SAFETY:
          .                 // 1. The `find_insert_slot` function either returns an `index` less than or
          .                 //    equal to `self.buckets() = self.bucket_mask + 1` of the table, or never
          .                 //    returns if it cannot find an empty or deleted slot.
          .                 // 2. The caller of this function guarantees that the table has already been
          .                 //    allocated
      3,927 (0.0%)          let old_ctrl = *self.ctrl(index);
          .                 self.set_ctrl_h2(index, hash);
          .                 (index, old_ctrl)
          .             }
          .         
          .             /// Searches for an empty or deleted bucket which is suitable for inserting
          .             /// a new element, returning the `index` for the new [`Bucket`].
          .             ///
          .             /// This function does not make any changes to the `data` part of the table, or any
-- line 2085 ----------------------------------------
-- line 2124 ----------------------------------------
          .                     //   byte will never be read for the allocated table);
          .                     //
          .                     // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will
          .                     //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`
          .                     //   bytes, which is safe (see RawTableInner::new).
          .                     let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
          .         
          .                     let index = self.find_insert_slot_in_group(&group, &probe_seq);
  1,338,400 (0.0%)              if likely(index.is_some()) {
          .                         // SAFETY:
          .                         // * Caller of this function ensures that the control bytes are properly initialized.
          .                         //
          .                         // * We use this function with the slot / index found by `self.find_insert_slot_in_group`
          .                         unsafe {
          .                             return self.fix_insert_slot(index.unwrap_unchecked());
          .                         }
          .                     }
-- line 2140 ----------------------------------------
-- line 2164 ----------------------------------------
          .             /// this function results in [`undefined behavior`].
          .             ///
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline(always)]
          .             unsafe fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
          .                 let h2_hash = h2(hash);
          .                 let mut probe_seq = self.probe_seq(hash);
          .         
     52,995 (0.0%)          loop {
          .                     // SAFETY:
          .                     // * Caller of this function ensures that the control bytes are properly initialized.
          .                     //
          .                     // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`
          .                     //   of the table due to masking with `self.bucket_mask`.
          .                     //
          .                     // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to
          .                     //   call `Group::load` due to the extended control bytes range, which is
-- line 2180 ----------------------------------------
-- line 2184 ----------------------------------------
          .                     // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will
          .                     //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`
          .                     //   bytes, which is safe (see RawTableInner::new_in).
          .                     let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
          .         
          .                     for bit in group.match_byte(h2_hash) {
          .                         // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number
          .                         // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
 17,153,283 (0.2%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
          .         
 23,624,517 (0.3%)                  if likely(eq(index)) {
          .                             return Some(index);
          .                         }
          .                     }
          .         
  4,244,965 (0.1%)              if likely(group.match_empty().any_bit_set()) {
          .                         return None;
          .                     }
          .         
          .                     probe_seq.move_next(self.bucket_mask);
          .                 }
          .             }
          .         
          .             /// Prepares for rehashing data in place (that is, without allocating new memory).
-- line 2207 ----------------------------------------
-- line 2256 ----------------------------------------
          .                     group.store_aligned(self.ctrl(i));
          .                 }
          .         
          .                 // Fix up the trailing control bytes. See the comments in set_ctrl
          .                 // for the handling of tables smaller than the group width.
          .                 //
          .                 // SAFETY: The caller of this function guarantees that [`RawTableInner`]
          .                 // has already been allocated
          3 (0.0%)          if unlikely(self.buckets() < Group::WIDTH) {
          .                     // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of control bytes,
          .                     // so copying `self.buckets() == self.bucket_mask + 1` bytes with offset equal to
          .                     // `Group::WIDTH` is safe
          .                     self.ctrl(0)
          .                         .copy_to(self.ctrl(Group::WIDTH), self.buckets());
          .                 } else {
          .                     // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of
          .                     // control bytes,so copying `Group::WIDTH` bytes with offset equal
-- line 2272 ----------------------------------------
-- line 2321 ----------------------------------------
          .                 //                        `RawTableInner::set_ctrl` function.
          .                 //
          .                 // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number
          .                 // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
          .                 let data = Bucket::from_base_index(self.data_end(), 0);
          .                 RawIter {
          .                     // SAFETY: See explanation above
          .                     iter: RawIterRange::new(self.ctrl.as_ptr(), data, self.buckets()),
    296,379 (0.0%)              items: self.items,
          .                 }
          .             }
          .         
          .             /// Executes the destructors (if any) of the values stored in the table.
          .             ///
          .             /// # Note
          .             ///
          .             /// This function does not erase the control bytes of the table and does
-- line 2337 ----------------------------------------
-- line 2364 ----------------------------------------
          .             ///
          .             /// [`Bucket::drop`]: Bucket::drop
          .             /// [`Bucket::as_ptr`]: Bucket::as_ptr
          .             /// [`clear_no_drop`]: RawTableInner::clear_no_drop
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             unsafe fn drop_elements<T>(&mut self) {
          .                 // Check that `self.items != 0`. Protects against the possibility
          .                 // of creating an iterator on an table with uninitialized control bytes.
     56,215 (0.0%)          if T::NEEDS_DROP && self.items != 0 {
          .                     // SAFETY: We know for sure that RawTableInner will outlive the
          .                     // returned `RawIter` iterator, and the caller of this function
          .                     // must uphold the safety contract for `drop_elements` method.
          .                     for item in self.iter::<T>() {
          .                         // SAFETY: The caller must uphold the safety contract for
          .                         // `drop_elements` method.
          .                         item.drop();
          .                     }
-- line 2380 ----------------------------------------
-- line 2422 ----------------------------------------
          .             /// data but with `Full` control bytes if `self.items == 0`.
          .             ///
          .             /// See also [`RawTableInner::drop_elements`] or [`RawTableInner::free_buckets`]
          .             /// for more  information.
          .             ///
          .             /// [`RawTableInner::drop_elements`]: RawTableInner::drop_elements
          .             /// [`RawTableInner::free_buckets`]: RawTableInner::free_buckets
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
         88 (0.0%)      unsafe fn drop_inner_table<T, A: Allocator>(&mut self, alloc: &A, table_layout: TableLayout) {
  7,338,896 (0.1%)          if !self.is_empty_singleton() {
          .                     unsafe {
          .                         // SAFETY: The caller must uphold the safety contract for `drop_inner_table` method.
          .                         self.drop_elements::<T>();
          .                         // SAFETY:
          .                         // 1. We have checked that our table is allocated.
          .                         // 2. The caller must uphold the safety contract for `drop_inner_table` method.
          .                         self.free_buckets(alloc, table_layout);
          .                     }
          .                 }
         56 (0.0%)      }
          .         
          .             /// Returns a pointer to an element in the table (convenience for
          .             /// `Bucket::from_base_index(self.data_end::<T>(), index)`).
          .             ///
          .             /// The caller must ensure that the `RawTableInner` outlives the returned [`Bucket<T>`],
          .             /// otherwise using it may result in [`undefined behavior`].
          .             ///
          .             /// # Safety
-- line 2449 ----------------------------------------
-- line 2550 ----------------------------------------
          .             ///
          .             /// [`RawTableInner::buckets`]: RawTableInner::buckets
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline]
          .             unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {
          .                 debug_assert_ne!(self.bucket_mask, 0);
          .                 debug_assert!(index < self.buckets());
          .                 let base: *mut u8 = self.data_end().as_ptr();
 16,316,609 (0.2%)          base.sub((index + 1) * size_of)
          .             }
          .         
          .             /// Returns pointer to one past last `data` element in the the table as viewed from
          .             /// the start point of the allocation (convenience for `self.ctrl.cast()`).
          .             ///
          .             /// This function actually returns a pointer to the end of the `data element` at
          .             /// index "0" (zero).
          .             ///
-- line 2566 ----------------------------------------
-- line 2592 ----------------------------------------
          .             /// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
          .             /// ```
          .             ///
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline]
          .             fn data_end<T>(&self) -> NonNull<T> {
          .                 unsafe {
          .                     // SAFETY: `self.ctrl` is `NonNull`, so casting it is safe
  8,063,083 (0.1%)              NonNull::new_unchecked(self.ctrl.as_ptr().cast())
          .                 }
          .             }
          .         
          .             /// Returns an iterator-like object for a probe sequence on the table.
          .             ///
          .             /// This iterator never terminates, but is guaranteed to visit each bucket
          .             /// group exactly once. The loop using `probe_seq` must terminate upon
          .             /// reaching a group containing an empty bucket.
          .             #[inline]
          .             fn probe_seq(&self, hash: u64) -> ProbeSeq {
          .                 ProbeSeq {
          .                     // This is the same as `hash as usize % self.buckets()` because the number
          .                     // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
 64,963,223 (0.8%)              pos: h1(hash) & self.bucket_mask,
          .                     stride: 0,
          .                 }
          .             }
          .         
          .             /// Returns the index of a bucket for which a value must be inserted if there is enough rooom
          .             /// in the table, otherwise returns error
          .             #[cfg(feature = "raw")]
          .             #[inline]
-- line 2622 ----------------------------------------
-- line 2628 ----------------------------------------
          .                 } else {
          .                     self.record_item_insert_at(index, old_ctrl, hash);
          .                     Ok(index)
          .                 }
          .             }
          .         
          .             #[inline]
          .             unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
  3,095,273 (0.0%)          self.growth_left -= usize::from(special_is_empty(old_ctrl));
          .                 self.set_ctrl_h2(index, hash);
  3,130,098 (0.0%)          self.items += 1;
          .             }
          .         
          .             #[inline]
          .             fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {
          .                 let probe_seq_pos = self.probe_seq(hash).pos;
          .                 let probe_index =
          .                     |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;
          .                 probe_index(i) == probe_index(new_i)
-- line 2646 ----------------------------------------
-- line 2760 ----------------------------------------
          .                 //
          .                 //     Real    |             Replicated
          .                 // ---------------------------------------------
          .                 // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
          .                 // ---------------------------------------------
          .         
          .                 // This is the same as `(index.wrapping_sub(Group::WIDTH)) % self.buckets() + Group::WIDTH`
          .                 // because the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
  8,339,873 (0.1%)          let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
          .         
          .                 // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl`]
  8,408,114 (0.1%)          *self.ctrl(index) = ctrl;
  8,484,516 (0.1%)          *self.ctrl(index2) = ctrl;
          .             }
          .         
          .             /// Returns a pointer to a control byte.
          .             ///
          .             /// # Safety
          .             ///
          .             /// For the allocated [`RawTableInner`], the result is [`Undefined Behavior`],
          .             /// if the `index` is greater than the `self.bucket_mask + 1 + Group::WIDTH`.
-- line 2780 ----------------------------------------
-- line 2794 ----------------------------------------
          .             /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].
          .             ///
          .             /// [`Bucket::as_ptr()`]: Bucket::as_ptr()
          .             /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline]
          .             unsafe fn ctrl(&self, index: usize) -> *mut u8 {
          .                 debug_assert!(index < self.num_ctrl_bytes());
          .                 // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::ctrl`]
    168,352 (0.0%)          self.ctrl.as_ptr().add(index)
          .             }
          .         
          .             #[inline]
          .             fn buckets(&self) -> usize {
    136,617 (0.0%)          self.bucket_mask + 1
          .             }
          .         
          .             /// Checks whether the bucket at `index` is full.
          .             ///
          .             /// # Safety
          .             ///
          .             /// The caller must ensure `index` is less than the number of buckets.
          .             #[inline]
          .             unsafe fn is_bucket_full(&self, index: usize) -> bool {
          .                 debug_assert!(index < self.buckets());
  3,820,551 (0.0%)          is_full(*self.ctrl(index))
          .             }
          .         
          .             #[inline]
          .             fn num_ctrl_bytes(&self) -> usize {
      6,916 (0.0%)          self.bucket_mask + 1 + Group::WIDTH
          .             }
          .         
          .             #[inline]
          .             fn is_empty_singleton(&self) -> bool {
    768,544 (0.0%)          self.bucket_mask == 0
          .             }
          .         
          .             /// Attempts to allocate a new hash table with at least enough capacity
          .             /// for inserting the given number of elements without reallocating,
          .             /// and return it inside ScopeGuard to protect against panic in the hash
          .             /// function.
          .             ///
          .             /// # Note
-- line 2836 ----------------------------------------
-- line 2847 ----------------------------------------
          .             ///
          .             /// If `table_layout` does not match the `TableLayout` that was used to allocate
          .             /// this table, then using `mem::swap` with the `self` and the new table returned
          .             /// by this function results in [`undefined behavior`].
          .             ///
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[allow(clippy::mut_mut)]
          .             #[inline]
     81,000 (0.0%)      fn prepare_resize<'a, A>(
          .                 &self,
          .                 alloc: &'a A,
          .                 table_layout: TableLayout,
          .                 capacity: usize,
          .                 fallibility: Fallibility,
          .             ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self) + 'a>, TryReserveError>
          .             where
          .                 A: Allocator,
          .             {
          .                 debug_assert!(self.items <= capacity);
          .         
          .                 // Allocate and initialize the new table.
          .                 let new_table =
     42,083 (0.0%)              RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, fallibility)?;
          .         
          .                 // The hash function may panic, in which case we simply free the new
          .                 // table without dropping any elements that may have been copied into
          .                 // it.
          .                 //
          .                 // This guard is also used to free the old table on success, see
          .                 // the comment at the bottom of this function.
     63,000 (0.0%)          Ok(guard(new_table, move |self_| {
    726,471 (0.0%)              if !self_.is_empty_singleton() {
          .                         // SAFETY:
          .                         // 1. We have checked that our table is allocated.
          .                         // 2. We know for sure that the `alloc` and `table_layout` matches the
          .                         //    [`Allocator`] and [`TableLayout`] used to allocate this table.
          .                         unsafe { self_.free_buckets(alloc, table_layout) };
          .                     }
          .                 }))
     72,000 (0.0%)      }
          .         
          .             /// Reserves or rehashes to make room for `additional` more elements.
          .             ///
          .             /// This uses dynamic dispatch to reduce the amount of
          .             /// code generated, but it is eliminated by LLVM optimizations when inlined.
          .             ///
          .             /// # Safety
          .             ///
-- line 2894 ----------------------------------------
-- line 2917 ----------------------------------------
          .                 fallibility: Fallibility,
          .                 layout: TableLayout,
          .                 drop: Option<fn(*mut u8)>,
          .             ) -> Result<(), TryReserveError>
          .             where
          .                 A: Allocator,
          .             {
          .                 // Avoid `Option::ok_or_else` because it bloats LLVM IR.
    172,313 (0.0%)          let new_items = match self.items.checked_add(additional) {
          .                     Some(new_items) => new_items,
          .                     None => return Err(fallibility.capacity_overflow()),
          .                 };
    363,234 (0.0%)          let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
  1,452,936 (0.0%)          if new_items <= full_capacity / 2 {
          .                     // Rehash in-place without re-allocating if we have plenty of spare
          .                     // capacity that is locked up due to DELETED entries.
          .         
          .                     // SAFETY:
          .                     // 1. We know for sure that `[`RawTableInner`]` has already been allocated
          .                     //    (since new_items <= full_capacity / 2);
          .                     // 2. The caller ensures that `drop` function is the actual drop function of
          .                     //    the elements stored in the table.
          .                     // 3. The caller ensures that `layout` matches the [`TableLayout`] that was
          .                     //    used to allocate this table.
          .                     // 4. The caller ensures that the control bytes of the `RawTableInner`
          .                     //    are already initialized.
          6 (0.0%)              self.rehash_in_place(hasher, layout.size, drop);
          .                     Ok(())
          .                 } else {
          .                     // Otherwise, conservatively resize to at least the next size up
          .                     // to avoid churning deletes into frequent rehashes.
          .                     //
          .                     // SAFETY:
          .                     // 1. We know for sure that `capacity >= self.items`.
          .                     // 2. The caller ensures that `alloc` and `layout` matches the [`Allocator`] and
          .                     //    [`TableLayout`] that were used to allocate this table.
          .                     // 3. The caller ensures that the control bytes of the `RawTableInner`
          .                     //    are already initialized.
          .                     self.resize_inner(
          .                         alloc,
    363,233 (0.0%)                  usize::max(new_items, full_capacity + 1),
          .                         hasher,
          .                         fallibility,
          .                         layout,
          .                     )
          .                 }
          .             }
          .         
          .             /// Returns an iterator over full buckets indices in the table.
-- line 2965 ----------------------------------------
-- line 2998 ----------------------------------------
          .                 let ctrl = NonNull::new_unchecked(self.ctrl(0));
          .         
          .                 FullBucketsIndices {
          .                     // Load the first group
          .                     // SAFETY: See explanation above.
          .                     current_group: Group::load_aligned(ctrl.as_ptr()).match_full().into_iter(),
          .                     group_first_index: 0,
          .                     ctrl,
    363,213 (0.0%)              items: self.items,
          .                 }
          .             }
          .         
          .             /// Allocates a new table of a different size and moves the contents of the
          .             /// current table into it.
          .             ///
          .             /// This uses dynamic dispatch to reduce the amount of
          .             /// code generated, but it is eliminated by LLVM optimizations when inlined.
-- line 3014 ----------------------------------------
-- line 3057 ----------------------------------------
          .                 fallibility: Fallibility,
          .                 layout: TableLayout,
          .             ) -> Result<(), TryReserveError>
          .             where
          .                 A: Allocator,
          .             {
          .                 // SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]
          .                 // that were used to allocate this table.
    445,778 (0.0%)          let mut new_table = self.prepare_resize(alloc, layout, capacity, fallibility)?;
          .         
          .                 // SAFETY: We know for sure that RawTableInner will outlive the
          .                 // returned `FullBucketsIndices` iterator, and the caller of this
          .                 // function ensures that the control bytes are properly initialized.
          .                 for full_byte_index in self.full_buckets_indices() {
          .                     // This may panic.
          .                     let hash = hasher(self, full_byte_index);
          .         
-- line 3073 ----------------------------------------
-- line 3102 ----------------------------------------
          .                         self.bucket_ptr(full_byte_index, layout.size),
          .                         new_table.bucket_ptr(new_index, layout.size),
          .                         layout.size,
          .                     );
          .                 }
          .         
          .                 // The hash function didn't panic, so we can safely set the
          .                 // `growth_left` and `items` fields of the new table.
    666,487 (0.0%)          new_table.growth_left -= self.items;
          .                 new_table.items = self.items;
          .         
          .                 // We successfully copied all elements without panicking. Now replace
          .                 // self with the new table. The old table will have its memory freed but
          .                 // the items will not be dropped (since they have been moved into the
          .                 // new table).
          .                 // SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]
          .                 // that was used to allocate this table.
-- line 3118 ----------------------------------------
-- line 3141 ----------------------------------------
          .             /// * The [`RawTableInner`] has already been allocated;
          .             ///
          .             /// * The [`RawTableInner`] must have properly initialized control bytes.
          .             ///
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[allow(clippy::inline_always)]
          .             #[cfg_attr(feature = "inline-more", inline(always))]
          .             #[cfg_attr(not(feature = "inline-more"), inline)]
         13 (0.0%)      unsafe fn rehash_in_place(
          .                 &mut self,
          .                 hasher: &dyn Fn(&mut Self, usize) -> u64,
          .                 size_of: usize,
          .                 drop: Option<fn(*mut u8)>,
          .             ) {
          .                 // If the hash function panics then properly clean up any elements
          .                 // that we haven't rehashed yet. We unfortunately can't preserve the
          .                 // element since we lost their hash and have no way of recovering it
          .                 // without risking another panic.
          2 (0.0%)          self.prepare_rehash_in_place();
          .         
          .                 let mut guard = guard(self, move |self_| {
          .                     if let Some(drop) = drop {
          .                         for i in 0..self_.buckets() {
          .                             if *self_.ctrl(i) == DELETED {
          .                                 self_.set_ctrl(i, EMPTY);
          .                                 drop(self_.bucket_ptr(i, size_of));
          .                                 self_.items -= 1;
-- line 3167 ----------------------------------------
-- line 3170 ----------------------------------------
          .                     }
          .                     self_.growth_left = bucket_mask_to_capacity(self_.bucket_mask) - self_.items;
          .                 });
          .         
          .                 // At this point, DELETED elements are elements that we haven't
          .                 // rehashed yet. Find them and re-insert them at their ideal
          .                 // position.
          .                 'outer: for i in 0..guard.buckets() {
         64 (0.0%)              if *guard.ctrl(i) != DELETED {
          .                         continue;
          .                     }
          .         
          .                     let i_p = guard.bucket_ptr(i, size_of);
          .         
          .                     'inner: loop {
          .                         // Hash the current item
          .                         let hash = hasher(*guard, i);
-- line 3186 ----------------------------------------
-- line 3219 ----------------------------------------
          .                             // swapped into the old slot.
          .                             debug_assert_eq!(prev_ctrl, DELETED);
          .                             ptr::swap_nonoverlapping(i_p, new_i_p, size_of);
          .                             continue 'inner;
          .                         }
          .                     }
          .                 }
          .         
          3 (0.0%)          guard.growth_left = bucket_mask_to_capacity(guard.bucket_mask) - guard.items;
          .         
          .                 mem::forget(guard);
          8 (0.0%)      }
          .         
          .             /// Deallocates the table without dropping any entries.
          .             ///
          .             /// # Note
          .             ///
          .             /// This function must be called only after [`drop_elements`](RawTableInner::drop_elements),
          .             /// else it can lead to leaking of memory. Also calling this function automatically
          .             /// makes invalid (dangling) all instances of buckets ([`Bucket`]) and makes invalid
-- line 3238 ----------------------------------------
-- line 3257 ----------------------------------------
          .             /// [`Allocator::deallocate`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html#tymethod.deallocate
          .             #[inline]
          .             unsafe fn free_buckets<A>(&mut self, alloc: &A, table_layout: TableLayout)
          .             where
          .                 A: Allocator,
          .             {
          .                 // SAFETY: The caller must uphold the safety contract for `free_buckets`
          .                 // method.
     38,365 (0.0%)          let (ptr, layout) = self.allocation_info(table_layout);
          .                 alloc.deallocate(ptr, layout);
          .             }
          .         
          .             /// Returns a pointer to the allocated memory and the layout that was used to
          .             /// allocate the table.
          .             ///
          .             /// # Safety
          .             ///
-- line 3273 ----------------------------------------
-- line 3330 ----------------------------------------
          .                     // that was used to allocate this table.
          .                     unsafe { self.allocation_info(table_layout) }
          .                 }
          .             }
          .         
          .             /// Marks all table buckets as empty without dropping their contents.
          .             #[inline]
          .             fn clear_no_drop(&mut self) {
     18,038 (0.0%)          if !self.is_empty_singleton() {
          .                     unsafe {
          .                         self.ctrl(0).write_bytes(EMPTY, self.num_ctrl_bytes());
          .                     }
          .                 }
      9,019 (0.0%)          self.items = 0;
     12,466 (0.0%)          self.growth_left = bucket_mask_to_capacity(self.bucket_mask);
          .             }
          .         
          .             /// Erases the [`Bucket`]'s control byte at the given index so that it does not
          .             /// triggered as full, decreases the `items` of the table and, if it can be done,
          .             /// increases `self.growth_left`.
          .             ///
          .             /// This function does not actually erase / drop the [`Bucket`] itself, i.e. it
          .             /// does not make any changes to the `data` parts of the table. The caller of this
-- line 3352 ----------------------------------------
-- line 3378 ----------------------------------------
          .             /// [`Bucket::as_ptr`]: Bucket::as_ptr
          .             /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline]
          .             unsafe fn erase(&mut self, index: usize) {
          .                 debug_assert!(self.is_bucket_full(index));
          .         
          .                 // This is the same as `index.wrapping_sub(Group::WIDTH) % self.buckets()` because
          .                 // the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.
    726,509 (0.0%)          let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;
          .                 // SAFETY:
          .                 // - The caller must uphold the safety contract for `erase` method;
          .                 // - `index_before` is guaranteed to be in range due to masking with `self.bucket_mask`
          .                 let empty_before = Group::load(self.ctrl(index_before)).match_empty();
          .                 let empty_after = Group::load(self.ctrl(index)).match_empty();
          .         
          .                 // Inserting and searching in the map is performed by two key functions:
          .                 //
-- line 3394 ----------------------------------------
-- line 3421 ----------------------------------------
          .                 // upon an `EMPTY` byte, so we can safely mark our erased byte as `EMPTY` as well.
          .                 //
          .                 // Finally, since `index_before == (index.wrapping_sub(Group::WIDTH) & self.bucket_mask) == index`
          .                 // and given all of the above, tables smaller than the group width (self.buckets() < Group::WIDTH)
          .                 // cannot have `DELETED` bytes.
          .                 //
          .                 // Note that in this context `leading_zeros` refers to the bytes at the end of a group, while
          .                 // `trailing_zeros` refers to the bytes at the beginning of a group.
  2,906,047 (0.0%)          let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {
          .                     DELETED
          .                 } else {
  1,427,034 (0.0%)              self.growth_left += 1;
          .                     EMPTY
          .                 };
          .                 // SAFETY: the caller must uphold the safety contract for `erase` method.
          .                 self.set_ctrl(index, ctrl);
    751,416 (0.0%)          self.items -= 1;
          .             }
          .         }
          .         
          .         impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {
          .             fn clone(&self) -> Self {
    107,125 (0.0%)          if self.table.is_empty_singleton() {
          .                     Self::new_in(self.alloc.clone())
          .                 } else {
          .                     unsafe {
          .                         // Avoid `Result::ok_or_else` because it bloats LLVM IR.
          .                         //
          .                         // SAFETY: This is safe as we are taking the size of an already allocated table
          .                         // and therefore сapacity overflow cannot occur, `self.table.buckets()` is power
          .                         // of two and all allocator errors will be caught inside `RawTableInner::new_uninitialized`.
          .                         let mut new_table = match Self::new_uninitialized(
          .                             self.alloc.clone(),
          .                             self.table.buckets(),
          .                             Fallibility::Infallible,
          .                         ) {
      2,488 (0.0%)                      Ok(table) => table,
          .                             Err(_) => hint::unreachable_unchecked(),
          .                         };
          .         
          .                         // Cloning elements may fail (the clone function may panic). But we don't
          .                         // need to worry about uninitialized control bits, since:
          .                         // 1. The number of items (elements) in the table is zero, which means that
          .                         //    the control bits will not be readed by Drop function.
          .                         // 2. The `clone_from_spec` method will first copy all control bits from
          .                         //    `self` (thus initializing them). But this will not affect the `Drop`
          .                         //    function, since the `clone_from_spec` function sets `items` only after
          .                         //    successfully clonning all elements.
          .                         new_table.clone_from_spec(self);
      4,314 (0.0%)                  new_table
          .                     }
          .                 }
          .             }
          .         
     44,613 (0.0%)      fn clone_from(&mut self, source: &Self) {
      9,914 (0.0%)          if source.table.is_empty_singleton() {
          .                     let mut old_inner = mem::replace(&mut self.table, RawTableInner::NEW);
          .                     unsafe {
          .                         // SAFETY:
          .                         // 1. We call the function only once;
          .                         // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]
          .                         //    and [`TableLayout`] that were used to allocate this table.
          .                         // 3. If any elements' drop function panics, then there will only be a memory leak,
          .                         //    because we have replaced the inner table with a new one.
-- line 3484 ----------------------------------------
-- line 3531 ----------------------------------------
          .                         // inside the `clone_from_impl` function will take care of that, dropping all
          .                         // cloned elements if necessary. Our `ScopeGuard` will clear the table.
          .                         self_.clone_from_spec(source);
          .         
          .                         // Disarm the scope guard if cloning was successful.
          .                         ScopeGuard::into_inner(self_);
          .                     }
          .                 }
     39,656 (0.0%)      }
          .         }
          .         
          .         /// Specialization of `clone_from` for `Copy` types
          .         trait RawTableClone {
          .             unsafe fn clone_from_spec(&mut self, source: &Self);
          .         }
          .         impl<T: Clone, A: Allocator + Clone> RawTableClone for RawTable<T, A> {
          .             default_fn! {
-- line 3547 ----------------------------------------
-- line 3559 ----------------------------------------
          .                     .table
          .                     .ctrl(0)
          .                     .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());
          .                 source
          .                     .data_start()
          .                     .as_ptr()
          .                     .copy_to_nonoverlapping(self.data_start().as_ptr(), self.table.buckets());
          .         
          1 (0.0%)          self.table.items = source.table.items;
          2 (0.0%)          self.table.growth_left = source.table.growth_left;
          .             }
          .         }
          .         
          .         impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {
          .             /// Common code for clone and clone_from. Assumes:
          .             /// - `self.buckets() == source.buckets()`.
          .             /// - Any existing elements have been dropped.
          .             /// - The control bytes are not initialized yet.
-- line 3576 ----------------------------------------
-- line 3602 ----------------------------------------
          .         
          .                     // Update the index in case we need to unwind.
          .                     guard.0 = index;
          .                 }
          .         
          .                 // Successfully cloned all items, no need to clean up.
          .                 mem::forget(guard);
          .         
        915 (0.0%)          self.table.items = source.table.items;
      1,248 (0.0%)          self.table.growth_left = source.table.growth_left;
          .             }
          .         
          .             /// Variant of `clone_from` to use when a hasher is available.
          .             #[cfg(feature = "raw")]
          .             pub fn clone_from_with_hasher(&mut self, source: &Self, hasher: impl Fn(&T) -> u64) {
          .                 // If we have enough capacity in the table, just clear it and insert
          .                 // elements one by one. We don't do this if we have the same number of
          .                 // buckets as the source since we can just copy the contents directly
          .                 // in that case.
      9,917 (0.0%)          if self.table.buckets() != source.table.buckets()
          2 (0.0%)              && bucket_mask_to_capacity(self.table.bucket_mask) >= source.len()
          .                 {
          .                     self.clear();
          .         
          .                     let mut guard_self = guard(&mut *self, |self_| {
          .                         // Clear the partially copied table if a panic occurs, otherwise
          .                         // items and growth_left will be out of sync with the contents
          .                         // of the table.
          .                         self_.clear();
-- line 3630 ----------------------------------------
-- line 3646 ----------------------------------------
          .                     }
          .         
          .                     // Successfully cloned all items, no need to clean up.
          .                     mem::forget(guard_self);
          .         
          .                     self.table.items = source.table.items;
          .                     self.table.growth_left -= source.table.items;
          .                 } else {
      4,957 (0.0%)              self.clone_from(source);
          .                 }
          .             }
          .         }
          .         
          .         impl<T, A: Allocator + Default> Default for RawTable<T, A> {
          .             #[inline]
          .             fn default() -> Self {
          .                 Self::new_in(Default::default())
-- line 3662 ----------------------------------------
-- line 3670 ----------------------------------------
          .                 unsafe {
          .                     // SAFETY:
          .                     // 1. We call the function only once;
          .                     // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]
          .                     //    and [`TableLayout`] that were used to allocate this table.
          .                     // 3. If the drop function of any elements fails, then only a memory leak will occur,
          .                     //    and we don't care because we are inside the `Drop` function of the `RawTable`,
          .                     //    so there won't be any table left in an inconsistent state.
         11 (0.0%)              self.table
          .                         .drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);
          .                 }
          .             }
          .         }
          .         #[cfg(not(feature = "nightly"))]
          .         impl<T, A: Allocator> Drop for RawTable<T, A> {
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             fn drop(&mut self) {
-- line 3686 ----------------------------------------
-- line 3835 ----------------------------------------
          .                     }
          .         
          .                     // We might read past self.end up to the next group boundary,
          .                     // but this is fine because it only occurs on tables smaller
          .                     // than the group size where the trailing control bytes are all
          .                     // EMPTY. On larger tables self.end is guaranteed to be aligned
          .                     // to the group size (since tables are power-of-two sized).
          .                     self.current_group = Group::load_aligned(self.next_ctrl).match_full().into_iter();
        847 (0.0%)              self.data = self.data.next_n(Group::WIDTH);
          .                     self.next_ctrl = self.next_ctrl.add(Group::WIDTH);
          .                 }
          .             }
          .         
          .             /// Folds every element into an accumulator by applying an operation,
          .             /// returning the final result.
          .             ///
          .             /// `fold_impl()` takes three arguments: the number of items remaining in
-- line 3851 ----------------------------------------
-- line 3877 ----------------------------------------
          .                 F: FnMut(B, Bucket<T>) -> B,
          .             {
          .                 loop {
          .                     while let Some(index) = self.current_group.next() {
          .                         // The returned `index` will always be in the range `0..Group::WIDTH`,
          .                         // so that calling `self.data.next_n(index)` is safe (see detailed explanation below).
          .                         debug_assert!(n != 0);
          .                         let bucket = self.data.next_n(index);
      1,492 (0.0%)                  acc = f(acc, bucket);
      4,755 (0.0%)                  n -= 1;
          .                     }
          .         
      2,968 (0.0%)              if n == 0 {
          .                         return acc;
          .                     }
          .         
          .                     // SAFETY: The caller of this function ensures that:
          .                     //
          .                     // 1. The provided `n` value matches the actual number of items in the table;
          .                     // 2. The table is alive and did not moved.
          .                     //
-- line 3897 ----------------------------------------
-- line 4097 ----------------------------------------
          .                         }
          .                     }
          .                 } else {
          .                     // We must have already iterated past the removed item.
          .                 }
          .             }
          .         
          .             unsafe fn drop_elements(&mut self) {
      3,421 (0.0%)          if T::NEEDS_DROP && self.items != 0 {
          .                     for item in self {
          .                         item.drop();
          .                     }
          .                 }
          .             }
          .         }
          .         
          .         impl<T> Clone for RawIter<T> {
-- line 4113 ----------------------------------------
-- line 4122 ----------------------------------------
          .         
          .         impl<T> Iterator for RawIter<T> {
          .             type Item = Bucket<T>;
          .         
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             fn next(&mut self) -> Option<Bucket<T>> {
          .                 // Inner iterator iterates over buckets
          .                 // so it can do unnecessary work if we already yielded all items.
  1,689,944 (0.0%)          if self.items == 0 {
          .                     return None;
          .                 }
          .         
          .                 let nxt = unsafe {
          .                     // SAFETY: We check number of items to yield using `items` field.
          .                     self.iter.next_impl::<false>()
          .                 };
          .         
          .                 debug_assert!(nxt.is_some());
     24,479 (0.0%)          self.items -= 1;
          .         
          .                 nxt
          .             }
          .         
          .             #[inline]
          .             fn size_hint(&self) -> (usize, Option<usize>) {
          .                 (self.items, Some(self.items))
          .             }
-- line 4148 ----------------------------------------
-- line 4204 ----------------------------------------
          .             ///
          .             /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
          .             #[inline(always)]
          .             unsafe fn next_impl(&mut self) -> Option<usize> {
          .                 loop {
          .                     if let Some(index) = self.current_group.next() {
          .                         // The returned `self.group_first_index + index` will always
          .                         // be in the range `0..self.buckets()`. See explanation below.
  3,877,544 (0.0%)                  return Some(self.group_first_index + index);
          .                     }
          .         
          .                     // SAFETY: The caller of this function ensures that:
          .                     //
          .                     // 1. It never tries to iterate after getting all the elements;
          .                     // 2. The table is alive and did not moved;
          .                     // 3. The first `self.ctrl` pointed to the start of the array of control bytes.
          .                     //
-- line 4220 ----------------------------------------
-- line 4234 ----------------------------------------
          .                     //    and subsequent `self.group_first_index + index` will always return a
          .                     //    number less than `self.buckets()`.
          .                     self.ctrl = NonNull::new_unchecked(self.ctrl.as_ptr().add(Group::WIDTH));
          .         
          .                     // SAFETY: See explanation above.
          .                     self.current_group = Group::load_aligned(self.ctrl.as_ptr())
          .                         .match_full()
          .                         .into_iter();
    217,599 (0.0%)              self.group_first_index += Group::WIDTH;
          .                 }
          .             }
          .         }
          .         
          .         impl Iterator for FullBucketsIndices {
          .             type Item = usize;
          .         
          .             /// Advances the iterator and returns the next value. It is up to
          .             /// the caller to ensure that the `RawTable` outlives the `FullBucketsIndices`,
          .             /// because we cannot make the `next` method unsafe.
          .             #[inline(always)]
          .             fn next(&mut self) -> Option<usize> {
          .                 // Return if we already yielded all items.
  8,452,776 (0.1%)          if self.items == 0 {
          .                     return None;
          .                 }
          .         
          .                 let nxt = unsafe {
          .                     // SAFETY:
          .                     // 1. We check number of items to yield using `items` field.
          .                     // 2. The caller ensures that the table is alive and has not moved.
          .                     self.next_impl()
-- line 4264 ----------------------------------------
-- line 4310 ----------------------------------------
          .         unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawIntoIter<T, A> {
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             fn drop(&mut self) {
          .                 unsafe {
          .                     // Drop all remaining elements
          .                     self.iter.drop_elements();
          .         
          .                     // Free the table
     40,560 (0.0%)              if let Some((ptr, layout, ref alloc)) = self.allocation {
          .                         alloc.deallocate(ptr, layout);
          .                     }
          .                 }
          .             }
          .         }
          .         #[cfg(not(feature = "nightly"))]
          .         impl<T, A: Allocator> Drop for RawIntoIter<T, A> {
          .             #[cfg_attr(feature = "inline-more", inline)]
-- line 4326 ----------------------------------------
-- line 4337 ----------------------------------------
          .             }
          .         }
          .         
          .         impl<T, A: Allocator> Iterator for RawIntoIter<T, A> {
          .             type Item = T;
          .         
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             fn next(&mut self) -> Option<T> {
     40,967 (0.0%)          unsafe { Some(self.iter.next()?.read()) }
          .             }
          .         
          .             #[inline]
          .             fn size_hint(&self) -> (usize, Option<usize>) {
          .                 self.iter.size_hint()
          .             }
          .         }
          .         
-- line 4353 ----------------------------------------
-- line 4396 ----------------------------------------
          .                     // Drop all remaining elements. Note that this may panic.
          .                     self.iter.drop_elements();
          .         
          .                     // Reset the contents of the table now that all elements have been
          .                     // dropped.
          .                     self.table.clear_no_drop();
          .         
          .                     // Move the now empty table back to its original location.
      5,552 (0.0%)              self.orig_table
          .                         .as_ptr()
          .                         .copy_from_nonoverlapping(&self.table, 1);
          .                 }
          .             }
          .         }
          .         
          .         impl<T, A: Allocator> Iterator for RawDrain<'_, T, A> {
          .             type Item = T;
          .         
          .             #[cfg_attr(feature = "inline-more", inline)]
          .             fn next(&mut self) -> Option<T> {
          .                 unsafe {
          .                     let item = self.iter.next()?;
          2 (0.0%)              Some(item.read())
          .                 }
          .             }
          .         
          .             #[inline]
          .             fn size_hint(&self) -> (usize, Option<usize>) {
          .                 self.iter.size_hint()
          .             }
          .         }
-- line 4426 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pulldown-cmark-0.9.6/src/firstpass.rs
--------------------------------------------------------------------------------
Ir______________ 

3,782,599 (0.0%)  <unknown (line 0)>

-- line 16 ----------------------------------------
        .         
        .         use unicase::UniCase;
        .         
        .         /// Runs the first pass, which resolves the block structure of the document,
        .         /// and returns the resulting tree.
        .         pub(crate) fn run_first_pass(text: &str, options: Options) -> (Tree<Item>, Allocations) {
        .             // This is a very naive heuristic for the number of nodes
        .             // we'll need.
   27,130 (0.0%)      let start_capacity = max(128, text.len() / 32);
        .             let lookup_table = &create_lut(&options);
  298,430 (0.0%)      let first_pass = FirstPass {
        .                 text,
        .                 tree: Tree::with_capacity(start_capacity),
        .                 begin_list_item: false,
        .                 last_line_blank: false,
        .                 allocs: Allocations::new(),
        .                 options,
        .                 lookup_table,
        .             };
-- line 34 ----------------------------------------
-- line 44 ----------------------------------------
        .             allocs: Allocations<'a>,
        .             options: Options,
        .             lookup_table: &'b LookupTable,
        .         }
        .         
        .         impl<'a, 'b> FirstPass<'a, 'b> {
        .             fn run(mut self) -> (Tree<Item>, Allocations<'a>) {
        .                 let mut ix = 0;
  345,680 (0.0%)          while ix < self.text.len() {
        .                     ix = self.parse_block(ix);
        .                 }
   40,695 (0.0%)          for _ in 0..self.tree.spine_len() {
      696 (0.0%)              self.pop(ix);
        .                 }
  149,215 (0.0%)          (self.tree, self.allocs)
        .             }
        .         
        .             /// Returns offset after block.
        .             fn parse_block(&mut self, mut start_ix: usize) -> usize {
  127,420 (0.0%)          let bytes = self.text.as_bytes();
        .                 let mut line_start = LineStart::new(&bytes[start_ix..]);
        .         
  127,420 (0.0%)          let i = scan_containers(&self.tree, &mut line_start);
        .                 for _ in i..self.tree.spine_len() {
    2,769 (0.0%)              self.pop(start_ix);
        .                 }
        .         
   63,710 (0.0%)          if self.options.contains(Options::ENABLE_FOOTNOTES) {
        .                     // finish footnote if it's still open and was preceded by blank line
   62,250 (0.0%)              if let Some(node_ix) = self.tree.peek_up() {
    2,118 (0.0%)                  if let ItemBody::FootnoteDefinition(..) = self.tree[node_ix].item.body {
        .                             if self.last_line_blank {
        .                                 self.pop(start_ix);
        .                             }
        .                         }
        .                     }
        .         
        .                     // Footnote definitions of the form
        .                     // [^bar]:
        .                     // * anything really
   61,191 (0.0%)              let container_start = start_ix + line_start.bytes_scanned();
        .                     if let Some(bytecount) = self.parse_footnote(container_start) {
        .                         start_ix = container_start + bytecount;
        .                         start_ix += scan_blank_line(&bytes[start_ix..]).unwrap_or(0);
        .                         line_start = LineStart::new(&bytes[start_ix..]);
        .                     }
        .                 }
        .         
        .                 // Process new containers
  127,420 (0.0%)          loop {
        .                     let container_start = start_ix + line_start.bytes_scanned();
        .                     if let Some((ch, index, indent)) = line_start.scan_list_marker() {
        .                         let after_marker_index = start_ix + line_start.bytes_scanned();
        .                         self.continue_list(container_start, ch, index);
    6,342 (0.0%)                  self.tree.append(Item {
        .                             start: container_start,
        .                             end: after_marker_index, // will get updated later if item not empty
        .                             body: ItemBody::ListItem(indent),
        .                         });
        .                         self.tree.push();
        .                         if let Some(n) = scan_blank_line(&bytes[after_marker_index..]) {
        .                             self.begin_list_item = true;
        .                             return after_marker_index + n;
        .                         }
      906 (0.0%)                  if self.options.contains(Options::ENABLE_TASKLISTS) {
        .                             if let Some(is_checked) = line_start.scan_task_list_marker() {
        .                                 self.tree.append(Item {
        .                                     start: after_marker_index,
        .                                     end: start_ix + line_start.bytes_scanned(),
        .                                     body: ItemBody::TaskListMarker(is_checked),
        .                                 });
        .                             }
        .                         }
        .                     } else if line_start.scan_blockquote_marker() {
        .                         self.finish_list(start_ix);
      582 (0.0%)                  self.tree.append(Item {
        .                             start: container_start,
        .                             end: 0, // will get set later
        .                             body: ItemBody::BlockQuote,
        .                         });
        .                         self.tree.push();
        .                     } else {
        .                         break;
        .                     }
        .                 }
        .         
        .                 let ix = start_ix + line_start.bytes_scanned();
        .         
        .                 if let Some(n) = scan_blank_line(&bytes[ix..]) {
   26,694 (0.0%)              if let Some(node_ix) = self.tree.peek_up() {
      644 (0.0%)                  match self.tree[node_ix].item.body {
        .                             ItemBody::BlockQuote => (),
        .                             _ => {
      634 (0.0%)                          if self.begin_list_item {
        .                                     // A list item can begin with at most one blank line.
        .                                     self.pop(start_ix);
        .                                 }
      317 (0.0%)                          self.last_line_blank = true;
        .                             }
        .                         }
        .                     }
   52,744 (0.0%)              return ix + n;
        .                 }
        .         
   37,338 (0.0%)          self.begin_list_item = false;
  149,352 (0.0%)          self.finish_list(start_ix);
        .         
        .                 // Save `remaining_space` here to avoid needing to backtrack `line_start` for HTML blocks
        .                 let remaining_space = line_start.remaining_space();
        .         
        .                 let indent = line_start.scan_space_upto(4);
  112,014 (0.0%)          if indent == 4 {
        .                     let ix = start_ix + line_start.bytes_scanned();
        .                     let remaining_space = line_start.remaining_space();
        .                     return self.parse_indented_code_block(ix, remaining_space);
        .                 }
        .         
   37,338 (0.0%)          let ix = start_ix + line_start.bytes_scanned();
        .         
        .                 // HTML Blocks
  186,690 (0.0%)          if bytes[ix] == b'<' {
        .                     // Types 1-5 are all detected by one function and all end with the same
        .                     // pattern
       63 (0.0%)              if let Some(html_end_tag) = get_html_end_tag(&bytes[(ix + 1)..]) {
        .                         return self.parse_html_block_type_1_to_5(ix, html_end_tag, remaining_space);
        .                     }
        .         
        .                     // Detect type 6
        6 (0.0%)              if starts_html_block_type_6(&bytes[(ix + 1)..]) {
        .                         return self.parse_html_block_type_6_or_7(ix, remaining_space);
        .                     }
        .         
        .                     // Detect type 7
        .                     if let Some(_html_bytes) = scan_html_type_7(&bytes[ix..]) {
        .                         return self.parse_html_block_type_6_or_7(ix, remaining_space);
        .                     }
        .                 }
-- line 180 ----------------------------------------
-- line 183 ----------------------------------------
        .                     return self.parse_hrule(n, ix);
        .                 }
        .         
        .                 if let Some(atx_size) = scan_atx_heading(&bytes[ix..]) {
        .                     return self.parse_atx_heading(ix, atx_size);
        .                 }
        .         
        .                 // parse refdef
  205,021 (0.0%)          if let Some((bytecount, label, link_def)) = self.parse_refdef_total(ix) {
   12,524 (0.0%)              self.allocs.refdefs.0.entry(label).or_insert(link_def);
    6,262 (0.0%)              let ix = ix + bytecount;
        .                     // try to read trailing whitespace or it will register as a completely blank line
        .                     // TODO: shouldn't we do this for all block level items?
   12,524 (0.0%)              return ix + scan_blank_line(&bytes[ix..]).unwrap_or(0);
   56,860 (0.0%)          }
        .         
  176,272 (0.0%)          if let Some((n, fence_ch)) = scan_code_fence(&bytes[ix..]) {
   34,152 (0.0%)              return self.parse_fenced_code_block(ix, indent, fence_ch, n);
        .                 }
   68,214 (0.0%)          self.parse_paragraph(ix)
        .             }
        .         
        .             /// Returns the offset of the first line after the table.
        .             /// Assumptions: current focus is a table element and the table header
        .             /// matches the separator line (same number of columns).
        .             fn parse_table(&mut self, table_cols: usize, head_start: usize, body_start: usize) -> usize {
        .                 // parse header. this shouldn't fail because we made sure the table header is ok
       48 (0.0%)          let (_sep_start, thead_ix) = self.parse_table_row_inner(head_start, table_cols);
       36 (0.0%)          self.tree[thead_ix].item.body = ItemBody::TableHead;
        .         
        .                 // parse body
        .                 let mut ix = body_start;
       96 (0.0%)          while let Some((next_ix, _row_ix)) = self.parse_table_row(ix, table_cols) {
        .                     ix = next_ix;
        .                 }
        .         
        .                 self.pop(ix);
        .                 ix
        .             }
        .         
        .             /// Call this when containers are taken care of.
        .             /// Returns bytes scanned, row_ix
      660 (0.0%)      fn parse_table_row_inner(&mut self, mut ix: usize, row_cells: usize) -> (usize, TreeIndex) {
      180 (0.0%)          let bytes = self.text.as_bytes();
        .                 let mut cells = 0;
        .                 let mut final_cell_ix = None;
        .         
      300 (0.0%)          let row_ix = self.tree.append(Item {
        .                     start: ix,
        .                     end: 0, // set at end of this function
        .                     body: ItemBody::TableRow,
        .                 });
        .                 self.tree.push();
        .         
        .                 loop {
      300 (0.0%)              ix += scan_ch(&bytes[ix..], b'|');
        .                     let start_ix = ix;
      300 (0.0%)              ix += scan_whitespace_no_nl(&bytes[ix..]);
        .         
        .                     if let Some(eol_bytes) = scan_eol(&bytes[ix..]) {
       60 (0.0%)                  ix += eol_bytes;
        .                         break;
        .                     }
        .         
    1,440 (0.0%)              let cell_ix = self.tree.append(Item {
        .                         start: start_ix,
        .                         end: ix,
        .                         body: ItemBody::TableCell,
        .                     });
        .                     self.tree.push();
    1,680 (0.0%)              let (next_ix, _brk) = self.parse_line(ix, None, TableParseMode::Active);
        .         
    1,200 (0.0%)              if let Some(cur_ix) = self.tree.cur() {
        .                         let trailing_whitespace = scan_rev_while(&bytes[..next_ix], is_ascii_whitespace);
      612 (0.0%)                  self.tree[cur_ix].item.end -= trailing_whitespace;
        .                     }
        .         
      720 (0.0%)              self.tree[cell_ix].item.end = next_ix;
        .                     self.tree.pop();
        .         
        .                     ix = next_ix;
      240 (0.0%)              cells += 1;
        .         
      720 (0.0%)              if cells == row_cells {
        .                         final_cell_ix = Some(cell_ix);
        .                     }
        .                 }
        .         
        .                 // fill empty cells if needed
        .                 // note: this is where GFM and commonmark-extra diverge. we follow
        .                 // GFM here
        .                 for _ in cells..row_cells {
-- line 274 ----------------------------------------
-- line 275 ----------------------------------------
        .                     self.tree.append(Item {
        .                         start: ix,
        .                         end: ix,
        .                         body: ItemBody::TableCell,
        .                     });
        .                 }
        .         
        .                 // drop excess cells
      180 (0.0%)          if let Some(cell_ix) = final_cell_ix {
      180 (0.0%)              self.tree[cell_ix].next = None;
        .                 }
        .         
      180 (0.0%)          self.pop(ix);
        .         
        .                 (ix, row_ix)
      600 (0.0%)      }
        .         
        .             /// Returns first offset after the row and the tree index of the row.
        .             fn parse_table_row(&mut self, mut ix: usize, row_cells: usize) -> Option<(usize, TreeIndex)> {
       60 (0.0%)          let bytes = self.text.as_bytes();
        .                 let mut line_start = LineStart::new(&bytes[ix..]);
        .                 let current_container =
      240 (0.0%)              scan_containers(&self.tree, &mut line_start) == self.tree.spine_len();
       60 (0.0%)          if !current_container {
        .                     return None;
        .                 }
        .                 line_start.scan_all_space();
       60 (0.0%)          ix += line_start.bytes_scanned();
      300 (0.0%)          if scan_paragraph_interrupt(&bytes[ix..], current_container) {
        .                     return None;
        .                 }
        .         
      240 (0.0%)          let (ix, row_ix) = self.parse_table_row_inner(ix, row_cells);
        .                 Some((ix, row_ix))
        .             }
        .         
        .             /// Returns offset of line start after paragraph.
  227,380 (0.0%)      fn parse_paragraph(&mut self, start_ix: usize) -> usize {
  113,690 (0.0%)          let node_ix = self.tree.append(Item {
        .                     start: start_ix,
        .                     end: 0, // will get set later
        .                     body: ItemBody::Paragraph,
        .                 });
        .                 self.tree.push();
  159,166 (0.0%)          let bytes = self.text.as_bytes();
        .         
        .                 let mut ix = start_ix;
        .                 loop {
  202,744 (0.0%)              if self.options.contains(Options::ENABLE_FOOTNOTES) && self.get_footnote(ix).is_some() {
        .                         self.tree[node_ix].item.end = if ix > start_ix { ix - 1 } else { start_ix };
        .                         self.tree.pop();
        .                         if let Some(node_ix) = self.tree.peek_up() {
        .                             if let ItemBody::FootnoteDefinition(..) = self.tree[node_ix].item.body {
        .                                 self.pop(ix);
        .                             }
        .                         }
        .                         return ix;
        .                     }
        .         
        .                     let scan_mode = if self.options.contains(Options::ENABLE_TABLES) && ix == start_ix {
        .                         TableParseMode::Scan
        .                     } else {
        .                         TableParseMode::Disabled
        .                     };
  718,556 (0.0%)              let (next_ix, brk) = self.parse_line(ix, None, scan_mode);
        .         
        .                     // break out when we find a table
   84,536 (0.0%)              if let Some(Item {
        .                         body: ItemBody::Table(alignment_ix),
        .                         ..
        .                     }) = brk
        .                     {
        .                         let table_cols = self.allocs[alignment_ix].len();
       24 (0.0%)                  self.tree[node_ix].item.body = ItemBody::Table(alignment_ix);
        .                         // this clears out any stuff we may have appended - but there may
        .                         // be a cleaner way
       12 (0.0%)                  self.tree[node_ix].child = None;
        .                         self.tree.pop();
        .                         self.tree.push();
        .                         return self.parse_table(table_cols, ix, next_ix);
        .                     }
        .         
        .                     ix = next_ix;
        .                     let mut line_start = LineStart::new(&bytes[ix..]);
        .                     let current_container =
  295,792 (0.0%)                  scan_containers(&self.tree, &mut line_start) == self.tree.spine_len();
        .                     if !line_start.scan_space(4) {
   42,256 (0.0%)                  let ix_new = ix + line_start.bytes_scanned();
   42,256 (0.0%)                  if current_container {
   82,968 (0.0%)                      let trailing_backslash_pos = match brk {
        .                                 Some(Item {
        .                                     start,
        .                                     body: ItemBody::HardBreak,
        .                                     ..
        .                                 }) if bytes[start] == b'\\' => Some(start),
        .                                 _ => None,
        .                             };
        .                             if let Some(ix_setext) =
-- line 372 ----------------------------------------
-- line 376 ----------------------------------------
        .                                     self.tree.append_text(pos, pos + 1);
        .                                 }
        .                                 ix = ix_setext;
        .                                 break;
        .                             }
        .                         }
        .                         // first check for non-empty lists, then for other interrupts
        .                         let suffix = &bytes[ix_new..];
  126,768 (0.0%)                  if scan_paragraph_interrupt(suffix, current_container) {
        .                             break;
        .                         }
        .                     }
        .                     line_start.scan_all_space();
   58,590 (0.0%)              if line_start.is_at_eol() {
        .                         break;
        .                     }
        .                     ix = next_ix + line_start.bytes_scanned();
  234,360 (0.0%)              if let Some(item) = brk {
   78,120 (0.0%)                  self.tree.append(item);
        .                     }
        .                 }
        .         
   90,904 (0.0%)          self.pop(ix);
        .                 ix
  204,642 (0.0%)      }
        .         
        .             /// Returns end ix of setext_heading on success.
        .             fn parse_setext_heading(
        .                 &mut self,
        .                 ix: usize,
        .                 node_ix: TreeIndex,
        .                 has_trailing_content: bool,
        .             ) -> Option<usize> {
   41,484 (0.0%)          let bytes = self.text.as_bytes();
   36,817 (0.0%)          let (n, level) = scan_setext_heading(&bytes[ix..])?;
        .                 let mut attrs = None;
        .         
        .                 if let Some(cur_ix) = self.tree.cur() {
        .                     let parent_ix = self.tree.peek_up().unwrap();
        .                     let header_start = self.tree[parent_ix].item.start;
        .                     // Note that `self.tree[parent_ix].item.end` might be zero at this point.
        .                     // Use the end position of the current node (i.e. the last known child
        .                     // of the parent) instead.
-- line 418 ----------------------------------------
-- line 448 ----------------------------------------
        .                 );
        .         
        .                 Some(ix + n)
        .             }
        .         
        .             /// Parse a line of input, appending text and items to tree.
        .             ///
        .             /// Returns: index after line and an item representing the break.
  482,780 (0.0%)      fn parse_line(
        .                 &mut self,
        .                 start: usize,
        .                 end: Option<usize>,
        .                 mode: TableParseMode,
        .             ) -> (usize, Option<Item>) {
  144,834 (0.0%)          let bytes = self.text.as_bytes();
   96,556 (0.0%)          let bytes = match end {
        .                     Some(end) => &bytes[..end],
        .                     None => bytes,
        .                 };
        .                 let bytes_len = bytes.len();
        .                 let mut pipes = 0;
        .                 let mut last_pipe_ix = start;
        .                 let mut begin_text = start;
        .         
  285,216 (0.0%)          let (final_ix, brk) = iterate_special_bytes(self.lookup_table, bytes, start, |ix, byte| {
  898,938 (0.0%)              match byte {
        .                         b'\n' | b'\r' => {
   43,826 (0.0%)                      if let TableParseMode::Active = mode {
        .                                 return LoopInstruction::BreakAtWith(ix, None);
        .                             }
        .         
        .                             let mut i = ix;
        .                             let eol_bytes = scan_eol(&bytes[ix..]).unwrap();
  126,216 (0.0%)                      if mode == TableParseMode::Scan && pipes > 0 {
        .                                 // check if we may be parsing a table
        .                                 let next_line_ix = ix + eol_bytes;
        .                                 let mut line_start = LineStart::new(&bytes[next_line_ix..]);
      220 (0.0%)                          if scan_containers(&self.tree, &mut line_start) == self.tree.spine_len() {
      106 (0.0%)                              let table_head_ix = next_line_ix + line_start.bytes_scanned();
        .                                     let (table_head_bytes, alignment) =
       53 (0.0%)                                  scan_table_head(&bytes[table_head_ix..]);
        .         
      135 (0.0%)                              if table_head_bytes > 0 {
        .                                         // computing header count from number of pipes
        .                                         let header_count =
        .                                             count_header_cols(bytes, pipes, start, last_pipe_ix);
        .         
        .                                         // make sure they match the number of columns we find in separator line
       48 (0.0%)                                  if alignment.len() == header_count {
        .                                             let alignment_ix = self.allocs.allocate_alignment(alignment);
       36 (0.0%)                                      let end_ix = table_head_ix + table_head_bytes;
        .                                             return LoopInstruction::BreakAtWith(
        .                                                 end_ix,
        .                                                 Some(Item {
        .                                                     start: i,
        .                                                     end: end_ix, // must update later
        .                                                     body: ItemBody::Table(alignment_ix),
        .                                                 }),
        .                                             );
        .                                         }
        .                                     }
        .                                 }
        .                             }
        .         
        .                             let end_ix = ix + eol_bytes;
   43,814 (0.0%)                      let trailing_backslashes = scan_rev_while(&bytes[..ix], |b| b == b'\\');
  131,442 (0.0%)                      if trailing_backslashes % 2 == 1 && end_ix < bytes_len {
        .                                 i -= 1;
        .                                 self.tree.append_text(begin_text, i);
        .                                 return LoopInstruction::BreakAtWith(
        .                                     end_ix,
        .                                     Some(Item {
        .                                         start: i,
        .                                         end: end_ix,
        .                                         body: ItemBody::HardBreak,
        .                                     }),
        .                                 );
        .                             }
        .                             let trailing_whitespace =
        .                                 scan_rev_while(&bytes[..ix], is_ascii_whitespace_no_nl);
   87,628 (0.0%)                      if trailing_whitespace >= 2 {
        .                                 i -= trailing_whitespace;
        .                                 self.tree.append_text(begin_text, i);
        .                                 return LoopInstruction::BreakAtWith(
        .                                     end_ix,
        .                                     Some(Item {
        .                                         start: i,
        .                                         end: end_ix,
        .                                         body: ItemBody::HardBreak,
-- line 536 ----------------------------------------
-- line 544 ----------------------------------------
        .                                 Some(Item {
        .                                     start: i,
        .                                     end: end_ix,
        .                                     body: ItemBody::SoftBreak,
        .                                 }),
        .                             )
        .                         }
        .                         b'\\' => {
      642 (0.0%)                      if ix + 1 < bytes_len && is_ascii_punctuation(bytes[ix + 1]) {
        .                                 self.tree.append_text(begin_text, ix);
       98 (0.0%)                          if bytes[ix + 1] == b'`' {
        .                                     let count = 1 + scan_ch_repeat(&bytes[(ix + 2)..], b'`');
        .                                     self.tree.append(Item {
        .                                         start: ix + 1,
        .                                         end: ix + count + 1,
        .                                         body: ItemBody::MaybeCode(count, true),
        .                                     });
        .                                     begin_text = ix + 1 + count;
        .                                     LoopInstruction::ContinueAndSkip(count)
-- line 562 ----------------------------------------
-- line 565 ----------------------------------------
        .                                     LoopInstruction::ContinueAndSkip(1)
        .                                 }
        .                             } else {
        .                                 LoopInstruction::ContinueAndSkip(0)
        .                             }
        .                         }
        .                         c @ b'*' | c @ b'_' | c @ b'~' => {
        .                             let string_suffix = &self.text[ix..];
    6,248 (0.0%)                      let count = 1 + scan_ch_repeat(&string_suffix.as_bytes()[1..], c);
   62,480 (0.0%)                      let can_open = delim_run_can_open(self.text, string_suffix, count, ix);
   37,488 (0.0%)                      let can_close = delim_run_can_close(self.text, string_suffix, count, ix);
   31,240 (0.0%)                      let is_valid_seq = c != b'~' || count <= 2;
        .         
   31,240 (0.0%)                      if (can_open || can_close) && is_valid_seq {
        .                                 self.tree.append_text(begin_text, ix);
        .                                 for i in 0..count {
   23,290 (0.0%)                              self.tree.append(Item {
        .                                         start: ix + i,
        .                                         end: ix + i + 1,
    2,329 (0.0%)                                  body: ItemBody::MaybeEmphasis(count - i, can_open, can_close),
        .                                     });
        .                                 }
    3,466 (0.0%)                          begin_text = ix + count;
        .                             }
        .                             LoopInstruction::ContinueAndSkip(count - 1)
        .                         }
        .                         b'`' => {
        .                             self.tree.append_text(begin_text, ix);
  136,455 (0.0%)                      let count = 1 + scan_ch_repeat(&bytes[(ix + 1)..], b'`');
  409,365 (0.0%)                      self.tree.append(Item {
        .                                 start: ix,
   90,970 (0.0%)                          end: ix + count,
        .                                 body: ItemBody::MaybeCode(count, false),
        .                             });
        .                             begin_text = ix + count;
        .                             LoopInstruction::ContinueAndSkip(count - 1)
        .                         }
        .                         b'<' => {
        .                             // Note: could detect some non-HTML cases and early escape here, but not
        .                             // clear that's a win.
        .                             self.tree.append_text(begin_text, ix);
    6,288 (0.0%)                      self.tree.append(Item {
        .                                 start: ix,
    1,572 (0.0%)                          end: ix + 1,
        .                                 body: ItemBody::MaybeHtml,
        .                             });
        .                             begin_text = ix + 1;
        .                             LoopInstruction::ContinueAndSkip(0)
        .                         }
        .                         b'!' => {
    1,428 (0.0%)                      if ix + 1 < bytes_len && bytes[ix + 1] == b'[' {
        .                                 self.tree.append_text(begin_text, ix);
       72 (0.0%)                          self.tree.append(Item {
        .                                     start: ix,
        8 (0.0%)                              end: ix + 2,
        .                                     body: ItemBody::MaybeImage,
        .                                 });
        .                                 begin_text = ix + 2;
        .                                 LoopInstruction::ContinueAndSkip(1)
        .                             } else {
        .                                 LoopInstruction::ContinueAndSkip(0)
        .                             }
        .                         }
        .                         b'[' => {
        .                             self.tree.append_text(begin_text, ix);
   45,505 (0.0%)                      self.tree.append(Item {
        .                                 start: ix,
    9,101 (0.0%)                          end: ix + 1,
        .                                 body: ItemBody::MaybeLinkOpen,
        .                             });
        .                             begin_text = ix + 1;
        .                             LoopInstruction::ContinueAndSkip(0)
        .                         }
        .                         b']' => {
        .                             self.tree.append_text(begin_text, ix);
   45,315 (0.0%)                      self.tree.append(Item {
        .                                 start: ix,
    9,063 (0.0%)                          end: ix + 1,
        .                                 body: ItemBody::MaybeLinkClose(true),
        .                             });
        .                             begin_text = ix + 1;
        .                             LoopInstruction::ContinueAndSkip(0)
        .                         }
    5,274 (0.0%)                  b'&' => match scan_entity(&bytes[ix..]) {
    2,544 (0.0%)                      (n, Some(value)) => {
        .                                 self.tree.append_text(begin_text, ix);
    3,816 (0.0%)                          self.tree.append(Item {
        .                                     start: ix,
        .                                     end: ix + n,
        .                                     body: ItemBody::SynthesizeText(self.allocs.allocate_cow(value)),
        .                                 });
        .                                 begin_text = ix + n;
    1,272 (0.0%)                          LoopInstruction::ContinueAndSkip(n - 1)
        .                             }
        .                             _ => LoopInstruction::ContinueAndSkip(0),
        .                         },
        .                         b'|' => {
      405 (0.0%)                      if let TableParseMode::Active = mode {
        .                                 LoopInstruction::BreakAtWith(ix, None)
        .                             } else {
        .                                 last_pipe_ix = ix;
      330 (0.0%)                          pipes += 1;
        .                                 LoopInstruction::ContinueAndSkip(0)
        .                             }
        .                         }
        .                         b'.' => {
  213,911 (0.0%)                      if ix + 2 < bytes.len() && bytes[ix + 1] == b'.' && bytes[ix + 2] == b'.' {
        .                                 self.tree.append_text(begin_text, ix);
       20 (0.0%)                          self.tree.append(Item {
        .                                     start: ix,
        2 (0.0%)                              end: ix + 3,
        .                                     body: ItemBody::SynthesizeChar('…'),
        .                                 });
        .                                 begin_text = ix + 3;
        .                                 LoopInstruction::ContinueAndSkip(2)
        .                             } else {
        .                                 LoopInstruction::ContinueAndSkip(0)
        .                             }
        .                         }
        .                         b'-' => {
    8,154 (0.0%)                      let count = 1 + scan_ch_repeat(&bytes[(ix + 1)..], b'-');
    8,230 (0.0%)                      if count == 1 {
        .                                 LoopInstruction::ContinueAndSkip(0)
        .                             } else {
        .                                 let itembody = if count == 2 {
        .                                     ItemBody::SynthesizeChar('–')
        .                                 } else if count == 3 {
        .                                     ItemBody::SynthesizeChar('—')
        .                                 } else {
        .                                     let (ems, ens) = match count % 6 {
-- line 694 ----------------------------------------
-- line 704 ----------------------------------------
        .                                     }
        .                                     for _ in 0..ens {
        .                                         buf.push('–');
        .                                     }
        .                                     ItemBody::SynthesizeText(self.allocs.allocate_cow(buf.into()))
        .                                 };
        .         
        .                                 self.tree.append_text(begin_text, ix);
      342 (0.0%)                          self.tree.append(Item {
        .                                     start: ix,
       19 (0.0%)                              end: ix + count,
        .                                     body: itembody,
        .                                 });
        .                                 begin_text = ix + count;
        .                                 LoopInstruction::ContinueAndSkip(count - 1)
        .                             }
        .                         }
        .                         c @ b'\'' | c @ b'"' => {
        .                             let string_suffix = &self.text[ix..];
   18,402 (0.0%)                      let can_open = delim_run_can_open(self.text, string_suffix, 1, ix);
   27,603 (0.0%)                      let can_close = delim_run_can_close(self.text, string_suffix, 1, ix);
        .         
        .                             self.tree.append_text(begin_text, ix);
   42,938 (0.0%)                      self.tree.append(Item {
        .                                 start: ix,
    3,067 (0.0%)                          end: ix + 1,
        .                                 body: ItemBody::MaybeSmartQuote(c, can_open, can_close),
        .                             });
        .                             begin_text = ix + 1;
        .         
        .                             LoopInstruction::ContinueAndSkip(0)
        .                         }
        .                         _ => LoopInstruction::ContinueAndSkip(0),
        .                     }
        .                 });
        .         
        .                 if brk.is_none() {
        .                     // need to close text at eof
        .                     self.tree.append_text(begin_text, final_ix);
        .                 }
  434,502 (0.0%)          (final_ix, brk)
  386,224 (0.0%)      }
        .         
        .             /// When start_ix is at the beginning of an HTML block of type 1 to 5,
        .             /// this will find the end of the block, adding the block itself to the
        .             /// tree and also keeping track of the lines of HTML within the block.
        .             ///
        .             /// The html_end_tag is the tag that must be found on a line to end the block.
        .             fn parse_html_block_type_1_to_5(
        .                 &mut self,
        .                 start_ix: usize,
        .                 html_end_tag: &str,
        .                 mut remaining_space: usize,
        .             ) -> usize {
        6 (0.0%)          let bytes = self.text.as_bytes();
        .                 let mut ix = start_ix;
        .                 loop {
        .                     let line_start_ix = ix;
       44 (0.0%)              ix += scan_nextline(&bytes[ix..]);
      176 (0.0%)              self.append_html_line(remaining_space, line_start_ix, ix);
        .         
        .                     let mut line_start = LineStart::new(&bytes[ix..]);
      132 (0.0%)              let n_containers = scan_containers(&self.tree, &mut line_start);
       88 (0.0%)              if n_containers < self.tree.spine_len() {
        .                         break;
        .                     }
        .         
      176 (0.0%)              if (&self.text[line_start_ix..ix]).contains(html_end_tag) {
        .                         break;
        .                     }
        .         
       38 (0.0%)              let next_line_ix = ix + line_start.bytes_scanned();
       76 (0.0%)              if next_line_ix == self.text.len() {
        .                         break;
        .                     }
        .                     ix = next_line_ix;
        .                     remaining_space = line_start.remaining_space();
        .                 }
        .                 ix
        .             }
        .         
        .             /// When start_ix is at the beginning of an HTML block of type 6 or 7,
        .             /// this will consume lines until there is a blank line and keep track of
        .             /// the HTML within the block.
        9 (0.0%)      fn parse_html_block_type_6_or_7(
        .                 &mut self,
        .                 start_ix: usize,
        .                 mut remaining_space: usize,
        .             ) -> usize {
        1 (0.0%)          let bytes = self.text.as_bytes();
        .                 let mut ix = start_ix;
        .                 loop {
        .                     let line_start_ix = ix;
       10 (0.0%)              ix += scan_nextline(&bytes[ix..]);
       30 (0.0%)              self.append_html_line(remaining_space, line_start_ix, ix);
        .         
        .                     let mut line_start = LineStart::new(&bytes[ix..]);
       15 (0.0%)              let n_containers = scan_containers(&self.tree, &mut line_start);
       22 (0.0%)              if n_containers < self.tree.spine_len() || line_start.is_at_eol() {
        .                         break;
        .                     }
        .         
        4 (0.0%)              let next_line_ix = ix + line_start.bytes_scanned();
        8 (0.0%)              if next_line_ix == self.text.len() || scan_blank_line(&bytes[next_line_ix..]).is_some()
        .                     {
        .                         break;
        .                     }
        .                     ix = next_line_ix;
        .                     remaining_space = line_start.remaining_space();
        .                 }
        .                 ix
        9 (0.0%)      }
        .         
        .             fn parse_indented_code_block(&mut self, start_ix: usize, mut remaining_space: usize) -> usize {
        .                 self.tree.append(Item {
        .                     start: start_ix,
        .                     end: 0, // will get set later
        .                     body: ItemBody::IndentCodeBlock,
        .                 });
        .                 self.tree.push();
-- line 823 ----------------------------------------
-- line 860 ----------------------------------------
        .                 if let Some(child) = last_nonblank_child {
        .                     self.tree[child].next = None;
        .                     self.tree[child].item.end = last_nonblank_ix;
        .                 }
        .                 self.pop(end_ix);
        .                 ix
        .             }
        .         
   56,920 (0.0%)      fn parse_fenced_code_block(
        .                 &mut self,
        .                 start_ix: usize,
        .                 indent: usize,
        .                 fence_ch: u8,
        .                 n_fence_char: usize,
        .             ) -> usize {
   17,076 (0.0%)          let bytes = self.text.as_bytes();
    5,692 (0.0%)          let mut info_start = start_ix + n_fence_char;
    5,692 (0.0%)          info_start += scan_whitespace_no_nl(&bytes[info_start..]);
        .                 // TODO: info strings are typically very short. wouldn't it be faster
        .                 // to just do a forward scan here?
   17,076 (0.0%)          let mut ix = info_start + scan_nextline(&bytes[info_start..]);
   11,384 (0.0%)          let info_end = ix - scan_rev_while(&bytes[info_start..ix], is_ascii_whitespace);
   17,076 (0.0%)          let info_string = unescape(&self.text[info_start..info_end]);
   39,844 (0.0%)          self.tree.append(Item {
        .                     start: start_ix,
        .                     end: 0, // will get set later
        .                     body: ItemBody::FencedCodeBlock(self.allocs.allocate_cow(info_string)),
        .                 });
        .                 self.tree.push();
        .                 loop {
        .                     let mut line_start = LineStart::new(&bytes[ix..]);
  179,472 (0.0%)              let n_containers = scan_containers(&self.tree, &mut line_start);
  119,648 (0.0%)              if n_containers < self.tree.spine_len() {
        .                         break;
        .                     }
        .                     line_start.scan_space(indent);
        .                     let mut close_line_start = line_start.clone();
        .                     if !close_line_start.scan_space(4) {
   50,334 (0.0%)                  let close_ix = ix + close_line_start.bytes_scanned();
        .                         if let Some(n) = scan_closing_code_fence(&bytes[close_ix..], fence_ch, n_fence_char)
        .                         {
   17,076 (0.0%)                      ix = close_ix + n;
        .                             break;
        .                         }
        .                     }
        .                     let remaining_space = line_start.remaining_space();
   54,132 (0.0%)              ix += line_start.bytes_scanned();
  108,264 (0.0%)              let next_ix = ix + scan_nextline(&bytes[ix..]);
  324,792 (0.0%)              self.append_code_text(remaining_space, ix, next_ix);
        .                     ix = next_ix;
        .                 }
        .         
   17,076 (0.0%)          self.pop(ix);
        .         
        .                 // try to read trailing whitespace or it will register as a completely blank line
    5,692 (0.0%)          ix + scan_blank_line(&bytes[ix..]).unwrap_or(0)
   51,228 (0.0%)      }
        .         
  595,452 (0.0%)      fn append_code_text(&mut self, remaining_space: usize, start: usize, end: usize) {
  108,264 (0.0%)          if remaining_space > 0 {
        .                     let cow_ix = self.allocs.allocate_cow("   "[..remaining_space].into());
        .                     self.tree.append(Item {
        .                         start,
        .                         end: start,
        .                         body: ItemBody::SynthesizeText(cow_ix),
        .                     });
        .                 }
  378,924 (0.0%)          if self.text.as_bytes()[end - 2] == b'\r' {
        .                     // Normalize CRLF to LF
        .                     self.tree.append_text(start, end - 2);
        .                     self.tree.append_text(end - 1, end);
        .                 } else {
        .                     self.tree.append_text(start, end);
        .                 }
  433,056 (0.0%)      }
        .         
        .             /// Appends a line of HTML to the tree.
      539 (0.0%)      fn append_html_line(&mut self, remaining_space: usize, start: usize, end: usize) {
       98 (0.0%)          if remaining_space > 0 {
        .                     let cow_ix = self.allocs.allocate_cow("   "[..remaining_space].into());
        .                     self.tree.append(Item {
        .                         start,
        .                         end: start,
        .                         // TODO: maybe this should synthesize to html rather than text?
        .                         body: ItemBody::SynthesizeText(cow_ix),
        .                     });
        .                 }
      343 (0.0%)          if self.text.as_bytes()[end - 2] == b'\r' {
        .                     // Normalize CRLF to LF
        .                     self.tree.append(Item {
        .                         start,
        .                         end: end - 2,
        .                         body: ItemBody::Html,
        .                     });
        .                     self.tree.append(Item {
        .                         start: end - 1,
        .                         end,
        .                         body: ItemBody::Html,
        .                     });
        .                 } else {
       49 (0.0%)              self.tree.append(Item {
        .                         start,
        .                         end,
        .                         body: ItemBody::Html,
        .                     });
        .                 }
      392 (0.0%)      }
        .         
        .             /// Pop a container, setting its end.
   59,664 (0.0%)      fn pop(&mut self, ix: usize) {
        .                 let cur_ix = self.tree.pop().unwrap();
   29,832 (0.0%)          self.tree[cur_ix].item.end = ix;
   60,342 (0.0%)          if let ItemBody::List(true, _, _) = self.tree[cur_ix].item.body {
        .                     surgerize_tight_list(&mut self.tree, cur_ix);
        .                 }
   59,664 (0.0%)      }
        .         
        .             /// Close a list if it's open. Also set loose if last line was blank
  149,392 (0.0%)      fn finish_list(&mut self, ix: usize) {
   38,720 (0.0%)          if let Some(node_ix) = self.tree.peek_up() {
    2,550 (0.0%)              if let ItemBody::List(_, _, _) = self.tree[node_ix].item.body {
      492 (0.0%)                  self.pop(ix);
        .                     }
        .                 }
   74,890 (0.0%)          if self.last_line_blank {
      261 (0.0%)              if let Some(node_ix) = self.tree.peek_grandparent() {
       16 (0.0%)                  if let ItemBody::List(ref mut is_tight, _, _) = self.tree[node_ix].item.body {
        8 (0.0%)                      *is_tight = false;
        .                         }
        .                     }
      253 (0.0%)              self.last_line_blank = false;
        .                 }
  149,392 (0.0%)      }
        .         
        .             /// Continue an existing list or start a new one if there's not an open
        .             /// list that matches.
        .             fn continue_list(&mut self, start: usize, ch: u8, index: u64) {
    1,483 (0.0%)          if let Some(node_ix) = self.tree.peek_up() {
    2,288 (0.0%)              if let ItemBody::List(ref mut is_tight, existing_ch, _) = self.tree[node_ix].item.body {
        .                         if existing_ch == ch {
    1,134 (0.0%)                      if self.last_line_blank {
      128 (0.0%)                          *is_tight = false;
        .                                 self.last_line_blank = false;
        .                             }
        .                             return;
        .                         }
        .                     }
        .                     // TODO: this is not the best choice for end; maybe get end from last list item.
       30 (0.0%)              self.finish_list(start);
        .                 }
    3,390 (0.0%)          self.tree.append(Item {
        .                     start,
        .                     end: 0, // will get set later
        .                     body: ItemBody::List(true, ch, index),
        .                 });
        .                 self.tree.push();
        .                 self.last_line_blank = false;
        .             }
        .         
-- line 1018 ----------------------------------------
-- line 1028 ----------------------------------------
        .                 ix + hrule_size
        .             }
        .         
        .             /// Parse an ATX heading.
        .             ///
        .             /// Returns index of start of next line.
        .             fn parse_atx_heading(&mut self, start: usize, atx_level: HeadingLevel) -> usize {
        .                 let mut ix = start;
   40,390 (0.0%)          let heading_ix = self.tree.append(Item {
        .                     start,
        .                     end: 0,                    // set later
        .                     body: ItemBody::default(), // set later
        .                 });
   17,310 (0.0%)          ix += atx_level as usize;
        .                 // next char is space or eol (guaranteed by scan_atx_heading)
    5,770 (0.0%)          let bytes = self.text.as_bytes();
        .                 if let Some(eol_bytes) = scan_eol(&bytes[ix..]) {
        .                     self.tree[heading_ix].item.end = ix + eol_bytes;
        .                     self.tree[heading_ix].item.body = ItemBody::Heading(atx_level, None);
        .                     return ix + eol_bytes;
        .                 }
        .                 // skip leading spaces
        .                 let skip_spaces = scan_whitespace_no_nl(&bytes[ix..]);
        .                 ix += skip_spaces;
        .         
        .                 // now handle the header text
        .                 let header_start = ix;
        .                 let header_node_idx = self.tree.push(); // so that we can set the endpoint later
        .         
        .                 // trim the trailing attribute block before parsing the entire line, if necessary
    5,770 (0.0%)          let (end, content_end, attrs) = if self.options.contains(Options::ENABLE_HEADING_ATTRIBUTES)
        .                 {
        .                     // the start of the next line is the end of the header since the
        .                     // header cannot have line breaks
        .                     let header_end = header_start + scan_nextline(&bytes[header_start..]);
        .                     let (content_end, attrs) =
        .                         self.extract_and_parse_heading_attribute_block(header_start, header_end);
        .                     self.parse_line(ix, Some(content_end), TableParseMode::Disabled);
        .                     (header_end, content_end, attrs)
        .                 } else {
   63,470 (0.0%)              ix = self.parse_line(ix, None, TableParseMode::Disabled).0;
        .                     (ix, ix, None)
        .                 };
    5,770 (0.0%)          self.tree[header_node_idx].item.end = end;
        .         
        .                 // remove trailing matter from header text
   11,540 (0.0%)          if let Some(cur_ix) = self.tree.cur() {
        .                     // remove closing of the ATX heading
        .                     let header_text = &bytes[header_start..content_end];
        .                     let mut limit = header_text
        .                         .iter()
   57,700 (0.0%)                  .rposition(|&b| !(b == b'\n' || b == b'\r' || b == b' '))
        .                         .map_or(0, |i| i + 1);
        .                     let closer = header_text[..limit]
        .                         .iter()
   11,540 (0.0%)                  .rposition(|&b| b != b'#')
        .                         .map_or(0, |i| i + 1);
        .                     if closer == 0 {
        .                         limit = closer;
        .                     } else {
    5,770 (0.0%)                  let spaces = scan_rev_while(&header_text[..closer], |b| b == b' ');
   46,160 (0.0%)                  if spaces > 0 {
        .                             limit = closer - spaces;
        .                         }
        .                     }
   23,080 (0.0%)              self.tree[cur_ix].item.end = limit + header_start;
        .                 }
        .         
        .                 self.tree.pop();
        .                 self.tree[heading_ix].item.body = ItemBody::Heading(
        .                     atx_level,
        .                     attrs.map(|attrs| self.allocs.allocate_heading(attrs)),
        .                 );
        .                 end
        .             }
        .         
  810,480 (0.0%)      fn get_footnote(&mut self, start: usize) -> Option<(usize, CowStr<'a>)> {
  101,310 (0.0%)          let bytes = &self.text.as_bytes()[start..];
  101,303 (0.0%)          if !bytes.starts_with(b"[^") {
  101,310 (0.0%)              return None;
        .                 }
        .                 let (mut i, label) = self.parse_refdef_label(start + 2)?;
        .                 i += 2;
        .                 if scan_ch(&bytes[i..], b':') == 0 {
        .                     return None;
        .                 }
        .                 i += 1;
        .                 Some((i, label))
  810,480 (0.0%)      }
        .         
        .             /// Returns the number of bytes scanned on success.
        .             fn parse_footnote(&mut self, start: usize) -> Option<usize> {
  244,764 (0.0%)          let (i, label) = self.get_footnote(start)?;
        .                 self.finish_list(start);
        .                 self.tree.append(Item {
        .                     start,
        .                     end: 0, // will get set later
        .                     // TODO: check whether the label here is strictly necessary
        .                     body: ItemBody::FootnoteDefinition(self.allocs.allocate_cow(label)),
        .                 });
        .                 self.tree.push();
        .                 Some(i)
        .             }
        .         
        .             /// Tries to parse a reference label, which can be interrupted by new blocks.
        .             /// On success, returns the number of bytes of the label and the label itself.
        .             fn parse_refdef_label(&self, start: usize) -> Option<(usize, CowStr<'a>)> {
   19,872 (0.0%)          scan_link_label_rest(&self.text[start..], &|bytes| {
        .                     let mut line_start = LineStart::new(bytes);
        .                     let current_container =
        .                         scan_containers(&self.tree, &mut line_start) == self.tree.spine_len();
        .                     let bytes_scanned = line_start.bytes_scanned();
        .                     let suffix = &bytes[bytes_scanned..];
        .                     if scan_paragraph_interrupt(suffix, current_container) {
        .                         None
        .                     } else {
        .                         Some(bytes_scanned)
        .                     }
        .                 })
        .             }
        .         
        .             /// Returns number of bytes scanned, label and definition on success.
  252,488 (0.0%)      fn parse_refdef_total(&mut self, start: usize) -> Option<(usize, LinkLabel<'a>, LinkDef<'a>)> {
   31,561 (0.0%)          let bytes = &self.text.as_bytes()[start..];
   31,561 (0.0%)          if scan_ch(bytes, b'[') == 0 {
   28,249 (0.0%)              return None;
        .                 }
    6,624 (0.0%)          let (mut i, label) = self.parse_refdef_label(start + 1)?;
    3,312 (0.0%)          i += 1;
    3,312 (0.0%)          if scan_ch(&bytes[i..], b':') == 0 {
        .                     return None;
        .                 }
        .                 i += 1;
    9,393 (0.0%)          let (bytecount, link_def) = self.scan_refdef(start, start + i)?;
   90,799 (0.0%)          Some((bytecount + i, UniCase::new(label), link_def))
  252,488 (0.0%)      }
        .         
        .             /// Returns number of bytes and number of newlines
   62,620 (0.0%)      fn scan_refdef_space(&self, bytes: &[u8], mut i: usize) -> Option<(usize, usize)> {
        .                 let mut newlines = 0;
        .                 loop {
        .                     let whitespaces = scan_whitespace_no_nl(&bytes[i..]);
    9,379 (0.0%)              i += whitespaces;
        .                     if let Some(eol_bytes) = scan_eol(&bytes[i..]) {
    3,117 (0.0%)                  i += eol_bytes;
        .                         newlines += 1;
        .                         if newlines > 1 {
        .                             return None;
        .                         }
        .                     } else {
        .                         break;
        .                     }
        .                     let mut line_start = LineStart::new(&bytes[i..]);
   15,585 (0.0%)              if self.tree.spine_len() != scan_containers(&self.tree, &mut line_start) {
        .                         return None;
        .                     }
    3,117 (0.0%)              i += line_start.bytes_scanned();
        .                 }
   13,572 (0.0%)          Some((i, newlines))
   50,096 (0.0%)      }
        .         
        .             /// Returns # of bytes and definition.
        .             /// Assumes the label of the reference including colon has already been scanned.
        .             fn scan_refdef(&self, span_start: usize, start: usize) -> Option<(usize, LinkDef<'a>)> {
    9,393 (0.0%)          let bytes = self.text.as_bytes();
        .         
        .                 // whitespace between label and url (including up to one newline)
   15,655 (0.0%)          let (mut i, _newlines) = self.scan_refdef_space(bytes, start)?;
        .         
        .                 // scan link dest
   15,655 (0.0%)          let (dest_length, dest) = scan_link_dest(self.text, i, 1)?;
    9,393 (0.0%)          if dest_length == 0 {
        .                     return None;
        .                 }
    3,131 (0.0%)          let dest = unescape(dest);
    3,131 (0.0%)          i += dest_length;
        .         
        .                 // no title
   21,917 (0.0%)          let mut backup = (
    6,262 (0.0%)              i - start,
        .                     LinkDef {
        .                         dest,
        .                         title: None,
        .                         span: span_start..i,
        .                     },
        .                 );
        .         
        .                 // scan whitespace between dest and label
        .                 let (mut i, newlines) =
   26,441 (0.0%)              if let Some((new_i, mut newlines)) = self.scan_refdef_space(bytes, i) {
    5,572 (0.0%)                  if i == self.text.len() {
        .                             newlines += 1;
        .                         }
    5,572 (0.0%)                  if new_i == i && newlines == 0 {
        .                             return None;
        .                         }
    2,786 (0.0%)                  if newlines > 1 {
        .                             return Some(backup);
        .                         };
        .                         (new_i, newlines)
        .                     } else {
        .                         return Some(backup);
        .                     };
        .         
        .                 // scan title
        .                 // if this fails but newline == 1, return also a refdef without title
    1,393 (0.0%)          if let Some((title_length, title)) = scan_refdef_title(&self.text[i..]) {
       48 (0.0%)              i += title_length;
       48 (0.0%)              backup.1.span = span_start..i;
      128 (0.0%)              backup.1.title = Some(unescape(title));
    2,754 (0.0%)          } else if newlines > 0 {
        .                     return Some(backup);
        .                 } else {
        .                     return None;
        .                 };
        .         
        .                 // scan EOL
       48 (0.0%)          if let Some(bytes) = scan_blank_line(&bytes[i..]) {
       32 (0.0%)              backup.0 = i + bytes - start;
      176 (0.0%)              Some(backup)
        .                 } else if newlines > 0 {
        .                     Some(backup)
        .                 } else {
        .                     None
        .                 }
        .             }
        .         
        .             /// Extracts and parses a heading attribute block if exists.
-- line 1255 ----------------------------------------
-- line 1296 ----------------------------------------
        .         /// that aren't followed or preceded by whitespace.
        .         fn count_header_cols(
        .             bytes: &[u8],
        .             mut pipes: usize,
        .             mut start: usize,
        .             last_pipe_ix: usize,
        .         ) -> usize {
        .             // was first pipe preceded by whitespace? if so, subtract one
       48 (0.0%)      start += scan_whitespace_no_nl(&bytes[start..]);
      168 (0.0%)      if bytes[start] == b'|' {
        .                 pipes -= 1;
        .             }
        .         
        .             // was last pipe followed by whitespace? if so, sub one
       24 (0.0%)      if scan_blank_line(&bytes[(last_pipe_ix + 1)..]).is_some() {
        .                 pipes
        .             } else {
        .                 pipes + 1
        .             }
        .         }
        .         
        .         /// Checks whether we should break a paragraph on the given input.
  380,844 (0.0%)  fn scan_paragraph_interrupt(bytes: &[u8], current_container: bool) -> bool {
        .             scan_eol(bytes).is_some()
        .                 || scan_hrule(bytes).is_ok()
        .                 || scan_atx_heading(bytes).is_some()
  121,470 (0.0%)          || scan_code_fence(bytes).is_some()
        .                 || scan_blockquote_start(bytes).is_some()
       33 (0.0%)          || scan_listitem(bytes).map_or(false, |(ix, delim, index, _)| {
    1,068 (0.0%)              ! current_container ||
        .                     // we don't allow interruption by either empty lists or
        .                     // numbered lists starting at an index other than 1
      132 (0.0%)              (delim == b'*' || delim == b'-' || delim == b'+' || index == 1)
        .                         && !scan_empty_list(&bytes[ix..])
        .                 })
   19,578 (0.0%)          || bytes.starts_with(b"<")
    2,354 (0.0%)              && (get_html_end_tag(&bytes[1..]).is_some() || starts_html_block_type_6(&bytes[1..]))
  378,918 (0.0%)  }
        .         
        .         /// Assumes `text_bytes` is preceded by `<`.
      442 (0.0%)  fn get_html_end_tag(text_bytes: &[u8]) -> Option<&'static str> {
        .             static BEGIN_TAGS: &[&[u8]; 4] = &[b"pre", b"style", b"script", b"textarea"];
        .             static ST_BEGIN_TAGS: &[&[u8]; 3] = &[b"!--", b"?", b"![CDATA["];
        .         
        .             for (beg_tag, end_tag) in BEGIN_TAGS
        .                 .iter()
        .                 .zip(["</pre>", "</style>", "</script>", "</textarea>"].iter())
        .             {
        .                 let tag_len = beg_tag.len();
        .         
    1,732 (0.0%)          if text_bytes.len() < tag_len {
        .                     // begin tags are increasing in size
        .                     break;
        .                 }
        .         
        .                 if !text_bytes[..tag_len].eq_ignore_ascii_case(beg_tag) {
        .                     continue;
        .                 }
        .         
        .                 // Must either be the end of the line...
       12 (0.0%)          if text_bytes.len() == tag_len {
        .                     return Some(end_tag);
        .                 }
        .         
        .                 // ...or be followed by whitespace, newline, or '>'.
        6 (0.0%)          let s = text_bytes[tag_len];
       24 (0.0%)          if is_ascii_whitespace(s) || s == b'>' {
        .                     return Some(end_tag);
        .                 }
        .             }
        .         
        .             for (beg_tag, end_tag) in ST_BEGIN_TAGS.iter().zip(["-->", "?>", "]]>"].iter()) {
      645 (0.0%)          if text_bytes.starts_with(beg_tag) {
        .                     return Some(end_tag);
        .                 }
        .             }
        .         
        .             if text_bytes.len() > 1
      430 (0.0%)          && text_bytes[0] == b'!'
        .                 && text_bytes[1] >= b'A'
        .                 && text_bytes[1] <= b'Z'
        .             {
        .                 Some(">")
        .             } else {
        .                 None
        .             }
      442 (0.0%)  }
        .         
        .         // https://english.stackexchange.com/a/285573
        .         fn surgerize_tight_list(tree: &mut Tree<Item>, list_ix: TreeIndex) {
        .             let mut list_item = tree[list_ix].child;
    2,166 (0.0%)      while let Some(listitem_ix) = list_item {
        .                 // first child is special, controls how we repoint list_item.child
      792 (0.0%)          let list_item_firstborn = tree[listitem_ix].child;
        .         
        .                 // Check that list item has children - this is not necessarily the case!
    1,584 (0.0%)          if let Some(firstborn_ix) = list_item_firstborn {
    1,584 (0.0%)              if let ItemBody::Paragraph = tree[firstborn_ix].item.body {
    1,584 (0.0%)                  tree[listitem_ix].child = tree[firstborn_ix].child;
        .                     }
        .         
        .                     let mut list_item_child = Some(firstborn_ix);
        .                     let mut node_to_repoint = None;
    2,390 (0.0%)              while let Some(child_ix) = list_item_child {
        .                         // surgerize paragraphs
    1,598 (0.0%)                  let repoint_ix = if let ItemBody::Paragraph = tree[child_ix].item.body {
    3,168 (0.0%)                      if let Some(child_firstborn) = tree[child_ix].child {
    1,584 (0.0%)                          if let Some(repoint_ix) = node_to_repoint {
        .                                     tree[repoint_ix].next = Some(child_firstborn);
        .                                 }
        .                                 let mut child_lastborn = child_firstborn;
   31,720 (0.0%)                          while let Some(lastborn_next_ix) = tree[child_lastborn].next {
        .                                     child_lastborn = lastborn_next_ix;
        .                                 }
        .                                 child_lastborn
        .                             } else {
        .                                 child_ix
        .                             }
        .                         } else {
        .                             child_ix
        .                         };
        .         
        .                         node_to_repoint = Some(repoint_ix);
    3,995 (0.0%)                  tree[repoint_ix].next = tree[child_ix].next;
        .                         list_item_child = tree[child_ix].next;
        .                     }
        .                 }
        .         
        .                 list_item = tree[listitem_ix].next;
        .             }
        .         }
        .         
        .         /// Determines whether the delimiter run starting at given index is
        .         /// left-flanking, as defined by the commonmark spec (and isn't intraword
        .         /// for _ delims).
        .         /// suffix is &s[ix..], which is passed in as an optimization, since taking
        .         /// a string subslice is O(n).
  121,095 (0.0%)  fn delim_run_can_open(s: &str, suffix: &str, run_len: usize, ix: usize) -> bool {
   65,205 (0.0%)      let next_char = if let Some(c) = suffix.chars().nth(run_len) {
        .                 c
        .             } else {
        .                 return false;
        .             };
        .             if next_char.is_whitespace() {
        .                 return false;
        .             }
   16,468 (0.0%)      if ix == 0 {
        .                 return true;
        .             }
        .             let delim = suffix.chars().next().unwrap();
   20,204 (0.0%)      if delim == '*' && !is_punctuation(next_char) {
        .                 return true;
        .             }
        .         
        .             let prev_char = s[..ix].chars().last().unwrap();
        .         
        .             prev_char.is_whitespace()
   27,808 (0.0%)          || is_punctuation(prev_char) && (delim != '\'' || ![']', ')'].contains(&prev_char))
   83,835 (0.0%)  }
        .         
        .         /// Determines whether the delimiter run starting at given index is
        .         /// left-flanking, as defined by the commonmark spec (and isn't intraword
        .         /// for _ delims)
   74,520 (0.0%)  fn delim_run_can_close(s: &str, suffix: &str, run_len: usize, ix: usize) -> bool {
   18,630 (0.0%)      if ix == 0 {
        .                 return false;
        .             }
        .             let prev_char = s[..ix].chars().last().unwrap();
        .             if prev_char.is_whitespace() {
        .                 return false;
        .             }
   39,335 (0.0%)      let next_char = if let Some(c) = suffix.chars().nth(run_len) {
        .                 c
        .             } else {
        .                 return true;
        .             };
        .             let delim = suffix.chars().next().unwrap();
   16,577 (0.0%)      if delim == '*' && !is_punctuation(prev_char) {
        .                 return true;
        .             }
        .         
   59,760 (0.0%)      next_char.is_whitespace() || is_punctuation(next_char)
   24,075 (0.0%)  }
        .         
        .         fn create_lut(options: &Options) -> LookupTable {
        .             #[cfg(all(target_arch = "x86_64", feature = "simd"))]
        .             {
        .                 LookupTable {
        .                     simd: simd::compute_lookup(options),
        .                     scalar: special_bytes(options),
        .                 }
-- line 1486 ----------------------------------------
-- line 1495 ----------------------------------------
        .             let mut bytes = [false; 256];
        .             let standard_bytes = [
        .                 b'\n', b'\r', b'*', b'_', b'&', b'\\', b'[', b']', b'<', b'!', b'`',
        .             ];
        .         
        .             for &byte in &standard_bytes {
        .                 bytes[byte as usize] = true;
        .             }
   40,695 (0.0%)      if options.contains(Options::ENABLE_TABLES) {
        .                 bytes[b'|' as usize] = true;
        .             }
   54,260 (0.0%)      if options.contains(Options::ENABLE_STRIKETHROUGH) {
        .                 bytes[b'~' as usize] = true;
        .             }
   27,130 (0.0%)      if options.contains(Options::ENABLE_SMART_PUNCTUATION) {
        .                 for &byte in &[b'.', b'-', b'"', b'\''] {
        .                     bytes[byte as usize] = true;
        .                 }
        .             }
        .         
  515,470 (0.0%)      bytes
        .         }
        .         
        .         enum LoopInstruction<T> {
        .             /// Continue looking for more special bytes, but skip next few bytes.
        .             ContinueAndSkip(usize),
        .             /// Break looping immediately, returning with the given index and value.
        .             BreakAtWith(usize, T),
        .         }
-- line 1523 ----------------------------------------
-- line 1564 ----------------------------------------
        .             lut: &[bool; 256],
        .             bytes: &[u8],
        .             mut ix: usize,
        .             mut callback: F,
        .         ) -> (usize, Option<T>)
        .         where
        .             F: FnMut(usize, u8) -> LoopInstruction<Option<T>>,
        .         {
4,796,518 (0.1%)      while ix < bytes.len() {
2,369,908 (0.0%)          let b = bytes[ix];
4,739,816 (0.1%)          if lut[b as usize] {
        .                     match callback(ix, b) {
        .                         LoopInstruction::ContinueAndSkip(skip) => {
  105,757 (0.0%)                      ix += skip;
        .                         }
        .                         LoopInstruction::BreakAtWith(ix, val) => {
        .                             return (ix, val);
        .                         }
        .                     }
        .                 }
2,325,842 (0.0%)          ix += 1;
        .             }
        .         
        .             (ix, None)
        .         }
        .         
        .         /// Split the usual heading content range and the content inside the trailing attribute block.
        .         ///
        .         /// Returns `(leading_content_len, Option<trailing_attr_block_range>)`.
-- line 1592 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustc-hash-1.1.0/src/lib.rs
--------------------------------------------------------------------------------
Ir______________ 

  976,809 (0.0%)  <unknown (line 0)>

-- line 64 ----------------------------------------
        .         #[cfg(target_pointer_width = "32")]
        .         const K: usize = 0x9e3779b9;
        .         #[cfg(target_pointer_width = "64")]
        .         const K: usize = 0x517cc1b727220a95;
        .         
        .         impl Default for FxHasher {
        .             #[inline]
        .             fn default() -> FxHasher {
4,317,130 (0.1%)          FxHasher { hash: 0 }
        .             }
        .         }
        .         
        .         impl FxHasher {
        .             #[inline]
        .             fn add_to_hash(&mut self, i: usize) {
4,176,557 (0.1%)          self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);
        .             }
        .         }
        .         
        .         impl Hasher for FxHasher {
        .             #[inline]
        .             fn write(&mut self, mut bytes: &[u8]) {
        .                 #[cfg(target_pointer_width = "32")]
        .                 let read_usize = |bytes: &[u8]| u32::from_ne_bytes(bytes[..4].try_into().unwrap());
        .                 #[cfg(target_pointer_width = "64")]
        .                 let read_usize = |bytes: &[u8]| u64::from_ne_bytes(bytes[..8].try_into().unwrap());
        .         
       11 (0.0%)          let mut hash = FxHasher { hash: self.hash };
        .                 assert!(size_of::<usize>() <= 8);
7,019,379 (0.1%)          while bytes.len() >= size_of::<usize>() {
        .                     hash.add_to_hash(read_usize(bytes) as usize);
        .                     bytes = &bytes[size_of::<usize>()..];
        .                 }
1,609,669 (0.0%)          if (size_of::<usize>() > 4) && (bytes.len() >= 4) {
        .                     hash.add_to_hash(u32::from_ne_bytes(bytes[..4].try_into().unwrap()) as usize);
        .                     bytes = &bytes[4..];
        .                 }
1,070,920 (0.0%)          if (size_of::<usize>() > 2) && bytes.len() >= 2 {
        .                     hash.add_to_hash(u16::from_ne_bytes(bytes[..2].try_into().unwrap()) as usize);
        .                     bytes = &bytes[2..];
        .                 }
1,199,014 (0.0%)          if (size_of::<usize>() > 1) && bytes.len() >= 1 {
  280,938 (0.0%)              hash.add_to_hash(bytes[0] as usize);
        .                 }
    4,038 (0.0%)          self.hash = hash.hash;
        .             }
        .         
        .             #[inline]
        .             fn write_u8(&mut self, i: u8) {
   45,640 (0.0%)          self.add_to_hash(i as usize);
        .             }
        .         
        .             #[inline]
        .             fn write_u16(&mut self, i: u16) {
      875 (0.0%)          self.add_to_hash(i as usize);
        .             }
        .         
        .             #[inline]
        .             fn write_u32(&mut self, i: u32) {
3,111,566 (0.0%)          self.add_to_hash(i as usize);
        .             }
        .         
        .             #[cfg(target_pointer_width = "32")]
        .             #[inline]
        .             fn write_u64(&mut self, i: u64) {
        .                 self.add_to_hash(i as usize);
        .                 self.add_to_hash((i >> 32) as usize);
        .             }
-- line 131 ----------------------------------------
-- line 138 ----------------------------------------
        .         
        .             #[inline]
        .             fn write_usize(&mut self, i: usize) {
        .                 self.add_to_hash(i);
        .             }
        .         
        .             #[inline]
        .             fn finish(&self) -> u64 {
1,467,220 (0.0%)          self.hash as u64
        .             }
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/lukas/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stacker-0.1.15/src/lib.rs
--------------------------------------------------------------------------------
Ir_______________ 

 2,169,098 (0.0%)  <unknown (line 0)>

-- line 42 ----------------------------------------
         .         /// `stack_size` bytes.
         .         ///
         .         /// The closure `f` is guaranteed to run on a stack with at least `red_zone` bytes, and it will be
         .         /// run on the current stack if there's space available.
         .         #[inline(always)]
         .         pub fn maybe_grow<R, F: FnOnce() -> R>(red_zone: usize, stack_size: usize, callback: F) -> R {
         .             // if we can't guess the remaining stack (unsupported on some platforms) we immediately grow
         .             // the stack and then cache the new stack size (which we do know now because we allocated it.
10,187,750 (0.1%)      let enough_space = match remaining_stack() {
         .                 Some(remaining) => remaining >= red_zone,
         .                 None => false,
         .             };
         .             if enough_space {
 3,426,548 (0.0%)          callback()
         .             } else {
         .                 grow(stack_size, callback)
         .             }
         .         }
         .         
         .         /// Always creates a new stack for the passed closure to run on.
         .         /// The closure will still be on the same thread as the caller of `grow`.
         .         /// This will allocate a new stack with at least `stack_size` bytes.
-- line 63 ----------------------------------------
-- line 82 ----------------------------------------
         .             _grow(stack_size, dyn_callback);
         .             ret.unwrap()
         .         }
         .         
         .         /// Queries the amount of remaining stack as interpreted by this library.
         .         ///
         .         /// This function will return the amount of stack space left which will be used
         .         /// to determine whether a stack switch should be made or not.
 7,803,928 (0.1%)  pub fn remaining_stack() -> Option<usize> {
         .             let current_ptr = current_stack_ptr();
         .             get_stack_limit().map(|limit| current_ptr - limit)
 9,754,910 (0.1%)  }
         .         
         .         psm_stack_information! (
         .             yes {
         .                 fn current_stack_ptr() -> usize {
 3,901,964 (0.0%)              psm::stack_pointer() as usize
         .                 }
         .             }
         .             no {
         .                 #[inline(always)]
         .                 fn current_stack_ptr() -> usize {
         .                     unsafe {
         .                         let mut x = std::mem::MaybeUninit::<u8>::uninit();
         .                         // Unlikely to be ever exercised. As a fallback we execute a volatile read to a
-- line 106 ----------------------------------------
-- line 407 ----------------------------------------
         .                         mi.as_mut_ptr(),
         .                         std::mem::size_of::<QueryT>() as SIZE_T,
         .                     );
         .                     Some(mi.assume_init().AllocationBase as usize + get_thread_stack_guarantee() + 0x1000)
         .                 }
         .             } else if #[cfg(any(target_os = "linux", target_os="solaris", target_os = "netbsd"))] {
         .                 unsafe fn guess_os_stack_limit() -> Option<usize> {
         .                     let mut attr = std::mem::MaybeUninit::<libc::pthread_attr_t>::uninit();
         4 (0.0%)              assert_eq!(libc::pthread_attr_init(attr.as_mut_ptr()), 0);
         7 (0.0%)              assert_eq!(libc::pthread_getattr_np(libc::pthread_self(),
         .                                                         attr.as_mut_ptr()), 0);
         .                     let mut stackaddr = std::ptr::null_mut();
         4 (0.0%)              let mut stacksize = 0;
         4 (0.0%)              assert_eq!(libc::pthread_attr_getstack(
         .                         attr.as_ptr(), &mut stackaddr, &mut stacksize
         .                     ), 0);
         4 (0.0%)              assert_eq!(libc::pthread_attr_destroy(attr.as_mut_ptr()), 0);
         2 (0.0%)              Some(stackaddr as usize)
         .                 }
         .             } else if #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))] {
         .                 unsafe fn guess_os_stack_limit() -> Option<usize> {
         .                     let mut attr = std::mem::MaybeUninit::<libc::pthread_attr_t>::uninit();
         .                     assert_eq!(libc::pthread_attr_init(attr.as_mut_ptr()), 0);
         .                     assert_eq!(libc::pthread_attr_get_np(libc::pthread_self(), attr.as_mut_ptr()), 0);
         .                     let mut stackaddr = std::ptr::null_mut();
         .                     let mut stacksize = 0;
-- line 432 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/malloc/arena.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/malloc/arena.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir___________________ 

3,403,271,941 (42.6%)    annotated: files known & above threshold & readable, line numbers known
  235,015,481  (2.9%)    annotated: files known & above threshold & readable, line numbers unknown
            0          unannotated: files known & above threshold & two or more non-identical
1,286,954,057 (16.1%)  unannotated: files known & above threshold & unreadable 
3,044,655,915 (38.1%)  unannotated: files known & below threshold
   14,915,772  (0.2%)  unannotated: files unknown

